/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/page"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Flei%2Fhome%2Funderg%2Ftheatre%2Fy3%2Fsegp%2Fmilkup%2Fsrc%2Fapp%2Fpage.js%22%2C%22ids%22%3A%5B%5D%7D&server=false!":
/*!****************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Flei%2Fhome%2Funderg%2Ftheatre%2Fy3%2Fsegp%2Fmilkup%2Fsrc%2Fapp%2Fpage.js%22%2C%22ids%22%3A%5B%5D%7D&server=false! ***!
  \****************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/app/page.js */ \"(app-pages-browser)/./src/app/page.js\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGVXNlcnMlMkZsZWklMkZob21lJTJGdW5kZXJnJTJGdGhlYXRyZSUyRnkzJTJGc2VncCUyRm1pbGt1cCUyRnNyYyUyRmFwcCUyRnBhZ2UuanMlMjIlMkMlMjJpZHMlMjIlM0ElNUIlNUQlN0Qmc2VydmVyPWZhbHNlISIsIm1hcHBpbmdzIjoiQUFBQSw0SkFBa0ciLCJzb3VyY2VzIjpbIiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIi9Vc2Vycy9sZWkvaG9tZS91bmRlcmcvdGhlYXRyZS95My9zZWdwL21pbGt1cC9zcmMvYXBwL3BhZ2UuanNcIik7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Flei%2Fhome%2Funderg%2Ftheatre%2Fy3%2Fsegp%2Fmilkup%2Fsrc%2Fapp%2Fpage.js%22%2C%22ids%22%3A%5B%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/page.js":
/*!*************************!*\
  !*** ./src/app/page.js ***!
  \*************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Home)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _lexical_react_LexicalComposer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/react/LexicalComposer */ \"(app-pages-browser)/./node_modules/@lexical/react/LexicalComposer.dev.mjs\");\n/* harmony import */ var _lexical_react_LexicalPlainTextPlugin__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lexical/react/LexicalPlainTextPlugin */ \"(app-pages-browser)/./node_modules/@lexical/react/LexicalPlainTextPlugin.dev.mjs\");\n/* harmony import */ var _lexical_react_LexicalContentEditable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lexical/react/LexicalContentEditable */ \"(app-pages-browser)/./node_modules/@lexical/react/LexicalContentEditable.dev.mjs\");\n/* harmony import */ var _lexical_react_LexicalHistoryPlugin__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lexical/react/LexicalHistoryPlugin */ \"(app-pages-browser)/./node_modules/@lexical/react/LexicalHistoryPlugin.dev.mjs\");\n/* harmony import */ var _lexical_react_LexicalErrorBoundary__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lexical/react/LexicalErrorBoundary */ \"(app-pages-browser)/./node_modules/@lexical/react/LexicalErrorBoundary.dev.mjs\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \n\n\n\n\n\nfunction Home() {\n    const initialConfig = {\n        namespace: 'MyEditor',\n        onError: (error)=>console.error(error)\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"main\", {\n        className: \"p-4\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_lexical_react_LexicalComposer__WEBPACK_IMPORTED_MODULE_1__.LexicalComposer, {\n            initialConfig: initialConfig,\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"editor-container\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_lexical_react_LexicalPlainTextPlugin__WEBPACK_IMPORTED_MODULE_2__.PlainTextPlugin, {\n                        contentEditable: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_lexical_react_LexicalContentEditable__WEBPACK_IMPORTED_MODULE_3__.ContentEditable, {\n                            className: \"editor-input\"\n                        }, void 0, false, {\n                            fileName: \"/Users/lei/home/underg/theatre/y3/segp/milkup/src/app/page.js\",\n                            lineNumber: 20,\n                            columnNumber: 30\n                        }, void 0),\n                        placeholder: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"editor-placeholder\",\n                            children: \"Enter some text...\"\n                        }, void 0, false, {\n                            fileName: \"/Users/lei/home/underg/theatre/y3/segp/milkup/src/app/page.js\",\n                            lineNumber: 21,\n                            columnNumber: 26\n                        }, void 0),\n                        ErrorBoundary: _lexical_react_LexicalErrorBoundary__WEBPACK_IMPORTED_MODULE_4__.ErrorBoundary\n                    }, void 0, false, {\n                        fileName: \"/Users/lei/home/underg/theatre/y3/segp/milkup/src/app/page.js\",\n                        lineNumber: 19,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_lexical_react_LexicalHistoryPlugin__WEBPACK_IMPORTED_MODULE_5__.HistoryPlugin, {}, void 0, false, {\n                        fileName: \"/Users/lei/home/underg/theatre/y3/segp/milkup/src/app/page.js\",\n                        lineNumber: 24,\n                        columnNumber: 11\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/lei/home/underg/theatre/y3/segp/milkup/src/app/page.js\",\n                lineNumber: 18,\n                columnNumber: 9\n            }, this)\n        }, void 0, false, {\n            fileName: \"/Users/lei/home/underg/theatre/y3/segp/milkup/src/app/page.js\",\n            lineNumber: 17,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"/Users/lei/home/underg/theatre/y3/segp/milkup/src/app/page.js\",\n        lineNumber: 16,\n        columnNumber: 5\n    }, this);\n}\n_c = Home;\nvar _c;\n$RefreshReg$(_c, \"Home\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvcGFnZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUVpRTtBQUNPO0FBQ0E7QUFDSjtBQUNBO0FBRXJELFNBQVNLO0lBQ3RCLE1BQU1DLGdCQUFnQjtRQUNwQkMsV0FBVztRQUNYQyxTQUFTLENBQUNDLFFBQVVDLFFBQVFELEtBQUssQ0FBQ0E7SUFDcEM7SUFFQSxxQkFDRSw4REFBQ0U7UUFBS0MsV0FBVTtrQkFDZCw0RUFBQ1osMkVBQWVBO1lBQUNNLGVBQWVBO3NCQUM5Qiw0RUFBQ087Z0JBQUlELFdBQVU7O2tDQUNiLDhEQUFDWCxrRkFBZUE7d0JBQ2RhLCtCQUFpQiw4REFBQ1osa0ZBQWVBOzRCQUFDVSxXQUFVOzs7Ozs7d0JBQzVDRywyQkFBYSw4REFBQ0Y7NEJBQUlELFdBQVU7c0NBQXFCOzs7Ozs7d0JBQ2pEUixlQUFlQSw4RUFBYUE7Ozs7OztrQ0FFOUIsOERBQUNELDhFQUFhQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBS3hCO0tBcEJ3QkUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9sZWkvaG9tZS91bmRlcmcvdGhlYXRyZS95My9zZWdwL21pbGt1cC9zcmMvYXBwL3BhZ2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgeyBMZXhpY2FsQ29tcG9zZXIgfSBmcm9tICdAbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ29tcG9zZXInO1xuaW1wb3J0IHsgUGxhaW5UZXh0UGx1Z2luIH0gZnJvbSAnQGxleGljYWwvcmVhY3QvTGV4aWNhbFBsYWluVGV4dFBsdWdpbic7XG5pbXBvcnQgeyBDb250ZW50RWRpdGFibGUgfSBmcm9tICdAbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ29udGVudEVkaXRhYmxlJztcbmltcG9ydCB7IEhpc3RvcnlQbHVnaW4gfSBmcm9tICdAbGV4aWNhbC9yZWFjdC9MZXhpY2FsSGlzdG9yeVBsdWdpbic7XG5pbXBvcnQgeyBFcnJvckJvdW5kYXJ5IH0gZnJvbSAnQGxleGljYWwvcmVhY3QvTGV4aWNhbEVycm9yQm91bmRhcnknO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBIb21lKCkge1xuICBjb25zdCBpbml0aWFsQ29uZmlnID0ge1xuICAgIG5hbWVzcGFjZTogJ015RWRpdG9yJyxcbiAgICBvbkVycm9yOiAoZXJyb3IpID0+IGNvbnNvbGUuZXJyb3IoZXJyb3IpLFxuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPG1haW4gY2xhc3NOYW1lPVwicC00XCI+XG4gICAgICA8TGV4aWNhbENvbXBvc2VyIGluaXRpYWxDb25maWc9e2luaXRpYWxDb25maWd9PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImVkaXRvci1jb250YWluZXJcIj5cbiAgICAgICAgICA8UGxhaW5UZXh0UGx1Z2luXG4gICAgICAgICAgICBjb250ZW50RWRpdGFibGU9ezxDb250ZW50RWRpdGFibGUgY2xhc3NOYW1lPVwiZWRpdG9yLWlucHV0XCIgLz59XG4gICAgICAgICAgICBwbGFjZWhvbGRlcj17PGRpdiBjbGFzc05hbWU9XCJlZGl0b3ItcGxhY2Vob2xkZXJcIj5FbnRlciBzb21lIHRleHQuLi48L2Rpdj59XG4gICAgICAgICAgICBFcnJvckJvdW5kYXJ5PXtFcnJvckJvdW5kYXJ5fVxuICAgICAgICAgIC8+XG4gICAgICAgICAgPEhpc3RvcnlQbHVnaW4gLz5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L0xleGljYWxDb21wb3Nlcj5cbiAgICA8L21haW4+XG4gICk7XG59XG4iXSwibmFtZXMiOlsiTGV4aWNhbENvbXBvc2VyIiwiUGxhaW5UZXh0UGx1Z2luIiwiQ29udGVudEVkaXRhYmxlIiwiSGlzdG9yeVBsdWdpbiIsIkVycm9yQm91bmRhcnkiLCJIb21lIiwiaW5pdGlhbENvbmZpZyIsIm5hbWVzcGFjZSIsIm9uRXJyb3IiLCJlcnJvciIsImNvbnNvbGUiLCJtYWluIiwiY2xhc3NOYW1lIiwiZGl2IiwiY29udGVudEVkaXRhYmxlIiwicGxhY2Vob2xkZXIiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/page.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  (function () {\n    function getComponentNameFromType(type) {\n      if (null == type) return null;\n      if (\"function\" === typeof type)\n        return type.$$typeof === REACT_CLIENT_REFERENCE$2\n          ? null\n          : type.displayName || type.name || null;\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return \"Fragment\";\n        case REACT_PORTAL_TYPE:\n          return \"Portal\";\n        case REACT_PROFILER_TYPE:\n          return \"Profiler\";\n        case REACT_STRICT_MODE_TYPE:\n          return \"StrictMode\";\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n      }\n      if (\"object\" === typeof type)\n        switch (\n          (\"number\" === typeof type.tag &&\n            console.error(\n              \"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"\n            ),\n          type.$$typeof)\n        ) {\n          case REACT_CONTEXT_TYPE:\n            return (type.displayName || \"Context\") + \".Provider\";\n          case REACT_CONSUMER_TYPE:\n            return (type._context.displayName || \"Context\") + \".Consumer\";\n          case REACT_FORWARD_REF_TYPE:\n            var innerType = type.render;\n            type = type.displayName;\n            type ||\n              ((type = innerType.displayName || innerType.name || \"\"),\n              (type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\"));\n            return type;\n          case REACT_MEMO_TYPE:\n            return (\n              (innerType = type.displayName || null),\n              null !== innerType\n                ? innerType\n                : getComponentNameFromType(type.type) || \"Memo\"\n            );\n          case REACT_LAZY_TYPE:\n            innerType = type._payload;\n            type = type._init;\n            try {\n              return getComponentNameFromType(type(innerType));\n            } catch (x) {}\n        }\n      return null;\n    }\n    function testStringCoercion(value) {\n      return \"\" + value;\n    }\n    function checkKeyStringCoercion(value) {\n      try {\n        testStringCoercion(value);\n        var JSCompiler_inline_result = !1;\n      } catch (e) {\n        JSCompiler_inline_result = !0;\n      }\n      if (JSCompiler_inline_result) {\n        JSCompiler_inline_result = console;\n        var JSCompiler_temp_const = JSCompiler_inline_result.error;\n        var JSCompiler_inline_result$jscomp$0 =\n          (\"function\" === typeof Symbol &&\n            Symbol.toStringTag &&\n            value[Symbol.toStringTag]) ||\n          value.constructor.name ||\n          \"Object\";\n        JSCompiler_temp_const.call(\n          JSCompiler_inline_result,\n          \"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\",\n          JSCompiler_inline_result$jscomp$0\n        );\n        return testStringCoercion(value);\n      }\n    }\n    function disabledLog() {}\n    function disableLogs() {\n      if (0 === disabledDepth) {\n        prevLog = console.log;\n        prevInfo = console.info;\n        prevWarn = console.warn;\n        prevError = console.error;\n        prevGroup = console.group;\n        prevGroupCollapsed = console.groupCollapsed;\n        prevGroupEnd = console.groupEnd;\n        var props = {\n          configurable: !0,\n          enumerable: !0,\n          value: disabledLog,\n          writable: !0\n        };\n        Object.defineProperties(console, {\n          info: props,\n          log: props,\n          warn: props,\n          error: props,\n          group: props,\n          groupCollapsed: props,\n          groupEnd: props\n        });\n      }\n      disabledDepth++;\n    }\n    function reenableLogs() {\n      disabledDepth--;\n      if (0 === disabledDepth) {\n        var props = { configurable: !0, enumerable: !0, writable: !0 };\n        Object.defineProperties(console, {\n          log: assign({}, props, { value: prevLog }),\n          info: assign({}, props, { value: prevInfo }),\n          warn: assign({}, props, { value: prevWarn }),\n          error: assign({}, props, { value: prevError }),\n          group: assign({}, props, { value: prevGroup }),\n          groupCollapsed: assign({}, props, { value: prevGroupCollapsed }),\n          groupEnd: assign({}, props, { value: prevGroupEnd })\n        });\n      }\n      0 > disabledDepth &&\n        console.error(\n          \"disabledDepth fell below zero. This is a bug in React. Please file an issue.\"\n        );\n    }\n    function describeBuiltInComponentFrame(name) {\n      if (void 0 === prefix)\n        try {\n          throw Error();\n        } catch (x) {\n          var match = x.stack.trim().match(/\\n( *(at )?)/);\n          prefix = (match && match[1]) || \"\";\n          suffix =\n            -1 < x.stack.indexOf(\"\\n    at\")\n              ? \" (<anonymous>)\"\n              : -1 < x.stack.indexOf(\"@\")\n                ? \"@unknown:0:0\"\n                : \"\";\n        }\n      return \"\\n\" + prefix + name + suffix;\n    }\n    function describeNativeComponentFrame(fn, construct) {\n      if (!fn || reentry) return \"\";\n      var frame = componentFrameCache.get(fn);\n      if (void 0 !== frame) return frame;\n      reentry = !0;\n      frame = Error.prepareStackTrace;\n      Error.prepareStackTrace = void 0;\n      var previousDispatcher = null;\n      previousDispatcher = ReactSharedInternals.H;\n      ReactSharedInternals.H = null;\n      disableLogs();\n      try {\n        var RunInRootFrame = {\n          DetermineComponentFrameRoot: function () {\n            try {\n              if (construct) {\n                var Fake = function () {\n                  throw Error();\n                };\n                Object.defineProperty(Fake.prototype, \"props\", {\n                  set: function () {\n                    throw Error();\n                  }\n                });\n                if (\"object\" === typeof Reflect && Reflect.construct) {\n                  try {\n                    Reflect.construct(Fake, []);\n                  } catch (x) {\n                    var control = x;\n                  }\n                  Reflect.construct(fn, [], Fake);\n                } else {\n                  try {\n                    Fake.call();\n                  } catch (x$0) {\n                    control = x$0;\n                  }\n                  fn.call(Fake.prototype);\n                }\n              } else {\n                try {\n                  throw Error();\n                } catch (x$1) {\n                  control = x$1;\n                }\n                (Fake = fn()) &&\n                  \"function\" === typeof Fake.catch &&\n                  Fake.catch(function () {});\n              }\n            } catch (sample) {\n              if (sample && control && \"string\" === typeof sample.stack)\n                return [sample.stack, control.stack];\n            }\n            return [null, null];\n          }\n        };\n        RunInRootFrame.DetermineComponentFrameRoot.displayName =\n          \"DetermineComponentFrameRoot\";\n        var namePropDescriptor = Object.getOwnPropertyDescriptor(\n          RunInRootFrame.DetermineComponentFrameRoot,\n          \"name\"\n        );\n        namePropDescriptor &&\n          namePropDescriptor.configurable &&\n          Object.defineProperty(\n            RunInRootFrame.DetermineComponentFrameRoot,\n            \"name\",\n            { value: \"DetermineComponentFrameRoot\" }\n          );\n        var _RunInRootFrame$Deter =\n            RunInRootFrame.DetermineComponentFrameRoot(),\n          sampleStack = _RunInRootFrame$Deter[0],\n          controlStack = _RunInRootFrame$Deter[1];\n        if (sampleStack && controlStack) {\n          var sampleLines = sampleStack.split(\"\\n\"),\n            controlLines = controlStack.split(\"\\n\");\n          for (\n            _RunInRootFrame$Deter = namePropDescriptor = 0;\n            namePropDescriptor < sampleLines.length &&\n            !sampleLines[namePropDescriptor].includes(\n              \"DetermineComponentFrameRoot\"\n            );\n\n          )\n            namePropDescriptor++;\n          for (\n            ;\n            _RunInRootFrame$Deter < controlLines.length &&\n            !controlLines[_RunInRootFrame$Deter].includes(\n              \"DetermineComponentFrameRoot\"\n            );\n\n          )\n            _RunInRootFrame$Deter++;\n          if (\n            namePropDescriptor === sampleLines.length ||\n            _RunInRootFrame$Deter === controlLines.length\n          )\n            for (\n              namePropDescriptor = sampleLines.length - 1,\n                _RunInRootFrame$Deter = controlLines.length - 1;\n              1 <= namePropDescriptor &&\n              0 <= _RunInRootFrame$Deter &&\n              sampleLines[namePropDescriptor] !==\n                controlLines[_RunInRootFrame$Deter];\n\n            )\n              _RunInRootFrame$Deter--;\n          for (\n            ;\n            1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter;\n            namePropDescriptor--, _RunInRootFrame$Deter--\n          )\n            if (\n              sampleLines[namePropDescriptor] !==\n              controlLines[_RunInRootFrame$Deter]\n            ) {\n              if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {\n                do\n                  if (\n                    (namePropDescriptor--,\n                    _RunInRootFrame$Deter--,\n                    0 > _RunInRootFrame$Deter ||\n                      sampleLines[namePropDescriptor] !==\n                        controlLines[_RunInRootFrame$Deter])\n                  ) {\n                    var _frame =\n                      \"\\n\" +\n                      sampleLines[namePropDescriptor].replace(\n                        \" at new \",\n                        \" at \"\n                      );\n                    fn.displayName &&\n                      _frame.includes(\"<anonymous>\") &&\n                      (_frame = _frame.replace(\"<anonymous>\", fn.displayName));\n                    \"function\" === typeof fn &&\n                      componentFrameCache.set(fn, _frame);\n                    return _frame;\n                  }\n                while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);\n              }\n              break;\n            }\n        }\n      } finally {\n        (reentry = !1),\n          (ReactSharedInternals.H = previousDispatcher),\n          reenableLogs(),\n          (Error.prepareStackTrace = frame);\n      }\n      sampleLines = (sampleLines = fn ? fn.displayName || fn.name : \"\")\n        ? describeBuiltInComponentFrame(sampleLines)\n        : \"\";\n      \"function\" === typeof fn && componentFrameCache.set(fn, sampleLines);\n      return sampleLines;\n    }\n    function describeUnknownElementTypeFrameInDEV(type) {\n      if (null == type) return \"\";\n      if (\"function\" === typeof type) {\n        var prototype = type.prototype;\n        return describeNativeComponentFrame(\n          type,\n          !(!prototype || !prototype.isReactComponent)\n        );\n      }\n      if (\"string\" === typeof type) return describeBuiltInComponentFrame(type);\n      switch (type) {\n        case REACT_SUSPENSE_TYPE:\n          return describeBuiltInComponentFrame(\"Suspense\");\n        case REACT_SUSPENSE_LIST_TYPE:\n          return describeBuiltInComponentFrame(\"SuspenseList\");\n      }\n      if (\"object\" === typeof type)\n        switch (type.$$typeof) {\n          case REACT_FORWARD_REF_TYPE:\n            return (type = describeNativeComponentFrame(type.render, !1)), type;\n          case REACT_MEMO_TYPE:\n            return describeUnknownElementTypeFrameInDEV(type.type);\n          case REACT_LAZY_TYPE:\n            prototype = type._payload;\n            type = type._init;\n            try {\n              return describeUnknownElementTypeFrameInDEV(type(prototype));\n            } catch (x) {}\n        }\n      return \"\";\n    }\n    function getOwner() {\n      var dispatcher = ReactSharedInternals.A;\n      return null === dispatcher ? null : dispatcher.getOwner();\n    }\n    function hasValidKey(config) {\n      if (hasOwnProperty.call(config, \"key\")) {\n        var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n        if (getter && getter.isReactWarning) return !1;\n      }\n      return void 0 !== config.key;\n    }\n    function defineKeyPropWarningGetter(props, displayName) {\n      function warnAboutAccessingKey() {\n        specialPropKeyWarningShown ||\n          ((specialPropKeyWarningShown = !0),\n          console.error(\n            \"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)\",\n            displayName\n          ));\n      }\n      warnAboutAccessingKey.isReactWarning = !0;\n      Object.defineProperty(props, \"key\", {\n        get: warnAboutAccessingKey,\n        configurable: !0\n      });\n    }\n    function elementRefGetterWithDeprecationWarning() {\n      var componentName = getComponentNameFromType(this.type);\n      didWarnAboutElementRef[componentName] ||\n        ((didWarnAboutElementRef[componentName] = !0),\n        console.error(\n          \"Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.\"\n        ));\n      componentName = this.props.ref;\n      return void 0 !== componentName ? componentName : null;\n    }\n    function ReactElement(type, key, self, source, owner, props) {\n      self = props.ref;\n      type = {\n        $$typeof: REACT_ELEMENT_TYPE,\n        type: type,\n        key: key,\n        props: props,\n        _owner: owner\n      };\n      null !== (void 0 !== self ? self : null)\n        ? Object.defineProperty(type, \"ref\", {\n            enumerable: !1,\n            get: elementRefGetterWithDeprecationWarning\n          })\n        : Object.defineProperty(type, \"ref\", { enumerable: !1, value: null });\n      type._store = {};\n      Object.defineProperty(type._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: 0\n      });\n      Object.defineProperty(type, \"_debugInfo\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: null\n      });\n      Object.freeze && (Object.freeze(type.props), Object.freeze(type));\n      return type;\n    }\n    function jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self\n    ) {\n      if (\n        \"string\" === typeof type ||\n        \"function\" === typeof type ||\n        type === REACT_FRAGMENT_TYPE ||\n        type === REACT_PROFILER_TYPE ||\n        type === REACT_STRICT_MODE_TYPE ||\n        type === REACT_SUSPENSE_TYPE ||\n        type === REACT_SUSPENSE_LIST_TYPE ||\n        type === REACT_OFFSCREEN_TYPE ||\n        (\"object\" === typeof type &&\n          null !== type &&\n          (type.$$typeof === REACT_LAZY_TYPE ||\n            type.$$typeof === REACT_MEMO_TYPE ||\n            type.$$typeof === REACT_CONTEXT_TYPE ||\n            type.$$typeof === REACT_CONSUMER_TYPE ||\n            type.$$typeof === REACT_FORWARD_REF_TYPE ||\n            type.$$typeof === REACT_CLIENT_REFERENCE$1 ||\n            void 0 !== type.getModuleId))\n      ) {\n        var children = config.children;\n        if (void 0 !== children)\n          if (isStaticChildren)\n            if (isArrayImpl(children)) {\n              for (\n                isStaticChildren = 0;\n                isStaticChildren < children.length;\n                isStaticChildren++\n              )\n                validateChildKeys(children[isStaticChildren], type);\n              Object.freeze && Object.freeze(children);\n            } else\n              console.error(\n                \"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\"\n              );\n          else validateChildKeys(children, type);\n      } else {\n        children = \"\";\n        if (\n          void 0 === type ||\n          (\"object\" === typeof type &&\n            null !== type &&\n            0 === Object.keys(type).length)\n        )\n          children +=\n            \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\";\n        null === type\n          ? (isStaticChildren = \"null\")\n          : isArrayImpl(type)\n            ? (isStaticChildren = \"array\")\n            : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE\n              ? ((isStaticChildren =\n                  \"<\" +\n                  (getComponentNameFromType(type.type) || \"Unknown\") +\n                  \" />\"),\n                (children =\n                  \" Did you accidentally export a JSX literal instead of a component?\"))\n              : (isStaticChildren = typeof type);\n        console.error(\n          \"React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s\",\n          isStaticChildren,\n          children\n        );\n      }\n      if (hasOwnProperty.call(config, \"key\")) {\n        children = getComponentNameFromType(type);\n        var keys = Object.keys(config).filter(function (k) {\n          return \"key\" !== k;\n        });\n        isStaticChildren =\n          0 < keys.length\n            ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\"\n            : \"{key: someKey}\";\n        didWarnAboutKeySpread[children + isStaticChildren] ||\n          ((keys =\n            0 < keys.length ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\"),\n          console.error(\n            'A props object containing a \"key\" prop is being spread into JSX:\\n  let props = %s;\\n  <%s {...props} />\\nReact keys must be passed directly to JSX without using spread:\\n  let props = %s;\\n  <%s key={someKey} {...props} />',\n            isStaticChildren,\n            children,\n            keys,\n            children\n          ),\n          (didWarnAboutKeySpread[children + isStaticChildren] = !0));\n      }\n      children = null;\n      void 0 !== maybeKey &&\n        (checkKeyStringCoercion(maybeKey), (children = \"\" + maybeKey));\n      hasValidKey(config) &&\n        (checkKeyStringCoercion(config.key), (children = \"\" + config.key));\n      if (\"key\" in config) {\n        maybeKey = {};\n        for (var propName in config)\n          \"key\" !== propName && (maybeKey[propName] = config[propName]);\n      } else maybeKey = config;\n      children &&\n        defineKeyPropWarningGetter(\n          maybeKey,\n          \"function\" === typeof type\n            ? type.displayName || type.name || \"Unknown\"\n            : type\n        );\n      return ReactElement(type, children, self, source, getOwner(), maybeKey);\n    }\n    function validateChildKeys(node, parentType) {\n      if (\n        \"object\" === typeof node &&\n        node &&\n        node.$$typeof !== REACT_CLIENT_REFERENCE\n      )\n        if (isArrayImpl(node))\n          for (var i = 0; i < node.length; i++) {\n            var child = node[i];\n            isValidElement(child) && validateExplicitKey(child, parentType);\n          }\n        else if (isValidElement(node))\n          node._store && (node._store.validated = 1);\n        else if (\n          (null === node || \"object\" !== typeof node\n            ? (i = null)\n            : ((i =\n                (MAYBE_ITERATOR_SYMBOL && node[MAYBE_ITERATOR_SYMBOL]) ||\n                node[\"@@iterator\"]),\n              (i = \"function\" === typeof i ? i : null)),\n          \"function\" === typeof i &&\n            i !== node.entries &&\n            ((i = i.call(node)), i !== node))\n        )\n          for (; !(node = i.next()).done; )\n            isValidElement(node.value) &&\n              validateExplicitKey(node.value, parentType);\n    }\n    function isValidElement(object) {\n      return (\n        \"object\" === typeof object &&\n        null !== object &&\n        object.$$typeof === REACT_ELEMENT_TYPE\n      );\n    }\n    function validateExplicitKey(element, parentType) {\n      if (\n        element._store &&\n        !element._store.validated &&\n        null == element.key &&\n        ((element._store.validated = 1),\n        (parentType = getCurrentComponentErrorInfo(parentType)),\n        !ownerHasKeyUseWarning[parentType])\n      ) {\n        ownerHasKeyUseWarning[parentType] = !0;\n        var childOwner = \"\";\n        element &&\n          null != element._owner &&\n          element._owner !== getOwner() &&\n          ((childOwner = null),\n          \"number\" === typeof element._owner.tag\n            ? (childOwner = getComponentNameFromType(element._owner.type))\n            : \"string\" === typeof element._owner.name &&\n              (childOwner = element._owner.name),\n          (childOwner = \" It was passed a child from \" + childOwner + \".\"));\n        var prevGetCurrentStack = ReactSharedInternals.getCurrentStack;\n        ReactSharedInternals.getCurrentStack = function () {\n          var stack = describeUnknownElementTypeFrameInDEV(element.type);\n          prevGetCurrentStack && (stack += prevGetCurrentStack() || \"\");\n          return stack;\n        };\n        console.error(\n          'Each child in a list should have a unique \"key\" prop.%s%s See https://react.dev/link/warning-keys for more information.',\n          parentType,\n          childOwner\n        );\n        ReactSharedInternals.getCurrentStack = prevGetCurrentStack;\n      }\n    }\n    function getCurrentComponentErrorInfo(parentType) {\n      var info = \"\",\n        owner = getOwner();\n      owner &&\n        (owner = getComponentNameFromType(owner.type)) &&\n        (info = \"\\n\\nCheck the render method of `\" + owner + \"`.\");\n      info ||\n        ((parentType = getComponentNameFromType(parentType)) &&\n          (info =\n            \"\\n\\nCheck the top-level render call using <\" + parentType + \">.\"));\n      return info;\n    }\n    var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"),\n      REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n      REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n      REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n      REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n      REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n    Symbol.for(\"react.provider\");\n    var REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\n      REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n      REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n      REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n      REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\n      REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n      REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n      REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\"),\n      MAYBE_ITERATOR_SYMBOL = Symbol.iterator,\n      REACT_CLIENT_REFERENCE$2 = Symbol.for(\"react.client.reference\"),\n      ReactSharedInternals =\n        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      assign = Object.assign,\n      REACT_CLIENT_REFERENCE$1 = Symbol.for(\"react.client.reference\"),\n      isArrayImpl = Array.isArray,\n      disabledDepth = 0,\n      prevLog,\n      prevInfo,\n      prevWarn,\n      prevError,\n      prevGroup,\n      prevGroupCollapsed,\n      prevGroupEnd;\n    disabledLog.__reactDisabledLog = !0;\n    var prefix,\n      suffix,\n      reentry = !1;\n    var componentFrameCache = new (\n      \"function\" === typeof WeakMap ? WeakMap : Map\n    )();\n    var REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n      specialPropKeyWarningShown;\n    var didWarnAboutElementRef = {};\n    var didWarnAboutKeySpread = {},\n      ownerHasKeyUseWarning = {};\n    exports.Fragment = REACT_FRAGMENT_TYPE;\n    exports.jsxDEV = function (\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self\n    ) {\n      return jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self);\n    };\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7QUFDYixLQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLHdCQUF3QixXQUFXLGdCQUFnQjtBQUNuRCx5QkFBeUIsV0FBVyxpQkFBaUI7QUFDckQseUJBQXlCLFdBQVcsaUJBQWlCO0FBQ3JELDBCQUEwQixXQUFXLGtCQUFrQjtBQUN2RCwwQkFBMEIsV0FBVyxrQkFBa0I7QUFDdkQsbUNBQW1DLFdBQVcsMkJBQTJCO0FBQ3pFLDZCQUE2QixXQUFXLHFCQUFxQjtBQUM3RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsK0NBQStDLDZCQUE2QjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQkFBZ0IsZ0RBQWdEO0FBQ2hFLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQSxnQ0FBZ0Msa0NBQWtDLE9BQU87QUFDekU7QUFDQSxnR0FBZ0csU0FBUyxVQUFVLHNGQUFzRixhQUFhLFVBQVUsVUFBVTtBQUMxTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpQkFBaUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIseUJBQXlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxzR0FBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSxJQUFJLGdCQUFnQjtBQUNwQixJQUFJLGNBQWM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyIsInNvdXJjZXMiOlsiL1VzZXJzL2xlaS9ob21lL3VuZGVyZy90aGVhdHJlL3kzL3NlZ3AvbWlsa3VwL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgICAgIGlmIChudWxsID09IHR5cGUpIHJldHVybiBudWxsO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHJldHVybiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDJcbiAgICAgICAgICA/IG51bGxcbiAgICAgICAgICA6IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHR5cGUpIHJldHVybiB0eXBlO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJGcmFnbWVudFwiO1xuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlBvcnRhbFwiO1xuICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiUHJvZmlsZXJcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN0cmljdE1vZGVcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlTGlzdFwiO1xuICAgICAgfVxuICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICBzd2l0Y2ggKFxuICAgICAgICAgIChcIm51bWJlclwiID09PSB0eXBlb2YgdHlwZS50YWcgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICB0eXBlLiQkdHlwZW9mKVxuICAgICAgICApIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZS5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Qcm92aWRlclwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OU1VNRVJfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZS5fY29udGV4dC5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Db25zdW1lclwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgIHZhciBpbm5lclR5cGUgPSB0eXBlLnJlbmRlcjtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lO1xuICAgICAgICAgICAgdHlwZSB8fFxuICAgICAgICAgICAgICAoKHR5cGUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgXCJcIiksXG4gICAgICAgICAgICAgICh0eXBlID0gXCJcIiAhPT0gdHlwZSA/IFwiRm9yd2FyZFJlZihcIiArIHR5cGUgKyBcIilcIiA6IFwiRm9yd2FyZFJlZlwiKSk7XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChpbm5lclR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGwpLFxuICAgICAgICAgICAgICBudWxsICE9PSBpbm5lclR5cGVcbiAgICAgICAgICAgICAgICA/IGlubmVyVHlwZVxuICAgICAgICAgICAgICAgIDogZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgXCJNZW1vXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICBpbm5lclR5cGUgPSB0eXBlLl9wYXlsb2FkO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUoaW5uZXJUeXBlKSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gXCJcIiArIHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITE7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICEwO1xuICAgICAgfVxuICAgICAgaWYgKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCkge1xuICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSBjb25zb2xlO1xuICAgICAgICB2YXIgSlNDb21waWxlcl90ZW1wX2NvbnN0ID0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LmVycm9yO1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwID1cbiAgICAgICAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgU3ltYm9sICYmXG4gICAgICAgICAgICBTeW1ib2wudG9TdHJpbmdUYWcgJiZcbiAgICAgICAgICAgIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10pIHx8XG4gICAgICAgICAgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fFxuICAgICAgICAgIFwiT2JqZWN0XCI7XG4gICAgICAgIEpTQ29tcGlsZXJfdGVtcF9jb25zdC5jYWxsKFxuICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCxcbiAgICAgICAgICBcIlRoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4gVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuXCIsXG4gICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG4gICAgZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gICAgICBpZiAoMCA9PT0gZGlzYWJsZWREZXB0aCkge1xuICAgICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xuICAgICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcbiAgICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDtcbiAgICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICAgIHdyaXRhYmxlOiAhMFxuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBkaXNhYmxlZERlcHRoKys7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAgICAgIGRpc2FibGVkRGVwdGgtLTtcbiAgICAgIGlmICgwID09PSBkaXNhYmxlZERlcHRoKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHsgY29uZmlndXJhYmxlOiAhMCwgZW51bWVyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2TG9nIH0pLFxuICAgICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZJbmZvIH0pLFxuICAgICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZXYXJuIH0pLFxuICAgICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2RXJyb3IgfSksXG4gICAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZHcm91cCB9KSxcbiAgICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkIH0pLFxuICAgICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2R3JvdXBFbmQgfSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAwID4gZGlzYWJsZWREZXB0aCAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIHtcbiAgICAgIGlmICh2b2lkIDAgPT09IHByZWZpeClcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgICBwcmVmaXggPSAobWF0Y2ggJiYgbWF0Y2hbMV0pIHx8IFwiXCI7XG4gICAgICAgICAgc3VmZml4ID1cbiAgICAgICAgICAgIC0xIDwgeC5zdGFjay5pbmRleE9mKFwiXFxuICAgIGF0XCIpXG4gICAgICAgICAgICAgID8gXCIgKDxhbm9ueW1vdXM+KVwiXG4gICAgICAgICAgICAgIDogLTEgPCB4LnN0YWNrLmluZGV4T2YoXCJAXCIpXG4gICAgICAgICAgICAgICAgPyBcIkB1bmtub3duOjA6MFwiXG4gICAgICAgICAgICAgICAgOiBcIlwiO1xuICAgICAgICB9XG4gICAgICByZXR1cm4gXCJcXG5cIiArIHByZWZpeCArIG5hbWUgKyBzdWZmaXg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAgICAgaWYgKCFmbiB8fCByZWVudHJ5KSByZXR1cm4gXCJcIjtcbiAgICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcbiAgICAgIGlmICh2b2lkIDAgIT09IGZyYW1lKSByZXR1cm4gZnJhbWU7XG4gICAgICByZWVudHJ5ID0gITA7XG4gICAgICBmcmFtZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlO1xuICAgICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB2b2lkIDA7XG4gICAgICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyID0gbnVsbDtcbiAgICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gbnVsbDtcbiAgICAgIGRpc2FibGVMb2dzKCk7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgUnVuSW5Sb290RnJhbWUgPSB7XG4gICAgICAgICAgRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCBcInByb3BzXCIsIHtcbiAgICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgUmVmbGVjdCAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udHJvbCA9IHg7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHgkMCkge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sID0geCQwO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHgkMSkge1xuICAgICAgICAgICAgICAgICAgY29udHJvbCA9IHgkMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKEZha2UgPSBmbigpKSAmJlxuICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgRmFrZS5jYXRjaCAmJlxuICAgICAgICAgICAgICAgICAgRmFrZS5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgICAgICAgICAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHNhbXBsZS5zdGFjaylcbiAgICAgICAgICAgICAgICByZXR1cm4gW3NhbXBsZS5zdGFjaywgY29udHJvbC5zdGFja107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW251bGwsIG51bGxdO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LmRpc3BsYXlOYW1lID1cbiAgICAgICAgICBcIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdFwiO1xuICAgICAgICB2YXIgbmFtZVByb3BEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihcbiAgICAgICAgICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsXG4gICAgICAgICAgXCJuYW1lXCJcbiAgICAgICAgKTtcbiAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yICYmXG4gICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSAmJlxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgICAgIFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCxcbiAgICAgICAgICAgIFwibmFtZVwiLFxuICAgICAgICAgICAgeyB2YWx1ZTogXCJEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3RcIiB9XG4gICAgICAgICAgKTtcbiAgICAgICAgdmFyIF9SdW5JblJvb3RGcmFtZSREZXRlciA9XG4gICAgICAgICAgICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QoKSxcbiAgICAgICAgICBzYW1wbGVTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclswXSxcbiAgICAgICAgICBjb250cm9sU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMV07XG4gICAgICAgIGlmIChzYW1wbGVTdGFjayAmJiBjb250cm9sU3RhY2spIHtcbiAgICAgICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGVTdGFjay5zcGxpdChcIlxcblwiKSxcbiAgICAgICAgICAgIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2xTdGFjay5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyID0gbmFtZVByb3BEZXNjcmlwdG9yID0gMDtcbiAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvciA8IHNhbXBsZUxpbmVzLmxlbmd0aCAmJlxuICAgICAgICAgICAgIXNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0uaW5jbHVkZXMoXG4gICAgICAgICAgICAgIFwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290XCJcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICApXG4gICAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IrKztcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyIDwgY29udHJvbExpbmVzLmxlbmd0aCAmJlxuICAgICAgICAgICAgIWNvbnRyb2xMaW5lc1tfUnVuSW5Sb290RnJhbWUkRGV0ZXJdLmluY2x1ZGVzKFxuICAgICAgICAgICAgICBcIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdFwiXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgKVxuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyKys7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yID09PSBzYW1wbGVMaW5lcy5sZW5ndGggfHxcbiAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlciA9PT0gY29udHJvbExpbmVzLmxlbmd0aFxuICAgICAgICAgIClcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvciA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDEsXG4gICAgICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgIDEgPD0gbmFtZVByb3BEZXNjcmlwdG9yICYmXG4gICAgICAgICAgICAgIDAgPD0gX1J1bkluUm9vdEZyYW1lJERldGVyICYmXG4gICAgICAgICAgICAgIHNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0gIT09XG4gICAgICAgICAgICAgICAgY29udHJvbExpbmVzW19SdW5JblJvb3RGcmFtZSREZXRlcl07XG5cbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyLS07XG4gICAgICAgICAgZm9yIChcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIDEgPD0gbmFtZVByb3BEZXNjcmlwdG9yICYmIDAgPD0gX1J1bkluUm9vdEZyYW1lJERldGVyO1xuICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yLS0sIF9SdW5JblJvb3RGcmFtZSREZXRlci0tXG4gICAgICAgICAgKVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBzYW1wbGVMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdICE9PVxuICAgICAgICAgICAgICBjb250cm9sTGluZXNbX1J1bkluUm9vdEZyYW1lJERldGVyXVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGlmICgxICE9PSBuYW1lUHJvcERlc2NyaXB0b3IgfHwgMSAhPT0gX1J1bkluUm9vdEZyYW1lJERldGVyKSB7XG4gICAgICAgICAgICAgICAgZG9cbiAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgKG5hbWVQcm9wRGVzY3JpcHRvci0tLFxuICAgICAgICAgICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXItLSxcbiAgICAgICAgICAgICAgICAgICAgMCA+IF9SdW5JblJvb3RGcmFtZSREZXRlciB8fFxuICAgICAgICAgICAgICAgICAgICAgIHNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0gIT09XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sTGluZXNbX1J1bkluUm9vdEZyYW1lJERldGVyXSlcbiAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID1cbiAgICAgICAgICAgICAgICAgICAgICBcIlxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgICBzYW1wbGVMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBhdCBuZXcgXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBhdCBcIlxuICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGZuLmRpc3BsYXlOYW1lICYmXG4gICAgICAgICAgICAgICAgICAgICAgX2ZyYW1lLmluY2x1ZGVzKFwiPGFub255bW91cz5cIikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAoX2ZyYW1lID0gX2ZyYW1lLnJlcGxhY2UoXCI8YW5vbnltb3VzPlwiLCBmbi5kaXNwbGF5TmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBmbiAmJlxuICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlICgxIDw9IG5hbWVQcm9wRGVzY3JpcHRvciAmJiAwIDw9IF9SdW5JblJvb3RGcmFtZSREZXRlcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIChyZWVudHJ5ID0gITEpLFxuICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldmlvdXNEaXNwYXRjaGVyKSxcbiAgICAgICAgICByZWVuYWJsZUxvZ3MoKSxcbiAgICAgICAgICAoRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBmcmFtZSk7XG4gICAgICB9XG4gICAgICBzYW1wbGVMaW5lcyA9IChzYW1wbGVMaW5lcyA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6IFwiXCIpXG4gICAgICAgID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoc2FtcGxlTGluZXMpXG4gICAgICAgIDogXCJcIjtcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGZuICYmIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzYW1wbGVMaW5lcyk7XG4gICAgICByZXR1cm4gc2FtcGxlTGluZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlKSB7XG4gICAgICBpZiAobnVsbCA9PSB0eXBlKSByZXR1cm4gXCJcIjtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlKSB7XG4gICAgICAgIHZhciBwcm90b3R5cGUgPSB0eXBlLnByb3RvdHlwZTtcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICAhKCFwcm90b3R5cGUgfHwgIXByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlKSByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShcIlN1c3BlbnNlXCIpO1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoXCJTdXNwZW5zZUxpc3RcIik7XG4gICAgICB9XG4gICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZSA9IGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIsICExKSksIHR5cGU7XG4gICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICBwcm90b3R5cGUgPSB0eXBlLl9wYXlsb2FkO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUocHJvdG90eXBlKSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0T3duZXIoKSB7XG4gICAgICB2YXIgZGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkE7XG4gICAgICByZXR1cm4gbnVsbCA9PT0gZGlzcGF0Y2hlciA/IG51bGwgOiBkaXNwYXRjaGVyLmdldE93bmVyKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBcImtleVwiKSkge1xuICAgICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsIFwia2V5XCIpLmdldDtcbiAgICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2lkIDAgIT09IGNvbmZpZy5rZXk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICAgICAgZnVuY3Rpb24gd2FybkFib3V0QWNjZXNzaW5nS2V5KCkge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biB8fFxuICAgICAgICAgICgoc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSAhMCksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSB2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50IHByb3AuIChodHRwczovL3JlYWN0LmRldi9saW5rL3NwZWNpYWwtcHJvcHMpXCIsXG4gICAgICAgICAgICBkaXNwbGF5TmFtZVxuICAgICAgICAgICkpO1xuICAgICAgfVxuICAgICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gITA7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsIFwia2V5XCIsIHtcbiAgICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbGVtZW50UmVmR2V0dGVyV2l0aERlcHJlY2F0aW9uV2FybmluZygpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHRoaXMudHlwZSk7XG4gICAgICBkaWRXYXJuQWJvdXRFbGVtZW50UmVmW2NvbXBvbmVudE5hbWVdIHx8XG4gICAgICAgICgoZGlkV2FybkFib3V0RWxlbWVudFJlZltjb21wb25lbnROYW1lXSA9ICEwKSxcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkFjY2Vzc2luZyBlbGVtZW50LnJlZiB3YXMgcmVtb3ZlZCBpbiBSZWFjdCAxOS4gcmVmIGlzIG5vdyBhIHJlZ3VsYXIgcHJvcC4gSXQgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIEpTWCBFbGVtZW50IHR5cGUgaW4gYSBmdXR1cmUgcmVsZWFzZS5cIlxuICAgICAgICApKTtcbiAgICAgIGNvbXBvbmVudE5hbWUgPSB0aGlzLnByb3BzLnJlZjtcbiAgICAgIHJldHVybiB2b2lkIDAgIT09IGNvbXBvbmVudE5hbWUgPyBjb21wb25lbnROYW1lIDogbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgICAgIHNlbGYgPSBwcm9wcy5yZWY7XG4gICAgICB0eXBlID0ge1xuICAgICAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICBfb3duZXI6IG93bmVyXG4gICAgICB9O1xuICAgICAgbnVsbCAhPT0gKHZvaWQgMCAhPT0gc2VsZiA/IHNlbGYgOiBudWxsKVxuICAgICAgICA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcInJlZlwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgICAgIGdldDogZWxlbWVudFJlZkdldHRlcldpdGhEZXByZWNhdGlvbldhcm5pbmdcbiAgICAgICAgICB9KVxuICAgICAgICA6IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcInJlZlwiLCB7IGVudW1lcmFibGU6ICExLCB2YWx1ZTogbnVsbCB9KTtcbiAgICAgIHR5cGUuX3N0b3JlID0ge307XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZS5fc3RvcmUsIFwidmFsaWRhdGVkXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6IDBcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwiX2RlYnVnSW5mb1wiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiBudWxsXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5mcmVlemUgJiYgKE9iamVjdC5mcmVlemUodHlwZS5wcm9wcyksIE9iamVjdC5mcmVlemUodHlwZSkpO1xuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGpzeERFVkltcGwoXG4gICAgICB0eXBlLFxuICAgICAgY29uZmlnLFxuICAgICAgbWF5YmVLZXksXG4gICAgICBpc1N0YXRpY0NoaWxkcmVuLFxuICAgICAgc291cmNlLFxuICAgICAgc2VsZlxuICAgICkge1xuICAgICAgaWYgKFxuICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZSB8fFxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlIHx8XG4gICAgICAgIHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHxcbiAgICAgICAgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fFxuICAgICAgICB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8XG4gICAgICAgIHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHxcbiAgICAgICAgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8XG4gICAgICAgIHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8XG4gICAgICAgIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSAmJlxuICAgICAgICAgIG51bGwgIT09IHR5cGUgJiZcbiAgICAgICAgICAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8XG4gICAgICAgICAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHxcbiAgICAgICAgICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fFxuICAgICAgICAgICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OU1VNRVJfVFlQRSB8fFxuICAgICAgICAgICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fFxuICAgICAgICAgICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxIHx8XG4gICAgICAgICAgICB2b2lkIDAgIT09IHR5cGUuZ2V0TW9kdWxlSWQpKVxuICAgICAgKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IGNvbmZpZy5jaGlsZHJlbjtcbiAgICAgICAgaWYgKHZvaWQgMCAhPT0gY2hpbGRyZW4pXG4gICAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pXG4gICAgICAgICAgICBpZiAoaXNBcnJheUltcGwoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgaXNTdGF0aWNDaGlsZHJlbiA9IDA7XG4gICAgICAgICAgICAgICAgaXNTdGF0aWNDaGlsZHJlbiA8IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuKytcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuW2lzU3RhdGljQ2hpbGRyZW5dLCB0eXBlKTtcbiAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSAmJiBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiBVc2UgdGhlIEJhYmVsIHRyYW5zZm9ybSBpbnN0ZWFkLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgZWxzZSB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbiwgdHlwZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGlsZHJlbiA9IFwiXCI7XG4gICAgICAgIGlmIChcbiAgICAgICAgICB2b2lkIDAgPT09IHR5cGUgfHxcbiAgICAgICAgICAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUgJiZcbiAgICAgICAgICAgIG51bGwgIT09IHR5cGUgJiZcbiAgICAgICAgICAgIDAgPT09IE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aClcbiAgICAgICAgKVxuICAgICAgICAgIGNoaWxkcmVuICs9XG4gICAgICAgICAgICBcIiBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSBpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICAgIG51bGwgPT09IHR5cGVcbiAgICAgICAgICA/IChpc1N0YXRpY0NoaWxkcmVuID0gXCJudWxsXCIpXG4gICAgICAgICAgOiBpc0FycmF5SW1wbCh0eXBlKVxuICAgICAgICAgICAgPyAoaXNTdGF0aWNDaGlsZHJlbiA9IFwiYXJyYXlcIilcbiAgICAgICAgICAgIDogdm9pZCAwICE9PSB0eXBlICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRVxuICAgICAgICAgICAgICA/ICgoaXNTdGF0aWNDaGlsZHJlbiA9XG4gICAgICAgICAgICAgICAgICBcIjxcIiArXG4gICAgICAgICAgICAgICAgICAoZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgXCJVbmtub3duXCIpICtcbiAgICAgICAgICAgICAgICAgIFwiIC8+XCIpLFxuICAgICAgICAgICAgICAgIChjaGlsZHJlbiA9XG4gICAgICAgICAgICAgICAgICBcIiBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50P1wiKSlcbiAgICAgICAgICAgICAgOiAoaXNTdGF0aWNDaGlsZHJlbiA9IHR5cGVvZiB0eXBlKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlJlYWN0LmpzeDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSBidXQgZ290OiAlcy4lc1wiLFxuICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICAgICAgY2hpbGRyZW5cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgXCJrZXlcIikpIHtcbiAgICAgICAgY2hpbGRyZW4gPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoY29uZmlnKS5maWx0ZXIoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICByZXR1cm4gXCJrZXlcIiAhPT0gaztcbiAgICAgICAgfSk7XG4gICAgICAgIGlzU3RhdGljQ2hpbGRyZW4gPVxuICAgICAgICAgIDAgPCBrZXlzLmxlbmd0aFxuICAgICAgICAgICAgPyBcIntrZXk6IHNvbWVLZXksIFwiICsga2V5cy5qb2luKFwiOiAuLi4sIFwiKSArIFwiOiAuLi59XCJcbiAgICAgICAgICAgIDogXCJ7a2V5OiBzb21lS2V5fVwiO1xuICAgICAgICBkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY2hpbGRyZW4gKyBpc1N0YXRpY0NoaWxkcmVuXSB8fFxuICAgICAgICAgICgoa2V5cyA9XG4gICAgICAgICAgICAwIDwga2V5cy5sZW5ndGggPyBcIntcIiArIGtleXMuam9pbihcIjogLi4uLCBcIikgKyBcIjogLi4ufVwiIDogXCJ7fVwiKSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgJ0EgcHJvcHMgb2JqZWN0IGNvbnRhaW5pbmcgYSBcImtleVwiIHByb3AgaXMgYmVpbmcgc3ByZWFkIGludG8gSlNYOlxcbiAgbGV0IHByb3BzID0gJXM7XFxuICA8JXMgey4uLnByb3BzfSAvPlxcblJlYWN0IGtleXMgbXVzdCBiZSBwYXNzZWQgZGlyZWN0bHkgdG8gSlNYIHdpdGhvdXQgdXNpbmcgc3ByZWFkOlxcbiAgbGV0IHByb3BzID0gJXM7XFxuICA8JXMga2V5PXtzb21lS2V5fSB7Li4ucHJvcHN9IC8+JyxcbiAgICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgICAgIGtleXMsXG4gICAgICAgICAgICBjaGlsZHJlblxuICAgICAgICAgICksXG4gICAgICAgICAgKGRpZFdhcm5BYm91dEtleVNwcmVhZFtjaGlsZHJlbiArIGlzU3RhdGljQ2hpbGRyZW5dID0gITApKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgICAgIHZvaWQgMCAhPT0gbWF5YmVLZXkgJiZcbiAgICAgICAgKGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpLCAoY2hpbGRyZW4gPSBcIlwiICsgbWF5YmVLZXkpKTtcbiAgICAgIGhhc1ZhbGlkS2V5KGNvbmZpZykgJiZcbiAgICAgICAgKGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSksIChjaGlsZHJlbiA9IFwiXCIgKyBjb25maWcua2V5KSk7XG4gICAgICBpZiAoXCJrZXlcIiBpbiBjb25maWcpIHtcbiAgICAgICAgbWF5YmVLZXkgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gY29uZmlnKVxuICAgICAgICAgIFwia2V5XCIgIT09IHByb3BOYW1lICYmIChtYXliZUtleVtwcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdKTtcbiAgICAgIH0gZWxzZSBtYXliZUtleSA9IGNvbmZpZztcbiAgICAgIGNoaWxkcmVuICYmXG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKFxuICAgICAgICAgIG1heWJlS2V5LFxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGVcbiAgICAgICAgICAgID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgXCJVbmtub3duXCJcbiAgICAgICAgICAgIDogdHlwZVxuICAgICAgICApO1xuICAgICAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBjaGlsZHJlbiwgc2VsZiwgc291cmNlLCBnZXRPd25lcigpLCBtYXliZUtleSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAgICAgIGlmIChcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIG5vZGUgJiZcbiAgICAgICAgbm9kZSAmJlxuICAgICAgICBub2RlLiQkdHlwZW9mICE9PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFXG4gICAgICApXG4gICAgICAgIGlmIChpc0FycmF5SW1wbChub2RlKSlcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG4gICAgICAgICAgICBpc1ZhbGlkRWxlbWVudChjaGlsZCkgJiYgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSlcbiAgICAgICAgICBub2RlLl9zdG9yZSAmJiAobm9kZS5fc3RvcmUudmFsaWRhdGVkID0gMSk7XG4gICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAgIChudWxsID09PSBub2RlIHx8IFwib2JqZWN0XCIgIT09IHR5cGVvZiBub2RlXG4gICAgICAgICAgICA/IChpID0gbnVsbClcbiAgICAgICAgICAgIDogKChpID1cbiAgICAgICAgICAgICAgICAoTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG5vZGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSkgfHxcbiAgICAgICAgICAgICAgICBub2RlW1wiQEBpdGVyYXRvclwiXSksXG4gICAgICAgICAgICAgIChpID0gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaSA/IGkgOiBudWxsKSksXG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaSAmJlxuICAgICAgICAgICAgaSAhPT0gbm9kZS5lbnRyaWVzICYmXG4gICAgICAgICAgICAoKGkgPSBpLmNhbGwobm9kZSkpLCBpICE9PSBub2RlKSlcbiAgICAgICAgKVxuICAgICAgICAgIGZvciAoOyAhKG5vZGUgPSBpLm5leHQoKSkuZG9uZTsgKVxuICAgICAgICAgICAgaXNWYWxpZEVsZW1lbnQobm9kZS52YWx1ZSkgJiZcbiAgICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShub2RlLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2Ygb2JqZWN0ICYmXG4gICAgICAgIG51bGwgIT09IG9iamVjdCAmJlxuICAgICAgICBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRVxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGVsZW1lbnQuX3N0b3JlICYmXG4gICAgICAgICFlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgJiZcbiAgICAgICAgbnVsbCA9PSBlbGVtZW50LmtleSAmJlxuICAgICAgICAoKGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IDEpLFxuICAgICAgICAocGFyZW50VHlwZSA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkpLFxuICAgICAgICAhb3duZXJIYXNLZXlVc2VXYXJuaW5nW3BhcmVudFR5cGVdKVxuICAgICAgKSB7XG4gICAgICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1twYXJlbnRUeXBlXSA9ICEwO1xuICAgICAgICB2YXIgY2hpbGRPd25lciA9IFwiXCI7XG4gICAgICAgIGVsZW1lbnQgJiZcbiAgICAgICAgICBudWxsICE9IGVsZW1lbnQuX293bmVyICYmXG4gICAgICAgICAgZWxlbWVudC5fb3duZXIgIT09IGdldE93bmVyKCkgJiZcbiAgICAgICAgICAoKGNoaWxkT3duZXIgPSBudWxsKSxcbiAgICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgZWxlbWVudC5fb3duZXIudGFnXG4gICAgICAgICAgICA/IChjaGlsZE93bmVyID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGVsZW1lbnQuX293bmVyLnR5cGUpKVxuICAgICAgICAgICAgOiBcInN0cmluZ1wiID09PSB0eXBlb2YgZWxlbWVudC5fb3duZXIubmFtZSAmJlxuICAgICAgICAgICAgICAoY2hpbGRPd25lciA9IGVsZW1lbnQuX293bmVyLm5hbWUpLFxuICAgICAgICAgIChjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBjaGlsZE93bmVyICsgXCIuXCIpKTtcbiAgICAgICAgdmFyIHByZXZHZXRDdXJyZW50U3RhY2sgPSBSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2s7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlKTtcbiAgICAgICAgICBwcmV2R2V0Q3VycmVudFN0YWNrICYmIChzdGFjayArPSBwcmV2R2V0Q3VycmVudFN0YWNrKCkgfHwgXCJcIik7XG4gICAgICAgICAgcmV0dXJuIHN0YWNrO1xuICAgICAgICB9O1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyxcbiAgICAgICAgICBwYXJlbnRUeXBlLFxuICAgICAgICAgIGNoaWxkT3duZXJcbiAgICAgICAgKTtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuZ2V0Q3VycmVudFN0YWNrID0gcHJldkdldEN1cnJlbnRTdGFjaztcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gICAgICB2YXIgaW5mbyA9IFwiXCIsXG4gICAgICAgIG93bmVyID0gZ2V0T3duZXIoKTtcbiAgICAgIG93bmVyICYmXG4gICAgICAgIChvd25lciA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShvd25lci50eXBlKSkgJiZcbiAgICAgICAgKGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGBcIiArIG93bmVyICsgXCJgLlwiKTtcbiAgICAgIGluZm8gfHxcbiAgICAgICAgKChwYXJlbnRUeXBlID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHBhcmVudFR5cGUpKSAmJlxuICAgICAgICAgIChpbmZvID1cbiAgICAgICAgICAgIFwiXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8XCIgKyBwYXJlbnRUeXBlICsgXCI+LlwiKSk7XG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG4gICAgdmFyIFJlYWN0ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdFwiKSxcbiAgICAgIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC50cmFuc2l0aW9uYWwuZWxlbWVudFwiKSxcbiAgICAgIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKSxcbiAgICAgIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIiksXG4gICAgICBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN0cmljdF9tb2RlXCIpLFxuICAgICAgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKTtcbiAgICBTeW1ib2wuZm9yKFwicmVhY3QucHJvdmlkZXJcIik7XG4gICAgdmFyIFJFQUNUX0NPTlNVTUVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29uc3VtZXJcIiksXG4gICAgICBSRUFDVF9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKSxcbiAgICAgIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIiksXG4gICAgICBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpLFxuICAgICAgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlX2xpc3RcIiksXG4gICAgICBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKSxcbiAgICAgIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5sYXp5XCIpLFxuICAgICAgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Qub2Zmc2NyZWVuXCIpLFxuICAgICAgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yLFxuICAgICAgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQyID0gU3ltYm9sLmZvcihcInJlYWN0LmNsaWVudC5yZWZlcmVuY2VcIiksXG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscyA9XG4gICAgICAgIFJlYWN0Ll9fQ0xJRU5UX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERSxcbiAgICAgIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxcbiAgICAgIGFzc2lnbiA9IE9iamVjdC5hc3NpZ24sXG4gICAgICBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDEgPSBTeW1ib2wuZm9yKFwicmVhY3QuY2xpZW50LnJlZmVyZW5jZVwiKSxcbiAgICAgIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheSxcbiAgICAgIGRpc2FibGVkRGVwdGggPSAwLFxuICAgICAgcHJldkxvZyxcbiAgICAgIHByZXZJbmZvLFxuICAgICAgcHJldldhcm4sXG4gICAgICBwcmV2RXJyb3IsXG4gICAgICBwcmV2R3JvdXAsXG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQsXG4gICAgICBwcmV2R3JvdXBFbmQ7XG4gICAgZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gITA7XG4gICAgdmFyIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIHJlZW50cnkgPSAhMTtcbiAgICB2YXIgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyAoXG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBXZWFrTWFwID8gV2Vha01hcCA6IE1hcFxuICAgICkoKTtcbiAgICB2YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jbGllbnQucmVmZXJlbmNlXCIpLFxuICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG4gICAgdmFyIGRpZFdhcm5BYm91dEVsZW1lbnRSZWYgPSB7fTtcbiAgICB2YXIgZGlkV2FybkFib3V0S2V5U3ByZWFkID0ge30sXG4gICAgICBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcbiAgICBleHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbiAgICBleHBvcnRzLmpzeERFViA9IGZ1bmN0aW9uIChcbiAgICAgIHR5cGUsXG4gICAgICBjb25maWcsXG4gICAgICBtYXliZUtleSxcbiAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICBzb3VyY2UsXG4gICAgICBzZWxmXG4gICAgKSB7XG4gICAgICByZXR1cm4ganN4REVWSW1wbCh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBpc1N0YXRpY0NoaWxkcmVuLCBzb3VyY2UsIHNlbGYpO1xuICAgIH07XG4gIH0pKCk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw4TEFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9sZWkvaG9tZS91bmRlcmcvdGhlYXRyZS95My9zZWdwL21pbGt1cC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/clipboard/LexicalClipboard.dev.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@lexical/clipboard/LexicalClipboard.dev.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $generateJSONFromSelectedNodes: () => (/* binding */ $generateJSONFromSelectedNodes),\n/* harmony export */   $generateNodesFromSerializedNodes: () => (/* binding */ $generateNodesFromSerializedNodes),\n/* harmony export */   $getClipboardDataFromSelection: () => (/* binding */ $getClipboardDataFromSelection),\n/* harmony export */   $getHtmlContent: () => (/* binding */ $getHtmlContent),\n/* harmony export */   $getLexicalContent: () => (/* binding */ $getLexicalContent),\n/* harmony export */   $insertDataTransferForPlainText: () => (/* binding */ $insertDataTransferForPlainText),\n/* harmony export */   $insertDataTransferForRichText: () => (/* binding */ $insertDataTransferForRichText),\n/* harmony export */   $insertGeneratedNodes: () => (/* binding */ $insertGeneratedNodes),\n/* harmony export */   copyToClipboard: () => (/* binding */ copyToClipboard),\n/* harmony export */   setLexicalClipboardDataTransfer: () => (/* binding */ setLexicalClipboardDataTransfer)\n/* harmony export */ });\n/* harmony import */ var _lexical_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/html */ \"(app-pages-browser)/./node_modules/@lexical/html/LexicalHtml.dev.mjs\");\n/* harmony import */ var _lexical_selection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lexical/selection */ \"(app-pages-browser)/./node_modules/@lexical/selection/LexicalSelection.dev.mjs\");\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lexical/utils */ \"(app-pages-browser)/./node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(app-pages-browser)/./node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Returns the *currently selected* Lexical content as an HTML string, relying on the\n * logic defined in the exportDOM methods on the LexicalNode classes. Note that\n * this will not return the HTML content of the entire editor (unless all the content is included\n * in the current selection).\n *\n * @param editor - LexicalEditor instance to get HTML content from\n * @param selection - The selection to use (default is $getSelection())\n * @returns a string of HTML content\n */\nfunction $getHtmlContent(editor, selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)()) {\n  if (selection == null) {\n    {\n      throw Error(`Expected valid LexicalSelection`);\n    }\n  }\n\n  // If we haven't selected anything\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return '';\n  }\n  return (0,_lexical_html__WEBPACK_IMPORTED_MODULE_1__.$generateHtmlFromNodes)(editor, selection);\n}\n\n/**\n * Returns the *currently selected* Lexical content as a JSON string, relying on the\n * logic defined in the exportJSON methods on the LexicalNode classes. Note that\n * this will not return the JSON content of the entire editor (unless all the content is included\n * in the current selection).\n *\n * @param editor  - LexicalEditor instance to get the JSON content from\n * @param selection - The selection to use (default is $getSelection())\n * @returns\n */\nfunction $getLexicalContent(editor, selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)()) {\n  if (selection == null) {\n    {\n      throw Error(`Expected valid LexicalSelection`);\n    }\n  }\n\n  // If we haven't selected anything\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return null;\n  }\n  return JSON.stringify($generateJSONFromSelectedNodes(editor, selection));\n}\n\n/**\n * Attempts to insert content of the mime-types text/plain or text/uri-list from\n * the provided DataTransfer object into the editor at the provided selection.\n * text/uri-list is only used if text/plain is not also provided.\n *\n * @param dataTransfer an object conforming to the [DataTransfer interface] (https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface)\n * @param selection the selection to use as the insertion point for the content in the DataTransfer object\n */\nfunction $insertDataTransferForPlainText(dataTransfer, selection) {\n  const text = dataTransfer.getData('text/plain') || dataTransfer.getData('text/uri-list');\n  if (text != null) {\n    selection.insertRawText(text);\n  }\n}\n\n/**\n * Attempts to insert content of the mime-types application/x-lexical-editor, text/html,\n * text/plain, or text/uri-list (in descending order of priority) from the provided DataTransfer\n * object into the editor at the provided selection.\n *\n * @param dataTransfer an object conforming to the [DataTransfer interface] (https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface)\n * @param selection the selection to use as the insertion point for the content in the DataTransfer object\n * @param editor the LexicalEditor the content is being inserted into.\n */\nfunction $insertDataTransferForRichText(dataTransfer, selection, editor) {\n  const lexicalString = dataTransfer.getData('application/x-lexical-editor');\n  if (lexicalString) {\n    try {\n      const payload = JSON.parse(lexicalString);\n      if (payload.namespace === editor._config.namespace && Array.isArray(payload.nodes)) {\n        const nodes = $generateNodesFromSerializedNodes(payload.nodes);\n        return $insertGeneratedNodes(editor, nodes, selection);\n      }\n    } catch (_unused) {\n      // Fail silently.\n    }\n  }\n  const htmlString = dataTransfer.getData('text/html');\n  if (htmlString) {\n    try {\n      const parser = new DOMParser();\n      const dom = parser.parseFromString(trustHTML(htmlString), 'text/html');\n      const nodes = (0,_lexical_html__WEBPACK_IMPORTED_MODULE_1__.$generateNodesFromDOM)(editor, dom);\n      return $insertGeneratedNodes(editor, nodes, selection);\n    } catch (_unused2) {\n      // Fail silently.\n    }\n  }\n\n  // Multi-line plain text in rich text mode pasted as separate paragraphs\n  // instead of single paragraph with linebreaks.\n  // Webkit-specific: Supports read 'text/uri-list' in clipboard.\n  const text = dataTransfer.getData('text/plain') || dataTransfer.getData('text/uri-list');\n  if (text != null) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      const parts = text.split(/(\\r?\\n|\\t)/);\n      if (parts[parts.length - 1] === '') {\n        parts.pop();\n      }\n      for (let i = 0; i < parts.length; i++) {\n        const currentSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(currentSelection)) {\n          const part = parts[i];\n          if (part === '\\n' || part === '\\r\\n') {\n            currentSelection.insertParagraph();\n          } else if (part === '\\t') {\n            currentSelection.insertNodes([(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTabNode)()]);\n          } else {\n            currentSelection.insertText(part);\n          }\n        }\n      }\n    } else {\n      selection.insertRawText(text);\n    }\n  }\n}\nfunction trustHTML(html) {\n  if (window.trustedTypes && window.trustedTypes.createPolicy) {\n    const policy = window.trustedTypes.createPolicy('lexical', {\n      createHTML: input => input\n    });\n    return policy.createHTML(html);\n  }\n  return html;\n}\n\n/**\n * Inserts Lexical nodes into the editor using different strategies depending on\n * some simple selection-based heuristics. If you're looking for a generic way to\n * to insert nodes into the editor at a specific selection point, you probably want\n * {@link lexical.$insertNodes}\n *\n * @param editor LexicalEditor instance to insert the nodes into.\n * @param nodes The nodes to insert.\n * @param selection The selection to insert the nodes into.\n */\nfunction $insertGeneratedNodes(editor, nodes, selection) {\n  if (!editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, {\n    nodes,\n    selection\n  })) {\n    selection.insertNodes(nodes);\n  }\n  return;\n}\nfunction exportNodeToJSON(node) {\n  const serializedNode = node.exportJSON();\n  const nodeClass = node.constructor;\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .exportJSON().`);\n    }\n  }\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node)) {\n    const serializedChildren = serializedNode.children;\n    if (!Array.isArray(serializedChildren)) {\n      {\n        throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);\n      }\n    }\n  }\n  return serializedNode;\n}\nfunction $appendNodesToJSON(editor, selection, currentNode, targetArray = []) {\n  let shouldInclude = selection !== null ? currentNode.isSelected(selection) : true;\n  const shouldExclude = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n  if (selection !== null) {\n    let clone = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$cloneWithProperties)(currentNode);\n    clone = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(clone) && selection !== null ? (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_2__.$sliceSelectedTextNodeContent)(selection, clone) : clone;\n    target = clone;\n  }\n  const children = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(target) ? target.getChildren() : [];\n  const serializedNode = exportNodeToJSON(target);\n\n  // TODO: TextNode calls getTextContent() (NOT node.__text) within its exportJSON method\n  // which uses getLatest() to get the text from the original node with the same key.\n  // This is a deeper issue with the word \"clone\" here, it's still a reference to the\n  // same node as far as the LexicalEditor is concerned since it shares a key.\n  // We need a way to create a clone of a Node in memory with its own key, but\n  // until then this hack will work for the selected text extract use case.\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(target)) {\n    const text = target.__text;\n    // If an uncollapsed selection ends or starts at the end of a line of specialized,\n    // TextNodes, such as code tokens, we will get a 'blank' TextNode here, i.e., one\n    // with text of length 0. We don't want this, it makes a confusing mess. Reset!\n    if (text.length > 0) {\n      serializedNode.text = text;\n    } else {\n      shouldInclude = false;\n    }\n  }\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToJSON(editor, selection, childNode, serializedNode.children);\n    if (!shouldInclude && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection, 'clone')) {\n      shouldInclude = true;\n    }\n  }\n  if (shouldInclude && !shouldExclude) {\n    targetArray.push(serializedNode);\n  } else if (Array.isArray(serializedNode.children)) {\n    for (let i = 0; i < serializedNode.children.length; i++) {\n      const serializedChildNode = serializedNode.children[i];\n      targetArray.push(serializedChildNode);\n    }\n  }\n  return shouldInclude;\n}\n\n// TODO why $ function with Editor instance?\n/**\n * Gets the Lexical JSON of the nodes inside the provided Selection.\n *\n * @param editor LexicalEditor to get the JSON content from.\n * @param selection Selection to get the JSON content from.\n * @returns an object with the editor namespace and a list of serializable nodes as JavaScript objects.\n */\nfunction $generateJSONFromSelectedNodes(editor, selection) {\n  const nodes = [];\n  const root = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)();\n  const topLevelChildren = root.getChildren();\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToJSON(editor, selection, topLevelNode, nodes);\n  }\n  return {\n    namespace: editor._config.namespace,\n    nodes\n  };\n}\n\n/**\n * This method takes an array of objects conforming to the BaseSeralizedNode interface and returns\n * an Array containing instances of the corresponding LexicalNode classes registered on the editor.\n * Normally, you'd get an Array of BaseSerialized nodes from {@link $generateJSONFromSelectedNodes}\n *\n * @param serializedNodes an Array of objects conforming to the BaseSerializedNode interface.\n * @returns an Array of Lexical Node objects.\n */\nfunction $generateNodesFromSerializedNodes(serializedNodes) {\n  const nodes = [];\n  for (let i = 0; i < serializedNodes.length; i++) {\n    const serializedNode = serializedNodes[i];\n    const node = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$parseSerializedNode)(serializedNode);\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(node)) {\n      (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_2__.$addNodeStyle)(node);\n    }\n    nodes.push(node);\n  }\n  return nodes;\n}\nconst EVENT_LATENCY = 50;\nlet clipboardEventTimeout = null;\n\n// TODO custom selection\n// TODO potentially have a node customizable version for plain text\n/**\n * Copies the content of the current selection to the clipboard in\n * text/plain, text/html, and application/x-lexical-editor (Lexical JSON)\n * formats.\n *\n * @param editor the LexicalEditor instance to copy content from\n * @param event the native browser ClipboardEvent to add the content to.\n * @returns\n */\nasync function copyToClipboard(editor, event, data) {\n  if (clipboardEventTimeout !== null) {\n    // Prevent weird race conditions that can happen when this function is run multiple times\n    // synchronously. In the future, we can do better, we can cancel/override the previously running job.\n    return false;\n  }\n  if (event !== null) {\n    return new Promise((resolve, reject) => {\n      editor.update(() => {\n        resolve($copyToClipboardEvent(editor, event, data));\n      });\n    });\n  }\n  const rootElement = editor.getRootElement();\n  const windowDocument = editor._window == null ? window.document : editor._window.document;\n  const domSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.getDOMSelection)(editor._window);\n  if (rootElement === null || domSelection === null) {\n    return false;\n  }\n  const element = windowDocument.createElement('span');\n  element.style.cssText = 'position: fixed; top: -1000px;';\n  element.append(windowDocument.createTextNode('#'));\n  rootElement.append(element);\n  const range = new Range();\n  range.setStart(element, 0);\n  range.setEnd(element, 1);\n  domSelection.removeAllRanges();\n  domSelection.addRange(range);\n  return new Promise((resolve, reject) => {\n    const removeListener = editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.COPY_COMMAND, secondEvent => {\n      if ((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_3__.objectKlassEquals)(secondEvent, ClipboardEvent)) {\n        removeListener();\n        if (clipboardEventTimeout !== null) {\n          window.clearTimeout(clipboardEventTimeout);\n          clipboardEventTimeout = null;\n        }\n        resolve($copyToClipboardEvent(editor, secondEvent, data));\n      }\n      // Block the entire copy flow while we wait for the next ClipboardEvent\n      return true;\n    }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL);\n    // If the above hack execCommand hack works, this timeout code should never fire. Otherwise,\n    // the listener will be quickly freed so that the user can reuse it again\n    clipboardEventTimeout = window.setTimeout(() => {\n      removeListener();\n      clipboardEventTimeout = null;\n      resolve(false);\n    }, EVENT_LATENCY);\n    windowDocument.execCommand('copy');\n    element.remove();\n  });\n}\n\n// TODO shouldn't pass editor (pass namespace directly)\nfunction $copyToClipboardEvent(editor, event, data) {\n  if (data === undefined) {\n    const domSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.getDOMSelection)(editor._window);\n    if (!domSelection) {\n      return false;\n    }\n    const anchorDOM = domSelection.anchorNode;\n    const focusDOM = domSelection.focusNode;\n    if (anchorDOM !== null && focusDOM !== null && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.isSelectionWithinEditor)(editor, anchorDOM, focusDOM)) {\n      return false;\n    }\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (selection === null) {\n      return false;\n    }\n    data = $getClipboardDataFromSelection(selection);\n  }\n  event.preventDefault();\n  const clipboardData = event.clipboardData;\n  if (clipboardData === null) {\n    return false;\n  }\n  setLexicalClipboardDataTransfer(clipboardData, data);\n  return true;\n}\nconst clipboardDataFunctions = [['text/html', $getHtmlContent], ['application/x-lexical-editor', $getLexicalContent]];\n\n/**\n * Serialize the content of the current selection to strings in\n * text/plain, text/html, and application/x-lexical-editor (Lexical JSON)\n * formats (as available).\n *\n * @param selection the selection to serialize (defaults to $getSelection())\n * @returns LexicalClipboardData\n */\nfunction $getClipboardDataFromSelection(selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)()) {\n  const clipboardData = {\n    'text/plain': selection ? selection.getTextContent() : ''\n  };\n  if (selection) {\n    const editor = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getEditor)();\n    for (const [mimeType, $editorFn] of clipboardDataFunctions) {\n      const v = $editorFn(editor, selection);\n      if (v !== null) {\n        clipboardData[mimeType] = v;\n      }\n    }\n  }\n  return clipboardData;\n}\n\n/**\n * Call setData on the given clipboardData for each MIME type present\n * in the given data (from {@link $getClipboardDataFromSelection})\n *\n * @param clipboardData the event.clipboardData to populate from data\n * @param data The lexical data\n */\nfunction setLexicalClipboardDataTransfer(clipboardData, data) {\n  for (const k in data) {\n    const v = data[k];\n    if (v !== undefined) {\n      clipboardData.setData(k, v);\n    }\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9jbGlwYm9hcmQvTGV4aWNhbENsaXBib2FyZC5kZXYubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRThFO0FBQ0k7QUFDL0I7QUFDb1A7O0FBRXZTO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHNEQUFhO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLDBEQUFpQjtBQUN2QjtBQUNBO0FBQ0EsU0FBUyxxRUFBc0I7QUFDL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Qsc0RBQWE7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU0sMERBQWlCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0VBQXFCO0FBQ3pDO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwwREFBaUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDLGlDQUFpQyxzREFBYTtBQUM5QyxZQUFZLDBEQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osMENBQTBDLHVEQUFjO0FBQ3hELFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw2RUFBd0M7QUFDdEU7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsZ0JBQWdCO0FBQ3ZEO0FBQ0E7QUFDQSxNQUFNLHVEQUFjO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxnQkFBZ0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdURBQWM7QUFDdEM7QUFDQTtBQUNBLGdCQUFnQiw2REFBb0I7QUFDcEMsWUFBWSxvREFBVyxnQ0FBZ0MsaUZBQTZCO0FBQ3BGO0FBQ0E7QUFDQSxtQkFBbUIsdURBQWM7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxvREFBVztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0EsMEJBQTBCLHVEQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osb0JBQW9CLG9DQUFvQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlEQUFRO0FBQ3ZCO0FBQ0Esa0JBQWtCLDZCQUE2QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNEJBQTRCO0FBQzlDO0FBQ0EsaUJBQWlCLDZEQUFvQjtBQUNyQyxRQUFRLG9EQUFXO0FBQ25CLE1BQU0saUVBQWE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsd0RBQWU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsYUFBYTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGlEQUFZO0FBQzlELFVBQVUsaUVBQWlCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssRUFBRSw4REFBeUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHdEQUFlO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsZ0VBQXVCO0FBQzNFO0FBQ0E7QUFDQSxzQkFBc0Isc0RBQWE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHNEQUFhO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1EQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLHFDQUFxQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTRSIiwic291cmNlcyI6WyIvVXNlcnMvbGVpL2hvbWUvdW5kZXJnL3RoZWF0cmUveTMvc2VncC9taWxrdXAvbm9kZV9tb2R1bGVzL0BsZXhpY2FsL2NsaXBib2FyZC9MZXhpY2FsQ2xpcGJvYXJkLmRldi5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5pbXBvcnQgeyAkZ2VuZXJhdGVIdG1sRnJvbU5vZGVzLCAkZ2VuZXJhdGVOb2Rlc0Zyb21ET00gfSBmcm9tICdAbGV4aWNhbC9odG1sJztcbmltcG9ydCB7ICRhZGROb2RlU3R5bGUsICRzbGljZVNlbGVjdGVkVGV4dE5vZGVDb250ZW50IH0gZnJvbSAnQGxleGljYWwvc2VsZWN0aW9uJztcbmltcG9ydCB7IG9iamVjdEtsYXNzRXF1YWxzIH0gZnJvbSAnQGxleGljYWwvdXRpbHMnO1xuaW1wb3J0IHsgJGlzUmFuZ2VTZWxlY3Rpb24sICRnZXRTZWxlY3Rpb24sICRjcmVhdGVUYWJOb2RlLCBTRUxFQ1RJT05fSU5TRVJUX0NMSVBCT0FSRF9OT0RFU19DT01NQU5ELCAkZ2V0Um9vdCwgJHBhcnNlU2VyaWFsaXplZE5vZGUsICRpc1RleHROb2RlLCBnZXRET01TZWxlY3Rpb24sIENPUFlfQ09NTUFORCwgQ09NTUFORF9QUklPUklUWV9DUklUSUNBTCwgaXNTZWxlY3Rpb25XaXRoaW5FZGl0b3IsICRnZXRFZGl0b3IsICRpc0VsZW1lbnROb2RlLCAkY2xvbmVXaXRoUHJvcGVydGllcyB9IGZyb20gJ2xleGljYWwnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8qKlxuICogUmV0dXJucyB0aGUgKmN1cnJlbnRseSBzZWxlY3RlZCogTGV4aWNhbCBjb250ZW50IGFzIGFuIEhUTUwgc3RyaW5nLCByZWx5aW5nIG9uIHRoZVxuICogbG9naWMgZGVmaW5lZCBpbiB0aGUgZXhwb3J0RE9NIG1ldGhvZHMgb24gdGhlIExleGljYWxOb2RlIGNsYXNzZXMuIE5vdGUgdGhhdFxuICogdGhpcyB3aWxsIG5vdCByZXR1cm4gdGhlIEhUTUwgY29udGVudCBvZiB0aGUgZW50aXJlIGVkaXRvciAodW5sZXNzIGFsbCB0aGUgY29udGVudCBpcyBpbmNsdWRlZFxuICogaW4gdGhlIGN1cnJlbnQgc2VsZWN0aW9uKS5cbiAqXG4gKiBAcGFyYW0gZWRpdG9yIC0gTGV4aWNhbEVkaXRvciBpbnN0YW5jZSB0byBnZXQgSFRNTCBjb250ZW50IGZyb21cbiAqIEBwYXJhbSBzZWxlY3Rpb24gLSBUaGUgc2VsZWN0aW9uIHRvIHVzZSAoZGVmYXVsdCBpcyAkZ2V0U2VsZWN0aW9uKCkpXG4gKiBAcmV0dXJucyBhIHN0cmluZyBvZiBIVE1MIGNvbnRlbnRcbiAqL1xuZnVuY3Rpb24gJGdldEh0bWxDb250ZW50KGVkaXRvciwgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpKSB7XG4gIGlmIChzZWxlY3Rpb24gPT0gbnVsbCkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCB2YWxpZCBMZXhpY2FsU2VsZWN0aW9uYCk7XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgd2UgaGF2ZW4ndCBzZWxlY3RlZCBhbnl0aGluZ1xuICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSAmJiBzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSB8fCBzZWxlY3Rpb24uZ2V0Tm9kZXMoKS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgcmV0dXJuICRnZW5lcmF0ZUh0bWxGcm9tTm9kZXMoZWRpdG9yLCBzZWxlY3Rpb24pO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlICpjdXJyZW50bHkgc2VsZWN0ZWQqIExleGljYWwgY29udGVudCBhcyBhIEpTT04gc3RyaW5nLCByZWx5aW5nIG9uIHRoZVxuICogbG9naWMgZGVmaW5lZCBpbiB0aGUgZXhwb3J0SlNPTiBtZXRob2RzIG9uIHRoZSBMZXhpY2FsTm9kZSBjbGFzc2VzLiBOb3RlIHRoYXRcbiAqIHRoaXMgd2lsbCBub3QgcmV0dXJuIHRoZSBKU09OIGNvbnRlbnQgb2YgdGhlIGVudGlyZSBlZGl0b3IgKHVubGVzcyBhbGwgdGhlIGNvbnRlbnQgaXMgaW5jbHVkZWRcbiAqIGluIHRoZSBjdXJyZW50IHNlbGVjdGlvbikuXG4gKlxuICogQHBhcmFtIGVkaXRvciAgLSBMZXhpY2FsRWRpdG9yIGluc3RhbmNlIHRvIGdldCB0aGUgSlNPTiBjb250ZW50IGZyb21cbiAqIEBwYXJhbSBzZWxlY3Rpb24gLSBUaGUgc2VsZWN0aW9uIHRvIHVzZSAoZGVmYXVsdCBpcyAkZ2V0U2VsZWN0aW9uKCkpXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiAkZ2V0TGV4aWNhbENvbnRlbnQoZWRpdG9yLCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCkpIHtcbiAgaWYgKHNlbGVjdGlvbiA9PSBudWxsKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIHZhbGlkIExleGljYWxTZWxlY3Rpb25gKTtcbiAgICB9XG4gIH1cblxuICAvLyBJZiB3ZSBoYXZlbid0IHNlbGVjdGVkIGFueXRoaW5nXG4gIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pICYmIHNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpIHx8IHNlbGVjdGlvbi5nZXROb2RlcygpLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSgkZ2VuZXJhdGVKU09ORnJvbVNlbGVjdGVkTm9kZXMoZWRpdG9yLCBzZWxlY3Rpb24pKTtcbn1cblxuLyoqXG4gKiBBdHRlbXB0cyB0byBpbnNlcnQgY29udGVudCBvZiB0aGUgbWltZS10eXBlcyB0ZXh0L3BsYWluIG9yIHRleHQvdXJpLWxpc3QgZnJvbVxuICogdGhlIHByb3ZpZGVkIERhdGFUcmFuc2ZlciBvYmplY3QgaW50byB0aGUgZWRpdG9yIGF0IHRoZSBwcm92aWRlZCBzZWxlY3Rpb24uXG4gKiB0ZXh0L3VyaS1saXN0IGlzIG9ubHkgdXNlZCBpZiB0ZXh0L3BsYWluIGlzIG5vdCBhbHNvIHByb3ZpZGVkLlxuICpcbiAqIEBwYXJhbSBkYXRhVHJhbnNmZXIgYW4gb2JqZWN0IGNvbmZvcm1pbmcgdG8gdGhlIFtEYXRhVHJhbnNmZXIgaW50ZXJmYWNlXSAoaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZG5kLmh0bWwjdGhlLWRhdGF0cmFuc2Zlci1pbnRlcmZhY2UpXG4gKiBAcGFyYW0gc2VsZWN0aW9uIHRoZSBzZWxlY3Rpb24gdG8gdXNlIGFzIHRoZSBpbnNlcnRpb24gcG9pbnQgZm9yIHRoZSBjb250ZW50IGluIHRoZSBEYXRhVHJhbnNmZXIgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uICRpbnNlcnREYXRhVHJhbnNmZXJGb3JQbGFpblRleHQoZGF0YVRyYW5zZmVyLCBzZWxlY3Rpb24pIHtcbiAgY29uc3QgdGV4dCA9IGRhdGFUcmFuc2Zlci5nZXREYXRhKCd0ZXh0L3BsYWluJykgfHwgZGF0YVRyYW5zZmVyLmdldERhdGEoJ3RleHQvdXJpLWxpc3QnKTtcbiAgaWYgKHRleHQgIT0gbnVsbCkge1xuICAgIHNlbGVjdGlvbi5pbnNlcnRSYXdUZXh0KHRleHQpO1xuICB9XG59XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gaW5zZXJ0IGNvbnRlbnQgb2YgdGhlIG1pbWUtdHlwZXMgYXBwbGljYXRpb24veC1sZXhpY2FsLWVkaXRvciwgdGV4dC9odG1sLFxuICogdGV4dC9wbGFpbiwgb3IgdGV4dC91cmktbGlzdCAoaW4gZGVzY2VuZGluZyBvcmRlciBvZiBwcmlvcml0eSkgZnJvbSB0aGUgcHJvdmlkZWQgRGF0YVRyYW5zZmVyXG4gKiBvYmplY3QgaW50byB0aGUgZWRpdG9yIGF0IHRoZSBwcm92aWRlZCBzZWxlY3Rpb24uXG4gKlxuICogQHBhcmFtIGRhdGFUcmFuc2ZlciBhbiBvYmplY3QgY29uZm9ybWluZyB0byB0aGUgW0RhdGFUcmFuc2ZlciBpbnRlcmZhY2VdIChodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9kbmQuaHRtbCN0aGUtZGF0YXRyYW5zZmVyLWludGVyZmFjZSlcbiAqIEBwYXJhbSBzZWxlY3Rpb24gdGhlIHNlbGVjdGlvbiB0byB1c2UgYXMgdGhlIGluc2VydGlvbiBwb2ludCBmb3IgdGhlIGNvbnRlbnQgaW4gdGhlIERhdGFUcmFuc2ZlciBvYmplY3RcbiAqIEBwYXJhbSBlZGl0b3IgdGhlIExleGljYWxFZGl0b3IgdGhlIGNvbnRlbnQgaXMgYmVpbmcgaW5zZXJ0ZWQgaW50by5cbiAqL1xuZnVuY3Rpb24gJGluc2VydERhdGFUcmFuc2ZlckZvclJpY2hUZXh0KGRhdGFUcmFuc2Zlciwgc2VsZWN0aW9uLCBlZGl0b3IpIHtcbiAgY29uc3QgbGV4aWNhbFN0cmluZyA9IGRhdGFUcmFuc2Zlci5nZXREYXRhKCdhcHBsaWNhdGlvbi94LWxleGljYWwtZWRpdG9yJyk7XG4gIGlmIChsZXhpY2FsU3RyaW5nKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSBKU09OLnBhcnNlKGxleGljYWxTdHJpbmcpO1xuICAgICAgaWYgKHBheWxvYWQubmFtZXNwYWNlID09PSBlZGl0b3IuX2NvbmZpZy5uYW1lc3BhY2UgJiYgQXJyYXkuaXNBcnJheShwYXlsb2FkLm5vZGVzKSkge1xuICAgICAgICBjb25zdCBub2RlcyA9ICRnZW5lcmF0ZU5vZGVzRnJvbVNlcmlhbGl6ZWROb2RlcyhwYXlsb2FkLm5vZGVzKTtcbiAgICAgICAgcmV0dXJuICRpbnNlcnRHZW5lcmF0ZWROb2RlcyhlZGl0b3IsIG5vZGVzLCBzZWxlY3Rpb24pO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKF91bnVzZWQpIHtcbiAgICAgIC8vIEZhaWwgc2lsZW50bHkuXG4gICAgfVxuICB9XG4gIGNvbnN0IGh0bWxTdHJpbmcgPSBkYXRhVHJhbnNmZXIuZ2V0RGF0YSgndGV4dC9odG1sJyk7XG4gIGlmIChodG1sU3RyaW5nKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcbiAgICAgIGNvbnN0IGRvbSA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcodHJ1c3RIVE1MKGh0bWxTdHJpbmcpLCAndGV4dC9odG1sJyk7XG4gICAgICBjb25zdCBub2RlcyA9ICRnZW5lcmF0ZU5vZGVzRnJvbURPTShlZGl0b3IsIGRvbSk7XG4gICAgICByZXR1cm4gJGluc2VydEdlbmVyYXRlZE5vZGVzKGVkaXRvciwgbm9kZXMsIHNlbGVjdGlvbik7XG4gICAgfSBjYXRjaCAoX3VudXNlZDIpIHtcbiAgICAgIC8vIEZhaWwgc2lsZW50bHkuXG4gICAgfVxuICB9XG5cbiAgLy8gTXVsdGktbGluZSBwbGFpbiB0ZXh0IGluIHJpY2ggdGV4dCBtb2RlIHBhc3RlZCBhcyBzZXBhcmF0ZSBwYXJhZ3JhcGhzXG4gIC8vIGluc3RlYWQgb2Ygc2luZ2xlIHBhcmFncmFwaCB3aXRoIGxpbmVicmVha3MuXG4gIC8vIFdlYmtpdC1zcGVjaWZpYzogU3VwcG9ydHMgcmVhZCAndGV4dC91cmktbGlzdCcgaW4gY2xpcGJvYXJkLlxuICBjb25zdCB0ZXh0ID0gZGF0YVRyYW5zZmVyLmdldERhdGEoJ3RleHQvcGxhaW4nKSB8fCBkYXRhVHJhbnNmZXIuZ2V0RGF0YSgndGV4dC91cmktbGlzdCcpO1xuICBpZiAodGV4dCAhPSBudWxsKSB7XG4gICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIGNvbnN0IHBhcnRzID0gdGV4dC5zcGxpdCgvKFxccj9cXG58XFx0KS8pO1xuICAgICAgaWYgKHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdID09PSAnJykge1xuICAgICAgICBwYXJ0cy5wb3AoKTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY3VycmVudFNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKGN1cnJlbnRTZWxlY3Rpb24pKSB7XG4gICAgICAgICAgY29uc3QgcGFydCA9IHBhcnRzW2ldO1xuICAgICAgICAgIGlmIChwYXJ0ID09PSAnXFxuJyB8fCBwYXJ0ID09PSAnXFxyXFxuJykge1xuICAgICAgICAgICAgY3VycmVudFNlbGVjdGlvbi5pbnNlcnRQYXJhZ3JhcGgoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHBhcnQgPT09ICdcXHQnKSB7XG4gICAgICAgICAgICBjdXJyZW50U2VsZWN0aW9uLmluc2VydE5vZGVzKFskY3JlYXRlVGFiTm9kZSgpXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN1cnJlbnRTZWxlY3Rpb24uaW5zZXJ0VGV4dChwYXJ0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZWN0aW9uLmluc2VydFJhd1RleHQodGV4dCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB0cnVzdEhUTUwoaHRtbCkge1xuICBpZiAod2luZG93LnRydXN0ZWRUeXBlcyAmJiB3aW5kb3cudHJ1c3RlZFR5cGVzLmNyZWF0ZVBvbGljeSkge1xuICAgIGNvbnN0IHBvbGljeSA9IHdpbmRvdy50cnVzdGVkVHlwZXMuY3JlYXRlUG9saWN5KCdsZXhpY2FsJywge1xuICAgICAgY3JlYXRlSFRNTDogaW5wdXQgPT4gaW5wdXRcbiAgICB9KTtcbiAgICByZXR1cm4gcG9saWN5LmNyZWF0ZUhUTUwoaHRtbCk7XG4gIH1cbiAgcmV0dXJuIGh0bWw7XG59XG5cbi8qKlxuICogSW5zZXJ0cyBMZXhpY2FsIG5vZGVzIGludG8gdGhlIGVkaXRvciB1c2luZyBkaWZmZXJlbnQgc3RyYXRlZ2llcyBkZXBlbmRpbmcgb25cbiAqIHNvbWUgc2ltcGxlIHNlbGVjdGlvbi1iYXNlZCBoZXVyaXN0aWNzLiBJZiB5b3UncmUgbG9va2luZyBmb3IgYSBnZW5lcmljIHdheSB0b1xuICogdG8gaW5zZXJ0IG5vZGVzIGludG8gdGhlIGVkaXRvciBhdCBhIHNwZWNpZmljIHNlbGVjdGlvbiBwb2ludCwgeW91IHByb2JhYmx5IHdhbnRcbiAqIHtAbGluayBsZXhpY2FsLiRpbnNlcnROb2Rlc31cbiAqXG4gKiBAcGFyYW0gZWRpdG9yIExleGljYWxFZGl0b3IgaW5zdGFuY2UgdG8gaW5zZXJ0IHRoZSBub2RlcyBpbnRvLlxuICogQHBhcmFtIG5vZGVzIFRoZSBub2RlcyB0byBpbnNlcnQuXG4gKiBAcGFyYW0gc2VsZWN0aW9uIFRoZSBzZWxlY3Rpb24gdG8gaW5zZXJ0IHRoZSBub2RlcyBpbnRvLlxuICovXG5mdW5jdGlvbiAkaW5zZXJ0R2VuZXJhdGVkTm9kZXMoZWRpdG9yLCBub2Rlcywgc2VsZWN0aW9uKSB7XG4gIGlmICghZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChTRUxFQ1RJT05fSU5TRVJUX0NMSVBCT0FSRF9OT0RFU19DT01NQU5ELCB7XG4gICAgbm9kZXMsXG4gICAgc2VsZWN0aW9uXG4gIH0pKSB7XG4gICAgc2VsZWN0aW9uLmluc2VydE5vZGVzKG5vZGVzKTtcbiAgfVxuICByZXR1cm47XG59XG5mdW5jdGlvbiBleHBvcnROb2RlVG9KU09OKG5vZGUpIHtcbiAgY29uc3Qgc2VyaWFsaXplZE5vZGUgPSBub2RlLmV4cG9ydEpTT04oKTtcbiAgY29uc3Qgbm9kZUNsYXNzID0gbm9kZS5jb25zdHJ1Y3RvcjtcbiAgaWYgKHNlcmlhbGl6ZWROb2RlLnR5cGUgIT09IG5vZGVDbGFzcy5nZXRUeXBlKCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgTGV4aWNhbE5vZGU6IE5vZGUgJHtub2RlQ2xhc3MubmFtZX0gZG9lcyBub3QgaW1wbGVtZW50IC5leHBvcnRKU09OKCkuYCk7XG4gICAgfVxuICB9XG4gIGlmICgkaXNFbGVtZW50Tm9kZShub2RlKSkge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRDaGlsZHJlbiA9IHNlcmlhbGl6ZWROb2RlLmNoaWxkcmVuO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShzZXJpYWxpemVkQ2hpbGRyZW4pKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKGBMZXhpY2FsTm9kZTogTm9kZSAke25vZGVDbGFzcy5uYW1lfSBpcyBhbiBlbGVtZW50IGJ1dCAuZXhwb3J0SlNPTigpIGRvZXMgbm90IGhhdmUgYSBjaGlsZHJlbiBhcnJheS5gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNlcmlhbGl6ZWROb2RlO1xufVxuZnVuY3Rpb24gJGFwcGVuZE5vZGVzVG9KU09OKGVkaXRvciwgc2VsZWN0aW9uLCBjdXJyZW50Tm9kZSwgdGFyZ2V0QXJyYXkgPSBbXSkge1xuICBsZXQgc2hvdWxkSW5jbHVkZSA9IHNlbGVjdGlvbiAhPT0gbnVsbCA/IGN1cnJlbnROb2RlLmlzU2VsZWN0ZWQoc2VsZWN0aW9uKSA6IHRydWU7XG4gIGNvbnN0IHNob3VsZEV4Y2x1ZGUgPSAkaXNFbGVtZW50Tm9kZShjdXJyZW50Tm9kZSkgJiYgY3VycmVudE5vZGUuZXhjbHVkZUZyb21Db3B5KCdodG1sJyk7XG4gIGxldCB0YXJnZXQgPSBjdXJyZW50Tm9kZTtcbiAgaWYgKHNlbGVjdGlvbiAhPT0gbnVsbCkge1xuICAgIGxldCBjbG9uZSA9ICRjbG9uZVdpdGhQcm9wZXJ0aWVzKGN1cnJlbnROb2RlKTtcbiAgICBjbG9uZSA9ICRpc1RleHROb2RlKGNsb25lKSAmJiBzZWxlY3Rpb24gIT09IG51bGwgPyAkc2xpY2VTZWxlY3RlZFRleHROb2RlQ29udGVudChzZWxlY3Rpb24sIGNsb25lKSA6IGNsb25lO1xuICAgIHRhcmdldCA9IGNsb25lO1xuICB9XG4gIGNvbnN0IGNoaWxkcmVuID0gJGlzRWxlbWVudE5vZGUodGFyZ2V0KSA/IHRhcmdldC5nZXRDaGlsZHJlbigpIDogW107XG4gIGNvbnN0IHNlcmlhbGl6ZWROb2RlID0gZXhwb3J0Tm9kZVRvSlNPTih0YXJnZXQpO1xuXG4gIC8vIFRPRE86IFRleHROb2RlIGNhbGxzIGdldFRleHRDb250ZW50KCkgKE5PVCBub2RlLl9fdGV4dCkgd2l0aGluIGl0cyBleHBvcnRKU09OIG1ldGhvZFxuICAvLyB3aGljaCB1c2VzIGdldExhdGVzdCgpIHRvIGdldCB0aGUgdGV4dCBmcm9tIHRoZSBvcmlnaW5hbCBub2RlIHdpdGggdGhlIHNhbWUga2V5LlxuICAvLyBUaGlzIGlzIGEgZGVlcGVyIGlzc3VlIHdpdGggdGhlIHdvcmQgXCJjbG9uZVwiIGhlcmUsIGl0J3Mgc3RpbGwgYSByZWZlcmVuY2UgdG8gdGhlXG4gIC8vIHNhbWUgbm9kZSBhcyBmYXIgYXMgdGhlIExleGljYWxFZGl0b3IgaXMgY29uY2VybmVkIHNpbmNlIGl0IHNoYXJlcyBhIGtleS5cbiAgLy8gV2UgbmVlZCBhIHdheSB0byBjcmVhdGUgYSBjbG9uZSBvZiBhIE5vZGUgaW4gbWVtb3J5IHdpdGggaXRzIG93biBrZXksIGJ1dFxuICAvLyB1bnRpbCB0aGVuIHRoaXMgaGFjayB3aWxsIHdvcmsgZm9yIHRoZSBzZWxlY3RlZCB0ZXh0IGV4dHJhY3QgdXNlIGNhc2UuXG4gIGlmICgkaXNUZXh0Tm9kZSh0YXJnZXQpKSB7XG4gICAgY29uc3QgdGV4dCA9IHRhcmdldC5fX3RleHQ7XG4gICAgLy8gSWYgYW4gdW5jb2xsYXBzZWQgc2VsZWN0aW9uIGVuZHMgb3Igc3RhcnRzIGF0IHRoZSBlbmQgb2YgYSBsaW5lIG9mIHNwZWNpYWxpemVkLFxuICAgIC8vIFRleHROb2Rlcywgc3VjaCBhcyBjb2RlIHRva2Vucywgd2Ugd2lsbCBnZXQgYSAnYmxhbmsnIFRleHROb2RlIGhlcmUsIGkuZS4sIG9uZVxuICAgIC8vIHdpdGggdGV4dCBvZiBsZW5ndGggMC4gV2UgZG9uJ3Qgd2FudCB0aGlzLCBpdCBtYWtlcyBhIGNvbmZ1c2luZyBtZXNzLiBSZXNldCFcbiAgICBpZiAodGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICBzZXJpYWxpemVkTm9kZS50ZXh0ID0gdGV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgc2hvdWxkSW5jbHVkZSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hpbGROb2RlID0gY2hpbGRyZW5baV07XG4gICAgY29uc3Qgc2hvdWxkSW5jbHVkZUNoaWxkID0gJGFwcGVuZE5vZGVzVG9KU09OKGVkaXRvciwgc2VsZWN0aW9uLCBjaGlsZE5vZGUsIHNlcmlhbGl6ZWROb2RlLmNoaWxkcmVuKTtcbiAgICBpZiAoIXNob3VsZEluY2x1ZGUgJiYgJGlzRWxlbWVudE5vZGUoY3VycmVudE5vZGUpICYmIHNob3VsZEluY2x1ZGVDaGlsZCAmJiBjdXJyZW50Tm9kZS5leHRyYWN0V2l0aENoaWxkKGNoaWxkTm9kZSwgc2VsZWN0aW9uLCAnY2xvbmUnKSkge1xuICAgICAgc2hvdWxkSW5jbHVkZSA9IHRydWU7XG4gICAgfVxuICB9XG4gIGlmIChzaG91bGRJbmNsdWRlICYmICFzaG91bGRFeGNsdWRlKSB7XG4gICAgdGFyZ2V0QXJyYXkucHVzaChzZXJpYWxpemVkTm9kZSk7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzZXJpYWxpemVkTm9kZS5jaGlsZHJlbikpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlcmlhbGl6ZWROb2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzZXJpYWxpemVkQ2hpbGROb2RlID0gc2VyaWFsaXplZE5vZGUuY2hpbGRyZW5baV07XG4gICAgICB0YXJnZXRBcnJheS5wdXNoKHNlcmlhbGl6ZWRDaGlsZE5vZGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2hvdWxkSW5jbHVkZTtcbn1cblxuLy8gVE9ETyB3aHkgJCBmdW5jdGlvbiB3aXRoIEVkaXRvciBpbnN0YW5jZT9cbi8qKlxuICogR2V0cyB0aGUgTGV4aWNhbCBKU09OIG9mIHRoZSBub2RlcyBpbnNpZGUgdGhlIHByb3ZpZGVkIFNlbGVjdGlvbi5cbiAqXG4gKiBAcGFyYW0gZWRpdG9yIExleGljYWxFZGl0b3IgdG8gZ2V0IHRoZSBKU09OIGNvbnRlbnQgZnJvbS5cbiAqIEBwYXJhbSBzZWxlY3Rpb24gU2VsZWN0aW9uIHRvIGdldCB0aGUgSlNPTiBjb250ZW50IGZyb20uXG4gKiBAcmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0aGUgZWRpdG9yIG5hbWVzcGFjZSBhbmQgYSBsaXN0IG9mIHNlcmlhbGl6YWJsZSBub2RlcyBhcyBKYXZhU2NyaXB0IG9iamVjdHMuXG4gKi9cbmZ1bmN0aW9uICRnZW5lcmF0ZUpTT05Gcm9tU2VsZWN0ZWROb2RlcyhlZGl0b3IsIHNlbGVjdGlvbikge1xuICBjb25zdCBub2RlcyA9IFtdO1xuICBjb25zdCByb290ID0gJGdldFJvb3QoKTtcbiAgY29uc3QgdG9wTGV2ZWxDaGlsZHJlbiA9IHJvb3QuZ2V0Q2hpbGRyZW4oKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3BMZXZlbENoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdG9wTGV2ZWxOb2RlID0gdG9wTGV2ZWxDaGlsZHJlbltpXTtcbiAgICAkYXBwZW5kTm9kZXNUb0pTT04oZWRpdG9yLCBzZWxlY3Rpb24sIHRvcExldmVsTm9kZSwgbm9kZXMpO1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZXNwYWNlOiBlZGl0b3IuX2NvbmZpZy5uYW1lc3BhY2UsXG4gICAgbm9kZXNcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCB0YWtlcyBhbiBhcnJheSBvZiBvYmplY3RzIGNvbmZvcm1pbmcgdG8gdGhlIEJhc2VTZXJhbGl6ZWROb2RlIGludGVyZmFjZSBhbmQgcmV0dXJuc1xuICogYW4gQXJyYXkgY29udGFpbmluZyBpbnN0YW5jZXMgb2YgdGhlIGNvcnJlc3BvbmRpbmcgTGV4aWNhbE5vZGUgY2xhc3NlcyByZWdpc3RlcmVkIG9uIHRoZSBlZGl0b3IuXG4gKiBOb3JtYWxseSwgeW91J2QgZ2V0IGFuIEFycmF5IG9mIEJhc2VTZXJpYWxpemVkIG5vZGVzIGZyb20ge0BsaW5rICRnZW5lcmF0ZUpTT05Gcm9tU2VsZWN0ZWROb2Rlc31cbiAqXG4gKiBAcGFyYW0gc2VyaWFsaXplZE5vZGVzIGFuIEFycmF5IG9mIG9iamVjdHMgY29uZm9ybWluZyB0byB0aGUgQmFzZVNlcmlhbGl6ZWROb2RlIGludGVyZmFjZS5cbiAqIEByZXR1cm5zIGFuIEFycmF5IG9mIExleGljYWwgTm9kZSBvYmplY3RzLlxuICovXG5mdW5jdGlvbiAkZ2VuZXJhdGVOb2Rlc0Zyb21TZXJpYWxpemVkTm9kZXMoc2VyaWFsaXplZE5vZGVzKSB7XG4gIGNvbnN0IG5vZGVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2VyaWFsaXplZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZE5vZGUgPSBzZXJpYWxpemVkTm9kZXNbaV07XG4gICAgY29uc3Qgbm9kZSA9ICRwYXJzZVNlcmlhbGl6ZWROb2RlKHNlcmlhbGl6ZWROb2RlKTtcbiAgICBpZiAoJGlzVGV4dE5vZGUobm9kZSkpIHtcbiAgICAgICRhZGROb2RlU3R5bGUobm9kZSk7XG4gICAgfVxuICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gIH1cbiAgcmV0dXJuIG5vZGVzO1xufVxuY29uc3QgRVZFTlRfTEFURU5DWSA9IDUwO1xubGV0IGNsaXBib2FyZEV2ZW50VGltZW91dCA9IG51bGw7XG5cbi8vIFRPRE8gY3VzdG9tIHNlbGVjdGlvblxuLy8gVE9ETyBwb3RlbnRpYWxseSBoYXZlIGEgbm9kZSBjdXN0b21pemFibGUgdmVyc2lvbiBmb3IgcGxhaW4gdGV4dFxuLyoqXG4gKiBDb3BpZXMgdGhlIGNvbnRlbnQgb2YgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHRvIHRoZSBjbGlwYm9hcmQgaW5cbiAqIHRleHQvcGxhaW4sIHRleHQvaHRtbCwgYW5kIGFwcGxpY2F0aW9uL3gtbGV4aWNhbC1lZGl0b3IgKExleGljYWwgSlNPTilcbiAqIGZvcm1hdHMuXG4gKlxuICogQHBhcmFtIGVkaXRvciB0aGUgTGV4aWNhbEVkaXRvciBpbnN0YW5jZSB0byBjb3B5IGNvbnRlbnQgZnJvbVxuICogQHBhcmFtIGV2ZW50IHRoZSBuYXRpdmUgYnJvd3NlciBDbGlwYm9hcmRFdmVudCB0byBhZGQgdGhlIGNvbnRlbnQgdG8uXG4gKiBAcmV0dXJuc1xuICovXG5hc3luYyBmdW5jdGlvbiBjb3B5VG9DbGlwYm9hcmQoZWRpdG9yLCBldmVudCwgZGF0YSkge1xuICBpZiAoY2xpcGJvYXJkRXZlbnRUaW1lb3V0ICE9PSBudWxsKSB7XG4gICAgLy8gUHJldmVudCB3ZWlyZCByYWNlIGNvbmRpdGlvbnMgdGhhdCBjYW4gaGFwcGVuIHdoZW4gdGhpcyBmdW5jdGlvbiBpcyBydW4gbXVsdGlwbGUgdGltZXNcbiAgICAvLyBzeW5jaHJvbm91c2x5LiBJbiB0aGUgZnV0dXJlLCB3ZSBjYW4gZG8gYmV0dGVyLCB3ZSBjYW4gY2FuY2VsL292ZXJyaWRlIHRoZSBwcmV2aW91c2x5IHJ1bm5pbmcgam9iLlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZXZlbnQgIT09IG51bGwpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICAgIHJlc29sdmUoJGNvcHlUb0NsaXBib2FyZEV2ZW50KGVkaXRvciwgZXZlbnQsIGRhdGEpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGNvbnN0IHJvb3RFbGVtZW50ID0gZWRpdG9yLmdldFJvb3RFbGVtZW50KCk7XG4gIGNvbnN0IHdpbmRvd0RvY3VtZW50ID0gZWRpdG9yLl93aW5kb3cgPT0gbnVsbCA/IHdpbmRvdy5kb2N1bWVudCA6IGVkaXRvci5fd2luZG93LmRvY3VtZW50O1xuICBjb25zdCBkb21TZWxlY3Rpb24gPSBnZXRET01TZWxlY3Rpb24oZWRpdG9yLl93aW5kb3cpO1xuICBpZiAocm9vdEVsZW1lbnQgPT09IG51bGwgfHwgZG9tU2VsZWN0aW9uID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGVsZW1lbnQgPSB3aW5kb3dEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gIGVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9ICdwb3NpdGlvbjogZml4ZWQ7IHRvcDogLTEwMDBweDsnO1xuICBlbGVtZW50LmFwcGVuZCh3aW5kb3dEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnIycpKTtcbiAgcm9vdEVsZW1lbnQuYXBwZW5kKGVsZW1lbnQpO1xuICBjb25zdCByYW5nZSA9IG5ldyBSYW5nZSgpO1xuICByYW5nZS5zZXRTdGFydChlbGVtZW50LCAwKTtcbiAgcmFuZ2Uuc2V0RW5kKGVsZW1lbnQsIDEpO1xuICBkb21TZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gIGRvbVNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgcmVtb3ZlTGlzdGVuZXIgPSBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKENPUFlfQ09NTUFORCwgc2Vjb25kRXZlbnQgPT4ge1xuICAgICAgaWYgKG9iamVjdEtsYXNzRXF1YWxzKHNlY29uZEV2ZW50LCBDbGlwYm9hcmRFdmVudCkpIHtcbiAgICAgICAgcmVtb3ZlTGlzdGVuZXIoKTtcbiAgICAgICAgaWYgKGNsaXBib2FyZEV2ZW50VGltZW91dCAhPT0gbnVsbCkge1xuICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoY2xpcGJvYXJkRXZlbnRUaW1lb3V0KTtcbiAgICAgICAgICBjbGlwYm9hcmRFdmVudFRpbWVvdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUoJGNvcHlUb0NsaXBib2FyZEV2ZW50KGVkaXRvciwgc2Vjb25kRXZlbnQsIGRhdGEpKTtcbiAgICAgIH1cbiAgICAgIC8vIEJsb2NrIHRoZSBlbnRpcmUgY29weSBmbG93IHdoaWxlIHdlIHdhaXQgZm9yIHRoZSBuZXh0IENsaXBib2FyZEV2ZW50XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LCBDT01NQU5EX1BSSU9SSVRZX0NSSVRJQ0FMKTtcbiAgICAvLyBJZiB0aGUgYWJvdmUgaGFjayBleGVjQ29tbWFuZCBoYWNrIHdvcmtzLCB0aGlzIHRpbWVvdXQgY29kZSBzaG91bGQgbmV2ZXIgZmlyZS4gT3RoZXJ3aXNlLFxuICAgIC8vIHRoZSBsaXN0ZW5lciB3aWxsIGJlIHF1aWNrbHkgZnJlZWQgc28gdGhhdCB0aGUgdXNlciBjYW4gcmV1c2UgaXQgYWdhaW5cbiAgICBjbGlwYm9hcmRFdmVudFRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICByZW1vdmVMaXN0ZW5lcigpO1xuICAgICAgY2xpcGJvYXJkRXZlbnRUaW1lb3V0ID0gbnVsbDtcbiAgICAgIHJlc29sdmUoZmFsc2UpO1xuICAgIH0sIEVWRU5UX0xBVEVOQ1kpO1xuICAgIHdpbmRvd0RvY3VtZW50LmV4ZWNDb21tYW5kKCdjb3B5Jyk7XG4gICAgZWxlbWVudC5yZW1vdmUoKTtcbiAgfSk7XG59XG5cbi8vIFRPRE8gc2hvdWxkbid0IHBhc3MgZWRpdG9yIChwYXNzIG5hbWVzcGFjZSBkaXJlY3RseSlcbmZ1bmN0aW9uICRjb3B5VG9DbGlwYm9hcmRFdmVudChlZGl0b3IsIGV2ZW50LCBkYXRhKSB7XG4gIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBkb21TZWxlY3Rpb24gPSBnZXRET01TZWxlY3Rpb24oZWRpdG9yLl93aW5kb3cpO1xuICAgIGlmICghZG9tU2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGFuY2hvckRPTSA9IGRvbVNlbGVjdGlvbi5hbmNob3JOb2RlO1xuICAgIGNvbnN0IGZvY3VzRE9NID0gZG9tU2VsZWN0aW9uLmZvY3VzTm9kZTtcbiAgICBpZiAoYW5jaG9yRE9NICE9PSBudWxsICYmIGZvY3VzRE9NICE9PSBudWxsICYmICFpc1NlbGVjdGlvbldpdGhpbkVkaXRvcihlZGl0b3IsIGFuY2hvckRPTSwgZm9jdXNET00pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoc2VsZWN0aW9uID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGRhdGEgPSAkZ2V0Q2xpcGJvYXJkRGF0YUZyb21TZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgfVxuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICBjb25zdCBjbGlwYm9hcmREYXRhID0gZXZlbnQuY2xpcGJvYXJkRGF0YTtcbiAgaWYgKGNsaXBib2FyZERhdGEgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc2V0TGV4aWNhbENsaXBib2FyZERhdGFUcmFuc2ZlcihjbGlwYm9hcmREYXRhLCBkYXRhKTtcbiAgcmV0dXJuIHRydWU7XG59XG5jb25zdCBjbGlwYm9hcmREYXRhRnVuY3Rpb25zID0gW1sndGV4dC9odG1sJywgJGdldEh0bWxDb250ZW50XSwgWydhcHBsaWNhdGlvbi94LWxleGljYWwtZWRpdG9yJywgJGdldExleGljYWxDb250ZW50XV07XG5cbi8qKlxuICogU2VyaWFsaXplIHRoZSBjb250ZW50IG9mIHRoZSBjdXJyZW50IHNlbGVjdGlvbiB0byBzdHJpbmdzIGluXG4gKiB0ZXh0L3BsYWluLCB0ZXh0L2h0bWwsIGFuZCBhcHBsaWNhdGlvbi94LWxleGljYWwtZWRpdG9yIChMZXhpY2FsIEpTT04pXG4gKiBmb3JtYXRzIChhcyBhdmFpbGFibGUpLlxuICpcbiAqIEBwYXJhbSBzZWxlY3Rpb24gdGhlIHNlbGVjdGlvbiB0byBzZXJpYWxpemUgKGRlZmF1bHRzIHRvICRnZXRTZWxlY3Rpb24oKSlcbiAqIEByZXR1cm5zIExleGljYWxDbGlwYm9hcmREYXRhXG4gKi9cbmZ1bmN0aW9uICRnZXRDbGlwYm9hcmREYXRhRnJvbVNlbGVjdGlvbihzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCkpIHtcbiAgY29uc3QgY2xpcGJvYXJkRGF0YSA9IHtcbiAgICAndGV4dC9wbGFpbic6IHNlbGVjdGlvbiA/IHNlbGVjdGlvbi5nZXRUZXh0Q29udGVudCgpIDogJydcbiAgfTtcbiAgaWYgKHNlbGVjdGlvbikge1xuICAgIGNvbnN0IGVkaXRvciA9ICRnZXRFZGl0b3IoKTtcbiAgICBmb3IgKGNvbnN0IFttaW1lVHlwZSwgJGVkaXRvckZuXSBvZiBjbGlwYm9hcmREYXRhRnVuY3Rpb25zKSB7XG4gICAgICBjb25zdCB2ID0gJGVkaXRvckZuKGVkaXRvciwgc2VsZWN0aW9uKTtcbiAgICAgIGlmICh2ICE9PSBudWxsKSB7XG4gICAgICAgIGNsaXBib2FyZERhdGFbbWltZVR5cGVdID0gdjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNsaXBib2FyZERhdGE7XG59XG5cbi8qKlxuICogQ2FsbCBzZXREYXRhIG9uIHRoZSBnaXZlbiBjbGlwYm9hcmREYXRhIGZvciBlYWNoIE1JTUUgdHlwZSBwcmVzZW50XG4gKiBpbiB0aGUgZ2l2ZW4gZGF0YSAoZnJvbSB7QGxpbmsgJGdldENsaXBib2FyZERhdGFGcm9tU2VsZWN0aW9ufSlcbiAqXG4gKiBAcGFyYW0gY2xpcGJvYXJkRGF0YSB0aGUgZXZlbnQuY2xpcGJvYXJkRGF0YSB0byBwb3B1bGF0ZSBmcm9tIGRhdGFcbiAqIEBwYXJhbSBkYXRhIFRoZSBsZXhpY2FsIGRhdGFcbiAqL1xuZnVuY3Rpb24gc2V0TGV4aWNhbENsaXBib2FyZERhdGFUcmFuc2ZlcihjbGlwYm9hcmREYXRhLCBkYXRhKSB7XG4gIGZvciAoY29uc3QgayBpbiBkYXRhKSB7XG4gICAgY29uc3QgdiA9IGRhdGFba107XG4gICAgaWYgKHYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2xpcGJvYXJkRGF0YS5zZXREYXRhKGssIHYpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgeyAkZ2VuZXJhdGVKU09ORnJvbVNlbGVjdGVkTm9kZXMsICRnZW5lcmF0ZU5vZGVzRnJvbVNlcmlhbGl6ZWROb2RlcywgJGdldENsaXBib2FyZERhdGFGcm9tU2VsZWN0aW9uLCAkZ2V0SHRtbENvbnRlbnQsICRnZXRMZXhpY2FsQ29udGVudCwgJGluc2VydERhdGFUcmFuc2ZlckZvclBsYWluVGV4dCwgJGluc2VydERhdGFUcmFuc2ZlckZvclJpY2hUZXh0LCAkaW5zZXJ0R2VuZXJhdGVkTm9kZXMsIGNvcHlUb0NsaXBib2FyZCwgc2V0TGV4aWNhbENsaXBib2FyZERhdGFUcmFuc2ZlciB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/clipboard/LexicalClipboard.dev.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/dragon/LexicalDragon.dev.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@lexical/dragon/LexicalDragon.dev.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   registerDragonSupport: () => (/* binding */ registerDragonSupport)\n/* harmony export */ });\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(app-pages-browser)/./node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction registerDragonSupport(editor) {\n  const origin = window.location.origin;\n  const handler = event => {\n    if (event.origin !== origin) {\n      return;\n    }\n    const rootElement = editor.getRootElement();\n    if (document.activeElement !== rootElement) {\n      return;\n    }\n    const data = event.data;\n    if (typeof data === 'string') {\n      let parsedData;\n      try {\n        parsedData = JSON.parse(data);\n      } catch (e) {\n        return;\n      }\n      if (parsedData && parsedData.protocol === 'nuanria_messaging' && parsedData.type === 'request') {\n        const payload = parsedData.payload;\n        if (payload && payload.functionId === 'makeChanges') {\n          const args = payload.args;\n          if (args) {\n            const [elementStart, elementLength, text, selStart, selLength, formatCommand] = args;\n            editor.update(() => {\n              const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n              if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n                const anchor = selection.anchor;\n                let anchorNode = anchor.getNode();\n                let setSelStart = 0;\n                let setSelEnd = 0;\n                if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(anchorNode)) {\n                  // set initial selection\n                  if (elementStart >= 0 && elementLength >= 0) {\n                    setSelStart = elementStart;\n                    setSelEnd = elementStart + elementLength;\n                    // If the offset is more than the end, make it the end\n                    selection.setTextNodeRange(anchorNode, setSelStart, anchorNode, setSelEnd);\n                  }\n                }\n                if (setSelStart !== setSelEnd || text !== '') {\n                  selection.insertRawText(text);\n                  anchorNode = anchor.getNode();\n                }\n                if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(anchorNode)) {\n                  // set final selection\n                  setSelStart = selStart;\n                  setSelEnd = selStart + selLength;\n                  const anchorNodeTextLength = anchorNode.getTextContentSize();\n                  // If the offset is more than the end, make it the end\n                  setSelStart = setSelStart > anchorNodeTextLength ? anchorNodeTextLength : setSelStart;\n                  setSelEnd = setSelEnd > anchorNodeTextLength ? anchorNodeTextLength : setSelEnd;\n                  selection.setTextNodeRange(anchorNode, setSelStart, anchorNode, setSelEnd);\n                }\n\n                // block the chrome extension from handling this event\n                event.stopImmediatePropagation();\n              }\n            });\n          }\n        }\n      }\n    }\n  };\n  window.addEventListener('message', handler, true);\n  return () => {\n    window.removeEventListener('message', handler, true);\n  };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9kcmFnb24vTGV4aWNhbERyYWdvbi5kZXYubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXdFOztBQUV4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHNEQUFhO0FBQzdDLGtCQUFrQiwwREFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0RBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9EQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWlDIiwic291cmNlcyI6WyIvVXNlcnMvbGVpL2hvbWUvdW5kZXJnL3RoZWF0cmUveTMvc2VncC9taWxrdXAvbm9kZV9tb2R1bGVzL0BsZXhpY2FsL2RyYWdvbi9MZXhpY2FsRHJhZ29uLmRldi5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5pbXBvcnQgeyAkZ2V0U2VsZWN0aW9uLCAkaXNSYW5nZVNlbGVjdGlvbiwgJGlzVGV4dE5vZGUgfSBmcm9tICdsZXhpY2FsJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiByZWdpc3RlckRyYWdvblN1cHBvcnQoZWRpdG9yKSB7XG4gIGNvbnN0IG9yaWdpbiA9IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW47XG4gIGNvbnN0IGhhbmRsZXIgPSBldmVudCA9PiB7XG4gICAgaWYgKGV2ZW50Lm9yaWdpbiAhPT0gb3JpZ2luKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJvb3RFbGVtZW50ID0gZWRpdG9yLmdldFJvb3RFbGVtZW50KCk7XG4gICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IHJvb3RFbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBldmVudC5kYXRhO1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGxldCBwYXJzZWREYXRhO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcGFyc2VkRGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJzZWREYXRhICYmIHBhcnNlZERhdGEucHJvdG9jb2wgPT09ICdudWFucmlhX21lc3NhZ2luZycgJiYgcGFyc2VkRGF0YS50eXBlID09PSAncmVxdWVzdCcpIHtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHBhcnNlZERhdGEucGF5bG9hZDtcbiAgICAgICAgaWYgKHBheWxvYWQgJiYgcGF5bG9hZC5mdW5jdGlvbklkID09PSAnbWFrZUNoYW5nZXMnKSB7XG4gICAgICAgICAgY29uc3QgYXJncyA9IHBheWxvYWQuYXJncztcbiAgICAgICAgICBpZiAoYXJncykge1xuICAgICAgICAgICAgY29uc3QgW2VsZW1lbnRTdGFydCwgZWxlbWVudExlbmd0aCwgdGV4dCwgc2VsU3RhcnQsIHNlbExlbmd0aCwgZm9ybWF0Q29tbWFuZF0gPSBhcmdzO1xuICAgICAgICAgICAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICAgICAgICAgICAgICAgIGxldCBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgICAgICAgICAgICAgICBsZXQgc2V0U2VsU3RhcnQgPSAwO1xuICAgICAgICAgICAgICAgIGxldCBzZXRTZWxFbmQgPSAwO1xuICAgICAgICAgICAgICAgIGlmICgkaXNUZXh0Tm9kZShhbmNob3JOb2RlKSkge1xuICAgICAgICAgICAgICAgICAgLy8gc2V0IGluaXRpYWwgc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudFN0YXJ0ID49IDAgJiYgZWxlbWVudExlbmd0aCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFNlbFN0YXJ0ID0gZWxlbWVudFN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICBzZXRTZWxFbmQgPSBlbGVtZW50U3RhcnQgKyBlbGVtZW50TGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgb2Zmc2V0IGlzIG1vcmUgdGhhbiB0aGUgZW5kLCBtYWtlIGl0IHRoZSBlbmRcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uLnNldFRleHROb2RlUmFuZ2UoYW5jaG9yTm9kZSwgc2V0U2VsU3RhcnQsIGFuY2hvck5vZGUsIHNldFNlbEVuZCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZXRTZWxTdGFydCAhPT0gc2V0U2VsRW5kIHx8IHRleHQgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICBzZWxlY3Rpb24uaW5zZXJ0UmF3VGV4dCh0ZXh0KTtcbiAgICAgICAgICAgICAgICAgIGFuY2hvck5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoJGlzVGV4dE5vZGUoYW5jaG9yTm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgIC8vIHNldCBmaW5hbCBzZWxlY3Rpb25cbiAgICAgICAgICAgICAgICAgIHNldFNlbFN0YXJ0ID0gc2VsU3RhcnQ7XG4gICAgICAgICAgICAgICAgICBzZXRTZWxFbmQgPSBzZWxTdGFydCArIHNlbExlbmd0aDtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGFuY2hvck5vZGVUZXh0TGVuZ3RoID0gYW5jaG9yTm9kZS5nZXRUZXh0Q29udGVudFNpemUoKTtcbiAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBvZmZzZXQgaXMgbW9yZSB0aGFuIHRoZSBlbmQsIG1ha2UgaXQgdGhlIGVuZFxuICAgICAgICAgICAgICAgICAgc2V0U2VsU3RhcnQgPSBzZXRTZWxTdGFydCA+IGFuY2hvck5vZGVUZXh0TGVuZ3RoID8gYW5jaG9yTm9kZVRleHRMZW5ndGggOiBzZXRTZWxTdGFydDtcbiAgICAgICAgICAgICAgICAgIHNldFNlbEVuZCA9IHNldFNlbEVuZCA+IGFuY2hvck5vZGVUZXh0TGVuZ3RoID8gYW5jaG9yTm9kZVRleHRMZW5ndGggOiBzZXRTZWxFbmQ7XG4gICAgICAgICAgICAgICAgICBzZWxlY3Rpb24uc2V0VGV4dE5vZGVSYW5nZShhbmNob3JOb2RlLCBzZXRTZWxTdGFydCwgYW5jaG9yTm9kZSwgc2V0U2VsRW5kKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBibG9jayB0aGUgY2hyb21lIGV4dGVuc2lvbiBmcm9tIGhhbmRsaW5nIHRoaXMgZXZlbnRcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGhhbmRsZXIsIHRydWUpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgaGFuZGxlciwgdHJ1ZSk7XG4gIH07XG59XG5cbmV4cG9ydCB7IHJlZ2lzdGVyRHJhZ29uU3VwcG9ydCB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/dragon/LexicalDragon.dev.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/history/LexicalHistory.dev.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@lexical/history/LexicalHistory.dev.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createEmptyHistoryState: () => (/* binding */ createEmptyHistoryState),\n/* harmony export */   registerHistory: () => (/* binding */ registerHistory)\n/* harmony export */ });\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/utils */ \"(app-pages-browser)/./node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(app-pages-browser)/./node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst HISTORY_MERGE = 0;\nconst HISTORY_PUSH = 1;\nconst DISCARD_HISTORY_CANDIDATE = 2;\nconst OTHER = 0;\nconst COMPOSING_CHARACTER = 1;\nconst INSERT_CHARACTER_AFTER_SELECTION = 2;\nconst DELETE_CHARACTER_BEFORE_SELECTION = 3;\nconst DELETE_CHARACTER_AFTER_SELECTION = 4;\nfunction getDirtyNodes(editorState, dirtyLeaves, dirtyElements) {\n  const nodeMap = editorState._nodeMap;\n  const nodes = [];\n  for (const dirtyLeafKey of dirtyLeaves) {\n    const dirtyLeaf = nodeMap.get(dirtyLeafKey);\n    if (dirtyLeaf !== undefined) {\n      nodes.push(dirtyLeaf);\n    }\n  }\n  for (const [dirtyElementKey, intentionallyMarkedAsDirty] of dirtyElements) {\n    if (!intentionallyMarkedAsDirty) {\n      continue;\n    }\n    const dirtyElement = nodeMap.get(dirtyElementKey);\n    if (dirtyElement !== undefined && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootNode)(dirtyElement)) {\n      nodes.push(dirtyElement);\n    }\n  }\n  return nodes;\n}\nfunction getChangeType(prevEditorState, nextEditorState, dirtyLeavesSet, dirtyElementsSet, isComposing) {\n  if (prevEditorState === null || dirtyLeavesSet.size === 0 && dirtyElementsSet.size === 0 && !isComposing) {\n    return OTHER;\n  }\n  const nextSelection = nextEditorState._selection;\n  const prevSelection = prevEditorState._selection;\n  if (isComposing) {\n    return COMPOSING_CHARACTER;\n  }\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(nextSelection) || !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(prevSelection) || !prevSelection.isCollapsed() || !nextSelection.isCollapsed()) {\n    return OTHER;\n  }\n  const dirtyNodes = getDirtyNodes(nextEditorState, dirtyLeavesSet, dirtyElementsSet);\n  if (dirtyNodes.length === 0) {\n    return OTHER;\n  }\n\n  // Catching the case when inserting new text node into an element (e.g. first char in paragraph/list),\n  // or after existing node.\n  if (dirtyNodes.length > 1) {\n    const nextNodeMap = nextEditorState._nodeMap;\n    const nextAnchorNode = nextNodeMap.get(nextSelection.anchor.key);\n    const prevAnchorNode = nextNodeMap.get(prevSelection.anchor.key);\n    if (nextAnchorNode && prevAnchorNode && !prevEditorState._nodeMap.has(nextAnchorNode.__key) && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(nextAnchorNode) && nextAnchorNode.__text.length === 1 && nextSelection.anchor.offset === 1) {\n      return INSERT_CHARACTER_AFTER_SELECTION;\n    }\n    return OTHER;\n  }\n  const nextDirtyNode = dirtyNodes[0];\n  const prevDirtyNode = prevEditorState._nodeMap.get(nextDirtyNode.__key);\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(prevDirtyNode) || !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(nextDirtyNode) || prevDirtyNode.__mode !== nextDirtyNode.__mode) {\n    return OTHER;\n  }\n  const prevText = prevDirtyNode.__text;\n  const nextText = nextDirtyNode.__text;\n  if (prevText === nextText) {\n    return OTHER;\n  }\n  const nextAnchor = nextSelection.anchor;\n  const prevAnchor = prevSelection.anchor;\n  if (nextAnchor.key !== prevAnchor.key || nextAnchor.type !== 'text') {\n    return OTHER;\n  }\n  const nextAnchorOffset = nextAnchor.offset;\n  const prevAnchorOffset = prevAnchor.offset;\n  const textDiff = nextText.length - prevText.length;\n  if (textDiff === 1 && prevAnchorOffset === nextAnchorOffset - 1) {\n    return INSERT_CHARACTER_AFTER_SELECTION;\n  }\n  if (textDiff === -1 && prevAnchorOffset === nextAnchorOffset + 1) {\n    return DELETE_CHARACTER_BEFORE_SELECTION;\n  }\n  if (textDiff === -1 && prevAnchorOffset === nextAnchorOffset) {\n    return DELETE_CHARACTER_AFTER_SELECTION;\n  }\n  return OTHER;\n}\nfunction isTextNodeUnchanged(key, prevEditorState, nextEditorState) {\n  const prevNode = prevEditorState._nodeMap.get(key);\n  const nextNode = nextEditorState._nodeMap.get(key);\n  const prevSelection = prevEditorState._selection;\n  const nextSelection = nextEditorState._selection;\n  const isDeletingLine = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(prevSelection) && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(nextSelection) && prevSelection.anchor.type === 'element' && prevSelection.focus.type === 'element' && nextSelection.anchor.type === 'text' && nextSelection.focus.type === 'text';\n  if (!isDeletingLine && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(prevNode) && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(nextNode) && prevNode.__parent === nextNode.__parent) {\n    // This has the assumption that object key order won't change if the\n    // content did not change, which should normally be safe given\n    // the manner in which nodes and exportJSON are typically implemented.\n    return JSON.stringify(prevEditorState.read(() => prevNode.exportJSON())) === JSON.stringify(nextEditorState.read(() => nextNode.exportJSON()));\n  }\n  return false;\n}\nfunction createMergeActionGetter(editor, delay) {\n  let prevChangeTime = Date.now();\n  let prevChangeType = OTHER;\n  return (prevEditorState, nextEditorState, currentHistoryEntry, dirtyLeaves, dirtyElements, tags) => {\n    const changeTime = Date.now();\n\n    // If applying changes from history stack there's no need\n    // to run history logic again, as history entries already calculated\n    if (tags.has('historic')) {\n      prevChangeType = OTHER;\n      prevChangeTime = changeTime;\n      return DISCARD_HISTORY_CANDIDATE;\n    }\n    const changeType = getChangeType(prevEditorState, nextEditorState, dirtyLeaves, dirtyElements, editor.isComposing());\n    const mergeAction = (() => {\n      const isSameEditor = currentHistoryEntry === null || currentHistoryEntry.editor === editor;\n      const shouldPushHistory = tags.has('history-push');\n      const shouldMergeHistory = !shouldPushHistory && isSameEditor && tags.has('history-merge');\n      if (shouldMergeHistory) {\n        return HISTORY_MERGE;\n      }\n      if (prevEditorState === null) {\n        return HISTORY_PUSH;\n      }\n      const selection = nextEditorState._selection;\n      const hasDirtyNodes = dirtyLeaves.size > 0 || dirtyElements.size > 0;\n      if (!hasDirtyNodes) {\n        if (selection !== null) {\n          return HISTORY_MERGE;\n        }\n        return DISCARD_HISTORY_CANDIDATE;\n      }\n      if (shouldPushHistory === false && changeType !== OTHER && changeType === prevChangeType && changeTime < prevChangeTime + delay && isSameEditor) {\n        return HISTORY_MERGE;\n      }\n\n      // A single node might have been marked as dirty, but not have changed\n      // due to some node transform reverting the change.\n      if (dirtyLeaves.size === 1) {\n        const dirtyLeafKey = Array.from(dirtyLeaves)[0];\n        if (isTextNodeUnchanged(dirtyLeafKey, prevEditorState, nextEditorState)) {\n          return HISTORY_MERGE;\n        }\n      }\n      return HISTORY_PUSH;\n    })();\n    prevChangeTime = changeTime;\n    prevChangeType = changeType;\n    return mergeAction;\n  };\n}\nfunction redo(editor, historyState) {\n  const redoStack = historyState.redoStack;\n  const undoStack = historyState.undoStack;\n  if (redoStack.length !== 0) {\n    const current = historyState.current;\n    if (current !== null) {\n      undoStack.push(current);\n      editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CAN_UNDO_COMMAND, true);\n    }\n    const historyStateEntry = redoStack.pop();\n    if (redoStack.length === 0) {\n      editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CAN_REDO_COMMAND, false);\n    }\n    historyState.current = historyStateEntry || null;\n    if (historyStateEntry) {\n      historyStateEntry.editor.setEditorState(historyStateEntry.editorState, {\n        tag: 'historic'\n      });\n    }\n  }\n}\nfunction undo(editor, historyState) {\n  const redoStack = historyState.redoStack;\n  const undoStack = historyState.undoStack;\n  const undoStackLength = undoStack.length;\n  if (undoStackLength !== 0) {\n    const current = historyState.current;\n    const historyStateEntry = undoStack.pop();\n    if (current !== null) {\n      redoStack.push(current);\n      editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CAN_REDO_COMMAND, true);\n    }\n    if (undoStack.length === 0) {\n      editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CAN_UNDO_COMMAND, false);\n    }\n    historyState.current = historyStateEntry || null;\n    if (historyStateEntry) {\n      historyStateEntry.editor.setEditorState(historyStateEntry.editorState, {\n        tag: 'historic'\n      });\n    }\n  }\n}\nfunction clearHistory(historyState) {\n  historyState.undoStack = [];\n  historyState.redoStack = [];\n  historyState.current = null;\n}\n\n/**\n * Registers necessary listeners to manage undo/redo history stack and related editor commands.\n * It returns `unregister` callback that cleans up all listeners and should be called on editor unmount.\n * @param editor - The lexical editor.\n * @param historyState - The history state, containing the current state and the undo/redo stack.\n * @param delay - The time (in milliseconds) the editor should delay generating a new history stack,\n * instead of merging the current changes with the current stack.\n * @returns The listeners cleanup callback function.\n */\nfunction registerHistory(editor, historyState, delay) {\n  const getMergeAction = createMergeActionGetter(editor, delay);\n  const applyChange = ({\n    editorState,\n    prevEditorState,\n    dirtyLeaves,\n    dirtyElements,\n    tags\n  }) => {\n    const current = historyState.current;\n    const redoStack = historyState.redoStack;\n    const undoStack = historyState.undoStack;\n    const currentEditorState = current === null ? null : current.editorState;\n    if (current !== null && editorState === currentEditorState) {\n      return;\n    }\n    const mergeAction = getMergeAction(prevEditorState, editorState, current, dirtyLeaves, dirtyElements, tags);\n    if (mergeAction === HISTORY_PUSH) {\n      if (redoStack.length !== 0) {\n        historyState.redoStack = [];\n        editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CAN_REDO_COMMAND, false);\n      }\n      if (current !== null) {\n        undoStack.push({\n          ...current\n        });\n        editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CAN_UNDO_COMMAND, true);\n      }\n    } else if (mergeAction === DISCARD_HISTORY_CANDIDATE) {\n      return;\n    }\n\n    // Else we merge\n    historyState.current = {\n      editor,\n      editorState\n    };\n  };\n  const unregister = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.mergeRegister)(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.UNDO_COMMAND, () => {\n    undo(editor, historyState);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.REDO_COMMAND, () => {\n    redo(editor, historyState);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CLEAR_EDITOR_COMMAND, () => {\n    clearHistory(historyState);\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CLEAR_HISTORY_COMMAND, () => {\n    clearHistory(historyState);\n    editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CAN_REDO_COMMAND, false);\n    editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CAN_UNDO_COMMAND, false);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerUpdateListener(applyChange));\n  return unregister;\n}\n\n/**\n * Creates an empty history state.\n * @returns - The empty history state, as an object.\n */\nfunction createEmptyHistoryState() {\n  return {\n    current: null,\n    redoStack: [],\n    undoStack: []\n  };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9oaXN0b3J5L0xleGljYWxIaXN0b3J5LmRldi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUrQztBQUM2Sjs7QUFFNU07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsb0RBQVc7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sMERBQWlCLG9CQUFvQiwwREFBaUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyxvREFBVztBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLG9EQUFXLG9CQUFvQixvREFBVztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwwREFBaUIsbUJBQW1CLDBEQUFpQjtBQUM5RSx5QkFBeUIsb0RBQVcsY0FBYyxvREFBVztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHFEQUFnQjtBQUM3QztBQUNBO0FBQ0E7QUFDQSw2QkFBNkIscURBQWdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHFEQUFnQjtBQUM3QztBQUNBO0FBQ0EsNkJBQTZCLHFEQUFnQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHFEQUFnQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCwrQkFBK0IscURBQWdCO0FBQy9DO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDZEQUFhLHdCQUF3QixpREFBWTtBQUN0RTtBQUNBO0FBQ0EsR0FBRyxFQUFFLDREQUF1QiwwQkFBMEIsaURBQVk7QUFDbEU7QUFDQTtBQUNBLEdBQUcsRUFBRSw0REFBdUIsMEJBQTBCLHlEQUFvQjtBQUMxRTtBQUNBO0FBQ0EsR0FBRyxFQUFFLDREQUF1QiwwQkFBMEIsMERBQXFCO0FBQzNFO0FBQ0EsMkJBQTJCLHFEQUFnQjtBQUMzQywyQkFBMkIscURBQWdCO0FBQzNDO0FBQ0EsR0FBRyxFQUFFLDREQUF1QjtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW9EIiwic291cmNlcyI6WyIvVXNlcnMvbGVpL2hvbWUvdW5kZXJnL3RoZWF0cmUveTMvc2VncC9taWxrdXAvbm9kZV9tb2R1bGVzL0BsZXhpY2FsL2hpc3RvcnkvTGV4aWNhbEhpc3RvcnkuZGV2Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmltcG9ydCB7IG1lcmdlUmVnaXN0ZXIgfSBmcm9tICdAbGV4aWNhbC91dGlscyc7XG5pbXBvcnQgeyBVTkRPX0NPTU1BTkQsIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SLCBSRURPX0NPTU1BTkQsIENMRUFSX0VESVRPUl9DT01NQU5ELCBDTEVBUl9ISVNUT1JZX0NPTU1BTkQsIENBTl9SRURPX0NPTU1BTkQsIENBTl9VTkRPX0NPTU1BTkQsICRpc1JhbmdlU2VsZWN0aW9uLCAkaXNUZXh0Tm9kZSwgJGlzUm9vdE5vZGUgfSBmcm9tICdsZXhpY2FsJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBISVNUT1JZX01FUkdFID0gMDtcbmNvbnN0IEhJU1RPUllfUFVTSCA9IDE7XG5jb25zdCBESVNDQVJEX0hJU1RPUllfQ0FORElEQVRFID0gMjtcbmNvbnN0IE9USEVSID0gMDtcbmNvbnN0IENPTVBPU0lOR19DSEFSQUNURVIgPSAxO1xuY29uc3QgSU5TRVJUX0NIQVJBQ1RFUl9BRlRFUl9TRUxFQ1RJT04gPSAyO1xuY29uc3QgREVMRVRFX0NIQVJBQ1RFUl9CRUZPUkVfU0VMRUNUSU9OID0gMztcbmNvbnN0IERFTEVURV9DSEFSQUNURVJfQUZURVJfU0VMRUNUSU9OID0gNDtcbmZ1bmN0aW9uIGdldERpcnR5Tm9kZXMoZWRpdG9yU3RhdGUsIGRpcnR5TGVhdmVzLCBkaXJ0eUVsZW1lbnRzKSB7XG4gIGNvbnN0IG5vZGVNYXAgPSBlZGl0b3JTdGF0ZS5fbm9kZU1hcDtcbiAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgZm9yIChjb25zdCBkaXJ0eUxlYWZLZXkgb2YgZGlydHlMZWF2ZXMpIHtcbiAgICBjb25zdCBkaXJ0eUxlYWYgPSBub2RlTWFwLmdldChkaXJ0eUxlYWZLZXkpO1xuICAgIGlmIChkaXJ0eUxlYWYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbm9kZXMucHVzaChkaXJ0eUxlYWYpO1xuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IFtkaXJ0eUVsZW1lbnRLZXksIGludGVudGlvbmFsbHlNYXJrZWRBc0RpcnR5XSBvZiBkaXJ0eUVsZW1lbnRzKSB7XG4gICAgaWYgKCFpbnRlbnRpb25hbGx5TWFya2VkQXNEaXJ0eSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGRpcnR5RWxlbWVudCA9IG5vZGVNYXAuZ2V0KGRpcnR5RWxlbWVudEtleSk7XG4gICAgaWYgKGRpcnR5RWxlbWVudCAhPT0gdW5kZWZpbmVkICYmICEkaXNSb290Tm9kZShkaXJ0eUVsZW1lbnQpKSB7XG4gICAgICBub2Rlcy5wdXNoKGRpcnR5RWxlbWVudCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBub2Rlcztcbn1cbmZ1bmN0aW9uIGdldENoYW5nZVR5cGUocHJldkVkaXRvclN0YXRlLCBuZXh0RWRpdG9yU3RhdGUsIGRpcnR5TGVhdmVzU2V0LCBkaXJ0eUVsZW1lbnRzU2V0LCBpc0NvbXBvc2luZykge1xuICBpZiAocHJldkVkaXRvclN0YXRlID09PSBudWxsIHx8IGRpcnR5TGVhdmVzU2V0LnNpemUgPT09IDAgJiYgZGlydHlFbGVtZW50c1NldC5zaXplID09PSAwICYmICFpc0NvbXBvc2luZykge1xuICAgIHJldHVybiBPVEhFUjtcbiAgfVxuICBjb25zdCBuZXh0U2VsZWN0aW9uID0gbmV4dEVkaXRvclN0YXRlLl9zZWxlY3Rpb247XG4gIGNvbnN0IHByZXZTZWxlY3Rpb24gPSBwcmV2RWRpdG9yU3RhdGUuX3NlbGVjdGlvbjtcbiAgaWYgKGlzQ29tcG9zaW5nKSB7XG4gICAgcmV0dXJuIENPTVBPU0lOR19DSEFSQUNURVI7XG4gIH1cbiAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihuZXh0U2VsZWN0aW9uKSB8fCAhJGlzUmFuZ2VTZWxlY3Rpb24ocHJldlNlbGVjdGlvbikgfHwgIXByZXZTZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSB8fCAhbmV4dFNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpKSB7XG4gICAgcmV0dXJuIE9USEVSO1xuICB9XG4gIGNvbnN0IGRpcnR5Tm9kZXMgPSBnZXREaXJ0eU5vZGVzKG5leHRFZGl0b3JTdGF0ZSwgZGlydHlMZWF2ZXNTZXQsIGRpcnR5RWxlbWVudHNTZXQpO1xuICBpZiAoZGlydHlOb2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gT1RIRVI7XG4gIH1cblxuICAvLyBDYXRjaGluZyB0aGUgY2FzZSB3aGVuIGluc2VydGluZyBuZXcgdGV4dCBub2RlIGludG8gYW4gZWxlbWVudCAoZS5nLiBmaXJzdCBjaGFyIGluIHBhcmFncmFwaC9saXN0KSxcbiAgLy8gb3IgYWZ0ZXIgZXhpc3Rpbmcgbm9kZS5cbiAgaWYgKGRpcnR5Tm9kZXMubGVuZ3RoID4gMSkge1xuICAgIGNvbnN0IG5leHROb2RlTWFwID0gbmV4dEVkaXRvclN0YXRlLl9ub2RlTWFwO1xuICAgIGNvbnN0IG5leHRBbmNob3JOb2RlID0gbmV4dE5vZGVNYXAuZ2V0KG5leHRTZWxlY3Rpb24uYW5jaG9yLmtleSk7XG4gICAgY29uc3QgcHJldkFuY2hvck5vZGUgPSBuZXh0Tm9kZU1hcC5nZXQocHJldlNlbGVjdGlvbi5hbmNob3Iua2V5KTtcbiAgICBpZiAobmV4dEFuY2hvck5vZGUgJiYgcHJldkFuY2hvck5vZGUgJiYgIXByZXZFZGl0b3JTdGF0ZS5fbm9kZU1hcC5oYXMobmV4dEFuY2hvck5vZGUuX19rZXkpICYmICRpc1RleHROb2RlKG5leHRBbmNob3JOb2RlKSAmJiBuZXh0QW5jaG9yTm9kZS5fX3RleHQubGVuZ3RoID09PSAxICYmIG5leHRTZWxlY3Rpb24uYW5jaG9yLm9mZnNldCA9PT0gMSkge1xuICAgICAgcmV0dXJuIElOU0VSVF9DSEFSQUNURVJfQUZURVJfU0VMRUNUSU9OO1xuICAgIH1cbiAgICByZXR1cm4gT1RIRVI7XG4gIH1cbiAgY29uc3QgbmV4dERpcnR5Tm9kZSA9IGRpcnR5Tm9kZXNbMF07XG4gIGNvbnN0IHByZXZEaXJ0eU5vZGUgPSBwcmV2RWRpdG9yU3RhdGUuX25vZGVNYXAuZ2V0KG5leHREaXJ0eU5vZGUuX19rZXkpO1xuICBpZiAoISRpc1RleHROb2RlKHByZXZEaXJ0eU5vZGUpIHx8ICEkaXNUZXh0Tm9kZShuZXh0RGlydHlOb2RlKSB8fCBwcmV2RGlydHlOb2RlLl9fbW9kZSAhPT0gbmV4dERpcnR5Tm9kZS5fX21vZGUpIHtcbiAgICByZXR1cm4gT1RIRVI7XG4gIH1cbiAgY29uc3QgcHJldlRleHQgPSBwcmV2RGlydHlOb2RlLl9fdGV4dDtcbiAgY29uc3QgbmV4dFRleHQgPSBuZXh0RGlydHlOb2RlLl9fdGV4dDtcbiAgaWYgKHByZXZUZXh0ID09PSBuZXh0VGV4dCkge1xuICAgIHJldHVybiBPVEhFUjtcbiAgfVxuICBjb25zdCBuZXh0QW5jaG9yID0gbmV4dFNlbGVjdGlvbi5hbmNob3I7XG4gIGNvbnN0IHByZXZBbmNob3IgPSBwcmV2U2VsZWN0aW9uLmFuY2hvcjtcbiAgaWYgKG5leHRBbmNob3Iua2V5ICE9PSBwcmV2QW5jaG9yLmtleSB8fCBuZXh0QW5jaG9yLnR5cGUgIT09ICd0ZXh0Jykge1xuICAgIHJldHVybiBPVEhFUjtcbiAgfVxuICBjb25zdCBuZXh0QW5jaG9yT2Zmc2V0ID0gbmV4dEFuY2hvci5vZmZzZXQ7XG4gIGNvbnN0IHByZXZBbmNob3JPZmZzZXQgPSBwcmV2QW5jaG9yLm9mZnNldDtcbiAgY29uc3QgdGV4dERpZmYgPSBuZXh0VGV4dC5sZW5ndGggLSBwcmV2VGV4dC5sZW5ndGg7XG4gIGlmICh0ZXh0RGlmZiA9PT0gMSAmJiBwcmV2QW5jaG9yT2Zmc2V0ID09PSBuZXh0QW5jaG9yT2Zmc2V0IC0gMSkge1xuICAgIHJldHVybiBJTlNFUlRfQ0hBUkFDVEVSX0FGVEVSX1NFTEVDVElPTjtcbiAgfVxuICBpZiAodGV4dERpZmYgPT09IC0xICYmIHByZXZBbmNob3JPZmZzZXQgPT09IG5leHRBbmNob3JPZmZzZXQgKyAxKSB7XG4gICAgcmV0dXJuIERFTEVURV9DSEFSQUNURVJfQkVGT1JFX1NFTEVDVElPTjtcbiAgfVxuICBpZiAodGV4dERpZmYgPT09IC0xICYmIHByZXZBbmNob3JPZmZzZXQgPT09IG5leHRBbmNob3JPZmZzZXQpIHtcbiAgICByZXR1cm4gREVMRVRFX0NIQVJBQ1RFUl9BRlRFUl9TRUxFQ1RJT047XG4gIH1cbiAgcmV0dXJuIE9USEVSO1xufVxuZnVuY3Rpb24gaXNUZXh0Tm9kZVVuY2hhbmdlZChrZXksIHByZXZFZGl0b3JTdGF0ZSwgbmV4dEVkaXRvclN0YXRlKSB7XG4gIGNvbnN0IHByZXZOb2RlID0gcHJldkVkaXRvclN0YXRlLl9ub2RlTWFwLmdldChrZXkpO1xuICBjb25zdCBuZXh0Tm9kZSA9IG5leHRFZGl0b3JTdGF0ZS5fbm9kZU1hcC5nZXQoa2V5KTtcbiAgY29uc3QgcHJldlNlbGVjdGlvbiA9IHByZXZFZGl0b3JTdGF0ZS5fc2VsZWN0aW9uO1xuICBjb25zdCBuZXh0U2VsZWN0aW9uID0gbmV4dEVkaXRvclN0YXRlLl9zZWxlY3Rpb247XG4gIGNvbnN0IGlzRGVsZXRpbmdMaW5lID0gJGlzUmFuZ2VTZWxlY3Rpb24ocHJldlNlbGVjdGlvbikgJiYgJGlzUmFuZ2VTZWxlY3Rpb24obmV4dFNlbGVjdGlvbikgJiYgcHJldlNlbGVjdGlvbi5hbmNob3IudHlwZSA9PT0gJ2VsZW1lbnQnICYmIHByZXZTZWxlY3Rpb24uZm9jdXMudHlwZSA9PT0gJ2VsZW1lbnQnICYmIG5leHRTZWxlY3Rpb24uYW5jaG9yLnR5cGUgPT09ICd0ZXh0JyAmJiBuZXh0U2VsZWN0aW9uLmZvY3VzLnR5cGUgPT09ICd0ZXh0JztcbiAgaWYgKCFpc0RlbGV0aW5nTGluZSAmJiAkaXNUZXh0Tm9kZShwcmV2Tm9kZSkgJiYgJGlzVGV4dE5vZGUobmV4dE5vZGUpICYmIHByZXZOb2RlLl9fcGFyZW50ID09PSBuZXh0Tm9kZS5fX3BhcmVudCkge1xuICAgIC8vIFRoaXMgaGFzIHRoZSBhc3N1bXB0aW9uIHRoYXQgb2JqZWN0IGtleSBvcmRlciB3b24ndCBjaGFuZ2UgaWYgdGhlXG4gICAgLy8gY29udGVudCBkaWQgbm90IGNoYW5nZSwgd2hpY2ggc2hvdWxkIG5vcm1hbGx5IGJlIHNhZmUgZ2l2ZW5cbiAgICAvLyB0aGUgbWFubmVyIGluIHdoaWNoIG5vZGVzIGFuZCBleHBvcnRKU09OIGFyZSB0eXBpY2FsbHkgaW1wbGVtZW50ZWQuXG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHByZXZFZGl0b3JTdGF0ZS5yZWFkKCgpID0+IHByZXZOb2RlLmV4cG9ydEpTT04oKSkpID09PSBKU09OLnN0cmluZ2lmeShuZXh0RWRpdG9yU3RhdGUucmVhZCgoKSA9PiBuZXh0Tm9kZS5leHBvcnRKU09OKCkpKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjcmVhdGVNZXJnZUFjdGlvbkdldHRlcihlZGl0b3IsIGRlbGF5KSB7XG4gIGxldCBwcmV2Q2hhbmdlVGltZSA9IERhdGUubm93KCk7XG4gIGxldCBwcmV2Q2hhbmdlVHlwZSA9IE9USEVSO1xuICByZXR1cm4gKHByZXZFZGl0b3JTdGF0ZSwgbmV4dEVkaXRvclN0YXRlLCBjdXJyZW50SGlzdG9yeUVudHJ5LCBkaXJ0eUxlYXZlcywgZGlydHlFbGVtZW50cywgdGFncykgPT4ge1xuICAgIGNvbnN0IGNoYW5nZVRpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgLy8gSWYgYXBwbHlpbmcgY2hhbmdlcyBmcm9tIGhpc3Rvcnkgc3RhY2sgdGhlcmUncyBubyBuZWVkXG4gICAgLy8gdG8gcnVuIGhpc3RvcnkgbG9naWMgYWdhaW4sIGFzIGhpc3RvcnkgZW50cmllcyBhbHJlYWR5IGNhbGN1bGF0ZWRcbiAgICBpZiAodGFncy5oYXMoJ2hpc3RvcmljJykpIHtcbiAgICAgIHByZXZDaGFuZ2VUeXBlID0gT1RIRVI7XG4gICAgICBwcmV2Q2hhbmdlVGltZSA9IGNoYW5nZVRpbWU7XG4gICAgICByZXR1cm4gRElTQ0FSRF9ISVNUT1JZX0NBTkRJREFURTtcbiAgICB9XG4gICAgY29uc3QgY2hhbmdlVHlwZSA9IGdldENoYW5nZVR5cGUocHJldkVkaXRvclN0YXRlLCBuZXh0RWRpdG9yU3RhdGUsIGRpcnR5TGVhdmVzLCBkaXJ0eUVsZW1lbnRzLCBlZGl0b3IuaXNDb21wb3NpbmcoKSk7XG4gICAgY29uc3QgbWVyZ2VBY3Rpb24gPSAoKCkgPT4ge1xuICAgICAgY29uc3QgaXNTYW1lRWRpdG9yID0gY3VycmVudEhpc3RvcnlFbnRyeSA9PT0gbnVsbCB8fCBjdXJyZW50SGlzdG9yeUVudHJ5LmVkaXRvciA9PT0gZWRpdG9yO1xuICAgICAgY29uc3Qgc2hvdWxkUHVzaEhpc3RvcnkgPSB0YWdzLmhhcygnaGlzdG9yeS1wdXNoJyk7XG4gICAgICBjb25zdCBzaG91bGRNZXJnZUhpc3RvcnkgPSAhc2hvdWxkUHVzaEhpc3RvcnkgJiYgaXNTYW1lRWRpdG9yICYmIHRhZ3MuaGFzKCdoaXN0b3J5LW1lcmdlJyk7XG4gICAgICBpZiAoc2hvdWxkTWVyZ2VIaXN0b3J5KSB7XG4gICAgICAgIHJldHVybiBISVNUT1JZX01FUkdFO1xuICAgICAgfVxuICAgICAgaWYgKHByZXZFZGl0b3JTdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gSElTVE9SWV9QVVNIO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gbmV4dEVkaXRvclN0YXRlLl9zZWxlY3Rpb247XG4gICAgICBjb25zdCBoYXNEaXJ0eU5vZGVzID0gZGlydHlMZWF2ZXMuc2l6ZSA+IDAgfHwgZGlydHlFbGVtZW50cy5zaXplID4gMDtcbiAgICAgIGlmICghaGFzRGlydHlOb2Rlcykge1xuICAgICAgICBpZiAoc2VsZWN0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIEhJU1RPUllfTUVSR0U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERJU0NBUkRfSElTVE9SWV9DQU5ESURBVEU7XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkUHVzaEhpc3RvcnkgPT09IGZhbHNlICYmIGNoYW5nZVR5cGUgIT09IE9USEVSICYmIGNoYW5nZVR5cGUgPT09IHByZXZDaGFuZ2VUeXBlICYmIGNoYW5nZVRpbWUgPCBwcmV2Q2hhbmdlVGltZSArIGRlbGF5ICYmIGlzU2FtZUVkaXRvcikge1xuICAgICAgICByZXR1cm4gSElTVE9SWV9NRVJHRTtcbiAgICAgIH1cblxuICAgICAgLy8gQSBzaW5nbGUgbm9kZSBtaWdodCBoYXZlIGJlZW4gbWFya2VkIGFzIGRpcnR5LCBidXQgbm90IGhhdmUgY2hhbmdlZFxuICAgICAgLy8gZHVlIHRvIHNvbWUgbm9kZSB0cmFuc2Zvcm0gcmV2ZXJ0aW5nIHRoZSBjaGFuZ2UuXG4gICAgICBpZiAoZGlydHlMZWF2ZXMuc2l6ZSA9PT0gMSkge1xuICAgICAgICBjb25zdCBkaXJ0eUxlYWZLZXkgPSBBcnJheS5mcm9tKGRpcnR5TGVhdmVzKVswXTtcbiAgICAgICAgaWYgKGlzVGV4dE5vZGVVbmNoYW5nZWQoZGlydHlMZWFmS2V5LCBwcmV2RWRpdG9yU3RhdGUsIG5leHRFZGl0b3JTdGF0ZSkpIHtcbiAgICAgICAgICByZXR1cm4gSElTVE9SWV9NRVJHRTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIEhJU1RPUllfUFVTSDtcbiAgICB9KSgpO1xuICAgIHByZXZDaGFuZ2VUaW1lID0gY2hhbmdlVGltZTtcbiAgICBwcmV2Q2hhbmdlVHlwZSA9IGNoYW5nZVR5cGU7XG4gICAgcmV0dXJuIG1lcmdlQWN0aW9uO1xuICB9O1xufVxuZnVuY3Rpb24gcmVkbyhlZGl0b3IsIGhpc3RvcnlTdGF0ZSkge1xuICBjb25zdCByZWRvU3RhY2sgPSBoaXN0b3J5U3RhdGUucmVkb1N0YWNrO1xuICBjb25zdCB1bmRvU3RhY2sgPSBoaXN0b3J5U3RhdGUudW5kb1N0YWNrO1xuICBpZiAocmVkb1N0YWNrLmxlbmd0aCAhPT0gMCkge1xuICAgIGNvbnN0IGN1cnJlbnQgPSBoaXN0b3J5U3RhdGUuY3VycmVudDtcbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgdW5kb1N0YWNrLnB1c2goY3VycmVudCk7XG4gICAgICBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKENBTl9VTkRPX0NPTU1BTkQsIHRydWUpO1xuICAgIH1cbiAgICBjb25zdCBoaXN0b3J5U3RhdGVFbnRyeSA9IHJlZG9TdGFjay5wb3AoKTtcbiAgICBpZiAocmVkb1N0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChDQU5fUkVET19DT01NQU5ELCBmYWxzZSk7XG4gICAgfVxuICAgIGhpc3RvcnlTdGF0ZS5jdXJyZW50ID0gaGlzdG9yeVN0YXRlRW50cnkgfHwgbnVsbDtcbiAgICBpZiAoaGlzdG9yeVN0YXRlRW50cnkpIHtcbiAgICAgIGhpc3RvcnlTdGF0ZUVudHJ5LmVkaXRvci5zZXRFZGl0b3JTdGF0ZShoaXN0b3J5U3RhdGVFbnRyeS5lZGl0b3JTdGF0ZSwge1xuICAgICAgICB0YWc6ICdoaXN0b3JpYydcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdW5kbyhlZGl0b3IsIGhpc3RvcnlTdGF0ZSkge1xuICBjb25zdCByZWRvU3RhY2sgPSBoaXN0b3J5U3RhdGUucmVkb1N0YWNrO1xuICBjb25zdCB1bmRvU3RhY2sgPSBoaXN0b3J5U3RhdGUudW5kb1N0YWNrO1xuICBjb25zdCB1bmRvU3RhY2tMZW5ndGggPSB1bmRvU3RhY2subGVuZ3RoO1xuICBpZiAodW5kb1N0YWNrTGVuZ3RoICE9PSAwKSB7XG4gICAgY29uc3QgY3VycmVudCA9IGhpc3RvcnlTdGF0ZS5jdXJyZW50O1xuICAgIGNvbnN0IGhpc3RvcnlTdGF0ZUVudHJ5ID0gdW5kb1N0YWNrLnBvcCgpO1xuICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICByZWRvU3RhY2sucHVzaChjdXJyZW50KTtcbiAgICAgIGVkaXRvci5kaXNwYXRjaENvbW1hbmQoQ0FOX1JFRE9fQ09NTUFORCwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmICh1bmRvU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKENBTl9VTkRPX0NPTU1BTkQsIGZhbHNlKTtcbiAgICB9XG4gICAgaGlzdG9yeVN0YXRlLmN1cnJlbnQgPSBoaXN0b3J5U3RhdGVFbnRyeSB8fCBudWxsO1xuICAgIGlmIChoaXN0b3J5U3RhdGVFbnRyeSkge1xuICAgICAgaGlzdG9yeVN0YXRlRW50cnkuZWRpdG9yLnNldEVkaXRvclN0YXRlKGhpc3RvcnlTdGF0ZUVudHJ5LmVkaXRvclN0YXRlLCB7XG4gICAgICAgIHRhZzogJ2hpc3RvcmljJ1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjbGVhckhpc3RvcnkoaGlzdG9yeVN0YXRlKSB7XG4gIGhpc3RvcnlTdGF0ZS51bmRvU3RhY2sgPSBbXTtcbiAgaGlzdG9yeVN0YXRlLnJlZG9TdGFjayA9IFtdO1xuICBoaXN0b3J5U3RhdGUuY3VycmVudCA9IG51bGw7XG59XG5cbi8qKlxuICogUmVnaXN0ZXJzIG5lY2Vzc2FyeSBsaXN0ZW5lcnMgdG8gbWFuYWdlIHVuZG8vcmVkbyBoaXN0b3J5IHN0YWNrIGFuZCByZWxhdGVkIGVkaXRvciBjb21tYW5kcy5cbiAqIEl0IHJldHVybnMgYHVucmVnaXN0ZXJgIGNhbGxiYWNrIHRoYXQgY2xlYW5zIHVwIGFsbCBsaXN0ZW5lcnMgYW5kIHNob3VsZCBiZSBjYWxsZWQgb24gZWRpdG9yIHVubW91bnQuXG4gKiBAcGFyYW0gZWRpdG9yIC0gVGhlIGxleGljYWwgZWRpdG9yLlxuICogQHBhcmFtIGhpc3RvcnlTdGF0ZSAtIFRoZSBoaXN0b3J5IHN0YXRlLCBjb250YWluaW5nIHRoZSBjdXJyZW50IHN0YXRlIGFuZCB0aGUgdW5kby9yZWRvIHN0YWNrLlxuICogQHBhcmFtIGRlbGF5IC0gVGhlIHRpbWUgKGluIG1pbGxpc2Vjb25kcykgdGhlIGVkaXRvciBzaG91bGQgZGVsYXkgZ2VuZXJhdGluZyBhIG5ldyBoaXN0b3J5IHN0YWNrLFxuICogaW5zdGVhZCBvZiBtZXJnaW5nIHRoZSBjdXJyZW50IGNoYW5nZXMgd2l0aCB0aGUgY3VycmVudCBzdGFjay5cbiAqIEByZXR1cm5zIFRoZSBsaXN0ZW5lcnMgY2xlYW51cCBjYWxsYmFjayBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJIaXN0b3J5KGVkaXRvciwgaGlzdG9yeVN0YXRlLCBkZWxheSkge1xuICBjb25zdCBnZXRNZXJnZUFjdGlvbiA9IGNyZWF0ZU1lcmdlQWN0aW9uR2V0dGVyKGVkaXRvciwgZGVsYXkpO1xuICBjb25zdCBhcHBseUNoYW5nZSA9ICh7XG4gICAgZWRpdG9yU3RhdGUsXG4gICAgcHJldkVkaXRvclN0YXRlLFxuICAgIGRpcnR5TGVhdmVzLFxuICAgIGRpcnR5RWxlbWVudHMsXG4gICAgdGFnc1xuICB9KSA9PiB7XG4gICAgY29uc3QgY3VycmVudCA9IGhpc3RvcnlTdGF0ZS5jdXJyZW50O1xuICAgIGNvbnN0IHJlZG9TdGFjayA9IGhpc3RvcnlTdGF0ZS5yZWRvU3RhY2s7XG4gICAgY29uc3QgdW5kb1N0YWNrID0gaGlzdG9yeVN0YXRlLnVuZG9TdGFjaztcbiAgICBjb25zdCBjdXJyZW50RWRpdG9yU3RhdGUgPSBjdXJyZW50ID09PSBudWxsID8gbnVsbCA6IGN1cnJlbnQuZWRpdG9yU3RhdGU7XG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgZWRpdG9yU3RhdGUgPT09IGN1cnJlbnRFZGl0b3JTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBtZXJnZUFjdGlvbiA9IGdldE1lcmdlQWN0aW9uKHByZXZFZGl0b3JTdGF0ZSwgZWRpdG9yU3RhdGUsIGN1cnJlbnQsIGRpcnR5TGVhdmVzLCBkaXJ0eUVsZW1lbnRzLCB0YWdzKTtcbiAgICBpZiAobWVyZ2VBY3Rpb24gPT09IEhJU1RPUllfUFVTSCkge1xuICAgICAgaWYgKHJlZG9TdGFjay5sZW5ndGggIT09IDApIHtcbiAgICAgICAgaGlzdG9yeVN0YXRlLnJlZG9TdGFjayA9IFtdO1xuICAgICAgICBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKENBTl9SRURPX0NPTU1BTkQsIGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgIHVuZG9TdGFjay5wdXNoKHtcbiAgICAgICAgICAuLi5jdXJyZW50XG4gICAgICAgIH0pO1xuICAgICAgICBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKENBTl9VTkRPX0NPTU1BTkQsIHRydWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobWVyZ2VBY3Rpb24gPT09IERJU0NBUkRfSElTVE9SWV9DQU5ESURBVEUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBFbHNlIHdlIG1lcmdlXG4gICAgaGlzdG9yeVN0YXRlLmN1cnJlbnQgPSB7XG4gICAgICBlZGl0b3IsXG4gICAgICBlZGl0b3JTdGF0ZVxuICAgIH07XG4gIH07XG4gIGNvbnN0IHVucmVnaXN0ZXIgPSBtZXJnZVJlZ2lzdGVyKGVkaXRvci5yZWdpc3RlckNvbW1hbmQoVU5ET19DT01NQU5ELCAoKSA9PiB7XG4gICAgdW5kbyhlZGl0b3IsIGhpc3RvcnlTdGF0ZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChSRURPX0NPTU1BTkQsICgpID0+IHtcbiAgICByZWRvKGVkaXRvciwgaGlzdG9yeVN0YXRlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKENMRUFSX0VESVRPUl9DT01NQU5ELCAoKSA9PiB7XG4gICAgY2xlYXJIaXN0b3J5KGhpc3RvcnlTdGF0ZSk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoQ0xFQVJfSElTVE9SWV9DT01NQU5ELCAoKSA9PiB7XG4gICAgY2xlYXJIaXN0b3J5KGhpc3RvcnlTdGF0ZSk7XG4gICAgZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChDQU5fUkVET19DT01NQU5ELCBmYWxzZSk7XG4gICAgZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChDQU5fVU5ET19DT01NQU5ELCBmYWxzZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyVXBkYXRlTGlzdGVuZXIoYXBwbHlDaGFuZ2UpKTtcbiAgcmV0dXJuIHVucmVnaXN0ZXI7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBlbXB0eSBoaXN0b3J5IHN0YXRlLlxuICogQHJldHVybnMgLSBUaGUgZW1wdHkgaGlzdG9yeSBzdGF0ZSwgYXMgYW4gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBjcmVhdGVFbXB0eUhpc3RvcnlTdGF0ZSgpIHtcbiAgcmV0dXJuIHtcbiAgICBjdXJyZW50OiBudWxsLFxuICAgIHJlZG9TdGFjazogW10sXG4gICAgdW5kb1N0YWNrOiBbXVxuICB9O1xufVxuXG5leHBvcnQgeyBjcmVhdGVFbXB0eUhpc3RvcnlTdGF0ZSwgcmVnaXN0ZXJIaXN0b3J5IH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/history/LexicalHistory.dev.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/html/LexicalHtml.dev.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@lexical/html/LexicalHtml.dev.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $generateHtmlFromNodes: () => (/* binding */ $generateHtmlFromNodes),\n/* harmony export */   $generateNodesFromDOM: () => (/* binding */ $generateNodesFromDOM)\n/* harmony export */ });\n/* harmony import */ var _lexical_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/selection */ \"(app-pages-browser)/./node_modules/@lexical/selection/LexicalSelection.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(app-pages-browser)/./node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n/**\n * How you parse your html string to get a document is left up to you. In the browser you can use the native\n * DOMParser API to generate a document (see clipboard.ts), but to use in a headless environment you can use JSDom\n * or an equivalent library and pass in the document here.\n */\nfunction $generateNodesFromDOM(editor, dom) {\n  const elements = dom.body ? dom.body.childNodes : [];\n  let lexicalNodes = [];\n  const allArtificialNodes = [];\n  for (let i = 0; i < elements.length; i++) {\n    const element = elements[i];\n    if (!IGNORE_TAGS.has(element.nodeName)) {\n      const lexicalNode = $createNodesFromDOM(element, editor, allArtificialNodes, false);\n      if (lexicalNode !== null) {\n        lexicalNodes = lexicalNodes.concat(lexicalNode);\n      }\n    }\n  }\n  $unwrapArtificalNodes(allArtificialNodes);\n  return lexicalNodes;\n}\nfunction $generateHtmlFromNodes(editor, selection) {\n  if (typeof document === 'undefined' || typeof window === 'undefined' && typeof global.window === 'undefined') {\n    throw new Error('To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.');\n  }\n  const container = document.createElement('div');\n  const root = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)();\n  const topLevelChildren = root.getChildren();\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToHTML(editor, topLevelNode, container, selection);\n  }\n  return container.innerHTML;\n}\nfunction $appendNodesToHTML(editor, currentNode, parentElement, selection = null) {\n  let shouldInclude = selection !== null ? currentNode.isSelected(selection) : true;\n  const shouldExclude = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n  if (selection !== null) {\n    let clone = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$cloneWithProperties)(currentNode);\n    clone = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(clone) && selection !== null ? (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_1__.$sliceSelectedTextNodeContent)(selection, clone) : clone;\n    target = clone;\n  }\n  const children = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(target) ? target.getChildren() : [];\n  const registeredNode = editor._nodes.get(target.getType());\n  let exportOutput;\n\n  // Use HTMLConfig overrides, if available.\n  if (registeredNode && registeredNode.exportDOM !== undefined) {\n    exportOutput = registeredNode.exportDOM(editor, target);\n  } else {\n    exportOutput = target.exportDOM(editor);\n  }\n  const {\n    element,\n    after\n  } = exportOutput;\n  if (!element) {\n    return false;\n  }\n  const fragment = document.createDocumentFragment();\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToHTML(editor, childNode, fragment, selection);\n    if (!shouldInclude && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection, 'html')) {\n      shouldInclude = true;\n    }\n  }\n  if (shouldInclude && !shouldExclude) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.isDocumentFragment)(element)) {\n      element.append(fragment);\n    }\n    parentElement.append(element);\n    if (after) {\n      const newElement = after.call(target, element);\n      if (newElement) {\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.isDocumentFragment)(element)) {\n          element.replaceChildren(newElement);\n        } else {\n          element.replaceWith(newElement);\n        }\n      }\n    }\n  } else {\n    parentElement.append(fragment);\n  }\n  return shouldInclude;\n}\nfunction getConversionFunction(domNode, editor) {\n  const {\n    nodeName\n  } = domNode;\n  const cachedConversions = editor._htmlConversions.get(nodeName.toLowerCase());\n  let currentConversion = null;\n  if (cachedConversions !== undefined) {\n    for (const cachedConversion of cachedConversions) {\n      const domConversion = cachedConversion(domNode);\n      if (domConversion !== null && (currentConversion === null ||\n      // Given equal priority, prefer the last registered importer\n      // which is typically an application custom node or HTMLConfig['import']\n      (currentConversion.priority || 0) <= (domConversion.priority || 0))) {\n        currentConversion = domConversion;\n      }\n    }\n  }\n  return currentConversion !== null ? currentConversion.conversion : null;\n}\nconst IGNORE_TAGS = new Set(['STYLE', 'SCRIPT']);\nfunction $createNodesFromDOM(node, editor, allArtificialNodes, hasBlockAncestorLexicalNode, forChildMap = new Map(), parentLexicalNode) {\n  let lexicalNodes = [];\n  if (IGNORE_TAGS.has(node.nodeName)) {\n    return lexicalNodes;\n  }\n  let currentLexicalNode = null;\n  const transformFunction = getConversionFunction(node, editor);\n  const transformOutput = transformFunction ? transformFunction(node) : null;\n  let postTransform = null;\n  if (transformOutput !== null) {\n    postTransform = transformOutput.after;\n    const transformNodes = transformOutput.node;\n    currentLexicalNode = Array.isArray(transformNodes) ? transformNodes[transformNodes.length - 1] : transformNodes;\n    if (currentLexicalNode !== null) {\n      for (const [, forChildFunction] of forChildMap) {\n        currentLexicalNode = forChildFunction(currentLexicalNode, parentLexicalNode);\n        if (!currentLexicalNode) {\n          break;\n        }\n      }\n      if (currentLexicalNode) {\n        lexicalNodes.push(...(Array.isArray(transformNodes) ? transformNodes : [currentLexicalNode]));\n      }\n    }\n    if (transformOutput.forChild != null) {\n      forChildMap.set(node.nodeName, transformOutput.forChild);\n    }\n  }\n\n  // If the DOM node doesn't have a transformer, we don't know what\n  // to do with it but we still need to process any childNodes.\n  const children = node.childNodes;\n  let childLexicalNodes = [];\n  const hasBlockAncestorLexicalNodeForChildren = currentLexicalNode != null && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(currentLexicalNode) ? false : currentLexicalNode != null && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isBlockElementNode)(currentLexicalNode) || hasBlockAncestorLexicalNode;\n  for (let i = 0; i < children.length; i++) {\n    childLexicalNodes.push(...$createNodesFromDOM(children[i], editor, allArtificialNodes, hasBlockAncestorLexicalNodeForChildren, new Map(forChildMap), currentLexicalNode));\n  }\n  if (postTransform != null) {\n    childLexicalNodes = postTransform(childLexicalNodes);\n  }\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.isBlockDomNode)(node)) {\n    if (!hasBlockAncestorLexicalNodeForChildren) {\n      childLexicalNodes = wrapContinuousInlines(node, childLexicalNodes, lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode);\n    } else {\n      childLexicalNodes = wrapContinuousInlines(node, childLexicalNodes, () => {\n        const artificialNode = new lexical__WEBPACK_IMPORTED_MODULE_0__.ArtificialNode__DO_NOT_USE();\n        allArtificialNodes.push(artificialNode);\n        return artificialNode;\n      });\n    }\n  }\n  if (currentLexicalNode == null) {\n    if (childLexicalNodes.length > 0) {\n      // If it hasn't been converted to a LexicalNode, we hoist its children\n      // up to the same level as it.\n      lexicalNodes = lexicalNodes.concat(childLexicalNodes);\n    } else {\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.isBlockDomNode)(node) && isDomNodeBetweenTwoInlineNodes(node)) {\n        // Empty block dom node that hasnt been converted, we replace it with a linebreak if its between inline nodes\n        lexicalNodes = lexicalNodes.concat((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createLineBreakNode)());\n      }\n    }\n  } else {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentLexicalNode)) {\n      // If the current node is a ElementNode after conversion,\n      // we can append all the children to it.\n      currentLexicalNode.append(...childLexicalNodes);\n    }\n  }\n  return lexicalNodes;\n}\nfunction wrapContinuousInlines(domNode, nodes, createWrapperFn) {\n  const textAlign = domNode.style.textAlign;\n  const out = [];\n  let continuousInlines = [];\n  // wrap contiguous inline child nodes in para\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isBlockElementNode)(node)) {\n      if (textAlign && !node.getFormat()) {\n        node.setFormat(textAlign);\n      }\n      out.push(node);\n    } else {\n      continuousInlines.push(node);\n      if (i === nodes.length - 1 || i < nodes.length - 1 && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isBlockElementNode)(nodes[i + 1])) {\n        const wrapper = createWrapperFn();\n        wrapper.setFormat(textAlign);\n        wrapper.append(...continuousInlines);\n        out.push(wrapper);\n        continuousInlines = [];\n      }\n    }\n  }\n  return out;\n}\nfunction $unwrapArtificalNodes(allArtificialNodes) {\n  for (const node of allArtificialNodes) {\n    if (node.getNextSibling() instanceof lexical__WEBPACK_IMPORTED_MODULE_0__.ArtificialNode__DO_NOT_USE) {\n      node.insertAfter((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createLineBreakNode)());\n    }\n  }\n  // Replace artificial node with it's children\n  for (const node of allArtificialNodes) {\n    const children = node.getChildren();\n    for (const child of children) {\n      node.insertBefore(child);\n    }\n    node.remove();\n  }\n}\nfunction isDomNodeBetweenTwoInlineNodes(node) {\n  if (node.nextSibling == null || node.previousSibling == null) {\n    return false;\n  }\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.isInlineDomNode)(node.nextSibling) && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.isInlineDomNode)(node.previousSibling);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9odG1sL0xleGljYWxIdG1sLmRldi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVtRTtBQUNKO0FBQzhLOztBQUU3TztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaURBQVE7QUFDdkI7QUFDQSxrQkFBa0IsNkJBQTZCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVEQUFjO0FBQ3RDO0FBQ0E7QUFDQSxnQkFBZ0IsNkRBQW9CO0FBQ3BDLFlBQVksb0RBQVcsZ0NBQWdDLGlGQUE2QjtBQUNwRjtBQUNBO0FBQ0EsbUJBQW1CLHVEQUFjO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQSwwQkFBMEIsdURBQWM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNEQUFhLGFBQWEsMkRBQWtCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMkRBQWtCO0FBQzlCO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsNERBQW1CLDZEQUE2RCw0REFBbUI7QUFDbEwsa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSx1REFBYztBQUNwQjtBQUNBLHlFQUF5RSx5REFBb0I7QUFDN0YsTUFBTTtBQUNOO0FBQ0EsbUNBQW1DLCtEQUEwQjtBQUM3RDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLFVBQVUsdURBQWM7QUFDeEI7QUFDQSwyQ0FBMkMsNkRBQW9CO0FBQy9EO0FBQ0E7QUFDQSxJQUFJO0FBQ0osUUFBUSx1REFBYztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0EsUUFBUSw0REFBbUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSw0REFBNEQsNERBQW1CO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QywrREFBMEI7QUFDbkUsdUJBQXVCLDZEQUFvQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHdEQUFlLHNCQUFzQix3REFBZTtBQUM3RDs7QUFFeUQiLCJzb3VyY2VzIjpbIi9Vc2Vycy9sZWkvaG9tZS91bmRlcmcvdGhlYXRyZS95My9zZWdwL21pbGt1cC9ub2RlX21vZHVsZXMvQGxleGljYWwvaHRtbC9MZXhpY2FsSHRtbC5kZXYubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuaW1wb3J0IHsgJHNsaWNlU2VsZWN0ZWRUZXh0Tm9kZUNvbnRlbnQgfSBmcm9tICdAbGV4aWNhbC9zZWxlY3Rpb24nO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCwgaXNCbG9ja0RvbU5vZGUgfSBmcm9tICdAbGV4aWNhbC91dGlscyc7XG5pbXBvcnQgeyAkZ2V0Um9vdCwgJGlzRWxlbWVudE5vZGUsICRjbG9uZVdpdGhQcm9wZXJ0aWVzLCAkaXNUZXh0Tm9kZSwgaXNEb2N1bWVudEZyYWdtZW50LCAkaXNSb290T3JTaGFkb3dSb290LCAkaXNCbG9ja0VsZW1lbnROb2RlLCAkY3JlYXRlTGluZUJyZWFrTm9kZSwgQXJ0aWZpY2lhbE5vZGVfX0RPX05PVF9VU0UsIGlzSW5saW5lRG9tTm9kZSwgJGNyZWF0ZVBhcmFncmFwaE5vZGUgfSBmcm9tICdsZXhpY2FsJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5cbi8qKlxuICogSG93IHlvdSBwYXJzZSB5b3VyIGh0bWwgc3RyaW5nIHRvIGdldCBhIGRvY3VtZW50IGlzIGxlZnQgdXAgdG8geW91LiBJbiB0aGUgYnJvd3NlciB5b3UgY2FuIHVzZSB0aGUgbmF0aXZlXG4gKiBET01QYXJzZXIgQVBJIHRvIGdlbmVyYXRlIGEgZG9jdW1lbnQgKHNlZSBjbGlwYm9hcmQudHMpLCBidXQgdG8gdXNlIGluIGEgaGVhZGxlc3MgZW52aXJvbm1lbnQgeW91IGNhbiB1c2UgSlNEb21cbiAqIG9yIGFuIGVxdWl2YWxlbnQgbGlicmFyeSBhbmQgcGFzcyBpbiB0aGUgZG9jdW1lbnQgaGVyZS5cbiAqL1xuZnVuY3Rpb24gJGdlbmVyYXRlTm9kZXNGcm9tRE9NKGVkaXRvciwgZG9tKSB7XG4gIGNvbnN0IGVsZW1lbnRzID0gZG9tLmJvZHkgPyBkb20uYm9keS5jaGlsZE5vZGVzIDogW107XG4gIGxldCBsZXhpY2FsTm9kZXMgPSBbXTtcbiAgY29uc3QgYWxsQXJ0aWZpY2lhbE5vZGVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgaWYgKCFJR05PUkVfVEFHUy5oYXMoZWxlbWVudC5ub2RlTmFtZSkpIHtcbiAgICAgIGNvbnN0IGxleGljYWxOb2RlID0gJGNyZWF0ZU5vZGVzRnJvbURPTShlbGVtZW50LCBlZGl0b3IsIGFsbEFydGlmaWNpYWxOb2RlcywgZmFsc2UpO1xuICAgICAgaWYgKGxleGljYWxOb2RlICE9PSBudWxsKSB7XG4gICAgICAgIGxleGljYWxOb2RlcyA9IGxleGljYWxOb2Rlcy5jb25jYXQobGV4aWNhbE5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAkdW53cmFwQXJ0aWZpY2FsTm9kZXMoYWxsQXJ0aWZpY2lhbE5vZGVzKTtcbiAgcmV0dXJuIGxleGljYWxOb2Rlcztcbn1cbmZ1bmN0aW9uICRnZW5lcmF0ZUh0bWxGcm9tTm9kZXMoZWRpdG9yLCBzZWxlY3Rpb24pIHtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGdsb2JhbC53aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUbyB1c2UgJGdlbmVyYXRlSHRtbEZyb21Ob2RlcyBpbiBoZWFkbGVzcyBtb2RlIHBsZWFzZSBpbml0aWFsaXplIGEgaGVhZGxlc3MgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBzdWNoIGFzIEpTRG9tIGJlZm9yZSBjYWxsaW5nIHRoaXMgZnVuY3Rpb24uJyk7XG4gIH1cbiAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGNvbnN0IHJvb3QgPSAkZ2V0Um9vdCgpO1xuICBjb25zdCB0b3BMZXZlbENoaWxkcmVuID0gcm9vdC5nZXRDaGlsZHJlbigpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRvcExldmVsQ2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB0b3BMZXZlbE5vZGUgPSB0b3BMZXZlbENoaWxkcmVuW2ldO1xuICAgICRhcHBlbmROb2Rlc1RvSFRNTChlZGl0b3IsIHRvcExldmVsTm9kZSwgY29udGFpbmVyLCBzZWxlY3Rpb24pO1xuICB9XG4gIHJldHVybiBjb250YWluZXIuaW5uZXJIVE1MO1xufVxuZnVuY3Rpb24gJGFwcGVuZE5vZGVzVG9IVE1MKGVkaXRvciwgY3VycmVudE5vZGUsIHBhcmVudEVsZW1lbnQsIHNlbGVjdGlvbiA9IG51bGwpIHtcbiAgbGV0IHNob3VsZEluY2x1ZGUgPSBzZWxlY3Rpb24gIT09IG51bGwgPyBjdXJyZW50Tm9kZS5pc1NlbGVjdGVkKHNlbGVjdGlvbikgOiB0cnVlO1xuICBjb25zdCBzaG91bGRFeGNsdWRlID0gJGlzRWxlbWVudE5vZGUoY3VycmVudE5vZGUpICYmIGN1cnJlbnROb2RlLmV4Y2x1ZGVGcm9tQ29weSgnaHRtbCcpO1xuICBsZXQgdGFyZ2V0ID0gY3VycmVudE5vZGU7XG4gIGlmIChzZWxlY3Rpb24gIT09IG51bGwpIHtcbiAgICBsZXQgY2xvbmUgPSAkY2xvbmVXaXRoUHJvcGVydGllcyhjdXJyZW50Tm9kZSk7XG4gICAgY2xvbmUgPSAkaXNUZXh0Tm9kZShjbG9uZSkgJiYgc2VsZWN0aW9uICE9PSBudWxsID8gJHNsaWNlU2VsZWN0ZWRUZXh0Tm9kZUNvbnRlbnQoc2VsZWN0aW9uLCBjbG9uZSkgOiBjbG9uZTtcbiAgICB0YXJnZXQgPSBjbG9uZTtcbiAgfVxuICBjb25zdCBjaGlsZHJlbiA9ICRpc0VsZW1lbnROb2RlKHRhcmdldCkgPyB0YXJnZXQuZ2V0Q2hpbGRyZW4oKSA6IFtdO1xuICBjb25zdCByZWdpc3RlcmVkTm9kZSA9IGVkaXRvci5fbm9kZXMuZ2V0KHRhcmdldC5nZXRUeXBlKCkpO1xuICBsZXQgZXhwb3J0T3V0cHV0O1xuXG4gIC8vIFVzZSBIVE1MQ29uZmlnIG92ZXJyaWRlcywgaWYgYXZhaWxhYmxlLlxuICBpZiAocmVnaXN0ZXJlZE5vZGUgJiYgcmVnaXN0ZXJlZE5vZGUuZXhwb3J0RE9NICE9PSB1bmRlZmluZWQpIHtcbiAgICBleHBvcnRPdXRwdXQgPSByZWdpc3RlcmVkTm9kZS5leHBvcnRET00oZWRpdG9yLCB0YXJnZXQpO1xuICB9IGVsc2Uge1xuICAgIGV4cG9ydE91dHB1dCA9IHRhcmdldC5leHBvcnRET00oZWRpdG9yKTtcbiAgfVxuICBjb25zdCB7XG4gICAgZWxlbWVudCxcbiAgICBhZnRlclxuICB9ID0gZXhwb3J0T3V0cHV0O1xuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGlsZE5vZGUgPSBjaGlsZHJlbltpXTtcbiAgICBjb25zdCBzaG91bGRJbmNsdWRlQ2hpbGQgPSAkYXBwZW5kTm9kZXNUb0hUTUwoZWRpdG9yLCBjaGlsZE5vZGUsIGZyYWdtZW50LCBzZWxlY3Rpb24pO1xuICAgIGlmICghc2hvdWxkSW5jbHVkZSAmJiAkaXNFbGVtZW50Tm9kZShjdXJyZW50Tm9kZSkgJiYgc2hvdWxkSW5jbHVkZUNoaWxkICYmIGN1cnJlbnROb2RlLmV4dHJhY3RXaXRoQ2hpbGQoY2hpbGROb2RlLCBzZWxlY3Rpb24sICdodG1sJykpIHtcbiAgICAgIHNob3VsZEluY2x1ZGUgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBpZiAoc2hvdWxkSW5jbHVkZSAmJiAhc2hvdWxkRXhjbHVkZSkge1xuICAgIGlmIChpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8IGlzRG9jdW1lbnRGcmFnbWVudChlbGVtZW50KSkge1xuICAgICAgZWxlbWVudC5hcHBlbmQoZnJhZ21lbnQpO1xuICAgIH1cbiAgICBwYXJlbnRFbGVtZW50LmFwcGVuZChlbGVtZW50KTtcbiAgICBpZiAoYWZ0ZXIpIHtcbiAgICAgIGNvbnN0IG5ld0VsZW1lbnQgPSBhZnRlci5jYWxsKHRhcmdldCwgZWxlbWVudCk7XG4gICAgICBpZiAobmV3RWxlbWVudCkge1xuICAgICAgICBpZiAoaXNEb2N1bWVudEZyYWdtZW50KGVsZW1lbnQpKSB7XG4gICAgICAgICAgZWxlbWVudC5yZXBsYWNlQ2hpbGRyZW4obmV3RWxlbWVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWxlbWVudC5yZXBsYWNlV2l0aChuZXdFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwYXJlbnRFbGVtZW50LmFwcGVuZChmcmFnbWVudCk7XG4gIH1cbiAgcmV0dXJuIHNob3VsZEluY2x1ZGU7XG59XG5mdW5jdGlvbiBnZXRDb252ZXJzaW9uRnVuY3Rpb24oZG9tTm9kZSwgZWRpdG9yKSB7XG4gIGNvbnN0IHtcbiAgICBub2RlTmFtZVxuICB9ID0gZG9tTm9kZTtcbiAgY29uc3QgY2FjaGVkQ29udmVyc2lvbnMgPSBlZGl0b3IuX2h0bWxDb252ZXJzaW9ucy5nZXQobm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gIGxldCBjdXJyZW50Q29udmVyc2lvbiA9IG51bGw7XG4gIGlmIChjYWNoZWRDb252ZXJzaW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZm9yIChjb25zdCBjYWNoZWRDb252ZXJzaW9uIG9mIGNhY2hlZENvbnZlcnNpb25zKSB7XG4gICAgICBjb25zdCBkb21Db252ZXJzaW9uID0gY2FjaGVkQ29udmVyc2lvbihkb21Ob2RlKTtcbiAgICAgIGlmIChkb21Db252ZXJzaW9uICE9PSBudWxsICYmIChjdXJyZW50Q29udmVyc2lvbiA9PT0gbnVsbCB8fFxuICAgICAgLy8gR2l2ZW4gZXF1YWwgcHJpb3JpdHksIHByZWZlciB0aGUgbGFzdCByZWdpc3RlcmVkIGltcG9ydGVyXG4gICAgICAvLyB3aGljaCBpcyB0eXBpY2FsbHkgYW4gYXBwbGljYXRpb24gY3VzdG9tIG5vZGUgb3IgSFRNTENvbmZpZ1snaW1wb3J0J11cbiAgICAgIChjdXJyZW50Q29udmVyc2lvbi5wcmlvcml0eSB8fCAwKSA8PSAoZG9tQ29udmVyc2lvbi5wcmlvcml0eSB8fCAwKSkpIHtcbiAgICAgICAgY3VycmVudENvbnZlcnNpb24gPSBkb21Db252ZXJzaW9uO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY3VycmVudENvbnZlcnNpb24gIT09IG51bGwgPyBjdXJyZW50Q29udmVyc2lvbi5jb252ZXJzaW9uIDogbnVsbDtcbn1cbmNvbnN0IElHTk9SRV9UQUdTID0gbmV3IFNldChbJ1NUWUxFJywgJ1NDUklQVCddKTtcbmZ1bmN0aW9uICRjcmVhdGVOb2Rlc0Zyb21ET00obm9kZSwgZWRpdG9yLCBhbGxBcnRpZmljaWFsTm9kZXMsIGhhc0Jsb2NrQW5jZXN0b3JMZXhpY2FsTm9kZSwgZm9yQ2hpbGRNYXAgPSBuZXcgTWFwKCksIHBhcmVudExleGljYWxOb2RlKSB7XG4gIGxldCBsZXhpY2FsTm9kZXMgPSBbXTtcbiAgaWYgKElHTk9SRV9UQUdTLmhhcyhub2RlLm5vZGVOYW1lKSkge1xuICAgIHJldHVybiBsZXhpY2FsTm9kZXM7XG4gIH1cbiAgbGV0IGN1cnJlbnRMZXhpY2FsTm9kZSA9IG51bGw7XG4gIGNvbnN0IHRyYW5zZm9ybUZ1bmN0aW9uID0gZ2V0Q29udmVyc2lvbkZ1bmN0aW9uKG5vZGUsIGVkaXRvcik7XG4gIGNvbnN0IHRyYW5zZm9ybU91dHB1dCA9IHRyYW5zZm9ybUZ1bmN0aW9uID8gdHJhbnNmb3JtRnVuY3Rpb24obm9kZSkgOiBudWxsO1xuICBsZXQgcG9zdFRyYW5zZm9ybSA9IG51bGw7XG4gIGlmICh0cmFuc2Zvcm1PdXRwdXQgIT09IG51bGwpIHtcbiAgICBwb3N0VHJhbnNmb3JtID0gdHJhbnNmb3JtT3V0cHV0LmFmdGVyO1xuICAgIGNvbnN0IHRyYW5zZm9ybU5vZGVzID0gdHJhbnNmb3JtT3V0cHV0Lm5vZGU7XG4gICAgY3VycmVudExleGljYWxOb2RlID0gQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1Ob2RlcykgPyB0cmFuc2Zvcm1Ob2Rlc1t0cmFuc2Zvcm1Ob2Rlcy5sZW5ndGggLSAxXSA6IHRyYW5zZm9ybU5vZGVzO1xuICAgIGlmIChjdXJyZW50TGV4aWNhbE5vZGUgIT09IG51bGwpIHtcbiAgICAgIGZvciAoY29uc3QgWywgZm9yQ2hpbGRGdW5jdGlvbl0gb2YgZm9yQ2hpbGRNYXApIHtcbiAgICAgICAgY3VycmVudExleGljYWxOb2RlID0gZm9yQ2hpbGRGdW5jdGlvbihjdXJyZW50TGV4aWNhbE5vZGUsIHBhcmVudExleGljYWxOb2RlKTtcbiAgICAgICAgaWYgKCFjdXJyZW50TGV4aWNhbE5vZGUpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRMZXhpY2FsTm9kZSkge1xuICAgICAgICBsZXhpY2FsTm9kZXMucHVzaCguLi4oQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1Ob2RlcykgPyB0cmFuc2Zvcm1Ob2RlcyA6IFtjdXJyZW50TGV4aWNhbE5vZGVdKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0cmFuc2Zvcm1PdXRwdXQuZm9yQ2hpbGQgIT0gbnVsbCkge1xuICAgICAgZm9yQ2hpbGRNYXAuc2V0KG5vZGUubm9kZU5hbWUsIHRyYW5zZm9ybU91dHB1dC5mb3JDaGlsZCk7XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgdGhlIERPTSBub2RlIGRvZXNuJ3QgaGF2ZSBhIHRyYW5zZm9ybWVyLCB3ZSBkb24ndCBrbm93IHdoYXRcbiAgLy8gdG8gZG8gd2l0aCBpdCBidXQgd2Ugc3RpbGwgbmVlZCB0byBwcm9jZXNzIGFueSBjaGlsZE5vZGVzLlxuICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuY2hpbGROb2RlcztcbiAgbGV0IGNoaWxkTGV4aWNhbE5vZGVzID0gW107XG4gIGNvbnN0IGhhc0Jsb2NrQW5jZXN0b3JMZXhpY2FsTm9kZUZvckNoaWxkcmVuID0gY3VycmVudExleGljYWxOb2RlICE9IG51bGwgJiYgJGlzUm9vdE9yU2hhZG93Um9vdChjdXJyZW50TGV4aWNhbE5vZGUpID8gZmFsc2UgOiBjdXJyZW50TGV4aWNhbE5vZGUgIT0gbnVsbCAmJiAkaXNCbG9ja0VsZW1lbnROb2RlKGN1cnJlbnRMZXhpY2FsTm9kZSkgfHwgaGFzQmxvY2tBbmNlc3RvckxleGljYWxOb2RlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgY2hpbGRMZXhpY2FsTm9kZXMucHVzaCguLi4kY3JlYXRlTm9kZXNGcm9tRE9NKGNoaWxkcmVuW2ldLCBlZGl0b3IsIGFsbEFydGlmaWNpYWxOb2RlcywgaGFzQmxvY2tBbmNlc3RvckxleGljYWxOb2RlRm9yQ2hpbGRyZW4sIG5ldyBNYXAoZm9yQ2hpbGRNYXApLCBjdXJyZW50TGV4aWNhbE5vZGUpKTtcbiAgfVxuICBpZiAocG9zdFRyYW5zZm9ybSAhPSBudWxsKSB7XG4gICAgY2hpbGRMZXhpY2FsTm9kZXMgPSBwb3N0VHJhbnNmb3JtKGNoaWxkTGV4aWNhbE5vZGVzKTtcbiAgfVxuICBpZiAoaXNCbG9ja0RvbU5vZGUobm9kZSkpIHtcbiAgICBpZiAoIWhhc0Jsb2NrQW5jZXN0b3JMZXhpY2FsTm9kZUZvckNoaWxkcmVuKSB7XG4gICAgICBjaGlsZExleGljYWxOb2RlcyA9IHdyYXBDb250aW51b3VzSW5saW5lcyhub2RlLCBjaGlsZExleGljYWxOb2RlcywgJGNyZWF0ZVBhcmFncmFwaE5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGlsZExleGljYWxOb2RlcyA9IHdyYXBDb250aW51b3VzSW5saW5lcyhub2RlLCBjaGlsZExleGljYWxOb2RlcywgKCkgPT4ge1xuICAgICAgICBjb25zdCBhcnRpZmljaWFsTm9kZSA9IG5ldyBBcnRpZmljaWFsTm9kZV9fRE9fTk9UX1VTRSgpO1xuICAgICAgICBhbGxBcnRpZmljaWFsTm9kZXMucHVzaChhcnRpZmljaWFsTm9kZSk7XG4gICAgICAgIHJldHVybiBhcnRpZmljaWFsTm9kZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAoY3VycmVudExleGljYWxOb2RlID09IG51bGwpIHtcbiAgICBpZiAoY2hpbGRMZXhpY2FsTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgLy8gSWYgaXQgaGFzbid0IGJlZW4gY29udmVydGVkIHRvIGEgTGV4aWNhbE5vZGUsIHdlIGhvaXN0IGl0cyBjaGlsZHJlblxuICAgICAgLy8gdXAgdG8gdGhlIHNhbWUgbGV2ZWwgYXMgaXQuXG4gICAgICBsZXhpY2FsTm9kZXMgPSBsZXhpY2FsTm9kZXMuY29uY2F0KGNoaWxkTGV4aWNhbE5vZGVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzQmxvY2tEb21Ob2RlKG5vZGUpICYmIGlzRG9tTm9kZUJldHdlZW5Ud29JbmxpbmVOb2Rlcyhub2RlKSkge1xuICAgICAgICAvLyBFbXB0eSBibG9jayBkb20gbm9kZSB0aGF0IGhhc250IGJlZW4gY29udmVydGVkLCB3ZSByZXBsYWNlIGl0IHdpdGggYSBsaW5lYnJlYWsgaWYgaXRzIGJldHdlZW4gaW5saW5lIG5vZGVzXG4gICAgICAgIGxleGljYWxOb2RlcyA9IGxleGljYWxOb2Rlcy5jb25jYXQoJGNyZWF0ZUxpbmVCcmVha05vZGUoKSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICgkaXNFbGVtZW50Tm9kZShjdXJyZW50TGV4aWNhbE5vZGUpKSB7XG4gICAgICAvLyBJZiB0aGUgY3VycmVudCBub2RlIGlzIGEgRWxlbWVudE5vZGUgYWZ0ZXIgY29udmVyc2lvbixcbiAgICAgIC8vIHdlIGNhbiBhcHBlbmQgYWxsIHRoZSBjaGlsZHJlbiB0byBpdC5cbiAgICAgIGN1cnJlbnRMZXhpY2FsTm9kZS5hcHBlbmQoLi4uY2hpbGRMZXhpY2FsTm9kZXMpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbGV4aWNhbE5vZGVzO1xufVxuZnVuY3Rpb24gd3JhcENvbnRpbnVvdXNJbmxpbmVzKGRvbU5vZGUsIG5vZGVzLCBjcmVhdGVXcmFwcGVyRm4pIHtcbiAgY29uc3QgdGV4dEFsaWduID0gZG9tTm9kZS5zdHlsZS50ZXh0QWxpZ247XG4gIGNvbnN0IG91dCA9IFtdO1xuICBsZXQgY29udGludW91c0lubGluZXMgPSBbXTtcbiAgLy8gd3JhcCBjb250aWd1b3VzIGlubGluZSBjaGlsZCBub2RlcyBpbiBwYXJhXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgaWYgKCRpc0Jsb2NrRWxlbWVudE5vZGUobm9kZSkpIHtcbiAgICAgIGlmICh0ZXh0QWxpZ24gJiYgIW5vZGUuZ2V0Rm9ybWF0KCkpIHtcbiAgICAgICAgbm9kZS5zZXRGb3JtYXQodGV4dEFsaWduKTtcbiAgICAgIH1cbiAgICAgIG91dC5wdXNoKG5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250aW51b3VzSW5saW5lcy5wdXNoKG5vZGUpO1xuICAgICAgaWYgKGkgPT09IG5vZGVzLmxlbmd0aCAtIDEgfHwgaSA8IG5vZGVzLmxlbmd0aCAtIDEgJiYgJGlzQmxvY2tFbGVtZW50Tm9kZShub2Rlc1tpICsgMV0pKSB7XG4gICAgICAgIGNvbnN0IHdyYXBwZXIgPSBjcmVhdGVXcmFwcGVyRm4oKTtcbiAgICAgICAgd3JhcHBlci5zZXRGb3JtYXQodGV4dEFsaWduKTtcbiAgICAgICAgd3JhcHBlci5hcHBlbmQoLi4uY29udGludW91c0lubGluZXMpO1xuICAgICAgICBvdXQucHVzaCh3cmFwcGVyKTtcbiAgICAgICAgY29udGludW91c0lubGluZXMgPSBbXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbmZ1bmN0aW9uICR1bndyYXBBcnRpZmljYWxOb2RlcyhhbGxBcnRpZmljaWFsTm9kZXMpIHtcbiAgZm9yIChjb25zdCBub2RlIG9mIGFsbEFydGlmaWNpYWxOb2Rlcykge1xuICAgIGlmIChub2RlLmdldE5leHRTaWJsaW5nKCkgaW5zdGFuY2VvZiBBcnRpZmljaWFsTm9kZV9fRE9fTk9UX1VTRSkge1xuICAgICAgbm9kZS5pbnNlcnRBZnRlcigkY3JlYXRlTGluZUJyZWFrTm9kZSgpKTtcbiAgICB9XG4gIH1cbiAgLy8gUmVwbGFjZSBhcnRpZmljaWFsIG5vZGUgd2l0aCBpdCdzIGNoaWxkcmVuXG4gIGZvciAoY29uc3Qgbm9kZSBvZiBhbGxBcnRpZmljaWFsTm9kZXMpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuZ2V0Q2hpbGRyZW4oKTtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNoaWxkcmVuKSB7XG4gICAgICBub2RlLmluc2VydEJlZm9yZShjaGlsZCk7XG4gICAgfVxuICAgIG5vZGUucmVtb3ZlKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzRG9tTm9kZUJldHdlZW5Ud29JbmxpbmVOb2Rlcyhub2RlKSB7XG4gIGlmIChub2RlLm5leHRTaWJsaW5nID09IG51bGwgfHwgbm9kZS5wcmV2aW91c1NpYmxpbmcgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gaXNJbmxpbmVEb21Ob2RlKG5vZGUubmV4dFNpYmxpbmcpICYmIGlzSW5saW5lRG9tTm9kZShub2RlLnByZXZpb3VzU2libGluZyk7XG59XG5cbmV4cG9ydCB7ICRnZW5lcmF0ZUh0bWxGcm9tTm9kZXMsICRnZW5lcmF0ZU5vZGVzRnJvbURPTSB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/html/LexicalHtml.dev.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/plain-text/LexicalPlainText.dev.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@lexical/plain-text/LexicalPlainText.dev.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   registerPlainText: () => (/* binding */ registerPlainText)\n/* harmony export */ });\n/* harmony import */ var _lexical_clipboard__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lexical/clipboard */ \"(app-pages-browser)/./node_modules/@lexical/clipboard/LexicalClipboard.dev.mjs\");\n/* harmony import */ var _lexical_selection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lexical/selection */ \"(app-pages-browser)/./node_modules/@lexical/selection/LexicalSelection.dev.mjs\");\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lexical/utils */ \"(app-pages-browser)/./node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lexical */ \"(app-pages-browser)/./node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nconst CAN_USE_BEFORE_INPUT = CAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\n\n// Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\nconst IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent);\nconst IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction onCopyForPlainText(event, editor) {\n  editor.update(() => {\n    if (event !== null) {\n      const clipboardData = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_0__.objectKlassEquals)(event, KeyboardEvent) ? null : event.clipboardData;\n      const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$getSelection)();\n      if (selection !== null && clipboardData != null) {\n        event.preventDefault();\n        const htmlString = (0,_lexical_clipboard__WEBPACK_IMPORTED_MODULE_2__.$getHtmlContent)(editor);\n        if (htmlString !== null) {\n          clipboardData.setData('text/html', htmlString);\n        }\n        clipboardData.setData('text/plain', selection.getTextContent());\n      }\n    }\n  });\n}\nfunction onPasteForPlainText(event, editor) {\n  event.preventDefault();\n  editor.update(() => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$getSelection)();\n    const {\n      clipboardData\n    } = event;\n    if (clipboardData != null && (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isRangeSelection)(selection)) {\n      (0,_lexical_clipboard__WEBPACK_IMPORTED_MODULE_2__.$insertDataTransferForPlainText)(clipboardData, selection);\n    }\n  }, {\n    tag: 'paste'\n  });\n}\nfunction onCutForPlainText(event, editor) {\n  onCopyForPlainText(event, editor);\n  editor.update(() => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$getSelection)();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isRangeSelection)(selection)) {\n      selection.removeText();\n    }\n  });\n}\nfunction registerPlainText(editor) {\n  const removeListener = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_0__.mergeRegister)(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_1__.DELETE_CHARACTER_COMMAND, isBackward => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    selection.deleteCharacter(isBackward);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_1__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_1__.DELETE_WORD_COMMAND, isBackward => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    selection.deleteWord(isBackward);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_1__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_1__.DELETE_LINE_COMMAND, isBackward => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    selection.deleteLine(isBackward);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_1__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_1__.CONTROLLED_TEXT_INSERTION_COMMAND, eventOrText => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    if (typeof eventOrText === 'string') {\n      selection.insertText(eventOrText);\n    } else {\n      const dataTransfer = eventOrText.dataTransfer;\n      if (dataTransfer != null) {\n        (0,_lexical_clipboard__WEBPACK_IMPORTED_MODULE_2__.$insertDataTransferForPlainText)(dataTransfer, selection);\n      } else {\n        const data = eventOrText.data;\n        if (data) {\n          selection.insertText(data);\n        }\n      }\n    }\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_1__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_1__.REMOVE_TEXT_COMMAND, () => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    selection.removeText();\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_1__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_1__.INSERT_LINE_BREAK_COMMAND, selectStart => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    selection.insertLineBreak(selectStart);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_1__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_1__.INSERT_PARAGRAPH_COMMAND, () => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    selection.insertLineBreak();\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_1__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_1__.KEY_ARROW_LEFT_COMMAND, payload => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    const event = payload;\n    const isHoldingShift = event.shiftKey;\n    if ((0,_lexical_selection__WEBPACK_IMPORTED_MODULE_3__.$shouldOverrideDefaultCharacterSelection)(selection, true)) {\n      event.preventDefault();\n      (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_3__.$moveCharacter)(selection, isHoldingShift, true);\n      return true;\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_1__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_1__.KEY_ARROW_RIGHT_COMMAND, payload => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    const event = payload;\n    const isHoldingShift = event.shiftKey;\n    if ((0,_lexical_selection__WEBPACK_IMPORTED_MODULE_3__.$shouldOverrideDefaultCharacterSelection)(selection, false)) {\n      event.preventDefault();\n      (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_3__.$moveCharacter)(selection, isHoldingShift, false);\n      return true;\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_1__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_1__.KEY_BACKSPACE_COMMAND, event => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isRangeSelection)(selection)) {\n      return false;\n    }\n\n    // Exception handling for iOS native behavior instead of Lexical's behavior when using Korean on iOS devices.\n    // more details - https://github.com/facebook/lexical/issues/5841\n    if (IS_IOS && navigator.language === 'ko-KR') {\n      return false;\n    }\n    event.preventDefault();\n    return editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_1__.DELETE_CHARACTER_COMMAND, true);\n  }, lexical__WEBPACK_IMPORTED_MODULE_1__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_1__.KEY_DELETE_COMMAND, event => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    event.preventDefault();\n    return editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_1__.DELETE_CHARACTER_COMMAND, false);\n  }, lexical__WEBPACK_IMPORTED_MODULE_1__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_1__.KEY_ENTER_COMMAND, event => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    if (event !== null) {\n      // If we have beforeinput, then we can avoid blocking\n      // the default behavior. This ensures that the iOS can\n      // intercept that we're actually inserting a paragraph,\n      // and autocomplete, autocapitalize etc work as intended.\n      // This can also cause a strange performance issue in\n      // Safari, where there is a noticeable pause due to\n      // preventing the key down of enter.\n      if ((IS_IOS || IS_SAFARI || IS_APPLE_WEBKIT) && CAN_USE_BEFORE_INPUT) {\n        return false;\n      }\n      event.preventDefault();\n    }\n    return editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_1__.INSERT_LINE_BREAK_COMMAND, false);\n  }, lexical__WEBPACK_IMPORTED_MODULE_1__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_1__.SELECT_ALL_COMMAND, () => {\n    (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$selectAll)();\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_1__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_1__.COPY_COMMAND, event => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    onCopyForPlainText(event, editor);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_1__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_1__.CUT_COMMAND, event => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    onCutForPlainText(event, editor);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_1__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_1__.PASTE_COMMAND, event => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    onPasteForPlainText(event, editor);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_1__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_1__.DROP_COMMAND, event => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isRangeSelection)(selection)) {\n      return false;\n    }\n\n    // TODO: Make drag and drop work at some point.\n    event.preventDefault();\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_1__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_1__.DRAGSTART_COMMAND, event => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isRangeSelection)(selection)) {\n      return false;\n    }\n\n    // TODO: Make drag and drop work at some point.\n    event.preventDefault();\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_1__.COMMAND_PRIORITY_EDITOR));\n  return removeListener;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9wbGFpbi10ZXh0L0xleGljYWxQbGFpblRleHQuZGV2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVzRjtBQUNRO0FBQzVCO0FBQzZaOztBQUUvZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsaUVBQWlCO0FBQzdDLHdCQUF3QixzREFBYTtBQUNyQztBQUNBO0FBQ0EsMkJBQTJCLG1FQUFlO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzREFBYTtBQUNuQztBQUNBO0FBQ0EsTUFBTTtBQUNOLGlDQUFpQywwREFBaUI7QUFDbEQsTUFBTSxtRkFBK0I7QUFDckM7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0RBQWE7QUFDbkMsUUFBUSwwREFBaUI7QUFDekI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EseUJBQXlCLDZEQUFhLHdCQUF3Qiw2REFBd0I7QUFDdEYsc0JBQXNCLHNEQUFhO0FBQ25DLFNBQVMsMERBQWlCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxFQUFFLDREQUF1QiwwQkFBMEIsd0RBQW1CO0FBQ3pFLHNCQUFzQixzREFBYTtBQUNuQyxTQUFTLDBEQUFpQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRSw0REFBdUIsMEJBQTBCLHdEQUFtQjtBQUN6RSxzQkFBc0Isc0RBQWE7QUFDbkMsU0FBUywwREFBaUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLEVBQUUsNERBQXVCLDBCQUEwQixzRUFBaUM7QUFDdkYsc0JBQXNCLHNEQUFhO0FBQ25DLFNBQVMsMERBQWlCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRLG1GQUErQjtBQUN2QyxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLEVBQUUsNERBQXVCLDBCQUEwQix3REFBbUI7QUFDekUsc0JBQXNCLHNEQUFhO0FBQ25DLFNBQVMsMERBQWlCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxFQUFFLDREQUF1QiwwQkFBMEIsOERBQXlCO0FBQy9FLHNCQUFzQixzREFBYTtBQUNuQyxTQUFTLDBEQUFpQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRSw0REFBdUIsMEJBQTBCLDZEQUF3QjtBQUM5RSxzQkFBc0Isc0RBQWE7QUFDbkMsU0FBUywwREFBaUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLEVBQUUsNERBQXVCLDBCQUEwQiwyREFBc0I7QUFDNUUsc0JBQXNCLHNEQUFhO0FBQ25DLFNBQVMsMERBQWlCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw0RkFBd0M7QUFDaEQ7QUFDQSxNQUFNLGtFQUFjO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRSw0REFBdUIsMEJBQTBCLDREQUF1QjtBQUM3RSxzQkFBc0Isc0RBQWE7QUFDbkMsU0FBUywwREFBaUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDRGQUF3QztBQUNoRDtBQUNBLE1BQU0sa0VBQWM7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsR0FBRyxFQUFFLDREQUF1QiwwQkFBMEIsMERBQXFCO0FBQzNFLHNCQUFzQixzREFBYTtBQUNuQyxTQUFTLDBEQUFpQjtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyw2REFBd0I7QUFDMUQsR0FBRyxFQUFFLDREQUF1QiwwQkFBMEIsdURBQWtCO0FBQ3hFLHNCQUFzQixzREFBYTtBQUNuQyxTQUFTLDBEQUFpQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsNkRBQXdCO0FBQzFELEdBQUcsRUFBRSw0REFBdUIsMEJBQTBCLHNEQUFpQjtBQUN2RSxzQkFBc0Isc0RBQWE7QUFDbkMsU0FBUywwREFBaUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDhEQUF5QjtBQUMzRCxHQUFHLEVBQUUsNERBQXVCLDBCQUEwQix1REFBa0I7QUFDeEUsSUFBSSxtREFBVTtBQUNkO0FBQ0EsR0FBRyxFQUFFLDREQUF1QiwwQkFBMEIsaURBQVk7QUFDbEUsc0JBQXNCLHNEQUFhO0FBQ25DLFNBQVMsMERBQWlCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxFQUFFLDREQUF1QiwwQkFBMEIsZ0RBQVc7QUFDakUsc0JBQXNCLHNEQUFhO0FBQ25DLFNBQVMsMERBQWlCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxFQUFFLDREQUF1QiwwQkFBMEIsa0RBQWE7QUFDbkUsc0JBQXNCLHNEQUFhO0FBQ25DLFNBQVMsMERBQWlCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxFQUFFLDREQUF1QiwwQkFBMEIsaURBQVk7QUFDbEUsc0JBQXNCLHNEQUFhO0FBQ25DLFNBQVMsMERBQWlCO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRyxFQUFFLDREQUF1QiwwQkFBMEIsc0RBQWlCO0FBQ3ZFLHNCQUFzQixzREFBYTtBQUNuQyxTQUFTLDBEQUFpQjtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRSw0REFBdUI7QUFDNUI7QUFDQTs7QUFFNkIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9sZWkvaG9tZS91bmRlcmcvdGhlYXRyZS95My9zZWdwL21pbGt1cC9ub2RlX21vZHVsZXMvQGxleGljYWwvcGxhaW4tdGV4dC9MZXhpY2FsUGxhaW5UZXh0LmRldi5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5pbXBvcnQgeyAkaW5zZXJ0RGF0YVRyYW5zZmVyRm9yUGxhaW5UZXh0LCAkZ2V0SHRtbENvbnRlbnQgfSBmcm9tICdAbGV4aWNhbC9jbGlwYm9hcmQnO1xuaW1wb3J0IHsgJHNob3VsZE92ZXJyaWRlRGVmYXVsdENoYXJhY3RlclNlbGVjdGlvbiwgJG1vdmVDaGFyYWN0ZXIgfSBmcm9tICdAbGV4aWNhbC9zZWxlY3Rpb24nO1xuaW1wb3J0IHsgbWVyZ2VSZWdpc3Rlciwgb2JqZWN0S2xhc3NFcXVhbHMgfSBmcm9tICdAbGV4aWNhbC91dGlscyc7XG5pbXBvcnQgeyBERUxFVEVfQ0hBUkFDVEVSX0NPTU1BTkQsICRnZXRTZWxlY3Rpb24sICRpc1JhbmdlU2VsZWN0aW9uLCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiwgREVMRVRFX1dPUkRfQ09NTUFORCwgREVMRVRFX0xJTkVfQ09NTUFORCwgQ09OVFJPTExFRF9URVhUX0lOU0VSVElPTl9DT01NQU5ELCBSRU1PVkVfVEVYVF9DT01NQU5ELCBJTlNFUlRfTElORV9CUkVBS19DT01NQU5ELCBJTlNFUlRfUEFSQUdSQVBIX0NPTU1BTkQsIEtFWV9BUlJPV19MRUZUX0NPTU1BTkQsIEtFWV9BUlJPV19SSUdIVF9DT01NQU5ELCBLRVlfQkFDS1NQQUNFX0NPTU1BTkQsIEtFWV9ERUxFVEVfQ09NTUFORCwgS0VZX0VOVEVSX0NPTU1BTkQsIFNFTEVDVF9BTExfQ09NTUFORCwgJHNlbGVjdEFsbCwgQ09QWV9DT01NQU5ELCBDVVRfQ09NTUFORCwgUEFTVEVfQ09NTUFORCwgRFJPUF9DT01NQU5ELCBEUkFHU1RBUlRfQ09NTUFORCB9IGZyb20gJ2xleGljYWwnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IENBTl9VU0VfRE9NID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBkb2N1bWVudE1vZGUgPSBDQU5fVVNFX0RPTSAmJiAnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCA/IGRvY3VtZW50LmRvY3VtZW50TW9kZSA6IG51bGw7XG5jb25zdCBDQU5fVVNFX0JFRk9SRV9JTlBVVCA9IENBTl9VU0VfRE9NICYmICdJbnB1dEV2ZW50JyBpbiB3aW5kb3cgJiYgIWRvY3VtZW50TW9kZSA/ICdnZXRUYXJnZXRSYW5nZXMnIGluIG5ldyB3aW5kb3cuSW5wdXRFdmVudCgnaW5wdXQnKSA6IGZhbHNlO1xuY29uc3QgSVNfU0FGQVJJID0gQ0FOX1VTRV9ET00gJiYgL1ZlcnNpb25cXC9bXFxkLl0rLipTYWZhcmkvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5jb25zdCBJU19JT1MgPSBDQU5fVVNFX0RPTSAmJiAvaVBhZHxpUGhvbmV8aVBvZC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAhd2luZG93Lk1TU3RyZWFtO1xuXG4vLyBLZWVwIHRoZXNlIGluIGNhc2Ugd2UgbmVlZCB0byB1c2UgdGhlbSBpbiB0aGUgZnV0dXJlLlxuLy8gZXhwb3J0IGNvbnN0IElTX1dJTkRPV1M6IGJvb2xlYW4gPSBDQU5fVVNFX0RPTSAmJiAvV2luLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSk7XG5jb25zdCBJU19DSFJPTUUgPSBDQU5fVVNFX0RPTSAmJiAvXig/PS4qQ2hyb21lKS4qL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbmNvbnN0IElTX0FQUExFX1dFQktJVCA9IENBTl9VU0VfRE9NICYmIC9BcHBsZVdlYktpdFxcL1tcXGQuXSsvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgIUlTX0NIUk9NRTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiBvbkNvcHlGb3JQbGFpblRleHQoZXZlbnQsIGVkaXRvcikge1xuICBlZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICBpZiAoZXZlbnQgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGNsaXBib2FyZERhdGEgPSBvYmplY3RLbGFzc0VxdWFscyhldmVudCwgS2V5Ym9hcmRFdmVudCkgPyBudWxsIDogZXZlbnQuY2xpcGJvYXJkRGF0YTtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICAgIGlmIChzZWxlY3Rpb24gIT09IG51bGwgJiYgY2xpcGJvYXJkRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGNvbnN0IGh0bWxTdHJpbmcgPSAkZ2V0SHRtbENvbnRlbnQoZWRpdG9yKTtcbiAgICAgICAgaWYgKGh0bWxTdHJpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICBjbGlwYm9hcmREYXRhLnNldERhdGEoJ3RleHQvaHRtbCcsIGh0bWxTdHJpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGNsaXBib2FyZERhdGEuc2V0RGF0YSgndGV4dC9wbGFpbicsIHNlbGVjdGlvbi5nZXRUZXh0Q29udGVudCgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gb25QYXN0ZUZvclBsYWluVGV4dChldmVudCwgZWRpdG9yKSB7XG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBjb25zdCB7XG4gICAgICBjbGlwYm9hcmREYXRhXG4gICAgfSA9IGV2ZW50O1xuICAgIGlmIChjbGlwYm9hcmREYXRhICE9IG51bGwgJiYgJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgJGluc2VydERhdGFUcmFuc2ZlckZvclBsYWluVGV4dChjbGlwYm9hcmREYXRhLCBzZWxlY3Rpb24pO1xuICAgIH1cbiAgfSwge1xuICAgIHRhZzogJ3Bhc3RlJ1xuICB9KTtcbn1cbmZ1bmN0aW9uIG9uQ3V0Rm9yUGxhaW5UZXh0KGV2ZW50LCBlZGl0b3IpIHtcbiAgb25Db3B5Rm9yUGxhaW5UZXh0KGV2ZW50LCBlZGl0b3IpO1xuICBlZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHNlbGVjdGlvbi5yZW1vdmVUZXh0KCk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyUGxhaW5UZXh0KGVkaXRvcikge1xuICBjb25zdCByZW1vdmVMaXN0ZW5lciA9IG1lcmdlUmVnaXN0ZXIoZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChERUxFVEVfQ0hBUkFDVEVSX0NPTU1BTkQsIGlzQmFja3dhcmQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc2VsZWN0aW9uLmRlbGV0ZUNoYXJhY3Rlcihpc0JhY2t3YXJkKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKERFTEVURV9XT1JEX0NPTU1BTkQsIGlzQmFja3dhcmQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc2VsZWN0aW9uLmRlbGV0ZVdvcmQoaXNCYWNrd2FyZCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChERUxFVEVfTElORV9DT01NQU5ELCBpc0JhY2t3YXJkID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHNlbGVjdGlvbi5kZWxldGVMaW5lKGlzQmFja3dhcmQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoQ09OVFJPTExFRF9URVhUX0lOU0VSVElPTl9DT01NQU5ELCBldmVudE9yVGV4dCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGV2ZW50T3JUZXh0ID09PSAnc3RyaW5nJykge1xuICAgICAgc2VsZWN0aW9uLmluc2VydFRleHQoZXZlbnRPclRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBkYXRhVHJhbnNmZXIgPSBldmVudE9yVGV4dC5kYXRhVHJhbnNmZXI7XG4gICAgICBpZiAoZGF0YVRyYW5zZmVyICE9IG51bGwpIHtcbiAgICAgICAgJGluc2VydERhdGFUcmFuc2ZlckZvclBsYWluVGV4dChkYXRhVHJhbnNmZXIsIHNlbGVjdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBkYXRhID0gZXZlbnRPclRleHQuZGF0YTtcbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICBzZWxlY3Rpb24uaW5zZXJ0VGV4dChkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKFJFTU9WRV9URVhUX0NPTU1BTkQsICgpID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHNlbGVjdGlvbi5yZW1vdmVUZXh0KCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChJTlNFUlRfTElORV9CUkVBS19DT01NQU5ELCBzZWxlY3RTdGFydCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzZWxlY3Rpb24uaW5zZXJ0TGluZUJyZWFrKHNlbGVjdFN0YXJ0KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKElOU0VSVF9QQVJBR1JBUEhfQ09NTUFORCwgKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc2VsZWN0aW9uLmluc2VydExpbmVCcmVhaygpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoS0VZX0FSUk9XX0xFRlRfQ09NTUFORCwgcGF5bG9hZCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBldmVudCA9IHBheWxvYWQ7XG4gICAgY29uc3QgaXNIb2xkaW5nU2hpZnQgPSBldmVudC5zaGlmdEtleTtcbiAgICBpZiAoJHNob3VsZE92ZXJyaWRlRGVmYXVsdENoYXJhY3RlclNlbGVjdGlvbihzZWxlY3Rpb24sIHRydWUpKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgJG1vdmVDaGFyYWN0ZXIoc2VsZWN0aW9uLCBpc0hvbGRpbmdTaGlmdCwgdHJ1ZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoS0VZX0FSUk9XX1JJR0hUX0NPTU1BTkQsIHBheWxvYWQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgZXZlbnQgPSBwYXlsb2FkO1xuICAgIGNvbnN0IGlzSG9sZGluZ1NoaWZ0ID0gZXZlbnQuc2hpZnRLZXk7XG4gICAgaWYgKCRzaG91bGRPdmVycmlkZURlZmF1bHRDaGFyYWN0ZXJTZWxlY3Rpb24oc2VsZWN0aW9uLCBmYWxzZSkpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAkbW92ZUNoYXJhY3RlcihzZWxlY3Rpb24sIGlzSG9sZGluZ1NoaWZ0LCBmYWxzZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoS0VZX0JBQ0tTUEFDRV9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIEV4Y2VwdGlvbiBoYW5kbGluZyBmb3IgaU9TIG5hdGl2ZSBiZWhhdmlvciBpbnN0ZWFkIG9mIExleGljYWwncyBiZWhhdmlvciB3aGVuIHVzaW5nIEtvcmVhbiBvbiBpT1MgZGV2aWNlcy5cbiAgICAvLyBtb3JlIGRldGFpbHMgLSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svbGV4aWNhbC9pc3N1ZXMvNTg0MVxuICAgIGlmIChJU19JT1MgJiYgbmF2aWdhdG9yLmxhbmd1YWdlID09PSAna28tS1InKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgcmV0dXJuIGVkaXRvci5kaXNwYXRjaENvbW1hbmQoREVMRVRFX0NIQVJBQ1RFUl9DT01NQU5ELCB0cnVlKTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEtFWV9ERUxFVEVfQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICByZXR1cm4gZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChERUxFVEVfQ0hBUkFDVEVSX0NPTU1BTkQsIGZhbHNlKTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEtFWV9FTlRFUl9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZXZlbnQgIT09IG51bGwpIHtcbiAgICAgIC8vIElmIHdlIGhhdmUgYmVmb3JlaW5wdXQsIHRoZW4gd2UgY2FuIGF2b2lkIGJsb2NraW5nXG4gICAgICAvLyB0aGUgZGVmYXVsdCBiZWhhdmlvci4gVGhpcyBlbnN1cmVzIHRoYXQgdGhlIGlPUyBjYW5cbiAgICAgIC8vIGludGVyY2VwdCB0aGF0IHdlJ3JlIGFjdHVhbGx5IGluc2VydGluZyBhIHBhcmFncmFwaCxcbiAgICAgIC8vIGFuZCBhdXRvY29tcGxldGUsIGF1dG9jYXBpdGFsaXplIGV0YyB3b3JrIGFzIGludGVuZGVkLlxuICAgICAgLy8gVGhpcyBjYW4gYWxzbyBjYXVzZSBhIHN0cmFuZ2UgcGVyZm9ybWFuY2UgaXNzdWUgaW5cbiAgICAgIC8vIFNhZmFyaSwgd2hlcmUgdGhlcmUgaXMgYSBub3RpY2VhYmxlIHBhdXNlIGR1ZSB0b1xuICAgICAgLy8gcHJldmVudGluZyB0aGUga2V5IGRvd24gb2YgZW50ZXIuXG4gICAgICBpZiAoKElTX0lPUyB8fCBJU19TQUZBUkkgfHwgSVNfQVBQTEVfV0VCS0lUKSAmJiBDQU5fVVNFX0JFRk9SRV9JTlBVVCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICByZXR1cm4gZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChJTlNFUlRfTElORV9CUkVBS19DT01NQU5ELCBmYWxzZSk7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChTRUxFQ1RfQUxMX0NPTU1BTkQsICgpID0+IHtcbiAgICAkc2VsZWN0QWxsKCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChDT1BZX0NPTU1BTkQsIGV2ZW50ID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG9uQ29weUZvclBsYWluVGV4dChldmVudCwgZWRpdG9yKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKENVVF9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBvbkN1dEZvclBsYWluVGV4dChldmVudCwgZWRpdG9yKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKFBBU1RFX0NPTU1BTkQsIGV2ZW50ID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG9uUGFzdGVGb3JQbGFpblRleHQoZXZlbnQsIGVkaXRvcik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChEUk9QX0NPTU1BTkQsIGV2ZW50ID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogTWFrZSBkcmFnIGFuZCBkcm9wIHdvcmsgYXQgc29tZSBwb2ludC5cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoRFJBR1NUQVJUX0NPTU1BTkQsIGV2ZW50ID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogTWFrZSBkcmFnIGFuZCBkcm9wIHdvcmsgYXQgc29tZSBwb2ludC5cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUikpO1xuICByZXR1cm4gcmVtb3ZlTGlzdGVuZXI7XG59XG5cbmV4cG9ydCB7IHJlZ2lzdGVyUGxhaW5UZXh0IH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/plain-text/LexicalPlainText.dev.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/react/LexicalComposer.dev.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalComposer.dev.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LexicalComposer: () => (/* binding */ LexicalComposer)\n/* harmony export */ });\n/* harmony import */ var _lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(app-pages-browser)/./node_modules/@lexical/react/LexicalComposerContext.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lexical */ \"(app-pages-browser)/./node_modules/lexical/Lexical.dev.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// This workaround is no longer necessary in React 19,\n// but we currently support React >=17.x\n// https://github.com/facebook/react/pull/26395\nconst useLayoutEffectImpl = CAN_USE_DOM ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst HISTORY_MERGE_OPTIONS = {\n  tag: 'history-merge'\n};\nfunction LexicalComposer({\n  initialConfig,\n  children\n}) {\n  const composerContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    const {\n      theme,\n      namespace,\n      nodes,\n      onError,\n      editorState: initialEditorState,\n      html\n    } = initialConfig;\n    const context = (0,_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_2__.createLexicalComposerContext)(null, theme);\n    const editor = (0,lexical__WEBPACK_IMPORTED_MODULE_3__.createEditor)({\n      editable: initialConfig.editable,\n      html,\n      namespace,\n      nodes,\n      onError: error => onError(error, editor),\n      theme\n    });\n    initializeEditor(editor, initialEditorState);\n    return [editor, context];\n  },\n  // We only do this for init\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  []);\n  useLayoutEffectImpl(() => {\n    const isEditable = initialConfig.editable;\n    const [editor] = composerContext;\n    editor.setEditable(isEditable !== undefined ? isEditable : true);\n\n    // We only do this for init\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_2__.LexicalComposerContext.Provider, {\n    value: composerContext,\n    children: children\n  });\n}\nfunction initializeEditor(editor, initialEditorState) {\n  if (initialEditorState === null) {\n    return;\n  } else if (initialEditorState === undefined) {\n    editor.update(() => {\n      const root = (0,lexical__WEBPACK_IMPORTED_MODULE_3__.$getRoot)();\n      if (root.isEmpty()) {\n        const paragraph = (0,lexical__WEBPACK_IMPORTED_MODULE_3__.$createParagraphNode)();\n        root.append(paragraph);\n        const activeElement = CAN_USE_DOM ? document.activeElement : null;\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_3__.$getSelection)() !== null || activeElement !== null && activeElement === editor.getRootElement()) {\n          paragraph.select();\n        }\n      }\n    }, HISTORY_MERGE_OPTIONS);\n  } else if (initialEditorState !== null) {\n    switch (typeof initialEditorState) {\n      case 'string':\n        {\n          const parsedEditorState = editor.parseEditorState(initialEditorState);\n          editor.setEditorState(parsedEditorState, HISTORY_MERGE_OPTIONS);\n          break;\n        }\n      case 'object':\n        {\n          editor.setEditorState(initialEditorState, HISTORY_MERGE_OPTIONS);\n          break;\n        }\n      case 'function':\n        {\n          editor.update(() => {\n            const root = (0,lexical__WEBPACK_IMPORTED_MODULE_3__.$getRoot)();\n            if (root.isEmpty()) {\n              initialEditorState(editor);\n            }\n          }, HISTORY_MERGE_OPTIONS);\n          break;\n        }\n    }\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ29tcG9zZXIuZGV2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU2RztBQUN2QjtBQUMxQjtBQUNwQjs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxrREFBZSxHQUFHLDRDQUFTOztBQUVyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsMEJBQTBCLDhDQUFPO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLG9CQUFvQixtR0FBNEI7QUFDaEQsbUJBQW1CLHFEQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsc0JBQXNCLHNEQUFHLENBQUMseUZBQXNCO0FBQ2hEO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxtQkFBbUIsaURBQVE7QUFDM0I7QUFDQSwwQkFBMEIsNkRBQW9CO0FBQzlDO0FBQ0E7QUFDQSxZQUFZLHNEQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGlEQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUyQiIsInNvdXJjZXMiOlsiL1VzZXJzL2xlaS9ob21lL3VuZGVyZy90aGVhdHJlL3kzL3NlZ3AvbWlsa3VwL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ29tcG9zZXIuZGV2Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmltcG9ydCB7IGNyZWF0ZUxleGljYWxDb21wb3NlckNvbnRleHQsIExleGljYWxDb21wb3NlckNvbnRleHQgfSBmcm9tICdAbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ29tcG9zZXJDb250ZXh0JztcbmltcG9ydCB7IGNyZWF0ZUVkaXRvciwgJGdldFJvb3QsICRjcmVhdGVQYXJhZ3JhcGhOb2RlLCAkZ2V0U2VsZWN0aW9uIH0gZnJvbSAnbGV4aWNhbCc7XG5pbXBvcnQgeyB1c2VMYXlvdXRFZmZlY3QsIHVzZUVmZmVjdCwgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGpzeCB9IGZyb20gJ3JlYWN0L2pzeC1ydW50aW1lJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBDQU5fVVNFX0RPTSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuXG4vLyBUaGlzIHdvcmthcm91bmQgaXMgbm8gbG9uZ2VyIG5lY2Vzc2FyeSBpbiBSZWFjdCAxOSxcbi8vIGJ1dCB3ZSBjdXJyZW50bHkgc3VwcG9ydCBSZWFjdCA+PTE3Lnhcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzI2Mzk1XG5jb25zdCB1c2VMYXlvdXRFZmZlY3RJbXBsID0gQ0FOX1VTRV9ET00gPyB1c2VMYXlvdXRFZmZlY3QgOiB1c2VFZmZlY3Q7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuY29uc3QgSElTVE9SWV9NRVJHRV9PUFRJT05TID0ge1xuICB0YWc6ICdoaXN0b3J5LW1lcmdlJ1xufTtcbmZ1bmN0aW9uIExleGljYWxDb21wb3Nlcih7XG4gIGluaXRpYWxDb25maWcsXG4gIGNoaWxkcmVuXG59KSB7XG4gIGNvbnN0IGNvbXBvc2VyQ29udGV4dCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHRoZW1lLFxuICAgICAgbmFtZXNwYWNlLFxuICAgICAgbm9kZXMsXG4gICAgICBvbkVycm9yLFxuICAgICAgZWRpdG9yU3RhdGU6IGluaXRpYWxFZGl0b3JTdGF0ZSxcbiAgICAgIGh0bWxcbiAgICB9ID0gaW5pdGlhbENvbmZpZztcbiAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlTGV4aWNhbENvbXBvc2VyQ29udGV4dChudWxsLCB0aGVtZSk7XG4gICAgY29uc3QgZWRpdG9yID0gY3JlYXRlRWRpdG9yKHtcbiAgICAgIGVkaXRhYmxlOiBpbml0aWFsQ29uZmlnLmVkaXRhYmxlLFxuICAgICAgaHRtbCxcbiAgICAgIG5hbWVzcGFjZSxcbiAgICAgIG5vZGVzLFxuICAgICAgb25FcnJvcjogZXJyb3IgPT4gb25FcnJvcihlcnJvciwgZWRpdG9yKSxcbiAgICAgIHRoZW1lXG4gICAgfSk7XG4gICAgaW5pdGlhbGl6ZUVkaXRvcihlZGl0b3IsIGluaXRpYWxFZGl0b3JTdGF0ZSk7XG4gICAgcmV0dXJuIFtlZGl0b3IsIGNvbnRleHRdO1xuICB9LFxuICAvLyBXZSBvbmx5IGRvIHRoaXMgZm9yIGluaXRcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBbXSk7XG4gIHVzZUxheW91dEVmZmVjdEltcGwoKCkgPT4ge1xuICAgIGNvbnN0IGlzRWRpdGFibGUgPSBpbml0aWFsQ29uZmlnLmVkaXRhYmxlO1xuICAgIGNvbnN0IFtlZGl0b3JdID0gY29tcG9zZXJDb250ZXh0O1xuICAgIGVkaXRvci5zZXRFZGl0YWJsZShpc0VkaXRhYmxlICE9PSB1bmRlZmluZWQgPyBpc0VkaXRhYmxlIDogdHJ1ZSk7XG5cbiAgICAvLyBXZSBvbmx5IGRvIHRoaXMgZm9yIGluaXRcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIFtdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goTGV4aWNhbENvbXBvc2VyQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjb21wb3NlckNvbnRleHQsXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gIH0pO1xufVxuZnVuY3Rpb24gaW5pdGlhbGl6ZUVkaXRvcihlZGl0b3IsIGluaXRpYWxFZGl0b3JTdGF0ZSkge1xuICBpZiAoaW5pdGlhbEVkaXRvclN0YXRlID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKGluaXRpYWxFZGl0b3JTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICBjb25zdCByb290ID0gJGdldFJvb3QoKTtcbiAgICAgIGlmIChyb290LmlzRW1wdHkoKSkge1xuICAgICAgICBjb25zdCBwYXJhZ3JhcGggPSAkY3JlYXRlUGFyYWdyYXBoTm9kZSgpO1xuICAgICAgICByb290LmFwcGVuZChwYXJhZ3JhcGgpO1xuICAgICAgICBjb25zdCBhY3RpdmVFbGVtZW50ID0gQ0FOX1VTRV9ET00gPyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IDogbnVsbDtcbiAgICAgICAgaWYgKCRnZXRTZWxlY3Rpb24oKSAhPT0gbnVsbCB8fCBhY3RpdmVFbGVtZW50ICE9PSBudWxsICYmIGFjdGl2ZUVsZW1lbnQgPT09IGVkaXRvci5nZXRSb290RWxlbWVudCgpKSB7XG4gICAgICAgICAgcGFyYWdyYXBoLnNlbGVjdCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgSElTVE9SWV9NRVJHRV9PUFRJT05TKTtcbiAgfSBlbHNlIGlmIChpbml0aWFsRWRpdG9yU3RhdGUgIT09IG51bGwpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiBpbml0aWFsRWRpdG9yU3RhdGUpIHtcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBwYXJzZWRFZGl0b3JTdGF0ZSA9IGVkaXRvci5wYXJzZUVkaXRvclN0YXRlKGluaXRpYWxFZGl0b3JTdGF0ZSk7XG4gICAgICAgICAgZWRpdG9yLnNldEVkaXRvclN0YXRlKHBhcnNlZEVkaXRvclN0YXRlLCBISVNUT1JZX01FUkdFX09QVElPTlMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICB7XG4gICAgICAgICAgZWRpdG9yLnNldEVkaXRvclN0YXRlKGluaXRpYWxFZGl0b3JTdGF0ZSwgSElTVE9SWV9NRVJHRV9PUFRJT05TKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICB7XG4gICAgICAgICAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByb290ID0gJGdldFJvb3QoKTtcbiAgICAgICAgICAgIGlmIChyb290LmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICBpbml0aWFsRWRpdG9yU3RhdGUoZWRpdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBISVNUT1JZX01FUkdFX09QVElPTlMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB7IExleGljYWxDb21wb3NlciB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/react/LexicalComposer.dev.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/react/LexicalComposerContext.dev.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalComposerContext.dev.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LexicalComposerContext: () => (/* binding */ LexicalComposerContext),\n/* harmony export */   createLexicalComposerContext: () => (/* binding */ createLexicalComposerContext),\n/* harmony export */   useLexicalComposerContext: () => (/* binding */ useLexicalComposerContext)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst LexicalComposerContext = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nfunction createLexicalComposerContext(parent, theme) {\n  let parentContext = null;\n  if (parent != null) {\n    parentContext = parent[1];\n  }\n  function getTheme() {\n    if (theme != null) {\n      return theme;\n    }\n    return parentContext != null ? parentContext.getTheme() : null;\n  }\n  return {\n    getTheme\n  };\n}\nfunction useLexicalComposerContext() {\n  const composerContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(LexicalComposerContext);\n  if (composerContext == null) {\n    {\n      throw Error(`LexicalComposerContext.useLexicalComposerContext: cannot find a LexicalComposerContext`);\n    }\n  }\n  return composerContext;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ29tcG9zZXJDb250ZXh0LmRldi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVrRDs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLG9EQUFhO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlEQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUyRiIsInNvdXJjZXMiOlsiL1VzZXJzL2xlaS9ob21lL3VuZGVyZy90aGVhdHJlL3kzL3NlZ3AvbWlsa3VwL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ29tcG9zZXJDb250ZXh0LmRldi5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IExleGljYWxDb21wb3NlckNvbnRleHQgPSAvKiNfX1BVUkVfXyovY3JlYXRlQ29udGV4dChudWxsKTtcbmZ1bmN0aW9uIGNyZWF0ZUxleGljYWxDb21wb3NlckNvbnRleHQocGFyZW50LCB0aGVtZSkge1xuICBsZXQgcGFyZW50Q29udGV4dCA9IG51bGw7XG4gIGlmIChwYXJlbnQgIT0gbnVsbCkge1xuICAgIHBhcmVudENvbnRleHQgPSBwYXJlbnRbMV07XG4gIH1cbiAgZnVuY3Rpb24gZ2V0VGhlbWUoKSB7XG4gICAgaWYgKHRoZW1lICE9IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGVtZTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmVudENvbnRleHQgIT0gbnVsbCA/IHBhcmVudENvbnRleHQuZ2V0VGhlbWUoKSA6IG51bGw7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBnZXRUaGVtZVxuICB9O1xufVxuZnVuY3Rpb24gdXNlTGV4aWNhbENvbXBvc2VyQ29udGV4dCgpIHtcbiAgY29uc3QgY29tcG9zZXJDb250ZXh0ID0gdXNlQ29udGV4dChMZXhpY2FsQ29tcG9zZXJDb250ZXh0KTtcbiAgaWYgKGNvbXBvc2VyQ29udGV4dCA9PSBudWxsKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYExleGljYWxDb21wb3NlckNvbnRleHQudXNlTGV4aWNhbENvbXBvc2VyQ29udGV4dDogY2Fubm90IGZpbmQgYSBMZXhpY2FsQ29tcG9zZXJDb250ZXh0YCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjb21wb3NlckNvbnRleHQ7XG59XG5cbmV4cG9ydCB7IExleGljYWxDb21wb3NlckNvbnRleHQsIGNyZWF0ZUxleGljYWxDb21wb3NlckNvbnRleHQsIHVzZUxleGljYWxDb21wb3NlckNvbnRleHQgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/react/LexicalComposerContext.dev.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/react/LexicalContentEditable.dev.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalContentEditable.dev.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContentEditable: () => (/* binding */ ContentEditable)\n/* harmony export */ });\n/* harmony import */ var _lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(app-pages-browser)/./node_modules/@lexical/react/LexicalComposerContext.dev.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\n/* harmony import */ var _lexical_text__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lexical/text */ \"(app-pages-browser)/./node_modules/@lexical/text/LexicalText.dev.mjs\");\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lexical/utils */ \"(app-pages-browser)/./node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// This workaround is no longer necessary in React 19,\n// but we currently support React >=17.x\n// https://github.com/facebook/react/pull/26395\nconst useLayoutEffectImpl = CAN_USE_DOM ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n// Source: https://github.com/gregberge/react-merge-refs/blob/main/src/index.tsx\n\nfunction mergeRefs(...refs) {\n  return value => {\n    refs.forEach(ref => {\n      if (typeof ref === 'function') {\n        ref(value);\n      } else if (ref != null) {\n        ref.current = value;\n      }\n    });\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction ContentEditableElementImpl({\n  editor,\n  ariaActiveDescendant,\n  ariaAutoComplete,\n  ariaControls,\n  ariaDescribedBy,\n  ariaErrorMessage,\n  ariaExpanded,\n  ariaInvalid,\n  ariaLabel,\n  ariaLabelledBy,\n  ariaMultiline,\n  ariaOwns,\n  ariaRequired,\n  autoCapitalize,\n  className,\n  id,\n  role = 'textbox',\n  spellCheck = true,\n  style,\n  tabIndex,\n  'data-testid': testid,\n  ...rest\n}, ref) {\n  const [isEditable, setEditable] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(editor.isEditable());\n  const handleRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(rootElement => {\n    // defaultView is required for a root element.\n    // In multi-window setups, the defaultView may not exist at certain points.\n    if (rootElement && rootElement.ownerDocument && rootElement.ownerDocument.defaultView) {\n      editor.setRootElement(rootElement);\n    } else {\n      editor.setRootElement(null);\n    }\n  }, [editor]);\n  const mergedRefs = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => mergeRefs(ref, handleRef), [handleRef, ref]);\n  useLayoutEffectImpl(() => {\n    setEditable(editor.isEditable());\n    return editor.registerEditableListener(currentIsEditable => {\n      setEditable(currentIsEditable);\n    });\n  }, [editor]);\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", {\n    \"aria-activedescendant\": isEditable ? ariaActiveDescendant : undefined,\n    \"aria-autocomplete\": isEditable ? ariaAutoComplete : 'none',\n    \"aria-controls\": isEditable ? ariaControls : undefined,\n    \"aria-describedby\": ariaDescribedBy\n    // for compat, only override aria-errormessage if ariaErrorMessage is defined\n    ,\n    ...(ariaErrorMessage != null ? {\n      'aria-errormessage': ariaErrorMessage\n    } : {}),\n    \"aria-expanded\": isEditable && role === 'combobox' ? !!ariaExpanded : undefined\n    // for compat, only override aria-invalid if ariaInvalid is defined\n    ,\n    ...(ariaInvalid != null ? {\n      'aria-invalid': ariaInvalid\n    } : {}),\n    \"aria-label\": ariaLabel,\n    \"aria-labelledby\": ariaLabelledBy,\n    \"aria-multiline\": ariaMultiline,\n    \"aria-owns\": isEditable ? ariaOwns : undefined,\n    \"aria-readonly\": isEditable ? undefined : true,\n    \"aria-required\": ariaRequired,\n    autoCapitalize: autoCapitalize,\n    className: className,\n    contentEditable: isEditable,\n    \"data-testid\": testid,\n    id: id,\n    ref: mergedRefs,\n    role: isEditable ? role : undefined,\n    spellCheck: spellCheck,\n    style: style,\n    tabIndex: tabIndex,\n    ...rest\n  });\n}\nconst ContentEditableElement = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(ContentEditableElementImpl);\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction canShowPlaceholderFromCurrentEditorState(editor) {\n  const currentCanShowPlaceholder = editor.getEditorState().read((0,_lexical_text__WEBPACK_IMPORTED_MODULE_2__.$canShowPlaceholderCurry)(editor.isComposing()));\n  return currentCanShowPlaceholder;\n}\nfunction useCanShowPlaceholder(editor) {\n  const [canShowPlaceholder, setCanShowPlaceholder] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => canShowPlaceholderFromCurrentEditorState(editor));\n  useLayoutEffectImpl(() => {\n    function resetCanShowPlaceholder() {\n      const currentCanShowPlaceholder = canShowPlaceholderFromCurrentEditorState(editor);\n      setCanShowPlaceholder(currentCanShowPlaceholder);\n    }\n    resetCanShowPlaceholder();\n    return (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_3__.mergeRegister)(editor.registerUpdateListener(() => {\n      resetCanShowPlaceholder();\n    }), editor.registerEditableListener(() => {\n      resetCanShowPlaceholder();\n    }));\n  }, [editor]);\n  return canShowPlaceholder;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst ContentEditable = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(ContentEditableImpl);\nfunction ContentEditableImpl(props, ref) {\n  const {\n    placeholder,\n    ...rest\n  } = props;\n  const [editor] = (0,_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_4__.useLexicalComposerContext)();\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, {\n    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ContentEditableElement, {\n      editor: editor,\n      ...rest,\n      ref: ref\n    }), placeholder != null && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Placeholder, {\n      editor: editor,\n      content: placeholder\n    })]\n  });\n}\nfunction Placeholder({\n  content,\n  editor\n}) {\n  const showPlaceholder = useCanShowPlaceholder(editor);\n  const [isEditable, setEditable] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(editor.isEditable());\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n    setEditable(editor.isEditable());\n    return editor.registerEditableListener(currentIsEditable => {\n      setEditable(currentIsEditable);\n    });\n  }, [editor]);\n  if (!showPlaceholder) {\n    return null;\n  }\n  let placeholder = null;\n  if (typeof content === 'function') {\n    placeholder = content(isEditable);\n  } else if (content !== null) {\n    placeholder = content;\n  }\n  if (placeholder === null) {\n    return null;\n  }\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", {\n    \"aria-hidden\": true,\n    children: placeholder\n  });\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ29udGVudEVkaXRhYmxlLmRldi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWtGO0FBQ2E7QUFDdkM7QUFDQztBQUNWOztBQUUvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGtEQUFlLEdBQUcsNENBQVM7O0FBRXJFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxvQ0FBb0MsK0NBQVE7QUFDNUMsb0JBQW9CLGtEQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0gscUJBQXFCLDhDQUFPO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxzQkFBc0Isc0RBQUc7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBSTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQUk7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsNENBQTRDLGlEQUFVOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlFQUFpRSx1RUFBd0I7QUFDekY7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELCtDQUFRO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNkRBQWE7QUFDeEI7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDLGlEQUFVO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLG1CQUFtQixnR0FBeUI7QUFDNUMsc0JBQXNCLHVEQUFJLENBQUMsdURBQVE7QUFDbkMsNEJBQTRCLHNEQUFHO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLEtBQUssdUNBQXVDLHNEQUFHO0FBQy9DO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esb0NBQW9DLCtDQUFRO0FBQzVDLEVBQUUsc0RBQWU7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzREFBRztBQUN6QjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUUyQiIsInNvdXJjZXMiOlsiL1VzZXJzL2xlaS9ob21lL3VuZGVyZy90aGVhdHJlL3kzL3NlZ3AvbWlsa3VwL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ29udGVudEVkaXRhYmxlLmRldi5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5pbXBvcnQgeyB1c2VMZXhpY2FsQ29tcG9zZXJDb250ZXh0IH0gZnJvbSAnQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbXBvc2VyQ29udGV4dCc7XG5pbXBvcnQgeyB1c2VMYXlvdXRFZmZlY3QsIHVzZUVmZmVjdCwgZm9yd2FyZFJlZiwgdXNlU3RhdGUsIHVzZUNhbGxiYWNrLCB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsganN4LCBqc3hzLCBGcmFnbWVudCB9IGZyb20gJ3JlYWN0L2pzeC1ydW50aW1lJztcbmltcG9ydCB7ICRjYW5TaG93UGxhY2Vob2xkZXJDdXJyeSB9IGZyb20gJ0BsZXhpY2FsL3RleHQnO1xuaW1wb3J0IHsgbWVyZ2VSZWdpc3RlciB9IGZyb20gJ0BsZXhpY2FsL3V0aWxzJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBDQU5fVVNFX0RPTSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuXG4vLyBUaGlzIHdvcmthcm91bmQgaXMgbm8gbG9uZ2VyIG5lY2Vzc2FyeSBpbiBSZWFjdCAxOSxcbi8vIGJ1dCB3ZSBjdXJyZW50bHkgc3VwcG9ydCBSZWFjdCA+PTE3Lnhcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzI2Mzk1XG5jb25zdCB1c2VMYXlvdXRFZmZlY3RJbXBsID0gQ0FOX1VTRV9ET00gPyB1c2VMYXlvdXRFZmZlY3QgOiB1c2VFZmZlY3Q7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbi8vIFNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL2dyZWdiZXJnZS9yZWFjdC1tZXJnZS1yZWZzL2Jsb2IvbWFpbi9zcmMvaW5kZXgudHN4XG5cbmZ1bmN0aW9uIG1lcmdlUmVmcyguLi5yZWZzKSB7XG4gIHJldHVybiB2YWx1ZSA9PiB7XG4gICAgcmVmcy5mb3JFYWNoKHJlZiA9PiB7XG4gICAgICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZWYodmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChyZWYgIT0gbnVsbCkge1xuICAgICAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uIENvbnRlbnRFZGl0YWJsZUVsZW1lbnRJbXBsKHtcbiAgZWRpdG9yLFxuICBhcmlhQWN0aXZlRGVzY2VuZGFudCxcbiAgYXJpYUF1dG9Db21wbGV0ZSxcbiAgYXJpYUNvbnRyb2xzLFxuICBhcmlhRGVzY3JpYmVkQnksXG4gIGFyaWFFcnJvck1lc3NhZ2UsXG4gIGFyaWFFeHBhbmRlZCxcbiAgYXJpYUludmFsaWQsXG4gIGFyaWFMYWJlbCxcbiAgYXJpYUxhYmVsbGVkQnksXG4gIGFyaWFNdWx0aWxpbmUsXG4gIGFyaWFPd25zLFxuICBhcmlhUmVxdWlyZWQsXG4gIGF1dG9DYXBpdGFsaXplLFxuICBjbGFzc05hbWUsXG4gIGlkLFxuICByb2xlID0gJ3RleHRib3gnLFxuICBzcGVsbENoZWNrID0gdHJ1ZSxcbiAgc3R5bGUsXG4gIHRhYkluZGV4LFxuICAnZGF0YS10ZXN0aWQnOiB0ZXN0aWQsXG4gIC4uLnJlc3Rcbn0sIHJlZikge1xuICBjb25zdCBbaXNFZGl0YWJsZSwgc2V0RWRpdGFibGVdID0gdXNlU3RhdGUoZWRpdG9yLmlzRWRpdGFibGUoKSk7XG4gIGNvbnN0IGhhbmRsZVJlZiA9IHVzZUNhbGxiYWNrKHJvb3RFbGVtZW50ID0+IHtcbiAgICAvLyBkZWZhdWx0VmlldyBpcyByZXF1aXJlZCBmb3IgYSByb290IGVsZW1lbnQuXG4gICAgLy8gSW4gbXVsdGktd2luZG93IHNldHVwcywgdGhlIGRlZmF1bHRWaWV3IG1heSBub3QgZXhpc3QgYXQgY2VydGFpbiBwb2ludHMuXG4gICAgaWYgKHJvb3RFbGVtZW50ICYmIHJvb3RFbGVtZW50Lm93bmVyRG9jdW1lbnQgJiYgcm9vdEVsZW1lbnQub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldykge1xuICAgICAgZWRpdG9yLnNldFJvb3RFbGVtZW50KHJvb3RFbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWRpdG9yLnNldFJvb3RFbGVtZW50KG51bGwpO1xuICAgIH1cbiAgfSwgW2VkaXRvcl0pO1xuICBjb25zdCBtZXJnZWRSZWZzID0gdXNlTWVtbygoKSA9PiBtZXJnZVJlZnMocmVmLCBoYW5kbGVSZWYpLCBbaGFuZGxlUmVmLCByZWZdKTtcbiAgdXNlTGF5b3V0RWZmZWN0SW1wbCgoKSA9PiB7XG4gICAgc2V0RWRpdGFibGUoZWRpdG9yLmlzRWRpdGFibGUoKSk7XG4gICAgcmV0dXJuIGVkaXRvci5yZWdpc3RlckVkaXRhYmxlTGlzdGVuZXIoY3VycmVudElzRWRpdGFibGUgPT4ge1xuICAgICAgc2V0RWRpdGFibGUoY3VycmVudElzRWRpdGFibGUpO1xuICAgIH0pO1xuICB9LCBbZWRpdG9yXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4KFwiZGl2XCIsIHtcbiAgICBcImFyaWEtYWN0aXZlZGVzY2VuZGFudFwiOiBpc0VkaXRhYmxlID8gYXJpYUFjdGl2ZURlc2NlbmRhbnQgOiB1bmRlZmluZWQsXG4gICAgXCJhcmlhLWF1dG9jb21wbGV0ZVwiOiBpc0VkaXRhYmxlID8gYXJpYUF1dG9Db21wbGV0ZSA6ICdub25lJyxcbiAgICBcImFyaWEtY29udHJvbHNcIjogaXNFZGl0YWJsZSA/IGFyaWFDb250cm9scyA6IHVuZGVmaW5lZCxcbiAgICBcImFyaWEtZGVzY3JpYmVkYnlcIjogYXJpYURlc2NyaWJlZEJ5XG4gICAgLy8gZm9yIGNvbXBhdCwgb25seSBvdmVycmlkZSBhcmlhLWVycm9ybWVzc2FnZSBpZiBhcmlhRXJyb3JNZXNzYWdlIGlzIGRlZmluZWRcbiAgICAsXG4gICAgLi4uKGFyaWFFcnJvck1lc3NhZ2UgIT0gbnVsbCA/IHtcbiAgICAgICdhcmlhLWVycm9ybWVzc2FnZSc6IGFyaWFFcnJvck1lc3NhZ2VcbiAgICB9IDoge30pLFxuICAgIFwiYXJpYS1leHBhbmRlZFwiOiBpc0VkaXRhYmxlICYmIHJvbGUgPT09ICdjb21ib2JveCcgPyAhIWFyaWFFeHBhbmRlZCA6IHVuZGVmaW5lZFxuICAgIC8vIGZvciBjb21wYXQsIG9ubHkgb3ZlcnJpZGUgYXJpYS1pbnZhbGlkIGlmIGFyaWFJbnZhbGlkIGlzIGRlZmluZWRcbiAgICAsXG4gICAgLi4uKGFyaWFJbnZhbGlkICE9IG51bGwgPyB7XG4gICAgICAnYXJpYS1pbnZhbGlkJzogYXJpYUludmFsaWRcbiAgICB9IDoge30pLFxuICAgIFwiYXJpYS1sYWJlbFwiOiBhcmlhTGFiZWwsXG4gICAgXCJhcmlhLWxhYmVsbGVkYnlcIjogYXJpYUxhYmVsbGVkQnksXG4gICAgXCJhcmlhLW11bHRpbGluZVwiOiBhcmlhTXVsdGlsaW5lLFxuICAgIFwiYXJpYS1vd25zXCI6IGlzRWRpdGFibGUgPyBhcmlhT3ducyA6IHVuZGVmaW5lZCxcbiAgICBcImFyaWEtcmVhZG9ubHlcIjogaXNFZGl0YWJsZSA/IHVuZGVmaW5lZCA6IHRydWUsXG4gICAgXCJhcmlhLXJlcXVpcmVkXCI6IGFyaWFSZXF1aXJlZCxcbiAgICBhdXRvQ2FwaXRhbGl6ZTogYXV0b0NhcGl0YWxpemUsXG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgY29udGVudEVkaXRhYmxlOiBpc0VkaXRhYmxlLFxuICAgIFwiZGF0YS10ZXN0aWRcIjogdGVzdGlkLFxuICAgIGlkOiBpZCxcbiAgICByZWY6IG1lcmdlZFJlZnMsXG4gICAgcm9sZTogaXNFZGl0YWJsZSA/IHJvbGUgOiB1bmRlZmluZWQsXG4gICAgc3BlbGxDaGVjazogc3BlbGxDaGVjayxcbiAgICBzdHlsZTogc3R5bGUsXG4gICAgdGFiSW5kZXg6IHRhYkluZGV4LFxuICAgIC4uLnJlc3RcbiAgfSk7XG59XG5jb25zdCBDb250ZW50RWRpdGFibGVFbGVtZW50ID0gLyojX19QVVJFX18qL2ZvcndhcmRSZWYoQ29udGVudEVkaXRhYmxlRWxlbWVudEltcGwpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uIGNhblNob3dQbGFjZWhvbGRlckZyb21DdXJyZW50RWRpdG9yU3RhdGUoZWRpdG9yKSB7XG4gIGNvbnN0IGN1cnJlbnRDYW5TaG93UGxhY2Vob2xkZXIgPSBlZGl0b3IuZ2V0RWRpdG9yU3RhdGUoKS5yZWFkKCRjYW5TaG93UGxhY2Vob2xkZXJDdXJyeShlZGl0b3IuaXNDb21wb3NpbmcoKSkpO1xuICByZXR1cm4gY3VycmVudENhblNob3dQbGFjZWhvbGRlcjtcbn1cbmZ1bmN0aW9uIHVzZUNhblNob3dQbGFjZWhvbGRlcihlZGl0b3IpIHtcbiAgY29uc3QgW2NhblNob3dQbGFjZWhvbGRlciwgc2V0Q2FuU2hvd1BsYWNlaG9sZGVyXSA9IHVzZVN0YXRlKCgpID0+IGNhblNob3dQbGFjZWhvbGRlckZyb21DdXJyZW50RWRpdG9yU3RhdGUoZWRpdG9yKSk7XG4gIHVzZUxheW91dEVmZmVjdEltcGwoKCkgPT4ge1xuICAgIGZ1bmN0aW9uIHJlc2V0Q2FuU2hvd1BsYWNlaG9sZGVyKCkge1xuICAgICAgY29uc3QgY3VycmVudENhblNob3dQbGFjZWhvbGRlciA9IGNhblNob3dQbGFjZWhvbGRlckZyb21DdXJyZW50RWRpdG9yU3RhdGUoZWRpdG9yKTtcbiAgICAgIHNldENhblNob3dQbGFjZWhvbGRlcihjdXJyZW50Q2FuU2hvd1BsYWNlaG9sZGVyKTtcbiAgICB9XG4gICAgcmVzZXRDYW5TaG93UGxhY2Vob2xkZXIoKTtcbiAgICByZXR1cm4gbWVyZ2VSZWdpc3RlcihlZGl0b3IucmVnaXN0ZXJVcGRhdGVMaXN0ZW5lcigoKSA9PiB7XG4gICAgICByZXNldENhblNob3dQbGFjZWhvbGRlcigpO1xuICAgIH0pLCBlZGl0b3IucmVnaXN0ZXJFZGl0YWJsZUxpc3RlbmVyKCgpID0+IHtcbiAgICAgIHJlc2V0Q2FuU2hvd1BsYWNlaG9sZGVyKCk7XG4gICAgfSkpO1xuICB9LCBbZWRpdG9yXSk7XG4gIHJldHVybiBjYW5TaG93UGxhY2Vob2xkZXI7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuY29uc3QgQ29udGVudEVkaXRhYmxlID0gLyojX19QVVJFX18qL2ZvcndhcmRSZWYoQ29udGVudEVkaXRhYmxlSW1wbCk7XG5mdW5jdGlvbiBDb250ZW50RWRpdGFibGVJbXBsKHByb3BzLCByZWYpIHtcbiAgY29uc3Qge1xuICAgIHBsYWNlaG9sZGVyLFxuICAgIC4uLnJlc3RcbiAgfSA9IHByb3BzO1xuICBjb25zdCBbZWRpdG9yXSA9IHVzZUxleGljYWxDb21wb3NlckNvbnRleHQoKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3hzKEZyYWdtZW50LCB7XG4gICAgY2hpbGRyZW46IFsvKiNfX1BVUkVfXyovanN4KENvbnRlbnRFZGl0YWJsZUVsZW1lbnQsIHtcbiAgICAgIGVkaXRvcjogZWRpdG9yLFxuICAgICAgLi4ucmVzdCxcbiAgICAgIHJlZjogcmVmXG4gICAgfSksIHBsYWNlaG9sZGVyICE9IG51bGwgJiYgLyojX19QVVJFX18qL2pzeChQbGFjZWhvbGRlciwge1xuICAgICAgZWRpdG9yOiBlZGl0b3IsXG4gICAgICBjb250ZW50OiBwbGFjZWhvbGRlclxuICAgIH0pXVxuICB9KTtcbn1cbmZ1bmN0aW9uIFBsYWNlaG9sZGVyKHtcbiAgY29udGVudCxcbiAgZWRpdG9yXG59KSB7XG4gIGNvbnN0IHNob3dQbGFjZWhvbGRlciA9IHVzZUNhblNob3dQbGFjZWhvbGRlcihlZGl0b3IpO1xuICBjb25zdCBbaXNFZGl0YWJsZSwgc2V0RWRpdGFibGVdID0gdXNlU3RhdGUoZWRpdG9yLmlzRWRpdGFibGUoKSk7XG4gIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgc2V0RWRpdGFibGUoZWRpdG9yLmlzRWRpdGFibGUoKSk7XG4gICAgcmV0dXJuIGVkaXRvci5yZWdpc3RlckVkaXRhYmxlTGlzdGVuZXIoY3VycmVudElzRWRpdGFibGUgPT4ge1xuICAgICAgc2V0RWRpdGFibGUoY3VycmVudElzRWRpdGFibGUpO1xuICAgIH0pO1xuICB9LCBbZWRpdG9yXSk7XG4gIGlmICghc2hvd1BsYWNlaG9sZGVyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgbGV0IHBsYWNlaG9sZGVyID0gbnVsbDtcbiAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcGxhY2Vob2xkZXIgPSBjb250ZW50KGlzRWRpdGFibGUpO1xuICB9IGVsc2UgaWYgKGNvbnRlbnQgIT09IG51bGwpIHtcbiAgICBwbGFjZWhvbGRlciA9IGNvbnRlbnQ7XG4gIH1cbiAgaWYgKHBsYWNlaG9sZGVyID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goXCJkaXZcIiwge1xuICAgIFwiYXJpYS1oaWRkZW5cIjogdHJ1ZSxcbiAgICBjaGlsZHJlbjogcGxhY2Vob2xkZXJcbiAgfSk7XG59XG5cbmV4cG9ydCB7IENvbnRlbnRFZGl0YWJsZSB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/react/LexicalContentEditable.dev.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/react/LexicalErrorBoundary.dev.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalErrorBoundary.dev.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LexicalErrorBoundary: () => (/* binding */ LexicalErrorBoundary),\n/* harmony export */   \"default\": () => (/* binding */ LexicalErrorBoundary)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  _setPrototypeOf(subClass, superClass);\n}\n\nvar changedArray = function changedArray(a, b) {\n  if (a === void 0) {\n    a = [];\n  }\n\n  if (b === void 0) {\n    b = [];\n  }\n\n  return a.length !== b.length || a.some(function (item, index) {\n    return !Object.is(item, b[index]);\n  });\n};\n\nvar initialState = {\n  error: null\n};\n\nvar ErrorBoundary = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(ErrorBoundary, _React$Component);\n\n  function ErrorBoundary() {\n    var _this;\n\n    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {\n      _args[_key] = arguments[_key];\n    }\n\n    _this = _React$Component.call.apply(_React$Component, [this].concat(_args)) || this;\n    _this.state = initialState;\n\n    _this.resetErrorBoundary = function () {\n      var _this$props;\n\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      _this.props.onReset == null ? void 0 : (_this$props = _this.props).onReset.apply(_this$props, args);\n\n      _this.reset();\n    };\n\n    return _this;\n  }\n\n  ErrorBoundary.getDerivedStateFromError = function getDerivedStateFromError(error) {\n    return {\n      error: error\n    };\n  };\n\n  var _proto = ErrorBoundary.prototype;\n\n  _proto.reset = function reset() {\n    this.setState(initialState);\n  };\n\n  _proto.componentDidCatch = function componentDidCatch(error, info) {\n    var _this$props$onError, _this$props2;\n\n    (_this$props$onError = (_this$props2 = this.props).onError) == null ? void 0 : _this$props$onError.call(_this$props2, error, info);\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {\n    var error = this.state.error;\n    var resetKeys = this.props.resetKeys; // There's an edge case where if the thing that triggered the error\n    // happens to *also* be in the resetKeys array, we'd end up resetting\n    // the error boundary immediately. This would likely trigger a second\n    // error to be thrown.\n    // So we make sure that we don't check the resetKeys on the first call\n    // of cDU after the error is set\n\n    if (error !== null && prevState.error !== null && changedArray(prevProps.resetKeys, resetKeys)) {\n      var _this$props$onResetKe, _this$props3;\n\n      (_this$props$onResetKe = (_this$props3 = this.props).onResetKeysChange) == null ? void 0 : _this$props$onResetKe.call(_this$props3, prevProps.resetKeys, resetKeys);\n      this.reset();\n    }\n  };\n\n  _proto.render = function render() {\n    var error = this.state.error;\n    var _this$props4 = this.props,\n        fallbackRender = _this$props4.fallbackRender,\n        FallbackComponent = _this$props4.FallbackComponent,\n        fallback = _this$props4.fallback;\n\n    if (error !== null) {\n      var _props = {\n        error: error,\n        resetErrorBoundary: this.resetErrorBoundary\n      };\n\n      if ( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(fallback)) {\n        return fallback;\n      } else if (typeof fallbackRender === 'function') {\n        return fallbackRender(_props);\n      } else if (FallbackComponent) {\n        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(FallbackComponent, _props);\n      } else {\n        throw new Error('react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop');\n      }\n    }\n\n    return this.props.children;\n  };\n\n  return ErrorBoundary;\n}(react__WEBPACK_IMPORTED_MODULE_0__.Component);\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction LexicalErrorBoundary({\n  children,\n  onError\n}) {\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ErrorBoundary, {\n    fallback: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", {\n      style: {\n        border: '1px solid #f00',\n        color: '#f00',\n        padding: '8px'\n      },\n      children: \"An error was thrown.\"\n    }),\n    onError: onError,\n    children: children\n  });\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsRXJyb3JCb3VuZGFyeS5kZXYubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFK0I7QUFDUzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlFQUF5RSxhQUFhO0FBQ3RGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDZFQUE2RSxlQUFlO0FBQzVGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsaURBQW9CO0FBQzVDO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSLDRCQUE0QixnREFBbUI7QUFDL0MsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQyxDQUFDLDRDQUFlOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsc0JBQXNCLHNEQUFHO0FBQ3pCLDJCQUEyQixzREFBRztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVpRSIsInNvdXJjZXMiOlsiL1VzZXJzL2xlaS9ob21lL3VuZGVyZy90aGVhdHJlL3kzL3NlZ3AvbWlsa3VwL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsRXJyb3JCb3VuZGFyeS5kZXYubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsganN4IH0gZnJvbSAncmVhY3QvanN4LXJ1bnRpbWUnO1xuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcbiAgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxudmFyIGNoYW5nZWRBcnJheSA9IGZ1bmN0aW9uIGNoYW5nZWRBcnJheShhLCBiKSB7XG4gIGlmIChhID09PSB2b2lkIDApIHtcbiAgICBhID0gW107XG4gIH1cblxuICBpZiAoYiA9PT0gdm9pZCAwKSB7XG4gICAgYiA9IFtdO1xuICB9XG5cbiAgcmV0dXJuIGEubGVuZ3RoICE9PSBiLmxlbmd0aCB8fCBhLnNvbWUoZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgcmV0dXJuICFPYmplY3QuaXMoaXRlbSwgYltpbmRleF0pO1xuICB9KTtcbn07XG5cbnZhciBpbml0aWFsU3RhdGUgPSB7XG4gIGVycm9yOiBudWxsXG59O1xuXG52YXIgRXJyb3JCb3VuZGFyeSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShFcnJvckJvdW5kYXJ5LCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBFcnJvckJvdW5kYXJ5KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBfYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIF9hcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIF90aGlzID0gX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoX2FyZ3MpKSB8fCB0aGlzO1xuICAgIF90aGlzLnN0YXRlID0gaW5pdGlhbFN0YXRlO1xuXG4gICAgX3RoaXMucmVzZXRFcnJvckJvdW5kYXJ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF90aGlzJHByb3BzO1xuXG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5wcm9wcy5vblJlc2V0ID09IG51bGwgPyB2b2lkIDAgOiAoX3RoaXMkcHJvcHMgPSBfdGhpcy5wcm9wcykub25SZXNldC5hcHBseShfdGhpcyRwcm9wcywgYXJncyk7XG5cbiAgICAgIF90aGlzLnJlc2V0KCk7XG4gICAgfTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIEVycm9yQm91bmRhcnkuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yID0gZnVuY3Rpb24gZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVycm9yOiBlcnJvclxuICAgIH07XG4gIH07XG5cbiAgdmFyIF9wcm90byA9IEVycm9yQm91bmRhcnkucHJvdG90eXBlO1xuXG4gIF9wcm90by5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIHRoaXMuc2V0U3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcG9uZW50RGlkQ2F0Y2ggPSBmdW5jdGlvbiBjb21wb25lbnREaWRDYXRjaChlcnJvciwgaW5mbykge1xuICAgIHZhciBfdGhpcyRwcm9wcyRvbkVycm9yLCBfdGhpcyRwcm9wczI7XG5cbiAgICAoX3RoaXMkcHJvcHMkb25FcnJvciA9IChfdGhpcyRwcm9wczIgPSB0aGlzLnByb3BzKS5vbkVycm9yKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkcHJvcHMkb25FcnJvci5jYWxsKF90aGlzJHByb3BzMiwgZXJyb3IsIGluZm8pO1xuICB9O1xuXG4gIF9wcm90by5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUpIHtcbiAgICB2YXIgZXJyb3IgPSB0aGlzLnN0YXRlLmVycm9yO1xuICAgIHZhciByZXNldEtleXMgPSB0aGlzLnByb3BzLnJlc2V0S2V5czsgLy8gVGhlcmUncyBhbiBlZGdlIGNhc2Ugd2hlcmUgaWYgdGhlIHRoaW5nIHRoYXQgdHJpZ2dlcmVkIHRoZSBlcnJvclxuICAgIC8vIGhhcHBlbnMgdG8gKmFsc28qIGJlIGluIHRoZSByZXNldEtleXMgYXJyYXksIHdlJ2QgZW5kIHVwIHJlc2V0dGluZ1xuICAgIC8vIHRoZSBlcnJvciBib3VuZGFyeSBpbW1lZGlhdGVseS4gVGhpcyB3b3VsZCBsaWtlbHkgdHJpZ2dlciBhIHNlY29uZFxuICAgIC8vIGVycm9yIHRvIGJlIHRocm93bi5cbiAgICAvLyBTbyB3ZSBtYWtlIHN1cmUgdGhhdCB3ZSBkb24ndCBjaGVjayB0aGUgcmVzZXRLZXlzIG9uIHRoZSBmaXJzdCBjYWxsXG4gICAgLy8gb2YgY0RVIGFmdGVyIHRoZSBlcnJvciBpcyBzZXRcblxuICAgIGlmIChlcnJvciAhPT0gbnVsbCAmJiBwcmV2U3RhdGUuZXJyb3IgIT09IG51bGwgJiYgY2hhbmdlZEFycmF5KHByZXZQcm9wcy5yZXNldEtleXMsIHJlc2V0S2V5cykpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wcyRvblJlc2V0S2UsIF90aGlzJHByb3BzMztcblxuICAgICAgKF90aGlzJHByb3BzJG9uUmVzZXRLZSA9IChfdGhpcyRwcm9wczMgPSB0aGlzLnByb3BzKS5vblJlc2V0S2V5c0NoYW5nZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJHByb3BzJG9uUmVzZXRLZS5jYWxsKF90aGlzJHByb3BzMywgcHJldlByb3BzLnJlc2V0S2V5cywgcmVzZXRLZXlzKTtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgZXJyb3IgPSB0aGlzLnN0YXRlLmVycm9yO1xuICAgIHZhciBfdGhpcyRwcm9wczQgPSB0aGlzLnByb3BzLFxuICAgICAgICBmYWxsYmFja1JlbmRlciA9IF90aGlzJHByb3BzNC5mYWxsYmFja1JlbmRlcixcbiAgICAgICAgRmFsbGJhY2tDb21wb25lbnQgPSBfdGhpcyRwcm9wczQuRmFsbGJhY2tDb21wb25lbnQsXG4gICAgICAgIGZhbGxiYWNrID0gX3RoaXMkcHJvcHM0LmZhbGxiYWNrO1xuXG4gICAgaWYgKGVycm9yICE9PSBudWxsKSB7XG4gICAgICB2YXIgX3Byb3BzID0ge1xuICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgIHJlc2V0RXJyb3JCb3VuZGFyeTogdGhpcy5yZXNldEVycm9yQm91bmRhcnlcbiAgICAgIH07XG5cbiAgICAgIGlmICggLyojX19QVVJFX18qL1JlYWN0LmlzVmFsaWRFbGVtZW50KGZhbGxiYWNrKSkge1xuICAgICAgICByZXR1cm4gZmFsbGJhY2s7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmYWxsYmFja1JlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gZmFsbGJhY2tSZW5kZXIoX3Byb3BzKTtcbiAgICAgIH0gZWxzZSBpZiAoRmFsbGJhY2tDb21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZhbGxiYWNrQ29tcG9uZW50LCBfcHJvcHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWFjdC1lcnJvci1ib3VuZGFyeSByZXF1aXJlcyBlaXRoZXIgYSBmYWxsYmFjaywgZmFsbGJhY2tSZW5kZXIsIG9yIEZhbGxiYWNrQ29tcG9uZW50IHByb3AnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgfTtcblxuICByZXR1cm4gRXJyb3JCb3VuZGFyeTtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiBMZXhpY2FsRXJyb3JCb3VuZGFyeSh7XG4gIGNoaWxkcmVuLFxuICBvbkVycm9yXG59KSB7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4KEVycm9yQm91bmRhcnksIHtcbiAgICBmYWxsYmFjazogLyojX19QVVJFX18qL2pzeChcImRpdlwiLCB7XG4gICAgICBzdHlsZToge1xuICAgICAgICBib3JkZXI6ICcxcHggc29saWQgI2YwMCcsXG4gICAgICAgIGNvbG9yOiAnI2YwMCcsXG4gICAgICAgIHBhZGRpbmc6ICc4cHgnXG4gICAgICB9LFxuICAgICAgY2hpbGRyZW46IFwiQW4gZXJyb3Igd2FzIHRocm93bi5cIlxuICAgIH0pLFxuICAgIG9uRXJyb3I6IG9uRXJyb3IsXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gIH0pO1xufVxuXG5leHBvcnQgeyBMZXhpY2FsRXJyb3JCb3VuZGFyeSwgTGV4aWNhbEVycm9yQm91bmRhcnkgYXMgZGVmYXVsdCB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/react/LexicalErrorBoundary.dev.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/react/LexicalHistoryPlugin.dev.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalHistoryPlugin.dev.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HistoryPlugin: () => (/* binding */ HistoryPlugin),\n/* harmony export */   createEmptyHistoryState: () => (/* reexport safe */ _lexical_history__WEBPACK_IMPORTED_MODULE_0__.createEmptyHistoryState)\n/* harmony export */ });\n/* harmony import */ var _lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(app-pages-browser)/./node_modules/@lexical/react/LexicalComposerContext.dev.mjs\");\n/* harmony import */ var _lexical_history__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lexical/history */ \"(app-pages-browser)/./node_modules/@lexical/history/LexicalHistory.dev.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction useHistory(editor, externalHistoryState, delay = 1000) {\n  const historyState = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => externalHistoryState || (0,_lexical_history__WEBPACK_IMPORTED_MODULE_0__.createEmptyHistoryState)(), [externalHistoryState]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    return (0,_lexical_history__WEBPACK_IMPORTED_MODULE_0__.registerHistory)(editor, historyState, delay);\n  }, [delay, editor, historyState]);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction HistoryPlugin({\n  delay,\n  externalHistoryState\n}) {\n  const [editor] = (0,_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_2__.useLexicalComposerContext)();\n  useHistory(editor, externalHistoryState, delay);\n  return null;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsSGlzdG9yeVBsdWdpbi5kZXYubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWtGO0FBQ047QUFDakI7QUFDaEI7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLDhDQUFPLCtCQUErQix5RUFBdUI7QUFDcEYsRUFBRSxnREFBUztBQUNYLFdBQVcsaUVBQWU7QUFDMUIsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxtQkFBbUIsZ0dBQXlCO0FBQzVDO0FBQ0E7QUFDQTs7QUFFeUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9sZWkvaG9tZS91bmRlcmcvdGhlYXRyZS95My9zZWdwL21pbGt1cC9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbEhpc3RvcnlQbHVnaW4uZGV2Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmltcG9ydCB7IHVzZUxleGljYWxDb21wb3NlckNvbnRleHQgfSBmcm9tICdAbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ29tcG9zZXJDb250ZXh0JztcbmltcG9ydCB7IGNyZWF0ZUVtcHR5SGlzdG9yeVN0YXRlLCByZWdpc3Rlckhpc3RvcnkgfSBmcm9tICdAbGV4aWNhbC9oaXN0b3J5JztcbmV4cG9ydCB7IGNyZWF0ZUVtcHR5SGlzdG9yeVN0YXRlIH0gZnJvbSAnQGxleGljYWwvaGlzdG9yeSc7XG5pbXBvcnQgeyB1c2VNZW1vLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gdXNlSGlzdG9yeShlZGl0b3IsIGV4dGVybmFsSGlzdG9yeVN0YXRlLCBkZWxheSA9IDEwMDApIHtcbiAgY29uc3QgaGlzdG9yeVN0YXRlID0gdXNlTWVtbygoKSA9PiBleHRlcm5hbEhpc3RvcnlTdGF0ZSB8fCBjcmVhdGVFbXB0eUhpc3RvcnlTdGF0ZSgpLCBbZXh0ZXJuYWxIaXN0b3J5U3RhdGVdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gcmVnaXN0ZXJIaXN0b3J5KGVkaXRvciwgaGlzdG9yeVN0YXRlLCBkZWxheSk7XG4gIH0sIFtkZWxheSwgZWRpdG9yLCBoaXN0b3J5U3RhdGVdKTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiBIaXN0b3J5UGx1Z2luKHtcbiAgZGVsYXksXG4gIGV4dGVybmFsSGlzdG9yeVN0YXRlXG59KSB7XG4gIGNvbnN0IFtlZGl0b3JdID0gdXNlTGV4aWNhbENvbXBvc2VyQ29udGV4dCgpO1xuICB1c2VIaXN0b3J5KGVkaXRvciwgZXh0ZXJuYWxIaXN0b3J5U3RhdGUsIGRlbGF5KTtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCB7IEhpc3RvcnlQbHVnaW4gfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/react/LexicalHistoryPlugin.dev.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/react/LexicalPlainTextPlugin.dev.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalPlainTextPlugin.dev.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PlainTextPlugin: () => (/* binding */ PlainTextPlugin)\n/* harmony export */ });\n/* harmony import */ var _lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(app-pages-browser)/./node_modules/@lexical/react/LexicalComposerContext.dev.mjs\");\n/* harmony import */ var _lexical_react_useLexicalEditable__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @lexical/react/useLexicalEditable */ \"(app-pages-browser)/./node_modules/@lexical/react/useLexicalEditable.dev.mjs\");\n/* harmony import */ var _lexical_text__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lexical/text */ \"(app-pages-browser)/./node_modules/@lexical/text/LexicalText.dev.mjs\");\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lexical/utils */ \"(app-pages-browser)/./node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\n/* harmony import */ var _lexical_dragon__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lexical/dragon */ \"(app-pages-browser)/./node_modules/@lexical/dragon/LexicalDragon.dev.mjs\");\n/* harmony import */ var _lexical_plain_text__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lexical/plain-text */ \"(app-pages-browser)/./node_modules/@lexical/plain-text/LexicalPlainText.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// This workaround is no longer necessary in React 19,\n// but we currently support React >=17.x\n// https://github.com/facebook/react/pull/26395\nconst useLayoutEffectImpl = CAN_USE_DOM ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction canShowPlaceholderFromCurrentEditorState(editor) {\n  const currentCanShowPlaceholder = editor.getEditorState().read((0,_lexical_text__WEBPACK_IMPORTED_MODULE_3__.$canShowPlaceholderCurry)(editor.isComposing()));\n  return currentCanShowPlaceholder;\n}\nfunction useCanShowPlaceholder(editor) {\n  const [canShowPlaceholder, setCanShowPlaceholder] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => canShowPlaceholderFromCurrentEditorState(editor));\n  useLayoutEffectImpl(() => {\n    function resetCanShowPlaceholder() {\n      const currentCanShowPlaceholder = canShowPlaceholderFromCurrentEditorState(editor);\n      setCanShowPlaceholder(currentCanShowPlaceholder);\n    }\n    resetCanShowPlaceholder();\n    return (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_4__.mergeRegister)(editor.registerUpdateListener(() => {\n      resetCanShowPlaceholder();\n    }), editor.registerEditableListener(() => {\n      resetCanShowPlaceholder();\n    }));\n  }, [editor]);\n  return canShowPlaceholder;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction useDecorators(editor, ErrorBoundary) {\n  const [decorators, setDecorators] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => editor.getDecorators());\n\n  // Subscribe to changes\n  useLayoutEffectImpl(() => {\n    return editor.registerDecoratorListener(nextDecorators => {\n      (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(() => {\n        setDecorators(nextDecorators);\n      });\n    });\n  }, [editor]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    // If the content editable mounts before the subscription is added, then\n    // nothing will be rendered on initial pass. We can get around that by\n    // ensuring that we set the value.\n    setDecorators(editor.getDecorators());\n  }, [editor]);\n\n  // Return decorators defined as React Portals\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    const decoratedPortals = [];\n    const decoratorKeys = Object.keys(decorators);\n    for (let i = 0; i < decoratorKeys.length; i++) {\n      const nodeKey = decoratorKeys[i];\n      const reactDecorator = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ErrorBoundary, {\n        onError: e => editor._onError(e),\n        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, {\n          fallback: null,\n          children: decorators[nodeKey]\n        })\n      });\n      const element = editor.getElementByKey(nodeKey);\n      if (element !== null) {\n        decoratedPortals.push(/*#__PURE__*/(0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(reactDecorator, element, nodeKey));\n      }\n    }\n    return decoratedPortals;\n  }, [ErrorBoundary, decorators, editor]);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction usePlainTextSetup(editor) {\n  useLayoutEffectImpl(() => {\n    return (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_4__.mergeRegister)((0,_lexical_plain_text__WEBPACK_IMPORTED_MODULE_5__.registerPlainText)(editor), (0,_lexical_dragon__WEBPACK_IMPORTED_MODULE_6__.registerDragonSupport)(editor));\n\n    // We only do this for init\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [editor]);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction PlainTextPlugin({\n  contentEditable,\n  // TODO Remove. This property is now part of ContentEditable\n  placeholder = null,\n  ErrorBoundary\n}) {\n  const [editor] = (0,_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_7__.useLexicalComposerContext)();\n  const decorators = useDecorators(editor, ErrorBoundary);\n  usePlainTextSetup(editor);\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, {\n    children: [contentEditable, /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Placeholder, {\n      content: placeholder\n    }), decorators]\n  });\n}\n\n// TODO Remove\nfunction Placeholder({\n  content\n}) {\n  const [editor] = (0,_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_7__.useLexicalComposerContext)();\n  const showPlaceholder = useCanShowPlaceholder(editor);\n  const editable = (0,_lexical_react_useLexicalEditable__WEBPACK_IMPORTED_MODULE_8__.useLexicalEditable)();\n  if (!showPlaceholder) {\n    return null;\n  }\n  if (typeof content === 'function') {\n    return content(editable);\n  } else {\n    return content;\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsUGxhaW5UZXh0UGx1Z2luLmRldi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVrRjtBQUNYO0FBQ2Q7QUFDVjtBQUNpQztBQUM1QjtBQUNJO0FBQ0E7QUFDQTs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxrREFBZSxHQUFHLDRDQUFTOztBQUVyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlFQUFpRSx1RUFBd0I7QUFDekY7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELCtDQUFRO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNkRBQWE7QUFDeEI7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0MsK0NBQVE7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBLE1BQU0sb0RBQVM7QUFDZjtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNILEVBQUUsZ0RBQVM7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxTQUFTLDhDQUFPO0FBQ2hCO0FBQ0E7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0EsMENBQTBDLHNEQUFHO0FBQzdDO0FBQ0EsK0JBQStCLHNEQUFHLENBQUMsMkNBQVE7QUFDM0M7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLDJDQUEyQyx1REFBWTtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsNkRBQWEsQ0FBQyxzRUFBaUIsVUFBVSxzRUFBcUI7O0FBRXpFO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxtQkFBbUIsZ0dBQXlCO0FBQzVDO0FBQ0E7QUFDQSxzQkFBc0IsdURBQUksQ0FBQyx1REFBUTtBQUNuQyw2Q0FBNkMsc0RBQUc7QUFDaEQ7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxtQkFBbUIsZ0dBQXlCO0FBQzVDO0FBQ0EsbUJBQW1CLHFGQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFMkIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9sZWkvaG9tZS91bmRlcmcvdGhlYXRyZS95My9zZWdwL21pbGt1cC9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbFBsYWluVGV4dFBsdWdpbi5kZXYubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuaW1wb3J0IHsgdXNlTGV4aWNhbENvbXBvc2VyQ29udGV4dCB9IGZyb20gJ0BsZXhpY2FsL3JlYWN0L0xleGljYWxDb21wb3NlckNvbnRleHQnO1xuaW1wb3J0IHsgdXNlTGV4aWNhbEVkaXRhYmxlIH0gZnJvbSAnQGxleGljYWwvcmVhY3QvdXNlTGV4aWNhbEVkaXRhYmxlJztcbmltcG9ydCB7ICRjYW5TaG93UGxhY2Vob2xkZXJDdXJyeSB9IGZyb20gJ0BsZXhpY2FsL3RleHQnO1xuaW1wb3J0IHsgbWVyZ2VSZWdpc3RlciB9IGZyb20gJ0BsZXhpY2FsL3V0aWxzJztcbmltcG9ydCB7IHVzZUxheW91dEVmZmVjdCwgdXNlRWZmZWN0LCB1c2VTdGF0ZSwgdXNlTWVtbywgU3VzcGVuc2UgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBmbHVzaFN5bmMsIGNyZWF0ZVBvcnRhbCB9IGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgeyBqc3gsIGpzeHMsIEZyYWdtZW50IH0gZnJvbSAncmVhY3QvanN4LXJ1bnRpbWUnO1xuaW1wb3J0IHsgcmVnaXN0ZXJEcmFnb25TdXBwb3J0IH0gZnJvbSAnQGxleGljYWwvZHJhZ29uJztcbmltcG9ydCB7IHJlZ2lzdGVyUGxhaW5UZXh0IH0gZnJvbSAnQGxleGljYWwvcGxhaW4tdGV4dCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuY29uc3QgQ0FOX1VTRV9ET00gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT09ICd1bmRlZmluZWQnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cblxuLy8gVGhpcyB3b3JrYXJvdW5kIGlzIG5vIGxvbmdlciBuZWNlc3NhcnkgaW4gUmVhY3QgMTksXG4vLyBidXQgd2UgY3VycmVudGx5IHN1cHBvcnQgUmVhY3QgPj0xNy54XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yNjM5NVxuY29uc3QgdXNlTGF5b3V0RWZmZWN0SW1wbCA9IENBTl9VU0VfRE9NID8gdXNlTGF5b3V0RWZmZWN0IDogdXNlRWZmZWN0O1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uIGNhblNob3dQbGFjZWhvbGRlckZyb21DdXJyZW50RWRpdG9yU3RhdGUoZWRpdG9yKSB7XG4gIGNvbnN0IGN1cnJlbnRDYW5TaG93UGxhY2Vob2xkZXIgPSBlZGl0b3IuZ2V0RWRpdG9yU3RhdGUoKS5yZWFkKCRjYW5TaG93UGxhY2Vob2xkZXJDdXJyeShlZGl0b3IuaXNDb21wb3NpbmcoKSkpO1xuICByZXR1cm4gY3VycmVudENhblNob3dQbGFjZWhvbGRlcjtcbn1cbmZ1bmN0aW9uIHVzZUNhblNob3dQbGFjZWhvbGRlcihlZGl0b3IpIHtcbiAgY29uc3QgW2NhblNob3dQbGFjZWhvbGRlciwgc2V0Q2FuU2hvd1BsYWNlaG9sZGVyXSA9IHVzZVN0YXRlKCgpID0+IGNhblNob3dQbGFjZWhvbGRlckZyb21DdXJyZW50RWRpdG9yU3RhdGUoZWRpdG9yKSk7XG4gIHVzZUxheW91dEVmZmVjdEltcGwoKCkgPT4ge1xuICAgIGZ1bmN0aW9uIHJlc2V0Q2FuU2hvd1BsYWNlaG9sZGVyKCkge1xuICAgICAgY29uc3QgY3VycmVudENhblNob3dQbGFjZWhvbGRlciA9IGNhblNob3dQbGFjZWhvbGRlckZyb21DdXJyZW50RWRpdG9yU3RhdGUoZWRpdG9yKTtcbiAgICAgIHNldENhblNob3dQbGFjZWhvbGRlcihjdXJyZW50Q2FuU2hvd1BsYWNlaG9sZGVyKTtcbiAgICB9XG4gICAgcmVzZXRDYW5TaG93UGxhY2Vob2xkZXIoKTtcbiAgICByZXR1cm4gbWVyZ2VSZWdpc3RlcihlZGl0b3IucmVnaXN0ZXJVcGRhdGVMaXN0ZW5lcigoKSA9PiB7XG4gICAgICByZXNldENhblNob3dQbGFjZWhvbGRlcigpO1xuICAgIH0pLCBlZGl0b3IucmVnaXN0ZXJFZGl0YWJsZUxpc3RlbmVyKCgpID0+IHtcbiAgICAgIHJlc2V0Q2FuU2hvd1BsYWNlaG9sZGVyKCk7XG4gICAgfSkpO1xuICB9LCBbZWRpdG9yXSk7XG4gIHJldHVybiBjYW5TaG93UGxhY2Vob2xkZXI7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gdXNlRGVjb3JhdG9ycyhlZGl0b3IsIEVycm9yQm91bmRhcnkpIHtcbiAgY29uc3QgW2RlY29yYXRvcnMsIHNldERlY29yYXRvcnNdID0gdXNlU3RhdGUoKCkgPT4gZWRpdG9yLmdldERlY29yYXRvcnMoKSk7XG5cbiAgLy8gU3Vic2NyaWJlIHRvIGNoYW5nZXNcbiAgdXNlTGF5b3V0RWZmZWN0SW1wbCgoKSA9PiB7XG4gICAgcmV0dXJuIGVkaXRvci5yZWdpc3RlckRlY29yYXRvckxpc3RlbmVyKG5leHREZWNvcmF0b3JzID0+IHtcbiAgICAgIGZsdXNoU3luYygoKSA9PiB7XG4gICAgICAgIHNldERlY29yYXRvcnMobmV4dERlY29yYXRvcnMpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0sIFtlZGl0b3JdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBJZiB0aGUgY29udGVudCBlZGl0YWJsZSBtb3VudHMgYmVmb3JlIHRoZSBzdWJzY3JpcHRpb24gaXMgYWRkZWQsIHRoZW5cbiAgICAvLyBub3RoaW5nIHdpbGwgYmUgcmVuZGVyZWQgb24gaW5pdGlhbCBwYXNzLiBXZSBjYW4gZ2V0IGFyb3VuZCB0aGF0IGJ5XG4gICAgLy8gZW5zdXJpbmcgdGhhdCB3ZSBzZXQgdGhlIHZhbHVlLlxuICAgIHNldERlY29yYXRvcnMoZWRpdG9yLmdldERlY29yYXRvcnMoKSk7XG4gIH0sIFtlZGl0b3JdKTtcblxuICAvLyBSZXR1cm4gZGVjb3JhdG9ycyBkZWZpbmVkIGFzIFJlYWN0IFBvcnRhbHNcbiAgcmV0dXJuIHVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IGRlY29yYXRlZFBvcnRhbHMgPSBbXTtcbiAgICBjb25zdCBkZWNvcmF0b3JLZXlzID0gT2JqZWN0LmtleXMoZGVjb3JhdG9ycyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWNvcmF0b3JLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBub2RlS2V5ID0gZGVjb3JhdG9yS2V5c1tpXTtcbiAgICAgIGNvbnN0IHJlYWN0RGVjb3JhdG9yID0gLyojX19QVVJFX18qL2pzeChFcnJvckJvdW5kYXJ5LCB7XG4gICAgICAgIG9uRXJyb3I6IGUgPT4gZWRpdG9yLl9vbkVycm9yKGUpLFxuICAgICAgICBjaGlsZHJlbjogLyojX19QVVJFX18qL2pzeChTdXNwZW5zZSwge1xuICAgICAgICAgIGZhbGxiYWNrOiBudWxsLFxuICAgICAgICAgIGNoaWxkcmVuOiBkZWNvcmF0b3JzW25vZGVLZXldXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KG5vZGVLZXkpO1xuICAgICAgaWYgKGVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgZGVjb3JhdGVkUG9ydGFscy5wdXNoKC8qI19fUFVSRV9fKi9jcmVhdGVQb3J0YWwocmVhY3REZWNvcmF0b3IsIGVsZW1lbnQsIG5vZGVLZXkpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlY29yYXRlZFBvcnRhbHM7XG4gIH0sIFtFcnJvckJvdW5kYXJ5LCBkZWNvcmF0b3JzLCBlZGl0b3JdKTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiB1c2VQbGFpblRleHRTZXR1cChlZGl0b3IpIHtcbiAgdXNlTGF5b3V0RWZmZWN0SW1wbCgoKSA9PiB7XG4gICAgcmV0dXJuIG1lcmdlUmVnaXN0ZXIocmVnaXN0ZXJQbGFpblRleHQoZWRpdG9yKSwgcmVnaXN0ZXJEcmFnb25TdXBwb3J0KGVkaXRvcikpO1xuXG4gICAgLy8gV2Ugb25seSBkbyB0aGlzIGZvciBpbml0XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICB9LCBbZWRpdG9yXSk7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gUGxhaW5UZXh0UGx1Z2luKHtcbiAgY29udGVudEVkaXRhYmxlLFxuICAvLyBUT0RPIFJlbW92ZS4gVGhpcyBwcm9wZXJ0eSBpcyBub3cgcGFydCBvZiBDb250ZW50RWRpdGFibGVcbiAgcGxhY2Vob2xkZXIgPSBudWxsLFxuICBFcnJvckJvdW5kYXJ5XG59KSB7XG4gIGNvbnN0IFtlZGl0b3JdID0gdXNlTGV4aWNhbENvbXBvc2VyQ29udGV4dCgpO1xuICBjb25zdCBkZWNvcmF0b3JzID0gdXNlRGVjb3JhdG9ycyhlZGl0b3IsIEVycm9yQm91bmRhcnkpO1xuICB1c2VQbGFpblRleHRTZXR1cChlZGl0b3IpO1xuICByZXR1cm4gLyojX19QVVJFX18qL2pzeHMoRnJhZ21lbnQsIHtcbiAgICBjaGlsZHJlbjogW2NvbnRlbnRFZGl0YWJsZSwgLyojX19QVVJFX18qL2pzeChQbGFjZWhvbGRlciwge1xuICAgICAgY29udGVudDogcGxhY2Vob2xkZXJcbiAgICB9KSwgZGVjb3JhdG9yc11cbiAgfSk7XG59XG5cbi8vIFRPRE8gUmVtb3ZlXG5mdW5jdGlvbiBQbGFjZWhvbGRlcih7XG4gIGNvbnRlbnRcbn0pIHtcbiAgY29uc3QgW2VkaXRvcl0gPSB1c2VMZXhpY2FsQ29tcG9zZXJDb250ZXh0KCk7XG4gIGNvbnN0IHNob3dQbGFjZWhvbGRlciA9IHVzZUNhblNob3dQbGFjZWhvbGRlcihlZGl0b3IpO1xuICBjb25zdCBlZGl0YWJsZSA9IHVzZUxleGljYWxFZGl0YWJsZSgpO1xuICBpZiAoIXNob3dQbGFjZWhvbGRlcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBjb250ZW50KGVkaXRhYmxlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxufVxuXG5leHBvcnQgeyBQbGFpblRleHRQbHVnaW4gfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/react/LexicalPlainTextPlugin.dev.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/react/useLexicalEditable.dev.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@lexical/react/useLexicalEditable.dev.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ useLexicalEditable),\n/* harmony export */   useLexicalEditable: () => (/* binding */ useLexicalEditable)\n/* harmony export */ });\n/* harmony import */ var _lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(app-pages-browser)/./node_modules/@lexical/react/LexicalComposerContext.dev.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// This workaround is no longer necessary in React 19,\n// but we currently support React >=17.x\n// https://github.com/facebook/react/pull/26395\nconst useLayoutEffectImpl = CAN_USE_DOM ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Shortcut to Lexical subscriptions when values are used for render.\n * @param subscription - The function to create the {@link LexicalSubscription}. This function's identity must be stable (e.g. defined at module scope or with useCallback).\n */\nfunction useLexicalSubscription(subscription) {\n  const [editor] = (0,_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_1__.useLexicalComposerContext)();\n  const initializedSubscription = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => subscription(editor), [editor, subscription]);\n  const [value, setValue] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => initializedSubscription.initialValueFn());\n  const valueRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(value);\n  useLayoutEffectImpl(() => {\n    const {\n      initialValueFn,\n      subscribe\n    } = initializedSubscription;\n    const currentValue = initialValueFn();\n    if (valueRef.current !== currentValue) {\n      valueRef.current = currentValue;\n      setValue(currentValue);\n    }\n    return subscribe(newValue => {\n      valueRef.current = newValue;\n      setValue(newValue);\n    });\n  }, [initializedSubscription, subscription]);\n  return value;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction subscription(editor) {\n  return {\n    initialValueFn: () => editor.isEditable(),\n    subscribe: callback => {\n      return editor.registerEditableListener(callback);\n    }\n  };\n}\n\n/**\n * Get the current value for {@link LexicalEditor.isEditable}\n * using {@link useLexicalSubscription}.\n * You should prefer this over manually observing the value with\n * {@link LexicalEditor.registerEditableListener},\n * which is a bit tricky to do correctly, particularly when using\n * React StrictMode (the default for development) or concurrency.\n */\nfunction useLexicalEditable() {\n  return useLexicalSubscription(subscription);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC91c2VMZXhpY2FsRWRpdGFibGUuZGV2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWtGO0FBQ0o7O0FBRTlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsa0RBQWUsR0FBRyw0Q0FBUzs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFEQUFxRCwwQkFBMEI7QUFDL0U7QUFDQTtBQUNBLG1CQUFtQixnR0FBeUI7QUFDNUMsa0NBQWtDLDhDQUFPO0FBQ3pDLDRCQUE0QiwrQ0FBUTtBQUNwQyxtQkFBbUIsNkNBQU07QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCLFVBQVUsNkJBQTZCO0FBQ3ZDO0FBQ0EsSUFBSSw2Q0FBNkM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU2RCIsInNvdXJjZXMiOlsiL1VzZXJzL2xlaS9ob21lL3VuZGVyZy90aGVhdHJlL3kzL3NlZ3AvbWlsa3VwL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC91c2VMZXhpY2FsRWRpdGFibGUuZGV2Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmltcG9ydCB7IHVzZUxleGljYWxDb21wb3NlckNvbnRleHQgfSBmcm9tICdAbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ29tcG9zZXJDb250ZXh0JztcbmltcG9ydCB7IHVzZUxheW91dEVmZmVjdCwgdXNlRWZmZWN0LCB1c2VNZW1vLCB1c2VTdGF0ZSwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IENBTl9VU0VfRE9NID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5cbi8vIFRoaXMgd29ya2Fyb3VuZCBpcyBubyBsb25nZXIgbmVjZXNzYXJ5IGluIFJlYWN0IDE5LFxuLy8gYnV0IHdlIGN1cnJlbnRseSBzdXBwb3J0IFJlYWN0ID49MTcueFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjYzOTVcbmNvbnN0IHVzZUxheW91dEVmZmVjdEltcGwgPSBDQU5fVVNFX0RPTSA/IHVzZUxheW91dEVmZmVjdCA6IHVzZUVmZmVjdDtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4vKipcbiAqIFNob3J0Y3V0IHRvIExleGljYWwgc3Vic2NyaXB0aW9ucyB3aGVuIHZhbHVlcyBhcmUgdXNlZCBmb3IgcmVuZGVyLlxuICogQHBhcmFtIHN1YnNjcmlwdGlvbiAtIFRoZSBmdW5jdGlvbiB0byBjcmVhdGUgdGhlIHtAbGluayBMZXhpY2FsU3Vic2NyaXB0aW9ufS4gVGhpcyBmdW5jdGlvbidzIGlkZW50aXR5IG11c3QgYmUgc3RhYmxlIChlLmcuIGRlZmluZWQgYXQgbW9kdWxlIHNjb3BlIG9yIHdpdGggdXNlQ2FsbGJhY2spLlxuICovXG5mdW5jdGlvbiB1c2VMZXhpY2FsU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbikge1xuICBjb25zdCBbZWRpdG9yXSA9IHVzZUxleGljYWxDb21wb3NlckNvbnRleHQoKTtcbiAgY29uc3QgaW5pdGlhbGl6ZWRTdWJzY3JpcHRpb24gPSB1c2VNZW1vKCgpID0+IHN1YnNjcmlwdGlvbihlZGl0b3IpLCBbZWRpdG9yLCBzdWJzY3JpcHRpb25dKTtcbiAgY29uc3QgW3ZhbHVlLCBzZXRWYWx1ZV0gPSB1c2VTdGF0ZSgoKSA9PiBpbml0aWFsaXplZFN1YnNjcmlwdGlvbi5pbml0aWFsVmFsdWVGbigpKTtcbiAgY29uc3QgdmFsdWVSZWYgPSB1c2VSZWYodmFsdWUpO1xuICB1c2VMYXlvdXRFZmZlY3RJbXBsKCgpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBpbml0aWFsVmFsdWVGbixcbiAgICAgIHN1YnNjcmliZVxuICAgIH0gPSBpbml0aWFsaXplZFN1YnNjcmlwdGlvbjtcbiAgICBjb25zdCBjdXJyZW50VmFsdWUgPSBpbml0aWFsVmFsdWVGbigpO1xuICAgIGlmICh2YWx1ZVJlZi5jdXJyZW50ICE9PSBjdXJyZW50VmFsdWUpIHtcbiAgICAgIHZhbHVlUmVmLmN1cnJlbnQgPSBjdXJyZW50VmFsdWU7XG4gICAgICBzZXRWYWx1ZShjdXJyZW50VmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gc3Vic2NyaWJlKG5ld1ZhbHVlID0+IHtcbiAgICAgIHZhbHVlUmVmLmN1cnJlbnQgPSBuZXdWYWx1ZTtcbiAgICAgIHNldFZhbHVlKG5ld1ZhbHVlKTtcbiAgICB9KTtcbiAgfSwgW2luaXRpYWxpemVkU3Vic2NyaXB0aW9uLCBzdWJzY3JpcHRpb25dKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uIHN1YnNjcmlwdGlvbihlZGl0b3IpIHtcbiAgcmV0dXJuIHtcbiAgICBpbml0aWFsVmFsdWVGbjogKCkgPT4gZWRpdG9yLmlzRWRpdGFibGUoKSxcbiAgICBzdWJzY3JpYmU6IGNhbGxiYWNrID0+IHtcbiAgICAgIHJldHVybiBlZGl0b3IucmVnaXN0ZXJFZGl0YWJsZUxpc3RlbmVyKGNhbGxiYWNrKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IHZhbHVlIGZvciB7QGxpbmsgTGV4aWNhbEVkaXRvci5pc0VkaXRhYmxlfVxuICogdXNpbmcge0BsaW5rIHVzZUxleGljYWxTdWJzY3JpcHRpb259LlxuICogWW91IHNob3VsZCBwcmVmZXIgdGhpcyBvdmVyIG1hbnVhbGx5IG9ic2VydmluZyB0aGUgdmFsdWUgd2l0aFxuICoge0BsaW5rIExleGljYWxFZGl0b3IucmVnaXN0ZXJFZGl0YWJsZUxpc3RlbmVyfSxcbiAqIHdoaWNoIGlzIGEgYml0IHRyaWNreSB0byBkbyBjb3JyZWN0bHksIHBhcnRpY3VsYXJseSB3aGVuIHVzaW5nXG4gKiBSZWFjdCBTdHJpY3RNb2RlICh0aGUgZGVmYXVsdCBmb3IgZGV2ZWxvcG1lbnQpIG9yIGNvbmN1cnJlbmN5LlxuICovXG5mdW5jdGlvbiB1c2VMZXhpY2FsRWRpdGFibGUoKSB7XG4gIHJldHVybiB1c2VMZXhpY2FsU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG59XG5cbmV4cG9ydCB7IHVzZUxleGljYWxFZGl0YWJsZSBhcyBkZWZhdWx0LCB1c2VMZXhpY2FsRWRpdGFibGUgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/react/useLexicalEditable.dev.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/selection/LexicalSelection.dev.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@lexical/selection/LexicalSelection.dev.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $addNodeStyle: () => (/* binding */ $addNodeStyle),\n/* harmony export */   $cloneWithProperties: () => (/* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.$cloneWithProperties),\n/* harmony export */   $forEachSelectedTextNode: () => (/* binding */ $forEachSelectedTextNode),\n/* harmony export */   $getSelectionStyleValueForProperty: () => (/* binding */ $getSelectionStyleValueForProperty),\n/* harmony export */   $isAtNodeEnd: () => (/* binding */ $isAtNodeEnd),\n/* harmony export */   $isParentElementRTL: () => (/* binding */ $isParentElementRTL),\n/* harmony export */   $moveCaretSelection: () => (/* binding */ $moveCaretSelection),\n/* harmony export */   $moveCharacter: () => (/* binding */ $moveCharacter),\n/* harmony export */   $patchStyleText: () => (/* binding */ $patchStyleText),\n/* harmony export */   $selectAll: () => (/* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.$selectAll),\n/* harmony export */   $setBlocksType: () => (/* binding */ $setBlocksType),\n/* harmony export */   $shouldOverrideDefaultCharacterSelection: () => (/* binding */ $shouldOverrideDefaultCharacterSelection),\n/* harmony export */   $sliceSelectedTextNodeContent: () => (/* binding */ $sliceSelectedTextNodeContent),\n/* harmony export */   $trimTextContentFromAnchor: () => (/* binding */ $trimTextContentFromAnchor),\n/* harmony export */   $wrapNodes: () => (/* binding */ $wrapNodes),\n/* harmony export */   createDOMRange: () => (/* binding */ createDOMRange),\n/* harmony export */   createRectsFromDOMRange: () => (/* binding */ createRectsFromDOMRange),\n/* harmony export */   getCSSFromStyleObject: () => (/* binding */ getCSSFromStyleObject),\n/* harmony export */   getStyleObjectFromCSS: () => (/* binding */ getStyleObjectFromCSS),\n/* harmony export */   trimTextContentFromAnchor: () => (/* binding */ trimTextContentFromAnchor)\n/* harmony export */ });\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(app-pages-browser)/./node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CSS_TO_STYLES = new Map();\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction getDOMTextNode(element) {\n  let node = element;\n  while (node != null) {\n    if (node.nodeType === Node.TEXT_NODE) {\n      return node;\n    }\n    node = node.firstChild;\n  }\n  return null;\n}\nfunction getDOMIndexWithinParent(node) {\n  const parent = node.parentNode;\n  if (parent == null) {\n    throw new Error('Should never happen');\n  }\n  return [parent, Array.from(parent.childNodes).indexOf(node)];\n}\n\n/**\n * Creates a selection range for the DOM.\n * @param editor - The lexical editor.\n * @param anchorNode - The anchor node of a selection.\n * @param _anchorOffset - The amount of space offset from the anchor to the focus.\n * @param focusNode - The current focus.\n * @param _focusOffset - The amount of space offset from the focus to the anchor.\n * @returns The range of selection for the DOM that was created.\n */\nfunction createDOMRange(editor, anchorNode, _anchorOffset, focusNode, _focusOffset) {\n  const anchorKey = anchorNode.getKey();\n  const focusKey = focusNode.getKey();\n  const range = document.createRange();\n  let anchorDOM = editor.getElementByKey(anchorKey);\n  let focusDOM = editor.getElementByKey(focusKey);\n  let anchorOffset = _anchorOffset;\n  let focusOffset = _focusOffset;\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(anchorNode)) {\n    anchorDOM = getDOMTextNode(anchorDOM);\n  }\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(focusNode)) {\n    focusDOM = getDOMTextNode(focusDOM);\n  }\n  if (anchorNode === undefined || focusNode === undefined || anchorDOM === null || focusDOM === null) {\n    return null;\n  }\n  if (anchorDOM.nodeName === 'BR') {\n    [anchorDOM, anchorOffset] = getDOMIndexWithinParent(anchorDOM);\n  }\n  if (focusDOM.nodeName === 'BR') {\n    [focusDOM, focusOffset] = getDOMIndexWithinParent(focusDOM);\n  }\n  const firstChild = anchorDOM.firstChild;\n  if (anchorDOM === focusDOM && firstChild != null && firstChild.nodeName === 'BR' && anchorOffset === 0 && focusOffset === 0) {\n    focusOffset = 1;\n  }\n  try {\n    range.setStart(anchorDOM, anchorOffset);\n    range.setEnd(focusDOM, focusOffset);\n  } catch (e) {\n    return null;\n  }\n  if (range.collapsed && (anchorOffset !== focusOffset || anchorKey !== focusKey)) {\n    // Range is backwards, we need to reverse it\n    range.setStart(focusDOM, focusOffset);\n    range.setEnd(anchorDOM, anchorOffset);\n  }\n  return range;\n}\n\n/**\n * Creates DOMRects, generally used to help the editor find a specific location on the screen.\n * @param editor - The lexical editor\n * @param range - A fragment of a document that can contain nodes and parts of text nodes.\n * @returns The selectionRects as an array.\n */\nfunction createRectsFromDOMRange(editor, range) {\n  const rootElement = editor.getRootElement();\n  if (rootElement === null) {\n    return [];\n  }\n  const rootRect = rootElement.getBoundingClientRect();\n  const computedStyle = getComputedStyle(rootElement);\n  const rootPadding = parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);\n  const selectionRects = Array.from(range.getClientRects());\n  let selectionRectsLength = selectionRects.length;\n  //sort rects from top left to bottom right.\n  selectionRects.sort((a, b) => {\n    const top = a.top - b.top;\n    // Some rects match position closely, but not perfectly,\n    // so we give a 3px tolerance.\n    if (Math.abs(top) <= 3) {\n      return a.left - b.left;\n    }\n    return top;\n  });\n  let prevRect;\n  for (let i = 0; i < selectionRectsLength; i++) {\n    const selectionRect = selectionRects[i];\n    // Exclude rects that overlap preceding Rects in the sorted list.\n    const isOverlappingRect = prevRect && prevRect.top <= selectionRect.top && prevRect.top + prevRect.height > selectionRect.top && prevRect.left + prevRect.width > selectionRect.left;\n    // Exclude selections that span the entire element\n    const selectionSpansElement = selectionRect.width + rootPadding === rootRect.width;\n    if (isOverlappingRect || selectionSpansElement) {\n      selectionRects.splice(i--, 1);\n      selectionRectsLength--;\n      continue;\n    }\n    prevRect = selectionRect;\n  }\n  return selectionRects;\n}\n\n/**\n * Creates an object containing all the styles and their values provided in the CSS string.\n * @param css - The CSS string of styles and their values.\n * @returns The styleObject containing all the styles and their values.\n */\nfunction getStyleObjectFromRawCSS(css) {\n  const styleObject = {};\n  if (!css) {\n    return styleObject;\n  }\n  const styles = css.split(';');\n  for (const style of styles) {\n    if (style !== '') {\n      const [key, value] = style.split(/:([^]+)/); // split on first colon\n      if (key && value) {\n        styleObject[key.trim()] = value.trim();\n      }\n    }\n  }\n  return styleObject;\n}\n\n/**\n * Given a CSS string, returns an object from the style cache.\n * @param css - The CSS property as a string.\n * @returns The value of the given CSS property.\n */\nfunction getStyleObjectFromCSS(css) {\n  let value = CSS_TO_STYLES.get(css);\n  if (value === undefined) {\n    value = getStyleObjectFromRawCSS(css);\n    CSS_TO_STYLES.set(css, value);\n  }\n  {\n    // Freeze the value in DEV to prevent accidental mutations\n    Object.freeze(value);\n  }\n  return value;\n}\n\n/**\n * Gets the CSS styles from the style object.\n * @param styles - The style object containing the styles to get.\n * @returns A string containing the CSS styles and their values.\n */\nfunction getCSSFromStyleObject(styles) {\n  let css = '';\n  for (const style in styles) {\n    if (style) {\n      css += `${style}: ${styles[style]};`;\n    }\n  }\n  return css;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Generally used to append text content to HTML and JSON. Grabs the text content and \"slices\"\n * it to be generated into the new TextNode.\n * @param selection - The selection containing the node whose TextNode is to be edited.\n * @param textNode - The TextNode to be edited.\n * @returns The updated TextNode.\n */\nfunction $sliceSelectedTextNodeContent(selection, textNode) {\n  const anchorAndFocus = selection.getStartEndPoints();\n  if (textNode.isSelected(selection) && !textNode.isSegmented() && !textNode.isToken() && anchorAndFocus !== null) {\n    const [anchor, focus] = anchorAndFocus;\n    const isBackward = selection.isBackward();\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    const isAnchor = textNode.is(anchorNode);\n    const isFocus = textNode.is(focusNode);\n    if (isAnchor || isFocus) {\n      const [anchorOffset, focusOffset] = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getCharacterOffsets)(selection);\n      const isSame = anchorNode.is(focusNode);\n      const isFirst = textNode.is(isBackward ? focusNode : anchorNode);\n      const isLast = textNode.is(isBackward ? anchorNode : focusNode);\n      let startOffset = 0;\n      let endOffset = undefined;\n      if (isSame) {\n        startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\n        endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;\n      } else if (isFirst) {\n        const offset = isBackward ? focusOffset : anchorOffset;\n        startOffset = offset;\n        endOffset = undefined;\n      } else if (isLast) {\n        const offset = isBackward ? anchorOffset : focusOffset;\n        startOffset = 0;\n        endOffset = offset;\n      }\n      textNode.__text = textNode.__text.slice(startOffset, endOffset);\n      return textNode;\n    }\n  }\n  return textNode;\n}\n\n/**\n * Determines if the current selection is at the end of the node.\n * @param point - The point of the selection to test.\n * @returns true if the provided point offset is in the last possible position, false otherwise.\n */\nfunction $isAtNodeEnd(point) {\n  if (point.type === 'text') {\n    return point.offset === point.getNode().getTextContentSize();\n  }\n  const node = point.getNode();\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node)) {\n    throw Error(`isAtNodeEnd: node must be a TextNode or ElementNode`);\n  }\n  return point.offset === node.getChildrenSize();\n}\n\n/**\n * Trims text from a node in order to shorten it, eg. to enforce a text's max length. If it deletes text\n * that is an ancestor of the anchor then it will leave 2 indents, otherwise, if no text content exists, it deletes\n * the TextNode. It will move the focus to either the end of any left over text or beginning of a new TextNode.\n * @param editor - The lexical editor.\n * @param anchor - The anchor of the current selection, where the selection should be pointing.\n * @param delCount - The amount of characters to delete. Useful as a dynamic variable eg. textContentSize - maxLength;\n */\nfunction $trimTextContentFromAnchor(editor, anchor, delCount) {\n  // Work from the current selection anchor point\n  let currentNode = anchor.getNode();\n  let remaining = delCount;\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode)) {\n    const descendantNode = currentNode.getDescendantByIndex(anchor.offset);\n    if (descendantNode !== null) {\n      currentNode = descendantNode;\n    }\n  }\n  while (remaining > 0 && currentNode !== null) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode)) {\n      const lastDescendant = currentNode.getLastDescendant();\n      if (lastDescendant !== null) {\n        currentNode = lastDescendant;\n      }\n    }\n    let nextNode = currentNode.getPreviousSibling();\n    let additionalElementWhitespace = 0;\n    if (nextNode === null) {\n      let parent = currentNode.getParentOrThrow();\n      let parentSibling = parent.getPreviousSibling();\n      while (parentSibling === null) {\n        parent = parent.getParent();\n        if (parent === null) {\n          nextNode = null;\n          break;\n        }\n        parentSibling = parent.getPreviousSibling();\n      }\n      if (parent !== null) {\n        additionalElementWhitespace = parent.isInline() ? 0 : 2;\n        nextNode = parentSibling;\n      }\n    }\n    let text = currentNode.getTextContent();\n    // If the text is empty, we need to consider adding in two line breaks to match\n    // the content if we were to get it from its parent.\n    if (text === '' && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode) && !currentNode.isInline()) {\n      // TODO: should this be handled in core?\n      text = '\\n\\n';\n    }\n    const currentNodeSize = text.length;\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(currentNode) || remaining >= currentNodeSize) {\n      const parent = currentNode.getParent();\n      currentNode.remove();\n      if (parent != null && parent.getChildrenSize() === 0 && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootNode)(parent)) {\n        parent.remove();\n      }\n      remaining -= currentNodeSize + additionalElementWhitespace;\n      currentNode = nextNode;\n    } else {\n      const key = currentNode.getKey();\n      // See if we can just revert it to what was in the last editor state\n      const prevTextContent = editor.getEditorState().read(() => {\n        const prevNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNodeByKey)(key);\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(prevNode) && prevNode.isSimpleText()) {\n          return prevNode.getTextContent();\n        }\n        return null;\n      });\n      const offset = currentNodeSize - remaining;\n      const slicedText = text.slice(0, offset);\n      if (prevTextContent !== null && prevTextContent !== text) {\n        const prevSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getPreviousSelection)();\n        let target = currentNode;\n        if (!currentNode.isSimpleText()) {\n          const textNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTextNode)(prevTextContent);\n          currentNode.replace(textNode);\n          target = textNode;\n        } else {\n          currentNode.setTextContent(prevTextContent);\n        }\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(prevSelection) && prevSelection.isCollapsed()) {\n          const prevOffset = prevSelection.anchor.offset;\n          target.select(prevOffset, prevOffset);\n        }\n      } else if (currentNode.isSimpleText()) {\n        // Split text\n        const isSelected = anchor.key === key;\n        let anchorOffset = anchor.offset;\n        // Move offset to end if it's less than the remaining number, otherwise\n        // we'll have a negative splitStart.\n        if (anchorOffset < remaining) {\n          anchorOffset = currentNodeSize;\n        }\n        const splitStart = isSelected ? anchorOffset - remaining : 0;\n        const splitEnd = isSelected ? anchorOffset : offset;\n        if (isSelected && splitStart === 0) {\n          const [excessNode] = currentNode.splitText(splitStart, splitEnd);\n          excessNode.remove();\n        } else {\n          const [, excessNode] = currentNode.splitText(splitStart, splitEnd);\n          excessNode.remove();\n        }\n      } else {\n        const textNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTextNode)(slicedText);\n        currentNode.replace(textNode);\n      }\n      remaining = 0;\n    }\n  }\n}\n\n/**\n * Gets the TextNode's style object and adds the styles to the CSS.\n * @param node - The TextNode to add styles to.\n */\nfunction $addNodeStyle(node) {\n  const CSSText = node.getStyle();\n  const styles = getStyleObjectFromRawCSS(CSSText);\n  CSS_TO_STYLES.set(CSSText, styles);\n}\nfunction $patchStyle(target, patch) {\n  const prevStyles = getStyleObjectFromCSS('getStyle' in target ? target.getStyle() : target.style);\n  const newStyles = Object.entries(patch).reduce((styles, [key, value]) => {\n    if (typeof value === 'function') {\n      styles[key] = value(prevStyles[key], target);\n    } else if (value === null) {\n      delete styles[key];\n    } else {\n      styles[key] = value;\n    }\n    return styles;\n  }, {\n    ...prevStyles\n  } || {});\n  const newCSSText = getCSSFromStyleObject(newStyles);\n  target.setStyle(newCSSText);\n  CSS_TO_STYLES.set(newCSSText, newStyles);\n}\n\n/**\n * Applies the provided styles to the TextNodes in the provided Selection.\n * Will update partially selected TextNodes by splitting the TextNode and applying\n * the styles to the appropriate one.\n * @param selection - The selected node(s) to update.\n * @param patch - The patch to apply, which can include multiple styles. \\\\{CSSProperty: value\\\\} . Can also accept a function that returns the new property value.\n */\nfunction $patchStyleText(selection, patch) {\n  if (selection.isCollapsed() && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n    $patchStyle(selection, patch);\n  } else {\n    $forEachSelectedTextNode(textNode => {\n      $patchStyle(textNode, patch);\n    });\n  }\n}\nfunction $forEachSelectedTextNode(fn) {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n    return;\n  }\n  const selectedNodes = selection.getNodes();\n  const selectedNodesLength = selectedNodes.length;\n  const {\n    anchor,\n    focus\n  } = selection;\n  const lastIndex = selectedNodesLength - 1;\n  let firstNode = selectedNodes[0];\n  let lastNode = selectedNodes[lastIndex];\n  const firstNodeText = firstNode.getTextContent();\n  const firstNodeTextLength = firstNodeText.length;\n  const focusOffset = focus.offset;\n  let anchorOffset = anchor.offset;\n  const isBefore = anchor.isBefore(focus);\n  let startOffset = isBefore ? anchorOffset : focusOffset;\n  let endOffset = isBefore ? focusOffset : anchorOffset;\n  const startType = isBefore ? anchor.type : focus.type;\n  const endType = isBefore ? focus.type : anchor.type;\n  const endKey = isBefore ? focus.key : anchor.key;\n\n  // This is the case where the user only selected the very end of the\n  // first node so we don't want to include it in the formatting change.\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(firstNode) && startOffset === firstNodeTextLength) {\n    const nextSibling = firstNode.getNextSibling();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(nextSibling)) {\n      // we basically make the second node the firstNode, changing offsets accordingly\n      anchorOffset = 0;\n      startOffset = 0;\n      firstNode = nextSibling;\n    }\n  }\n\n  // This is the case where we only selected a single node\n  if (selectedNodes.length === 1) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(firstNode) && firstNode.canHaveFormat()) {\n      startOffset = startType === 'element' ? 0 : anchorOffset > focusOffset ? focusOffset : anchorOffset;\n      endOffset = endType === 'element' ? firstNodeTextLength : anchorOffset > focusOffset ? anchorOffset : focusOffset;\n\n      // No actual text is selected, so do nothing.\n      if (startOffset === endOffset) {\n        return;\n      }\n\n      // The entire node is selected or a token/segment, so just format it\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTokenOrSegmented)(firstNode) || startOffset === 0 && endOffset === firstNodeTextLength) {\n        fn(firstNode);\n        firstNode.select(startOffset, endOffset);\n      } else {\n        // The node is partially selected, so split it into two nodes\n        // and style the selected one.\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        fn(replacement);\n        replacement.select(0, endOffset - startOffset);\n      }\n    } // multiple nodes selected.\n  } else {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(firstNode) && startOffset < firstNode.getTextContentSize() && firstNode.canHaveFormat()) {\n      if (startOffset !== 0 && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTokenOrSegmented)(firstNode)) {\n        // the entire first node isn't selected and it isn't a token or segmented, so split it\n        firstNode = firstNode.splitText(startOffset)[1];\n        startOffset = 0;\n        if (isBefore) {\n          anchor.set(firstNode.getKey(), startOffset, 'text');\n        } else {\n          focus.set(firstNode.getKey(), startOffset, 'text');\n        }\n      }\n      fn(firstNode);\n    }\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(lastNode) && lastNode.canHaveFormat()) {\n      const lastNodeText = lastNode.getTextContent();\n      const lastNodeTextLength = lastNodeText.length;\n\n      // The last node might not actually be the end node\n      //\n      // If not, assume the last node is fully-selected unless the end offset is\n      // zero.\n      if (lastNode.__key !== endKey && endOffset !== 0) {\n        endOffset = lastNodeTextLength;\n      }\n\n      // if the entire last node isn't selected and it isn't a token or segmented, split it\n      if (endOffset !== lastNodeTextLength && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTokenOrSegmented)(lastNode)) {\n        [lastNode] = lastNode.splitText(endOffset);\n      }\n      if (endOffset !== 0 || endType === 'element') {\n        fn(lastNode);\n      }\n    }\n\n    // style all the text nodes in between\n    for (let i = 1; i < lastIndex; i++) {\n      const selectedNode = selectedNodes[i];\n      const selectedNodeKey = selectedNode.getKey();\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(selectedNode) && selectedNode.canHaveFormat() && selectedNodeKey !== firstNode.getKey() && selectedNodeKey !== lastNode.getKey() && !selectedNode.isToken()) {\n        fn(selectedNode);\n      }\n    }\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n/**\n * Converts all nodes in the selection that are of one block type to another.\n * @param selection - The selected blocks to be converted.\n * @param createElement - The function that creates the node. eg. $createParagraphNode.\n */\nfunction $setBlocksType(selection, createElement) {\n  if (selection === null) {\n    return;\n  }\n  const anchorAndFocus = selection.getStartEndPoints();\n  const anchor = anchorAndFocus ? anchorAndFocus[0] : null;\n  if (anchor !== null && anchor.key === 'root') {\n    const element = createElement();\n    const root = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)();\n    const firstChild = root.getFirstChild();\n    if (firstChild) {\n      firstChild.replace(element, true);\n    } else {\n      root.append(element);\n    }\n    return;\n  }\n  const nodes = selection.getNodes();\n  const firstSelectedBlock = anchor !== null ? $getAncestor(anchor.getNode(), INTERNAL_$isBlock) : false;\n  if (firstSelectedBlock && nodes.indexOf(firstSelectedBlock) === -1) {\n    nodes.push(firstSelectedBlock);\n  }\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (!INTERNAL_$isBlock(node)) {\n      continue;\n    }\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node)) {\n      throw Error(`Expected block node to be an ElementNode`);\n    }\n    const targetElement = createElement();\n    targetElement.setFormat(node.getFormatType());\n    targetElement.setIndent(node.getIndent());\n    node.replace(targetElement, true);\n  }\n}\nfunction isPointAttached(point) {\n  return point.getNode().isAttached();\n}\nfunction $removeParentEmptyElements(startingNode) {\n  let node = startingNode;\n  while (node !== null && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(node)) {\n    const latest = node.getLatest();\n    const parentNode = node.getParent();\n    if (latest.getChildrenSize() === 0) {\n      node.remove(true);\n    }\n    node = parentNode;\n  }\n}\n\n/**\n * @deprecated\n * Wraps all nodes in the selection into another node of the type returned by createElement.\n * @param selection - The selection of nodes to be wrapped.\n * @param createElement - A function that creates the wrapping ElementNode. eg. $createParagraphNode.\n * @param wrappingElement - An element to append the wrapped selection and its children to.\n */\nfunction $wrapNodes(selection, createElement, wrappingElement = null) {\n  const anchorAndFocus = selection.getStartEndPoints();\n  const anchor = anchorAndFocus ? anchorAndFocus[0] : null;\n  const nodes = selection.getNodes();\n  const nodesLength = nodes.length;\n  if (anchor !== null && (nodesLength === 0 || nodesLength === 1 && anchor.type === 'element' && anchor.getNode().getChildrenSize() === 0)) {\n    const target = anchor.type === 'text' ? anchor.getNode().getParentOrThrow() : anchor.getNode();\n    const children = target.getChildren();\n    let element = createElement();\n    element.setFormat(target.getFormatType());\n    element.setIndent(target.getIndent());\n    children.forEach(child => element.append(child));\n    if (wrappingElement) {\n      element = wrappingElement.append(element);\n    }\n    target.replace(element);\n    return;\n  }\n  let topLevelNode = null;\n  let descendants = [];\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    // Determine whether wrapping has to be broken down into multiple chunks. This can happen if the\n    // user selected multiple Root-like nodes that have to be treated separately as if they are\n    // their own branch. I.e. you don't want to wrap a whole table, but rather the contents of each\n    // of each of the cell nodes.\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(node)) {\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n      descendants = [];\n      topLevelNode = node;\n    } else if (topLevelNode === null || topLevelNode !== null && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$hasAncestor)(node, topLevelNode)) {\n      descendants.push(node);\n    } else {\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n      descendants = [node];\n    }\n  }\n  $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n}\n\n/**\n * Wraps each node into a new ElementNode.\n * @param selection - The selection of nodes to wrap.\n * @param nodes - An array of nodes, generally the descendants of the selection.\n * @param nodesLength - The length of nodes.\n * @param createElement - A function that creates the wrapping ElementNode. eg. $createParagraphNode.\n * @param wrappingElement - An element to wrap all the nodes into.\n * @returns\n */\nfunction $wrapNodesImpl(selection, nodes, nodesLength, createElement, wrappingElement = null) {\n  if (nodes.length === 0) {\n    return;\n  }\n  const firstNode = nodes[0];\n  const elementMapping = new Map();\n  const elements = [];\n  // The below logic is to find the right target for us to\n  // either insertAfter/insertBefore/append the corresponding\n  // elements to. This is made more complicated due to nested\n  // structures.\n  let target = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(firstNode) ? firstNode : firstNode.getParentOrThrow();\n  if (target.isInline()) {\n    target = target.getParentOrThrow();\n  }\n  let targetIsPrevSibling = false;\n  while (target !== null) {\n    const prevSibling = target.getPreviousSibling();\n    if (prevSibling !== null) {\n      target = prevSibling;\n      targetIsPrevSibling = true;\n      break;\n    }\n    target = target.getParentOrThrow();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(target)) {\n      break;\n    }\n  }\n  const emptyElements = new Set();\n\n  // Find any top level empty elements\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && node.getChildrenSize() === 0) {\n      emptyElements.add(node.getKey());\n    }\n  }\n  const movedNodes = new Set();\n\n  // Move out all leaf nodes into our elements array.\n  // If we find a top level empty element, also move make\n  // an element for that.\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    let parent = node.getParent();\n    if (parent !== null && parent.isInline()) {\n      parent = parent.getParent();\n    }\n    if (parent !== null && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isLeafNode)(node) && !movedNodes.has(node.getKey())) {\n      const parentKey = parent.getKey();\n      if (elementMapping.get(parentKey) === undefined) {\n        const targetElement = createElement();\n        targetElement.setFormat(parent.getFormatType());\n        targetElement.setIndent(parent.getIndent());\n        elements.push(targetElement);\n        elementMapping.set(parentKey, targetElement);\n        // Move node and its siblings to the new\n        // element.\n        parent.getChildren().forEach(child => {\n          targetElement.append(child);\n          movedNodes.add(child.getKey());\n          if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(child)) {\n            // Skip nested leaf nodes if the parent has already been moved\n            child.getChildrenKeys().forEach(key => movedNodes.add(key));\n          }\n        });\n        $removeParentEmptyElements(parent);\n      }\n    } else if (emptyElements.has(node.getKey())) {\n      if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node)) {\n        throw Error(`Expected node in emptyElements to be an ElementNode`);\n      }\n      const targetElement = createElement();\n      targetElement.setFormat(node.getFormatType());\n      targetElement.setIndent(node.getIndent());\n      elements.push(targetElement);\n      node.remove(true);\n    }\n  }\n  if (wrappingElement !== null) {\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      wrappingElement.append(element);\n    }\n  }\n  let lastElement = null;\n\n  // If our target is Root-like, let's see if we can re-adjust\n  // so that the target is the first child instead.\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(target)) {\n    if (targetIsPrevSibling) {\n      if (wrappingElement !== null) {\n        target.insertAfter(wrappingElement);\n      } else {\n        for (let i = elements.length - 1; i >= 0; i--) {\n          const element = elements[i];\n          target.insertAfter(element);\n        }\n      }\n    } else {\n      const firstChild = target.getFirstChild();\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(firstChild)) {\n        target = firstChild;\n      }\n      if (firstChild === null) {\n        if (wrappingElement) {\n          target.append(wrappingElement);\n        } else {\n          for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            target.append(element);\n            lastElement = element;\n          }\n        }\n      } else {\n        if (wrappingElement !== null) {\n          firstChild.insertBefore(wrappingElement);\n        } else {\n          for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            firstChild.insertBefore(element);\n            lastElement = element;\n          }\n        }\n      }\n    }\n  } else {\n    if (wrappingElement) {\n      target.insertAfter(wrappingElement);\n    } else {\n      for (let i = elements.length - 1; i >= 0; i--) {\n        const element = elements[i];\n        target.insertAfter(element);\n        lastElement = element;\n      }\n    }\n  }\n  const prevSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getPreviousSelection)();\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(prevSelection) && isPointAttached(prevSelection.anchor) && isPointAttached(prevSelection.focus)) {\n    (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(prevSelection.clone());\n  } else if (lastElement !== null) {\n    lastElement.selectEnd();\n  } else {\n    selection.dirty = true;\n  }\n}\n\n/**\n * Determines if the default character selection should be overridden. Used with DecoratorNodes\n * @param selection - The selection whose default character selection may need to be overridden.\n * @param isBackward - Is the selection backwards (the focus comes before the anchor)?\n * @returns true if it should be overridden, false if not.\n */\nfunction $shouldOverrideDefaultCharacterSelection(selection, isBackward) {\n  const possibleNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getAdjacentNode)(selection.focus, isBackward);\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isDecoratorNode)(possibleNode) && !possibleNode.isIsolated() || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(possibleNode) && !possibleNode.isInline() && !possibleNode.canBeEmpty();\n}\n\n/**\n * Moves the selection according to the arguments.\n * @param selection - The selected text or nodes.\n * @param isHoldingShift - Is the shift key being held down during the operation.\n * @param isBackward - Is the selection selected backwards (the focus comes before the anchor)?\n * @param granularity - The distance to adjust the current selection.\n */\nfunction $moveCaretSelection(selection, isHoldingShift, isBackward, granularity) {\n  selection.modify(isHoldingShift ? 'extend' : 'move', isBackward, granularity);\n}\n\n/**\n * Tests a parent element for right to left direction.\n * @param selection - The selection whose parent is to be tested.\n * @returns true if the selections' parent element has a direction of 'rtl' (right to left), false otherwise.\n */\nfunction $isParentElementRTL(selection) {\n  const anchorNode = selection.anchor.getNode();\n  const parent = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootNode)(anchorNode) ? anchorNode : anchorNode.getParentOrThrow();\n  return parent.getDirection() === 'rtl';\n}\n\n/**\n * Moves selection by character according to arguments.\n * @param selection - The selection of the characters to move.\n * @param isHoldingShift - Is the shift key being held down during the operation.\n * @param isBackward - Is the selection backward (the focus comes before the anchor)?\n */\nfunction $moveCharacter(selection, isHoldingShift, isBackward) {\n  const isRTL = $isParentElementRTL(selection);\n  $moveCaretSelection(selection, isHoldingShift, isBackward ? !isRTL : isRTL, 'character');\n}\n\n/**\n * Returns the current value of a CSS property for Nodes, if set. If not set, it returns the defaultValue.\n * @param node - The node whose style value to get.\n * @param styleProperty - The CSS style property.\n * @param defaultValue - The default value for the property.\n * @returns The value of the property for node.\n */\nfunction $getNodeStyleValueForProperty(node, styleProperty, defaultValue) {\n  const css = node.getStyle();\n  const styleObject = getStyleObjectFromCSS(css);\n  if (styleObject !== null) {\n    return styleObject[styleProperty] || defaultValue;\n  }\n  return defaultValue;\n}\n\n/**\n * Returns the current value of a CSS property for TextNodes in the Selection, if set. If not set, it returns the defaultValue.\n * If all TextNodes do not have the same value, it returns an empty string.\n * @param selection - The selection of TextNodes whose value to find.\n * @param styleProperty - The CSS style property.\n * @param defaultValue - The default value for the property, defaults to an empty string.\n * @returns The value of the property for the selected TextNodes.\n */\nfunction $getSelectionStyleValueForProperty(selection, styleProperty, defaultValue = '') {\n  let styleValue = null;\n  const nodes = selection.getNodes();\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const isBackward = selection.isBackward();\n  const endOffset = isBackward ? focus.offset : anchor.offset;\n  const endNode = isBackward ? focus.getNode() : anchor.getNode();\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) && selection.isCollapsed() && selection.style !== '') {\n    const css = selection.style;\n    const styleObject = getStyleObjectFromCSS(css);\n    if (styleObject !== null && styleProperty in styleObject) {\n      return styleObject[styleProperty];\n    }\n  }\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n\n    // if no actual characters in the end node are selected, we don't\n    // include it in the selection for purposes of determining style\n    // value\n    if (i !== 0 && endOffset === 0 && node.is(endNode)) {\n      continue;\n    }\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(node)) {\n      const nodeStyleValue = $getNodeStyleValueForProperty(node, styleProperty, defaultValue);\n      if (styleValue === null) {\n        styleValue = nodeStyleValue;\n      } else if (styleValue !== nodeStyleValue) {\n        // multiple text nodes are in the selection and they don't all\n        // have the same style.\n        styleValue = '';\n        break;\n      }\n    }\n  }\n  return styleValue === null ? defaultValue : styleValue;\n}\n\n/**\n * This function is for internal use of the library.\n * Please do not use it as it may change in the future.\n */\nfunction INTERNAL_$isBlock(node) {\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isDecoratorNode)(node)) {\n    return false;\n  }\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(node)) {\n    return false;\n  }\n  const firstChild = node.getFirstChild();\n  const isLeafElement = firstChild === null || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isLineBreakNode)(firstChild) || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(firstChild) || firstChild.isInline();\n  return !node.isInline() && node.canBeEmpty() !== false && isLeafElement;\n}\nfunction $getAncestor(node, predicate) {\n  let parent = node;\n  while (parent !== null && parent.getParent() !== null && !predicate(parent)) {\n    parent = parent.getParentOrThrow();\n  }\n  return predicate(parent) ? parent : null;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @deprecated renamed to {@link $trimTextContentFromAnchor} by @lexical/eslint-plugin rules-of-lexical */\nconst trimTextContentFromAnchor = $trimTextContentFromAnchor;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9zZWxlY3Rpb24vTGV4aWNhbFNlbGVjdGlvbi5kZXYubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVzVTtBQUMzUTs7QUFFM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLG9EQUFXO0FBQ2pCO0FBQ0E7QUFDQSxNQUFNLG9EQUFXO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxrQkFBa0IsMEJBQTBCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixNQUFNLElBQUksZUFBZTtBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDZEQUFvQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sdURBQWM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSx1REFBYztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdURBQWM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLG9EQUFXO0FBQ3BCO0FBQ0E7QUFDQSwrREFBK0Qsb0RBQVc7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHNEQUFhO0FBQ3RDLFlBQVksb0RBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw4REFBcUI7QUFDbkQ7QUFDQTtBQUNBLDJCQUEyQix3REFBZTtBQUMxQztBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZLDBEQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHlCQUF5Qix3REFBZTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxJQUFJLEtBQUs7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLHNCQUFzQjtBQUNsRztBQUNBO0FBQ0EsaUNBQWlDLDBEQUFpQjtBQUNsRDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzREFBYTtBQUNqQyxPQUFPLDBEQUFpQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxvREFBVztBQUNqQjtBQUNBLFFBQVEsb0RBQVc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRLG9EQUFXO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLDREQUFtQjtBQUM3QjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLElBQUk7QUFDSixRQUFRLG9EQUFXO0FBQ25CLGdDQUFnQyw0REFBbUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvREFBVztBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0NBQStDLDREQUFtQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0EsVUFBVSxvREFBVztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixpREFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsdURBQWM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNERBQW1CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw0REFBbUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsTUFBTSwyREFBMkQscURBQVk7QUFDN0U7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVEQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNERBQW1CO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBLFFBQVEsdURBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG9EQUFXO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdURBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxNQUFNO0FBQ04sV0FBVyx1REFBYztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSw0REFBbUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsVUFBVSx1REFBYztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLDBCQUEwQixxQkFBcUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWLDBCQUEwQixxQkFBcUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTix3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsOERBQXFCO0FBQzdDLE1BQU0sMERBQWlCO0FBQ3ZCLElBQUksc0RBQWE7QUFDakIsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix5REFBZ0I7QUFDdkMsU0FBUyx5REFBZ0IsZ0RBQWdELHVEQUFjO0FBQ3ZGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG9EQUFXO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSwwREFBaUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9EQUFXO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0seURBQWdCO0FBQ3RCO0FBQ0E7QUFDQSxPQUFPLHVEQUFjLFVBQVUsNERBQW1CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyx5REFBZ0IsZ0JBQWdCLG9EQUFXO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsa0NBQWtDO0FBQzlEOztBQUVtYSIsInNvdXJjZXMiOlsiL1VzZXJzL2xlaS9ob21lL3VuZGVyZy90aGVhdHJlL3kzL3NlZ3AvbWlsa3VwL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9zZWxlY3Rpb24vTGV4aWNhbFNlbGVjdGlvbi5kZXYubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuaW1wb3J0IHsgJGlzVGV4dE5vZGUsICRnZXRDaGFyYWN0ZXJPZmZzZXRzLCAkaXNFbGVtZW50Tm9kZSwgJGlzUm9vdE5vZGUsICRnZXROb2RlQnlLZXksICRnZXRQcmV2aW91c1NlbGVjdGlvbiwgJGNyZWF0ZVRleHROb2RlLCAkaXNSYW5nZVNlbGVjdGlvbiwgJGdldFNlbGVjdGlvbiwgJGlzVG9rZW5PclNlZ21lbnRlZCwgJGdldFJvb3QsICRpc1Jvb3RPclNoYWRvd1Jvb3QsICRoYXNBbmNlc3RvciwgJGlzTGVhZk5vZGUsICRzZXRTZWxlY3Rpb24sICRnZXRBZGphY2VudE5vZGUsICRpc0RlY29yYXRvck5vZGUsICRpc0xpbmVCcmVha05vZGUgfSBmcm9tICdsZXhpY2FsJztcbmV4cG9ydCB7ICRjbG9uZVdpdGhQcm9wZXJ0aWVzLCAkc2VsZWN0QWxsIH0gZnJvbSAnbGV4aWNhbCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmNvbnN0IENTU19UT19TVFlMRVMgPSBuZXcgTWFwKCk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gZ2V0RE9NVGV4dE5vZGUoZWxlbWVudCkge1xuICBsZXQgbm9kZSA9IGVsZW1lbnQ7XG4gIHdoaWxlIChub2RlICE9IG51bGwpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBub2RlID0gbm9kZS5maXJzdENoaWxkO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0RE9NSW5kZXhXaXRoaW5QYXJlbnQobm9kZSkge1xuICBjb25zdCBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XG4gIGlmIChwYXJlbnQgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignU2hvdWxkIG5ldmVyIGhhcHBlbicpO1xuICB9XG4gIHJldHVybiBbcGFyZW50LCBBcnJheS5mcm9tKHBhcmVudC5jaGlsZE5vZGVzKS5pbmRleE9mKG5vZGUpXTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc2VsZWN0aW9uIHJhbmdlIGZvciB0aGUgRE9NLlxuICogQHBhcmFtIGVkaXRvciAtIFRoZSBsZXhpY2FsIGVkaXRvci5cbiAqIEBwYXJhbSBhbmNob3JOb2RlIC0gVGhlIGFuY2hvciBub2RlIG9mIGEgc2VsZWN0aW9uLlxuICogQHBhcmFtIF9hbmNob3JPZmZzZXQgLSBUaGUgYW1vdW50IG9mIHNwYWNlIG9mZnNldCBmcm9tIHRoZSBhbmNob3IgdG8gdGhlIGZvY3VzLlxuICogQHBhcmFtIGZvY3VzTm9kZSAtIFRoZSBjdXJyZW50IGZvY3VzLlxuICogQHBhcmFtIF9mb2N1c09mZnNldCAtIFRoZSBhbW91bnQgb2Ygc3BhY2Ugb2Zmc2V0IGZyb20gdGhlIGZvY3VzIHRvIHRoZSBhbmNob3IuXG4gKiBAcmV0dXJucyBUaGUgcmFuZ2Ugb2Ygc2VsZWN0aW9uIGZvciB0aGUgRE9NIHRoYXQgd2FzIGNyZWF0ZWQuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURPTVJhbmdlKGVkaXRvciwgYW5jaG9yTm9kZSwgX2FuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBfZm9jdXNPZmZzZXQpIHtcbiAgY29uc3QgYW5jaG9yS2V5ID0gYW5jaG9yTm9kZS5nZXRLZXkoKTtcbiAgY29uc3QgZm9jdXNLZXkgPSBmb2N1c05vZGUuZ2V0S2V5KCk7XG4gIGNvbnN0IHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgbGV0IGFuY2hvckRPTSA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkoYW5jaG9yS2V5KTtcbiAgbGV0IGZvY3VzRE9NID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleShmb2N1c0tleSk7XG4gIGxldCBhbmNob3JPZmZzZXQgPSBfYW5jaG9yT2Zmc2V0O1xuICBsZXQgZm9jdXNPZmZzZXQgPSBfZm9jdXNPZmZzZXQ7XG4gIGlmICgkaXNUZXh0Tm9kZShhbmNob3JOb2RlKSkge1xuICAgIGFuY2hvckRPTSA9IGdldERPTVRleHROb2RlKGFuY2hvckRPTSk7XG4gIH1cbiAgaWYgKCRpc1RleHROb2RlKGZvY3VzTm9kZSkpIHtcbiAgICBmb2N1c0RPTSA9IGdldERPTVRleHROb2RlKGZvY3VzRE9NKTtcbiAgfVxuICBpZiAoYW5jaG9yTm9kZSA9PT0gdW5kZWZpbmVkIHx8IGZvY3VzTm9kZSA9PT0gdW5kZWZpbmVkIHx8IGFuY2hvckRPTSA9PT0gbnVsbCB8fCBmb2N1c0RPTSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChhbmNob3JET00ubm9kZU5hbWUgPT09ICdCUicpIHtcbiAgICBbYW5jaG9yRE9NLCBhbmNob3JPZmZzZXRdID0gZ2V0RE9NSW5kZXhXaXRoaW5QYXJlbnQoYW5jaG9yRE9NKTtcbiAgfVxuICBpZiAoZm9jdXNET00ubm9kZU5hbWUgPT09ICdCUicpIHtcbiAgICBbZm9jdXNET00sIGZvY3VzT2Zmc2V0XSA9IGdldERPTUluZGV4V2l0aGluUGFyZW50KGZvY3VzRE9NKTtcbiAgfVxuICBjb25zdCBmaXJzdENoaWxkID0gYW5jaG9yRE9NLmZpcnN0Q2hpbGQ7XG4gIGlmIChhbmNob3JET00gPT09IGZvY3VzRE9NICYmIGZpcnN0Q2hpbGQgIT0gbnVsbCAmJiBmaXJzdENoaWxkLm5vZGVOYW1lID09PSAnQlInICYmIGFuY2hvck9mZnNldCA9PT0gMCAmJiBmb2N1c09mZnNldCA9PT0gMCkge1xuICAgIGZvY3VzT2Zmc2V0ID0gMTtcbiAgfVxuICB0cnkge1xuICAgIHJhbmdlLnNldFN0YXJ0KGFuY2hvckRPTSwgYW5jaG9yT2Zmc2V0KTtcbiAgICByYW5nZS5zZXRFbmQoZm9jdXNET00sIGZvY3VzT2Zmc2V0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChyYW5nZS5jb2xsYXBzZWQgJiYgKGFuY2hvck9mZnNldCAhPT0gZm9jdXNPZmZzZXQgfHwgYW5jaG9yS2V5ICE9PSBmb2N1c0tleSkpIHtcbiAgICAvLyBSYW5nZSBpcyBiYWNrd2FyZHMsIHdlIG5lZWQgdG8gcmV2ZXJzZSBpdFxuICAgIHJhbmdlLnNldFN0YXJ0KGZvY3VzRE9NLCBmb2N1c09mZnNldCk7XG4gICAgcmFuZ2Uuc2V0RW5kKGFuY2hvckRPTSwgYW5jaG9yT2Zmc2V0KTtcbiAgfVxuICByZXR1cm4gcmFuZ2U7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBET01SZWN0cywgZ2VuZXJhbGx5IHVzZWQgdG8gaGVscCB0aGUgZWRpdG9yIGZpbmQgYSBzcGVjaWZpYyBsb2NhdGlvbiBvbiB0aGUgc2NyZWVuLlxuICogQHBhcmFtIGVkaXRvciAtIFRoZSBsZXhpY2FsIGVkaXRvclxuICogQHBhcmFtIHJhbmdlIC0gQSBmcmFnbWVudCBvZiBhIGRvY3VtZW50IHRoYXQgY2FuIGNvbnRhaW4gbm9kZXMgYW5kIHBhcnRzIG9mIHRleHQgbm9kZXMuXG4gKiBAcmV0dXJucyBUaGUgc2VsZWN0aW9uUmVjdHMgYXMgYW4gYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJlY3RzRnJvbURPTVJhbmdlKGVkaXRvciwgcmFuZ2UpIHtcbiAgY29uc3Qgcm9vdEVsZW1lbnQgPSBlZGl0b3IuZ2V0Um9vdEVsZW1lbnQoKTtcbiAgaWYgKHJvb3RFbGVtZW50ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGNvbnN0IHJvb3RSZWN0ID0gcm9vdEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGNvbnN0IGNvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHJvb3RFbGVtZW50KTtcbiAgY29uc3Qgcm9vdFBhZGRpbmcgPSBwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGUucGFkZGluZ0xlZnQpICsgcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlLnBhZGRpbmdSaWdodCk7XG4gIGNvbnN0IHNlbGVjdGlvblJlY3RzID0gQXJyYXkuZnJvbShyYW5nZS5nZXRDbGllbnRSZWN0cygpKTtcbiAgbGV0IHNlbGVjdGlvblJlY3RzTGVuZ3RoID0gc2VsZWN0aW9uUmVjdHMubGVuZ3RoO1xuICAvL3NvcnQgcmVjdHMgZnJvbSB0b3AgbGVmdCB0byBib3R0b20gcmlnaHQuXG4gIHNlbGVjdGlvblJlY3RzLnNvcnQoKGEsIGIpID0+IHtcbiAgICBjb25zdCB0b3AgPSBhLnRvcCAtIGIudG9wO1xuICAgIC8vIFNvbWUgcmVjdHMgbWF0Y2ggcG9zaXRpb24gY2xvc2VseSwgYnV0IG5vdCBwZXJmZWN0bHksXG4gICAgLy8gc28gd2UgZ2l2ZSBhIDNweCB0b2xlcmFuY2UuXG4gICAgaWYgKE1hdGguYWJzKHRvcCkgPD0gMykge1xuICAgICAgcmV0dXJuIGEubGVmdCAtIGIubGVmdDtcbiAgICB9XG4gICAgcmV0dXJuIHRvcDtcbiAgfSk7XG4gIGxldCBwcmV2UmVjdDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWxlY3Rpb25SZWN0c0xlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2VsZWN0aW9uUmVjdCA9IHNlbGVjdGlvblJlY3RzW2ldO1xuICAgIC8vIEV4Y2x1ZGUgcmVjdHMgdGhhdCBvdmVybGFwIHByZWNlZGluZyBSZWN0cyBpbiB0aGUgc29ydGVkIGxpc3QuXG4gICAgY29uc3QgaXNPdmVybGFwcGluZ1JlY3QgPSBwcmV2UmVjdCAmJiBwcmV2UmVjdC50b3AgPD0gc2VsZWN0aW9uUmVjdC50b3AgJiYgcHJldlJlY3QudG9wICsgcHJldlJlY3QuaGVpZ2h0ID4gc2VsZWN0aW9uUmVjdC50b3AgJiYgcHJldlJlY3QubGVmdCArIHByZXZSZWN0LndpZHRoID4gc2VsZWN0aW9uUmVjdC5sZWZ0O1xuICAgIC8vIEV4Y2x1ZGUgc2VsZWN0aW9ucyB0aGF0IHNwYW4gdGhlIGVudGlyZSBlbGVtZW50XG4gICAgY29uc3Qgc2VsZWN0aW9uU3BhbnNFbGVtZW50ID0gc2VsZWN0aW9uUmVjdC53aWR0aCArIHJvb3RQYWRkaW5nID09PSByb290UmVjdC53aWR0aDtcbiAgICBpZiAoaXNPdmVybGFwcGluZ1JlY3QgfHwgc2VsZWN0aW9uU3BhbnNFbGVtZW50KSB7XG4gICAgICBzZWxlY3Rpb25SZWN0cy5zcGxpY2UoaS0tLCAxKTtcbiAgICAgIHNlbGVjdGlvblJlY3RzTGVuZ3RoLS07XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcHJldlJlY3QgPSBzZWxlY3Rpb25SZWN0O1xuICB9XG4gIHJldHVybiBzZWxlY3Rpb25SZWN0cztcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgc3R5bGVzIGFuZCB0aGVpciB2YWx1ZXMgcHJvdmlkZWQgaW4gdGhlIENTUyBzdHJpbmcuXG4gKiBAcGFyYW0gY3NzIC0gVGhlIENTUyBzdHJpbmcgb2Ygc3R5bGVzIGFuZCB0aGVpciB2YWx1ZXMuXG4gKiBAcmV0dXJucyBUaGUgc3R5bGVPYmplY3QgY29udGFpbmluZyBhbGwgdGhlIHN0eWxlcyBhbmQgdGhlaXIgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBnZXRTdHlsZU9iamVjdEZyb21SYXdDU1MoY3NzKSB7XG4gIGNvbnN0IHN0eWxlT2JqZWN0ID0ge307XG4gIGlmICghY3NzKSB7XG4gICAgcmV0dXJuIHN0eWxlT2JqZWN0O1xuICB9XG4gIGNvbnN0IHN0eWxlcyA9IGNzcy5zcGxpdCgnOycpO1xuICBmb3IgKGNvbnN0IHN0eWxlIG9mIHN0eWxlcykge1xuICAgIGlmIChzdHlsZSAhPT0gJycpIHtcbiAgICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IHN0eWxlLnNwbGl0KC86KFteXSspLyk7IC8vIHNwbGl0IG9uIGZpcnN0IGNvbG9uXG4gICAgICBpZiAoa2V5ICYmIHZhbHVlKSB7XG4gICAgICAgIHN0eWxlT2JqZWN0W2tleS50cmltKCldID0gdmFsdWUudHJpbSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gc3R5bGVPYmplY3Q7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBDU1Mgc3RyaW5nLCByZXR1cm5zIGFuIG9iamVjdCBmcm9tIHRoZSBzdHlsZSBjYWNoZS5cbiAqIEBwYXJhbSBjc3MgLSBUaGUgQ1NTIHByb3BlcnR5IGFzIGEgc3RyaW5nLlxuICogQHJldHVybnMgVGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBDU1MgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGdldFN0eWxlT2JqZWN0RnJvbUNTUyhjc3MpIHtcbiAgbGV0IHZhbHVlID0gQ1NTX1RPX1NUWUxFUy5nZXQoY3NzKTtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICB2YWx1ZSA9IGdldFN0eWxlT2JqZWN0RnJvbVJhd0NTUyhjc3MpO1xuICAgIENTU19UT19TVFlMRVMuc2V0KGNzcywgdmFsdWUpO1xuICB9XG4gIHtcbiAgICAvLyBGcmVlemUgdGhlIHZhbHVlIGluIERFViB0byBwcmV2ZW50IGFjY2lkZW50YWwgbXV0YXRpb25zXG4gICAgT2JqZWN0LmZyZWV6ZSh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIENTUyBzdHlsZXMgZnJvbSB0aGUgc3R5bGUgb2JqZWN0LlxuICogQHBhcmFtIHN0eWxlcyAtIFRoZSBzdHlsZSBvYmplY3QgY29udGFpbmluZyB0aGUgc3R5bGVzIHRvIGdldC5cbiAqIEByZXR1cm5zIEEgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIENTUyBzdHlsZXMgYW5kIHRoZWlyIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0Q1NTRnJvbVN0eWxlT2JqZWN0KHN0eWxlcykge1xuICBsZXQgY3NzID0gJyc7XG4gIGZvciAoY29uc3Qgc3R5bGUgaW4gc3R5bGVzKSB7XG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICBjc3MgKz0gYCR7c3R5bGV9OiAke3N0eWxlc1tzdHlsZV19O2A7XG4gICAgfVxuICB9XG4gIHJldHVybiBjc3M7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLyoqXG4gKiBHZW5lcmFsbHkgdXNlZCB0byBhcHBlbmQgdGV4dCBjb250ZW50IHRvIEhUTUwgYW5kIEpTT04uIEdyYWJzIHRoZSB0ZXh0IGNvbnRlbnQgYW5kIFwic2xpY2VzXCJcbiAqIGl0IHRvIGJlIGdlbmVyYXRlZCBpbnRvIHRoZSBuZXcgVGV4dE5vZGUuXG4gKiBAcGFyYW0gc2VsZWN0aW9uIC0gVGhlIHNlbGVjdGlvbiBjb250YWluaW5nIHRoZSBub2RlIHdob3NlIFRleHROb2RlIGlzIHRvIGJlIGVkaXRlZC5cbiAqIEBwYXJhbSB0ZXh0Tm9kZSAtIFRoZSBUZXh0Tm9kZSB0byBiZSBlZGl0ZWQuXG4gKiBAcmV0dXJucyBUaGUgdXBkYXRlZCBUZXh0Tm9kZS5cbiAqL1xuZnVuY3Rpb24gJHNsaWNlU2VsZWN0ZWRUZXh0Tm9kZUNvbnRlbnQoc2VsZWN0aW9uLCB0ZXh0Tm9kZSkge1xuICBjb25zdCBhbmNob3JBbmRGb2N1cyA9IHNlbGVjdGlvbi5nZXRTdGFydEVuZFBvaW50cygpO1xuICBpZiAodGV4dE5vZGUuaXNTZWxlY3RlZChzZWxlY3Rpb24pICYmICF0ZXh0Tm9kZS5pc1NlZ21lbnRlZCgpICYmICF0ZXh0Tm9kZS5pc1Rva2VuKCkgJiYgYW5jaG9yQW5kRm9jdXMgIT09IG51bGwpIHtcbiAgICBjb25zdCBbYW5jaG9yLCBmb2N1c10gPSBhbmNob3JBbmRGb2N1cztcbiAgICBjb25zdCBpc0JhY2t3YXJkID0gc2VsZWN0aW9uLmlzQmFja3dhcmQoKTtcbiAgICBjb25zdCBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgICBjb25zdCBmb2N1c05vZGUgPSBmb2N1cy5nZXROb2RlKCk7XG4gICAgY29uc3QgaXNBbmNob3IgPSB0ZXh0Tm9kZS5pcyhhbmNob3JOb2RlKTtcbiAgICBjb25zdCBpc0ZvY3VzID0gdGV4dE5vZGUuaXMoZm9jdXNOb2RlKTtcbiAgICBpZiAoaXNBbmNob3IgfHwgaXNGb2N1cykge1xuICAgICAgY29uc3QgW2FuY2hvck9mZnNldCwgZm9jdXNPZmZzZXRdID0gJGdldENoYXJhY3Rlck9mZnNldHMoc2VsZWN0aW9uKTtcbiAgICAgIGNvbnN0IGlzU2FtZSA9IGFuY2hvck5vZGUuaXMoZm9jdXNOb2RlKTtcbiAgICAgIGNvbnN0IGlzRmlyc3QgPSB0ZXh0Tm9kZS5pcyhpc0JhY2t3YXJkID8gZm9jdXNOb2RlIDogYW5jaG9yTm9kZSk7XG4gICAgICBjb25zdCBpc0xhc3QgPSB0ZXh0Tm9kZS5pcyhpc0JhY2t3YXJkID8gYW5jaG9yTm9kZSA6IGZvY3VzTm9kZSk7XG4gICAgICBsZXQgc3RhcnRPZmZzZXQgPSAwO1xuICAgICAgbGV0IGVuZE9mZnNldCA9IHVuZGVmaW5lZDtcbiAgICAgIGlmIChpc1NhbWUpIHtcbiAgICAgICAgc3RhcnRPZmZzZXQgPSBhbmNob3JPZmZzZXQgPiBmb2N1c09mZnNldCA/IGZvY3VzT2Zmc2V0IDogYW5jaG9yT2Zmc2V0O1xuICAgICAgICBlbmRPZmZzZXQgPSBhbmNob3JPZmZzZXQgPiBmb2N1c09mZnNldCA/IGFuY2hvck9mZnNldCA6IGZvY3VzT2Zmc2V0O1xuICAgICAgfSBlbHNlIGlmIChpc0ZpcnN0KSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IGlzQmFja3dhcmQgPyBmb2N1c09mZnNldCA6IGFuY2hvck9mZnNldDtcbiAgICAgICAgc3RhcnRPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIGVuZE9mZnNldCA9IHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSBpZiAoaXNMYXN0KSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IGlzQmFja3dhcmQgPyBhbmNob3JPZmZzZXQgOiBmb2N1c09mZnNldDtcbiAgICAgICAgc3RhcnRPZmZzZXQgPSAwO1xuICAgICAgICBlbmRPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICB9XG4gICAgICB0ZXh0Tm9kZS5fX3RleHQgPSB0ZXh0Tm9kZS5fX3RleHQuc2xpY2Uoc3RhcnRPZmZzZXQsIGVuZE9mZnNldCk7XG4gICAgICByZXR1cm4gdGV4dE5vZGU7XG4gICAgfVxuICB9XG4gIHJldHVybiB0ZXh0Tm9kZTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBpcyBhdCB0aGUgZW5kIG9mIHRoZSBub2RlLlxuICogQHBhcmFtIHBvaW50IC0gVGhlIHBvaW50IG9mIHRoZSBzZWxlY3Rpb24gdG8gdGVzdC5cbiAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHByb3ZpZGVkIHBvaW50IG9mZnNldCBpcyBpbiB0aGUgbGFzdCBwb3NzaWJsZSBwb3NpdGlvbiwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiAkaXNBdE5vZGVFbmQocG9pbnQpIHtcbiAgaWYgKHBvaW50LnR5cGUgPT09ICd0ZXh0Jykge1xuICAgIHJldHVybiBwb2ludC5vZmZzZXQgPT09IHBvaW50LmdldE5vZGUoKS5nZXRUZXh0Q29udGVudFNpemUoKTtcbiAgfVxuICBjb25zdCBub2RlID0gcG9pbnQuZ2V0Tm9kZSgpO1xuICBpZiAoISRpc0VsZW1lbnROb2RlKG5vZGUpKSB7XG4gICAgdGhyb3cgRXJyb3IoYGlzQXROb2RlRW5kOiBub2RlIG11c3QgYmUgYSBUZXh0Tm9kZSBvciBFbGVtZW50Tm9kZWApO1xuICB9XG4gIHJldHVybiBwb2ludC5vZmZzZXQgPT09IG5vZGUuZ2V0Q2hpbGRyZW5TaXplKCk7XG59XG5cbi8qKlxuICogVHJpbXMgdGV4dCBmcm9tIGEgbm9kZSBpbiBvcmRlciB0byBzaG9ydGVuIGl0LCBlZy4gdG8gZW5mb3JjZSBhIHRleHQncyBtYXggbGVuZ3RoLiBJZiBpdCBkZWxldGVzIHRleHRcbiAqIHRoYXQgaXMgYW4gYW5jZXN0b3Igb2YgdGhlIGFuY2hvciB0aGVuIGl0IHdpbGwgbGVhdmUgMiBpbmRlbnRzLCBvdGhlcndpc2UsIGlmIG5vIHRleHQgY29udGVudCBleGlzdHMsIGl0IGRlbGV0ZXNcbiAqIHRoZSBUZXh0Tm9kZS4gSXQgd2lsbCBtb3ZlIHRoZSBmb2N1cyB0byBlaXRoZXIgdGhlIGVuZCBvZiBhbnkgbGVmdCBvdmVyIHRleHQgb3IgYmVnaW5uaW5nIG9mIGEgbmV3IFRleHROb2RlLlxuICogQHBhcmFtIGVkaXRvciAtIFRoZSBsZXhpY2FsIGVkaXRvci5cbiAqIEBwYXJhbSBhbmNob3IgLSBUaGUgYW5jaG9yIG9mIHRoZSBjdXJyZW50IHNlbGVjdGlvbiwgd2hlcmUgdGhlIHNlbGVjdGlvbiBzaG91bGQgYmUgcG9pbnRpbmcuXG4gKiBAcGFyYW0gZGVsQ291bnQgLSBUaGUgYW1vdW50IG9mIGNoYXJhY3RlcnMgdG8gZGVsZXRlLiBVc2VmdWwgYXMgYSBkeW5hbWljIHZhcmlhYmxlIGVnLiB0ZXh0Q29udGVudFNpemUgLSBtYXhMZW5ndGg7XG4gKi9cbmZ1bmN0aW9uICR0cmltVGV4dENvbnRlbnRGcm9tQW5jaG9yKGVkaXRvciwgYW5jaG9yLCBkZWxDb3VudCkge1xuICAvLyBXb3JrIGZyb20gdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGFuY2hvciBwb2ludFxuICBsZXQgY3VycmVudE5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICBsZXQgcmVtYWluaW5nID0gZGVsQ291bnQ7XG4gIGlmICgkaXNFbGVtZW50Tm9kZShjdXJyZW50Tm9kZSkpIHtcbiAgICBjb25zdCBkZXNjZW5kYW50Tm9kZSA9IGN1cnJlbnROb2RlLmdldERlc2NlbmRhbnRCeUluZGV4KGFuY2hvci5vZmZzZXQpO1xuICAgIGlmIChkZXNjZW5kYW50Tm9kZSAhPT0gbnVsbCkge1xuICAgICAgY3VycmVudE5vZGUgPSBkZXNjZW5kYW50Tm9kZTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKHJlbWFpbmluZyA+IDAgJiYgY3VycmVudE5vZGUgIT09IG51bGwpIHtcbiAgICBpZiAoJGlzRWxlbWVudE5vZGUoY3VycmVudE5vZGUpKSB7XG4gICAgICBjb25zdCBsYXN0RGVzY2VuZGFudCA9IGN1cnJlbnROb2RlLmdldExhc3REZXNjZW5kYW50KCk7XG4gICAgICBpZiAobGFzdERlc2NlbmRhbnQgIT09IG51bGwpIHtcbiAgICAgICAgY3VycmVudE5vZGUgPSBsYXN0RGVzY2VuZGFudDtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IG5leHROb2RlID0gY3VycmVudE5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgbGV0IGFkZGl0aW9uYWxFbGVtZW50V2hpdGVzcGFjZSA9IDA7XG4gICAgaWYgKG5leHROb2RlID09PSBudWxsKSB7XG4gICAgICBsZXQgcGFyZW50ID0gY3VycmVudE5vZGUuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgICAgbGV0IHBhcmVudFNpYmxpbmcgPSBwYXJlbnQuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgICB3aGlsZSAocGFyZW50U2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnQuZ2V0UGFyZW50KCk7XG4gICAgICAgIGlmIChwYXJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICBuZXh0Tm9kZSA9IG51bGw7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50U2libGluZyA9IHBhcmVudC5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgYWRkaXRpb25hbEVsZW1lbnRXaGl0ZXNwYWNlID0gcGFyZW50LmlzSW5saW5lKCkgPyAwIDogMjtcbiAgICAgICAgbmV4dE5vZGUgPSBwYXJlbnRTaWJsaW5nO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgdGV4dCA9IGN1cnJlbnROb2RlLmdldFRleHRDb250ZW50KCk7XG4gICAgLy8gSWYgdGhlIHRleHQgaXMgZW1wdHksIHdlIG5lZWQgdG8gY29uc2lkZXIgYWRkaW5nIGluIHR3byBsaW5lIGJyZWFrcyB0byBtYXRjaFxuICAgIC8vIHRoZSBjb250ZW50IGlmIHdlIHdlcmUgdG8gZ2V0IGl0IGZyb20gaXRzIHBhcmVudC5cbiAgICBpZiAodGV4dCA9PT0gJycgJiYgJGlzRWxlbWVudE5vZGUoY3VycmVudE5vZGUpICYmICFjdXJyZW50Tm9kZS5pc0lubGluZSgpKSB7XG4gICAgICAvLyBUT0RPOiBzaG91bGQgdGhpcyBiZSBoYW5kbGVkIGluIGNvcmU/XG4gICAgICB0ZXh0ID0gJ1xcblxcbic7XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnROb2RlU2l6ZSA9IHRleHQubGVuZ3RoO1xuICAgIGlmICghJGlzVGV4dE5vZGUoY3VycmVudE5vZGUpIHx8IHJlbWFpbmluZyA+PSBjdXJyZW50Tm9kZVNpemUpIHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IGN1cnJlbnROb2RlLmdldFBhcmVudCgpO1xuICAgICAgY3VycmVudE5vZGUucmVtb3ZlKCk7XG4gICAgICBpZiAocGFyZW50ICE9IG51bGwgJiYgcGFyZW50LmdldENoaWxkcmVuU2l6ZSgpID09PSAwICYmICEkaXNSb290Tm9kZShwYXJlbnQpKSB7XG4gICAgICAgIHBhcmVudC5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICAgIHJlbWFpbmluZyAtPSBjdXJyZW50Tm9kZVNpemUgKyBhZGRpdGlvbmFsRWxlbWVudFdoaXRlc3BhY2U7XG4gICAgICBjdXJyZW50Tm9kZSA9IG5leHROb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBrZXkgPSBjdXJyZW50Tm9kZS5nZXRLZXkoKTtcbiAgICAgIC8vIFNlZSBpZiB3ZSBjYW4ganVzdCByZXZlcnQgaXQgdG8gd2hhdCB3YXMgaW4gdGhlIGxhc3QgZWRpdG9yIHN0YXRlXG4gICAgICBjb25zdCBwcmV2VGV4dENvbnRlbnQgPSBlZGl0b3IuZ2V0RWRpdG9yU3RhdGUoKS5yZWFkKCgpID0+IHtcbiAgICAgICAgY29uc3QgcHJldk5vZGUgPSAkZ2V0Tm9kZUJ5S2V5KGtleSk7XG4gICAgICAgIGlmICgkaXNUZXh0Tm9kZShwcmV2Tm9kZSkgJiYgcHJldk5vZGUuaXNTaW1wbGVUZXh0KCkpIHtcbiAgICAgICAgICByZXR1cm4gcHJldk5vZGUuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0pO1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gY3VycmVudE5vZGVTaXplIC0gcmVtYWluaW5nO1xuICAgICAgY29uc3Qgc2xpY2VkVGV4dCA9IHRleHQuc2xpY2UoMCwgb2Zmc2V0KTtcbiAgICAgIGlmIChwcmV2VGV4dENvbnRlbnQgIT09IG51bGwgJiYgcHJldlRleHRDb250ZW50ICE9PSB0ZXh0KSB7XG4gICAgICAgIGNvbnN0IHByZXZTZWxlY3Rpb24gPSAkZ2V0UHJldmlvdXNTZWxlY3Rpb24oKTtcbiAgICAgICAgbGV0IHRhcmdldCA9IGN1cnJlbnROb2RlO1xuICAgICAgICBpZiAoIWN1cnJlbnROb2RlLmlzU2ltcGxlVGV4dCgpKSB7XG4gICAgICAgICAgY29uc3QgdGV4dE5vZGUgPSAkY3JlYXRlVGV4dE5vZGUocHJldlRleHRDb250ZW50KTtcbiAgICAgICAgICBjdXJyZW50Tm9kZS5yZXBsYWNlKHRleHROb2RlKTtcbiAgICAgICAgICB0YXJnZXQgPSB0ZXh0Tm9kZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50Tm9kZS5zZXRUZXh0Q29udGVudChwcmV2VGV4dENvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgkaXNSYW5nZVNlbGVjdGlvbihwcmV2U2VsZWN0aW9uKSAmJiBwcmV2U2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgICAgICBjb25zdCBwcmV2T2Zmc2V0ID0gcHJldlNlbGVjdGlvbi5hbmNob3Iub2Zmc2V0O1xuICAgICAgICAgIHRhcmdldC5zZWxlY3QocHJldk9mZnNldCwgcHJldk9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY3VycmVudE5vZGUuaXNTaW1wbGVUZXh0KCkpIHtcbiAgICAgICAgLy8gU3BsaXQgdGV4dFxuICAgICAgICBjb25zdCBpc1NlbGVjdGVkID0gYW5jaG9yLmtleSA9PT0ga2V5O1xuICAgICAgICBsZXQgYW5jaG9yT2Zmc2V0ID0gYW5jaG9yLm9mZnNldDtcbiAgICAgICAgLy8gTW92ZSBvZmZzZXQgdG8gZW5kIGlmIGl0J3MgbGVzcyB0aGFuIHRoZSByZW1haW5pbmcgbnVtYmVyLCBvdGhlcndpc2VcbiAgICAgICAgLy8gd2UnbGwgaGF2ZSBhIG5lZ2F0aXZlIHNwbGl0U3RhcnQuXG4gICAgICAgIGlmIChhbmNob3JPZmZzZXQgPCByZW1haW5pbmcpIHtcbiAgICAgICAgICBhbmNob3JPZmZzZXQgPSBjdXJyZW50Tm9kZVNpemU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3BsaXRTdGFydCA9IGlzU2VsZWN0ZWQgPyBhbmNob3JPZmZzZXQgLSByZW1haW5pbmcgOiAwO1xuICAgICAgICBjb25zdCBzcGxpdEVuZCA9IGlzU2VsZWN0ZWQgPyBhbmNob3JPZmZzZXQgOiBvZmZzZXQ7XG4gICAgICAgIGlmIChpc1NlbGVjdGVkICYmIHNwbGl0U3RhcnQgPT09IDApIHtcbiAgICAgICAgICBjb25zdCBbZXhjZXNzTm9kZV0gPSBjdXJyZW50Tm9kZS5zcGxpdFRleHQoc3BsaXRTdGFydCwgc3BsaXRFbmQpO1xuICAgICAgICAgIGV4Y2Vzc05vZGUucmVtb3ZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgWywgZXhjZXNzTm9kZV0gPSBjdXJyZW50Tm9kZS5zcGxpdFRleHQoc3BsaXRTdGFydCwgc3BsaXRFbmQpO1xuICAgICAgICAgIGV4Y2Vzc05vZGUucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHRleHROb2RlID0gJGNyZWF0ZVRleHROb2RlKHNsaWNlZFRleHQpO1xuICAgICAgICBjdXJyZW50Tm9kZS5yZXBsYWNlKHRleHROb2RlKTtcbiAgICAgIH1cbiAgICAgIHJlbWFpbmluZyA9IDA7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogR2V0cyB0aGUgVGV4dE5vZGUncyBzdHlsZSBvYmplY3QgYW5kIGFkZHMgdGhlIHN0eWxlcyB0byB0aGUgQ1NTLlxuICogQHBhcmFtIG5vZGUgLSBUaGUgVGV4dE5vZGUgdG8gYWRkIHN0eWxlcyB0by5cbiAqL1xuZnVuY3Rpb24gJGFkZE5vZGVTdHlsZShub2RlKSB7XG4gIGNvbnN0IENTU1RleHQgPSBub2RlLmdldFN0eWxlKCk7XG4gIGNvbnN0IHN0eWxlcyA9IGdldFN0eWxlT2JqZWN0RnJvbVJhd0NTUyhDU1NUZXh0KTtcbiAgQ1NTX1RPX1NUWUxFUy5zZXQoQ1NTVGV4dCwgc3R5bGVzKTtcbn1cbmZ1bmN0aW9uICRwYXRjaFN0eWxlKHRhcmdldCwgcGF0Y2gpIHtcbiAgY29uc3QgcHJldlN0eWxlcyA9IGdldFN0eWxlT2JqZWN0RnJvbUNTUygnZ2V0U3R5bGUnIGluIHRhcmdldCA/IHRhcmdldC5nZXRTdHlsZSgpIDogdGFyZ2V0LnN0eWxlKTtcbiAgY29uc3QgbmV3U3R5bGVzID0gT2JqZWN0LmVudHJpZXMocGF0Y2gpLnJlZHVjZSgoc3R5bGVzLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzdHlsZXNba2V5XSA9IHZhbHVlKHByZXZTdHlsZXNba2V5XSwgdGFyZ2V0KTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICBkZWxldGUgc3R5bGVzW2tleV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlc1trZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBzdHlsZXM7XG4gIH0sIHtcbiAgICAuLi5wcmV2U3R5bGVzXG4gIH0gfHwge30pO1xuICBjb25zdCBuZXdDU1NUZXh0ID0gZ2V0Q1NTRnJvbVN0eWxlT2JqZWN0KG5ld1N0eWxlcyk7XG4gIHRhcmdldC5zZXRTdHlsZShuZXdDU1NUZXh0KTtcbiAgQ1NTX1RPX1NUWUxFUy5zZXQobmV3Q1NTVGV4dCwgbmV3U3R5bGVzKTtcbn1cblxuLyoqXG4gKiBBcHBsaWVzIHRoZSBwcm92aWRlZCBzdHlsZXMgdG8gdGhlIFRleHROb2RlcyBpbiB0aGUgcHJvdmlkZWQgU2VsZWN0aW9uLlxuICogV2lsbCB1cGRhdGUgcGFydGlhbGx5IHNlbGVjdGVkIFRleHROb2RlcyBieSBzcGxpdHRpbmcgdGhlIFRleHROb2RlIGFuZCBhcHBseWluZ1xuICogdGhlIHN0eWxlcyB0byB0aGUgYXBwcm9wcmlhdGUgb25lLlxuICogQHBhcmFtIHNlbGVjdGlvbiAtIFRoZSBzZWxlY3RlZCBub2RlKHMpIHRvIHVwZGF0ZS5cbiAqIEBwYXJhbSBwYXRjaCAtIFRoZSBwYXRjaCB0byBhcHBseSwgd2hpY2ggY2FuIGluY2x1ZGUgbXVsdGlwbGUgc3R5bGVzLiBcXFxce0NTU1Byb3BlcnR5OiB2YWx1ZVxcXFx9IC4gQ2FuIGFsc28gYWNjZXB0IGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBuZXcgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uICRwYXRjaFN0eWxlVGV4dChzZWxlY3Rpb24sIHBhdGNoKSB7XG4gIGlmIChzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSAmJiAkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgJHBhdGNoU3R5bGUoc2VsZWN0aW9uLCBwYXRjaCk7XG4gIH0gZWxzZSB7XG4gICAgJGZvckVhY2hTZWxlY3RlZFRleHROb2RlKHRleHROb2RlID0+IHtcbiAgICAgICRwYXRjaFN0eWxlKHRleHROb2RlLCBwYXRjaCk7XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uICRmb3JFYWNoU2VsZWN0ZWRUZXh0Tm9kZShmbikge1xuICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBzZWxlY3RlZE5vZGVzID0gc2VsZWN0aW9uLmdldE5vZGVzKCk7XG4gIGNvbnN0IHNlbGVjdGVkTm9kZXNMZW5ndGggPSBzZWxlY3RlZE5vZGVzLmxlbmd0aDtcbiAgY29uc3Qge1xuICAgIGFuY2hvcixcbiAgICBmb2N1c1xuICB9ID0gc2VsZWN0aW9uO1xuICBjb25zdCBsYXN0SW5kZXggPSBzZWxlY3RlZE5vZGVzTGVuZ3RoIC0gMTtcbiAgbGV0IGZpcnN0Tm9kZSA9IHNlbGVjdGVkTm9kZXNbMF07XG4gIGxldCBsYXN0Tm9kZSA9IHNlbGVjdGVkTm9kZXNbbGFzdEluZGV4XTtcbiAgY29uc3QgZmlyc3ROb2RlVGV4dCA9IGZpcnN0Tm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICBjb25zdCBmaXJzdE5vZGVUZXh0TGVuZ3RoID0gZmlyc3ROb2RlVGV4dC5sZW5ndGg7XG4gIGNvbnN0IGZvY3VzT2Zmc2V0ID0gZm9jdXMub2Zmc2V0O1xuICBsZXQgYW5jaG9yT2Zmc2V0ID0gYW5jaG9yLm9mZnNldDtcbiAgY29uc3QgaXNCZWZvcmUgPSBhbmNob3IuaXNCZWZvcmUoZm9jdXMpO1xuICBsZXQgc3RhcnRPZmZzZXQgPSBpc0JlZm9yZSA/IGFuY2hvck9mZnNldCA6IGZvY3VzT2Zmc2V0O1xuICBsZXQgZW5kT2Zmc2V0ID0gaXNCZWZvcmUgPyBmb2N1c09mZnNldCA6IGFuY2hvck9mZnNldDtcbiAgY29uc3Qgc3RhcnRUeXBlID0gaXNCZWZvcmUgPyBhbmNob3IudHlwZSA6IGZvY3VzLnR5cGU7XG4gIGNvbnN0IGVuZFR5cGUgPSBpc0JlZm9yZSA/IGZvY3VzLnR5cGUgOiBhbmNob3IudHlwZTtcbiAgY29uc3QgZW5kS2V5ID0gaXNCZWZvcmUgPyBmb2N1cy5rZXkgOiBhbmNob3Iua2V5O1xuXG4gIC8vIFRoaXMgaXMgdGhlIGNhc2Ugd2hlcmUgdGhlIHVzZXIgb25seSBzZWxlY3RlZCB0aGUgdmVyeSBlbmQgb2YgdGhlXG4gIC8vIGZpcnN0IG5vZGUgc28gd2UgZG9uJ3Qgd2FudCB0byBpbmNsdWRlIGl0IGluIHRoZSBmb3JtYXR0aW5nIGNoYW5nZS5cbiAgaWYgKCRpc1RleHROb2RlKGZpcnN0Tm9kZSkgJiYgc3RhcnRPZmZzZXQgPT09IGZpcnN0Tm9kZVRleHRMZW5ndGgpIHtcbiAgICBjb25zdCBuZXh0U2libGluZyA9IGZpcnN0Tm9kZS5nZXROZXh0U2libGluZygpO1xuICAgIGlmICgkaXNUZXh0Tm9kZShuZXh0U2libGluZykpIHtcbiAgICAgIC8vIHdlIGJhc2ljYWxseSBtYWtlIHRoZSBzZWNvbmQgbm9kZSB0aGUgZmlyc3ROb2RlLCBjaGFuZ2luZyBvZmZzZXRzIGFjY29yZGluZ2x5XG4gICAgICBhbmNob3JPZmZzZXQgPSAwO1xuICAgICAgc3RhcnRPZmZzZXQgPSAwO1xuICAgICAgZmlyc3ROb2RlID0gbmV4dFNpYmxpbmc7XG4gICAgfVxuICB9XG5cbiAgLy8gVGhpcyBpcyB0aGUgY2FzZSB3aGVyZSB3ZSBvbmx5IHNlbGVjdGVkIGEgc2luZ2xlIG5vZGVcbiAgaWYgKHNlbGVjdGVkTm9kZXMubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKCRpc1RleHROb2RlKGZpcnN0Tm9kZSkgJiYgZmlyc3ROb2RlLmNhbkhhdmVGb3JtYXQoKSkge1xuICAgICAgc3RhcnRPZmZzZXQgPSBzdGFydFR5cGUgPT09ICdlbGVtZW50JyA/IDAgOiBhbmNob3JPZmZzZXQgPiBmb2N1c09mZnNldCA/IGZvY3VzT2Zmc2V0IDogYW5jaG9yT2Zmc2V0O1xuICAgICAgZW5kT2Zmc2V0ID0gZW5kVHlwZSA9PT0gJ2VsZW1lbnQnID8gZmlyc3ROb2RlVGV4dExlbmd0aCA6IGFuY2hvck9mZnNldCA+IGZvY3VzT2Zmc2V0ID8gYW5jaG9yT2Zmc2V0IDogZm9jdXNPZmZzZXQ7XG5cbiAgICAgIC8vIE5vIGFjdHVhbCB0ZXh0IGlzIHNlbGVjdGVkLCBzbyBkbyBub3RoaW5nLlxuICAgICAgaWYgKHN0YXJ0T2Zmc2V0ID09PSBlbmRPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGUgZW50aXJlIG5vZGUgaXMgc2VsZWN0ZWQgb3IgYSB0b2tlbi9zZWdtZW50LCBzbyBqdXN0IGZvcm1hdCBpdFxuICAgICAgaWYgKCRpc1Rva2VuT3JTZWdtZW50ZWQoZmlyc3ROb2RlKSB8fCBzdGFydE9mZnNldCA9PT0gMCAmJiBlbmRPZmZzZXQgPT09IGZpcnN0Tm9kZVRleHRMZW5ndGgpIHtcbiAgICAgICAgZm4oZmlyc3ROb2RlKTtcbiAgICAgICAgZmlyc3ROb2RlLnNlbGVjdChzdGFydE9mZnNldCwgZW5kT2Zmc2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoZSBub2RlIGlzIHBhcnRpYWxseSBzZWxlY3RlZCwgc28gc3BsaXQgaXQgaW50byB0d28gbm9kZXNcbiAgICAgICAgLy8gYW5kIHN0eWxlIHRoZSBzZWxlY3RlZCBvbmUuXG4gICAgICAgIGNvbnN0IHNwbGl0Tm9kZXMgPSBmaXJzdE5vZGUuc3BsaXRUZXh0KHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpO1xuICAgICAgICBjb25zdCByZXBsYWNlbWVudCA9IHN0YXJ0T2Zmc2V0ID09PSAwID8gc3BsaXROb2Rlc1swXSA6IHNwbGl0Tm9kZXNbMV07XG4gICAgICAgIGZuKHJlcGxhY2VtZW50KTtcbiAgICAgICAgcmVwbGFjZW1lbnQuc2VsZWN0KDAsIGVuZE9mZnNldCAtIHN0YXJ0T2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9IC8vIG11bHRpcGxlIG5vZGVzIHNlbGVjdGVkLlxuICB9IGVsc2Uge1xuICAgIGlmICgkaXNUZXh0Tm9kZShmaXJzdE5vZGUpICYmIHN0YXJ0T2Zmc2V0IDwgZmlyc3ROb2RlLmdldFRleHRDb250ZW50U2l6ZSgpICYmIGZpcnN0Tm9kZS5jYW5IYXZlRm9ybWF0KCkpIHtcbiAgICAgIGlmIChzdGFydE9mZnNldCAhPT0gMCAmJiAhJGlzVG9rZW5PclNlZ21lbnRlZChmaXJzdE5vZGUpKSB7XG4gICAgICAgIC8vIHRoZSBlbnRpcmUgZmlyc3Qgbm9kZSBpc24ndCBzZWxlY3RlZCBhbmQgaXQgaXNuJ3QgYSB0b2tlbiBvciBzZWdtZW50ZWQsIHNvIHNwbGl0IGl0XG4gICAgICAgIGZpcnN0Tm9kZSA9IGZpcnN0Tm9kZS5zcGxpdFRleHQoc3RhcnRPZmZzZXQpWzFdO1xuICAgICAgICBzdGFydE9mZnNldCA9IDA7XG4gICAgICAgIGlmIChpc0JlZm9yZSkge1xuICAgICAgICAgIGFuY2hvci5zZXQoZmlyc3ROb2RlLmdldEtleSgpLCBzdGFydE9mZnNldCwgJ3RleHQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb2N1cy5zZXQoZmlyc3ROb2RlLmdldEtleSgpLCBzdGFydE9mZnNldCwgJ3RleHQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm4oZmlyc3ROb2RlKTtcbiAgICB9XG4gICAgaWYgKCRpc1RleHROb2RlKGxhc3ROb2RlKSAmJiBsYXN0Tm9kZS5jYW5IYXZlRm9ybWF0KCkpIHtcbiAgICAgIGNvbnN0IGxhc3ROb2RlVGV4dCA9IGxhc3ROb2RlLmdldFRleHRDb250ZW50KCk7XG4gICAgICBjb25zdCBsYXN0Tm9kZVRleHRMZW5ndGggPSBsYXN0Tm9kZVRleHQubGVuZ3RoO1xuXG4gICAgICAvLyBUaGUgbGFzdCBub2RlIG1pZ2h0IG5vdCBhY3R1YWxseSBiZSB0aGUgZW5kIG5vZGVcbiAgICAgIC8vXG4gICAgICAvLyBJZiBub3QsIGFzc3VtZSB0aGUgbGFzdCBub2RlIGlzIGZ1bGx5LXNlbGVjdGVkIHVubGVzcyB0aGUgZW5kIG9mZnNldCBpc1xuICAgICAgLy8gemVyby5cbiAgICAgIGlmIChsYXN0Tm9kZS5fX2tleSAhPT0gZW5kS2V5ICYmIGVuZE9mZnNldCAhPT0gMCkge1xuICAgICAgICBlbmRPZmZzZXQgPSBsYXN0Tm9kZVRleHRMZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHRoZSBlbnRpcmUgbGFzdCBub2RlIGlzbid0IHNlbGVjdGVkIGFuZCBpdCBpc24ndCBhIHRva2VuIG9yIHNlZ21lbnRlZCwgc3BsaXQgaXRcbiAgICAgIGlmIChlbmRPZmZzZXQgIT09IGxhc3ROb2RlVGV4dExlbmd0aCAmJiAhJGlzVG9rZW5PclNlZ21lbnRlZChsYXN0Tm9kZSkpIHtcbiAgICAgICAgW2xhc3ROb2RlXSA9IGxhc3ROb2RlLnNwbGl0VGV4dChlbmRPZmZzZXQpO1xuICAgICAgfVxuICAgICAgaWYgKGVuZE9mZnNldCAhPT0gMCB8fCBlbmRUeXBlID09PSAnZWxlbWVudCcpIHtcbiAgICAgICAgZm4obGFzdE5vZGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHN0eWxlIGFsbCB0aGUgdGV4dCBub2RlcyBpbiBiZXR3ZWVuXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBsYXN0SW5kZXg7IGkrKykge1xuICAgICAgY29uc3Qgc2VsZWN0ZWROb2RlID0gc2VsZWN0ZWROb2Rlc1tpXTtcbiAgICAgIGNvbnN0IHNlbGVjdGVkTm9kZUtleSA9IHNlbGVjdGVkTm9kZS5nZXRLZXkoKTtcbiAgICAgIGlmICgkaXNUZXh0Tm9kZShzZWxlY3RlZE5vZGUpICYmIHNlbGVjdGVkTm9kZS5jYW5IYXZlRm9ybWF0KCkgJiYgc2VsZWN0ZWROb2RlS2V5ICE9PSBmaXJzdE5vZGUuZ2V0S2V5KCkgJiYgc2VsZWN0ZWROb2RlS2V5ICE9PSBsYXN0Tm9kZS5nZXRLZXkoKSAmJiAhc2VsZWN0ZWROb2RlLmlzVG9rZW4oKSkge1xuICAgICAgICBmbihzZWxlY3RlZE5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cblxuLyoqXG4gKiBDb252ZXJ0cyBhbGwgbm9kZXMgaW4gdGhlIHNlbGVjdGlvbiB0aGF0IGFyZSBvZiBvbmUgYmxvY2sgdHlwZSB0byBhbm90aGVyLlxuICogQHBhcmFtIHNlbGVjdGlvbiAtIFRoZSBzZWxlY3RlZCBibG9ja3MgdG8gYmUgY29udmVydGVkLlxuICogQHBhcmFtIGNyZWF0ZUVsZW1lbnQgLSBUaGUgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIHRoZSBub2RlLiBlZy4gJGNyZWF0ZVBhcmFncmFwaE5vZGUuXG4gKi9cbmZ1bmN0aW9uICRzZXRCbG9ja3NUeXBlKHNlbGVjdGlvbiwgY3JlYXRlRWxlbWVudCkge1xuICBpZiAoc2VsZWN0aW9uID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGFuY2hvckFuZEZvY3VzID0gc2VsZWN0aW9uLmdldFN0YXJ0RW5kUG9pbnRzKCk7XG4gIGNvbnN0IGFuY2hvciA9IGFuY2hvckFuZEZvY3VzID8gYW5jaG9yQW5kRm9jdXNbMF0gOiBudWxsO1xuICBpZiAoYW5jaG9yICE9PSBudWxsICYmIGFuY2hvci5rZXkgPT09ICdyb290Jykge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KCk7XG4gICAgY29uc3Qgcm9vdCA9ICRnZXRSb290KCk7XG4gICAgY29uc3QgZmlyc3RDaGlsZCA9IHJvb3QuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgIGlmIChmaXJzdENoaWxkKSB7XG4gICAgICBmaXJzdENoaWxkLnJlcGxhY2UoZWxlbWVudCwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJvb3QuYXBwZW5kKGVsZW1lbnQpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgbm9kZXMgPSBzZWxlY3Rpb24uZ2V0Tm9kZXMoKTtcbiAgY29uc3QgZmlyc3RTZWxlY3RlZEJsb2NrID0gYW5jaG9yICE9PSBudWxsID8gJGdldEFuY2VzdG9yKGFuY2hvci5nZXROb2RlKCksIElOVEVSTkFMXyRpc0Jsb2NrKSA6IGZhbHNlO1xuICBpZiAoZmlyc3RTZWxlY3RlZEJsb2NrICYmIG5vZGVzLmluZGV4T2YoZmlyc3RTZWxlY3RlZEJsb2NrKSA9PT0gLTEpIHtcbiAgICBub2Rlcy5wdXNoKGZpcnN0U2VsZWN0ZWRCbG9jayk7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICBpZiAoIUlOVEVSTkFMXyRpc0Jsb2NrKG5vZGUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKCEkaXNFbGVtZW50Tm9kZShub2RlKSkge1xuICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIGJsb2NrIG5vZGUgdG8gYmUgYW4gRWxlbWVudE5vZGVgKTtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQoKTtcbiAgICB0YXJnZXRFbGVtZW50LnNldEZvcm1hdChub2RlLmdldEZvcm1hdFR5cGUoKSk7XG4gICAgdGFyZ2V0RWxlbWVudC5zZXRJbmRlbnQobm9kZS5nZXRJbmRlbnQoKSk7XG4gICAgbm9kZS5yZXBsYWNlKHRhcmdldEVsZW1lbnQsIHRydWUpO1xuICB9XG59XG5mdW5jdGlvbiBpc1BvaW50QXR0YWNoZWQocG9pbnQpIHtcbiAgcmV0dXJuIHBvaW50LmdldE5vZGUoKS5pc0F0dGFjaGVkKCk7XG59XG5mdW5jdGlvbiAkcmVtb3ZlUGFyZW50RW1wdHlFbGVtZW50cyhzdGFydGluZ05vZGUpIHtcbiAgbGV0IG5vZGUgPSBzdGFydGluZ05vZGU7XG4gIHdoaWxlIChub2RlICE9PSBudWxsICYmICEkaXNSb290T3JTaGFkb3dSb290KG5vZGUpKSB7XG4gICAgY29uc3QgbGF0ZXN0ID0gbm9kZS5nZXRMYXRlc3QoKTtcbiAgICBjb25zdCBwYXJlbnROb2RlID0gbm9kZS5nZXRQYXJlbnQoKTtcbiAgICBpZiAobGF0ZXN0LmdldENoaWxkcmVuU2l6ZSgpID09PSAwKSB7XG4gICAgICBub2RlLnJlbW92ZSh0cnVlKTtcbiAgICB9XG4gICAgbm9kZSA9IHBhcmVudE5vZGU7XG4gIH1cbn1cblxuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICogV3JhcHMgYWxsIG5vZGVzIGluIHRoZSBzZWxlY3Rpb24gaW50byBhbm90aGVyIG5vZGUgb2YgdGhlIHR5cGUgcmV0dXJuZWQgYnkgY3JlYXRlRWxlbWVudC5cbiAqIEBwYXJhbSBzZWxlY3Rpb24gLSBUaGUgc2VsZWN0aW9uIG9mIG5vZGVzIHRvIGJlIHdyYXBwZWQuXG4gKiBAcGFyYW0gY3JlYXRlRWxlbWVudCAtIEEgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIHRoZSB3cmFwcGluZyBFbGVtZW50Tm9kZS4gZWcuICRjcmVhdGVQYXJhZ3JhcGhOb2RlLlxuICogQHBhcmFtIHdyYXBwaW5nRWxlbWVudCAtIEFuIGVsZW1lbnQgdG8gYXBwZW5kIHRoZSB3cmFwcGVkIHNlbGVjdGlvbiBhbmQgaXRzIGNoaWxkcmVuIHRvLlxuICovXG5mdW5jdGlvbiAkd3JhcE5vZGVzKHNlbGVjdGlvbiwgY3JlYXRlRWxlbWVudCwgd3JhcHBpbmdFbGVtZW50ID0gbnVsbCkge1xuICBjb25zdCBhbmNob3JBbmRGb2N1cyA9IHNlbGVjdGlvbi5nZXRTdGFydEVuZFBvaW50cygpO1xuICBjb25zdCBhbmNob3IgPSBhbmNob3JBbmRGb2N1cyA/IGFuY2hvckFuZEZvY3VzWzBdIDogbnVsbDtcbiAgY29uc3Qgbm9kZXMgPSBzZWxlY3Rpb24uZ2V0Tm9kZXMoKTtcbiAgY29uc3Qgbm9kZXNMZW5ndGggPSBub2Rlcy5sZW5ndGg7XG4gIGlmIChhbmNob3IgIT09IG51bGwgJiYgKG5vZGVzTGVuZ3RoID09PSAwIHx8IG5vZGVzTGVuZ3RoID09PSAxICYmIGFuY2hvci50eXBlID09PSAnZWxlbWVudCcgJiYgYW5jaG9yLmdldE5vZGUoKS5nZXRDaGlsZHJlblNpemUoKSA9PT0gMCkpIHtcbiAgICBjb25zdCB0YXJnZXQgPSBhbmNob3IudHlwZSA9PT0gJ3RleHQnID8gYW5jaG9yLmdldE5vZGUoKS5nZXRQYXJlbnRPclRocm93KCkgOiBhbmNob3IuZ2V0Tm9kZSgpO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGFyZ2V0LmdldENoaWxkcmVuKCk7XG4gICAgbGV0IGVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KCk7XG4gICAgZWxlbWVudC5zZXRGb3JtYXQodGFyZ2V0LmdldEZvcm1hdFR5cGUoKSk7XG4gICAgZWxlbWVudC5zZXRJbmRlbnQodGFyZ2V0LmdldEluZGVudCgpKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IGVsZW1lbnQuYXBwZW5kKGNoaWxkKSk7XG4gICAgaWYgKHdyYXBwaW5nRWxlbWVudCkge1xuICAgICAgZWxlbWVudCA9IHdyYXBwaW5nRWxlbWVudC5hcHBlbmQoZWxlbWVudCk7XG4gICAgfVxuICAgIHRhcmdldC5yZXBsYWNlKGVsZW1lbnQpO1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgdG9wTGV2ZWxOb2RlID0gbnVsbDtcbiAgbGV0IGRlc2NlbmRhbnRzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXNMZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAvLyBEZXRlcm1pbmUgd2hldGhlciB3cmFwcGluZyBoYXMgdG8gYmUgYnJva2VuIGRvd24gaW50byBtdWx0aXBsZSBjaHVua3MuIFRoaXMgY2FuIGhhcHBlbiBpZiB0aGVcbiAgICAvLyB1c2VyIHNlbGVjdGVkIG11bHRpcGxlIFJvb3QtbGlrZSBub2RlcyB0aGF0IGhhdmUgdG8gYmUgdHJlYXRlZCBzZXBhcmF0ZWx5IGFzIGlmIHRoZXkgYXJlXG4gICAgLy8gdGhlaXIgb3duIGJyYW5jaC4gSS5lLiB5b3UgZG9uJ3Qgd2FudCB0byB3cmFwIGEgd2hvbGUgdGFibGUsIGJ1dCByYXRoZXIgdGhlIGNvbnRlbnRzIG9mIGVhY2hcbiAgICAvLyBvZiBlYWNoIG9mIHRoZSBjZWxsIG5vZGVzLlxuICAgIGlmICgkaXNSb290T3JTaGFkb3dSb290KG5vZGUpKSB7XG4gICAgICAkd3JhcE5vZGVzSW1wbChzZWxlY3Rpb24sIGRlc2NlbmRhbnRzLCBkZXNjZW5kYW50cy5sZW5ndGgsIGNyZWF0ZUVsZW1lbnQsIHdyYXBwaW5nRWxlbWVudCk7XG4gICAgICBkZXNjZW5kYW50cyA9IFtdO1xuICAgICAgdG9wTGV2ZWxOb2RlID0gbm9kZTtcbiAgICB9IGVsc2UgaWYgKHRvcExldmVsTm9kZSA9PT0gbnVsbCB8fCB0b3BMZXZlbE5vZGUgIT09IG51bGwgJiYgJGhhc0FuY2VzdG9yKG5vZGUsIHRvcExldmVsTm9kZSkpIHtcbiAgICAgIGRlc2NlbmRhbnRzLnB1c2gobm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICR3cmFwTm9kZXNJbXBsKHNlbGVjdGlvbiwgZGVzY2VuZGFudHMsIGRlc2NlbmRhbnRzLmxlbmd0aCwgY3JlYXRlRWxlbWVudCwgd3JhcHBpbmdFbGVtZW50KTtcbiAgICAgIGRlc2NlbmRhbnRzID0gW25vZGVdO1xuICAgIH1cbiAgfVxuICAkd3JhcE5vZGVzSW1wbChzZWxlY3Rpb24sIGRlc2NlbmRhbnRzLCBkZXNjZW5kYW50cy5sZW5ndGgsIGNyZWF0ZUVsZW1lbnQsIHdyYXBwaW5nRWxlbWVudCk7XG59XG5cbi8qKlxuICogV3JhcHMgZWFjaCBub2RlIGludG8gYSBuZXcgRWxlbWVudE5vZGUuXG4gKiBAcGFyYW0gc2VsZWN0aW9uIC0gVGhlIHNlbGVjdGlvbiBvZiBub2RlcyB0byB3cmFwLlxuICogQHBhcmFtIG5vZGVzIC0gQW4gYXJyYXkgb2Ygbm9kZXMsIGdlbmVyYWxseSB0aGUgZGVzY2VuZGFudHMgb2YgdGhlIHNlbGVjdGlvbi5cbiAqIEBwYXJhbSBub2Rlc0xlbmd0aCAtIFRoZSBsZW5ndGggb2Ygbm9kZXMuXG4gKiBAcGFyYW0gY3JlYXRlRWxlbWVudCAtIEEgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIHRoZSB3cmFwcGluZyBFbGVtZW50Tm9kZS4gZWcuICRjcmVhdGVQYXJhZ3JhcGhOb2RlLlxuICogQHBhcmFtIHdyYXBwaW5nRWxlbWVudCAtIEFuIGVsZW1lbnQgdG8gd3JhcCBhbGwgdGhlIG5vZGVzIGludG8uXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiAkd3JhcE5vZGVzSW1wbChzZWxlY3Rpb24sIG5vZGVzLCBub2Rlc0xlbmd0aCwgY3JlYXRlRWxlbWVudCwgd3JhcHBpbmdFbGVtZW50ID0gbnVsbCkge1xuICBpZiAobm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGZpcnN0Tm9kZSA9IG5vZGVzWzBdO1xuICBjb25zdCBlbGVtZW50TWFwcGluZyA9IG5ldyBNYXAoKTtcbiAgY29uc3QgZWxlbWVudHMgPSBbXTtcbiAgLy8gVGhlIGJlbG93IGxvZ2ljIGlzIHRvIGZpbmQgdGhlIHJpZ2h0IHRhcmdldCBmb3IgdXMgdG9cbiAgLy8gZWl0aGVyIGluc2VydEFmdGVyL2luc2VydEJlZm9yZS9hcHBlbmQgdGhlIGNvcnJlc3BvbmRpbmdcbiAgLy8gZWxlbWVudHMgdG8uIFRoaXMgaXMgbWFkZSBtb3JlIGNvbXBsaWNhdGVkIGR1ZSB0byBuZXN0ZWRcbiAgLy8gc3RydWN0dXJlcy5cbiAgbGV0IHRhcmdldCA9ICRpc0VsZW1lbnROb2RlKGZpcnN0Tm9kZSkgPyBmaXJzdE5vZGUgOiBmaXJzdE5vZGUuZ2V0UGFyZW50T3JUaHJvdygpO1xuICBpZiAodGFyZ2V0LmlzSW5saW5lKCkpIHtcbiAgICB0YXJnZXQgPSB0YXJnZXQuZ2V0UGFyZW50T3JUaHJvdygpO1xuICB9XG4gIGxldCB0YXJnZXRJc1ByZXZTaWJsaW5nID0gZmFsc2U7XG4gIHdoaWxlICh0YXJnZXQgIT09IG51bGwpIHtcbiAgICBjb25zdCBwcmV2U2libGluZyA9IHRhcmdldC5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICBpZiAocHJldlNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgIHRhcmdldCA9IHByZXZTaWJsaW5nO1xuICAgICAgdGFyZ2V0SXNQcmV2U2libGluZyA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdGFyZ2V0ID0gdGFyZ2V0LmdldFBhcmVudE9yVGhyb3coKTtcbiAgICBpZiAoJGlzUm9vdE9yU2hhZG93Um9vdCh0YXJnZXQpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgY29uc3QgZW1wdHlFbGVtZW50cyA9IG5ldyBTZXQoKTtcblxuICAvLyBGaW5kIGFueSB0b3AgbGV2ZWwgZW1wdHkgZWxlbWVudHNcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlc0xlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgIGlmICgkaXNFbGVtZW50Tm9kZShub2RlKSAmJiBub2RlLmdldENoaWxkcmVuU2l6ZSgpID09PSAwKSB7XG4gICAgICBlbXB0eUVsZW1lbnRzLmFkZChub2RlLmdldEtleSgpKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgbW92ZWROb2RlcyA9IG5ldyBTZXQoKTtcblxuICAvLyBNb3ZlIG91dCBhbGwgbGVhZiBub2RlcyBpbnRvIG91ciBlbGVtZW50cyBhcnJheS5cbiAgLy8gSWYgd2UgZmluZCBhIHRvcCBsZXZlbCBlbXB0eSBlbGVtZW50LCBhbHNvIG1vdmUgbWFrZVxuICAvLyBhbiBlbGVtZW50IGZvciB0aGF0LlxuICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzTGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgbGV0IHBhcmVudCA9IG5vZGUuZ2V0UGFyZW50KCk7XG4gICAgaWYgKHBhcmVudCAhPT0gbnVsbCAmJiBwYXJlbnQuaXNJbmxpbmUoKSkge1xuICAgICAgcGFyZW50ID0gcGFyZW50LmdldFBhcmVudCgpO1xuICAgIH1cbiAgICBpZiAocGFyZW50ICE9PSBudWxsICYmICRpc0xlYWZOb2RlKG5vZGUpICYmICFtb3ZlZE5vZGVzLmhhcyhub2RlLmdldEtleSgpKSkge1xuICAgICAgY29uc3QgcGFyZW50S2V5ID0gcGFyZW50LmdldEtleSgpO1xuICAgICAgaWYgKGVsZW1lbnRNYXBwaW5nLmdldChwYXJlbnRLZXkpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQoKTtcbiAgICAgICAgdGFyZ2V0RWxlbWVudC5zZXRGb3JtYXQocGFyZW50LmdldEZvcm1hdFR5cGUoKSk7XG4gICAgICAgIHRhcmdldEVsZW1lbnQuc2V0SW5kZW50KHBhcmVudC5nZXRJbmRlbnQoKSk7XG4gICAgICAgIGVsZW1lbnRzLnB1c2godGFyZ2V0RWxlbWVudCk7XG4gICAgICAgIGVsZW1lbnRNYXBwaW5nLnNldChwYXJlbnRLZXksIHRhcmdldEVsZW1lbnQpO1xuICAgICAgICAvLyBNb3ZlIG5vZGUgYW5kIGl0cyBzaWJsaW5ncyB0byB0aGUgbmV3XG4gICAgICAgIC8vIGVsZW1lbnQuXG4gICAgICAgIHBhcmVudC5nZXRDaGlsZHJlbigpLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICAgIHRhcmdldEVsZW1lbnQuYXBwZW5kKGNoaWxkKTtcbiAgICAgICAgICBtb3ZlZE5vZGVzLmFkZChjaGlsZC5nZXRLZXkoKSk7XG4gICAgICAgICAgaWYgKCRpc0VsZW1lbnROb2RlKGNoaWxkKSkge1xuICAgICAgICAgICAgLy8gU2tpcCBuZXN0ZWQgbGVhZiBub2RlcyBpZiB0aGUgcGFyZW50IGhhcyBhbHJlYWR5IGJlZW4gbW92ZWRcbiAgICAgICAgICAgIGNoaWxkLmdldENoaWxkcmVuS2V5cygpLmZvckVhY2goa2V5ID0+IG1vdmVkTm9kZXMuYWRkKGtleSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgICRyZW1vdmVQYXJlbnRFbXB0eUVsZW1lbnRzKHBhcmVudCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbXB0eUVsZW1lbnRzLmhhcyhub2RlLmdldEtleSgpKSkge1xuICAgICAgaWYgKCEkaXNFbGVtZW50Tm9kZShub2RlKSkge1xuICAgICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgbm9kZSBpbiBlbXB0eUVsZW1lbnRzIHRvIGJlIGFuIEVsZW1lbnROb2RlYCk7XG4gICAgICB9XG4gICAgICBjb25zdCB0YXJnZXRFbGVtZW50ID0gY3JlYXRlRWxlbWVudCgpO1xuICAgICAgdGFyZ2V0RWxlbWVudC5zZXRGb3JtYXQobm9kZS5nZXRGb3JtYXRUeXBlKCkpO1xuICAgICAgdGFyZ2V0RWxlbWVudC5zZXRJbmRlbnQobm9kZS5nZXRJbmRlbnQoKSk7XG4gICAgICBlbGVtZW50cy5wdXNoKHRhcmdldEVsZW1lbnQpO1xuICAgICAgbm9kZS5yZW1vdmUodHJ1ZSk7XG4gICAgfVxuICB9XG4gIGlmICh3cmFwcGluZ0VsZW1lbnQgIT09IG51bGwpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICB3cmFwcGluZ0VsZW1lbnQuYXBwZW5kKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuICBsZXQgbGFzdEVsZW1lbnQgPSBudWxsO1xuXG4gIC8vIElmIG91ciB0YXJnZXQgaXMgUm9vdC1saWtlLCBsZXQncyBzZWUgaWYgd2UgY2FuIHJlLWFkanVzdFxuICAvLyBzbyB0aGF0IHRoZSB0YXJnZXQgaXMgdGhlIGZpcnN0IGNoaWxkIGluc3RlYWQuXG4gIGlmICgkaXNSb290T3JTaGFkb3dSb290KHRhcmdldCkpIHtcbiAgICBpZiAodGFyZ2V0SXNQcmV2U2libGluZykge1xuICAgICAgaWYgKHdyYXBwaW5nRWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgICB0YXJnZXQuaW5zZXJ0QWZ0ZXIod3JhcHBpbmdFbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBlbGVtZW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICAgICAgICB0YXJnZXQuaW5zZXJ0QWZ0ZXIoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZmlyc3RDaGlsZCA9IHRhcmdldC5nZXRGaXJzdENoaWxkKCk7XG4gICAgICBpZiAoJGlzRWxlbWVudE5vZGUoZmlyc3RDaGlsZCkpIHtcbiAgICAgICAgdGFyZ2V0ID0gZmlyc3RDaGlsZDtcbiAgICAgIH1cbiAgICAgIGlmIChmaXJzdENoaWxkID09PSBudWxsKSB7XG4gICAgICAgIGlmICh3cmFwcGluZ0VsZW1lbnQpIHtcbiAgICAgICAgICB0YXJnZXQuYXBwZW5kKHdyYXBwaW5nRWxlbWVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuICAgICAgICAgICAgdGFyZ2V0LmFwcGVuZChlbGVtZW50KTtcbiAgICAgICAgICAgIGxhc3RFbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh3cmFwcGluZ0VsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgICBmaXJzdENoaWxkLmluc2VydEJlZm9yZSh3cmFwcGluZ0VsZW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICAgICAgICAgIGZpcnN0Q2hpbGQuaW5zZXJ0QmVmb3JlKGVsZW1lbnQpO1xuICAgICAgICAgICAgbGFzdEVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAod3JhcHBpbmdFbGVtZW50KSB7XG4gICAgICB0YXJnZXQuaW5zZXJ0QWZ0ZXIod3JhcHBpbmdFbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgaSA9IGVsZW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICAgICAgdGFyZ2V0Lmluc2VydEFmdGVyKGVsZW1lbnQpO1xuICAgICAgICBsYXN0RWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IHByZXZTZWxlY3Rpb24gPSAkZ2V0UHJldmlvdXNTZWxlY3Rpb24oKTtcbiAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHByZXZTZWxlY3Rpb24pICYmIGlzUG9pbnRBdHRhY2hlZChwcmV2U2VsZWN0aW9uLmFuY2hvcikgJiYgaXNQb2ludEF0dGFjaGVkKHByZXZTZWxlY3Rpb24uZm9jdXMpKSB7XG4gICAgJHNldFNlbGVjdGlvbihwcmV2U2VsZWN0aW9uLmNsb25lKCkpO1xuICB9IGVsc2UgaWYgKGxhc3RFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgbGFzdEVsZW1lbnQuc2VsZWN0RW5kKCk7XG4gIH0gZWxzZSB7XG4gICAgc2VsZWN0aW9uLmRpcnR5ID0gdHJ1ZTtcbiAgfVxufVxuXG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIGRlZmF1bHQgY2hhcmFjdGVyIHNlbGVjdGlvbiBzaG91bGQgYmUgb3ZlcnJpZGRlbi4gVXNlZCB3aXRoIERlY29yYXRvck5vZGVzXG4gKiBAcGFyYW0gc2VsZWN0aW9uIC0gVGhlIHNlbGVjdGlvbiB3aG9zZSBkZWZhdWx0IGNoYXJhY3RlciBzZWxlY3Rpb24gbWF5IG5lZWQgdG8gYmUgb3ZlcnJpZGRlbi5cbiAqIEBwYXJhbSBpc0JhY2t3YXJkIC0gSXMgdGhlIHNlbGVjdGlvbiBiYWNrd2FyZHMgKHRoZSBmb2N1cyBjb21lcyBiZWZvcmUgdGhlIGFuY2hvcik/XG4gKiBAcmV0dXJucyB0cnVlIGlmIGl0IHNob3VsZCBiZSBvdmVycmlkZGVuLCBmYWxzZSBpZiBub3QuXG4gKi9cbmZ1bmN0aW9uICRzaG91bGRPdmVycmlkZURlZmF1bHRDaGFyYWN0ZXJTZWxlY3Rpb24oc2VsZWN0aW9uLCBpc0JhY2t3YXJkKSB7XG4gIGNvbnN0IHBvc3NpYmxlTm9kZSA9ICRnZXRBZGphY2VudE5vZGUoc2VsZWN0aW9uLmZvY3VzLCBpc0JhY2t3YXJkKTtcbiAgcmV0dXJuICRpc0RlY29yYXRvck5vZGUocG9zc2libGVOb2RlKSAmJiAhcG9zc2libGVOb2RlLmlzSXNvbGF0ZWQoKSB8fCAkaXNFbGVtZW50Tm9kZShwb3NzaWJsZU5vZGUpICYmICFwb3NzaWJsZU5vZGUuaXNJbmxpbmUoKSAmJiAhcG9zc2libGVOb2RlLmNhbkJlRW1wdHkoKTtcbn1cblxuLyoqXG4gKiBNb3ZlcyB0aGUgc2VsZWN0aW9uIGFjY29yZGluZyB0byB0aGUgYXJndW1lbnRzLlxuICogQHBhcmFtIHNlbGVjdGlvbiAtIFRoZSBzZWxlY3RlZCB0ZXh0IG9yIG5vZGVzLlxuICogQHBhcmFtIGlzSG9sZGluZ1NoaWZ0IC0gSXMgdGhlIHNoaWZ0IGtleSBiZWluZyBoZWxkIGRvd24gZHVyaW5nIHRoZSBvcGVyYXRpb24uXG4gKiBAcGFyYW0gaXNCYWNrd2FyZCAtIElzIHRoZSBzZWxlY3Rpb24gc2VsZWN0ZWQgYmFja3dhcmRzICh0aGUgZm9jdXMgY29tZXMgYmVmb3JlIHRoZSBhbmNob3IpP1xuICogQHBhcmFtIGdyYW51bGFyaXR5IC0gVGhlIGRpc3RhbmNlIHRvIGFkanVzdCB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gKi9cbmZ1bmN0aW9uICRtb3ZlQ2FyZXRTZWxlY3Rpb24oc2VsZWN0aW9uLCBpc0hvbGRpbmdTaGlmdCwgaXNCYWNrd2FyZCwgZ3JhbnVsYXJpdHkpIHtcbiAgc2VsZWN0aW9uLm1vZGlmeShpc0hvbGRpbmdTaGlmdCA/ICdleHRlbmQnIDogJ21vdmUnLCBpc0JhY2t3YXJkLCBncmFudWxhcml0eSk7XG59XG5cbi8qKlxuICogVGVzdHMgYSBwYXJlbnQgZWxlbWVudCBmb3IgcmlnaHQgdG8gbGVmdCBkaXJlY3Rpb24uXG4gKiBAcGFyYW0gc2VsZWN0aW9uIC0gVGhlIHNlbGVjdGlvbiB3aG9zZSBwYXJlbnQgaXMgdG8gYmUgdGVzdGVkLlxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgc2VsZWN0aW9ucycgcGFyZW50IGVsZW1lbnQgaGFzIGEgZGlyZWN0aW9uIG9mICdydGwnIChyaWdodCB0byBsZWZ0KSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiAkaXNQYXJlbnRFbGVtZW50UlRMKHNlbGVjdGlvbikge1xuICBjb25zdCBhbmNob3JOb2RlID0gc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCk7XG4gIGNvbnN0IHBhcmVudCA9ICRpc1Jvb3ROb2RlKGFuY2hvck5vZGUpID8gYW5jaG9yTm9kZSA6IGFuY2hvck5vZGUuZ2V0UGFyZW50T3JUaHJvdygpO1xuICByZXR1cm4gcGFyZW50LmdldERpcmVjdGlvbigpID09PSAncnRsJztcbn1cblxuLyoqXG4gKiBNb3ZlcyBzZWxlY3Rpb24gYnkgY2hhcmFjdGVyIGFjY29yZGluZyB0byBhcmd1bWVudHMuXG4gKiBAcGFyYW0gc2VsZWN0aW9uIC0gVGhlIHNlbGVjdGlvbiBvZiB0aGUgY2hhcmFjdGVycyB0byBtb3ZlLlxuICogQHBhcmFtIGlzSG9sZGluZ1NoaWZ0IC0gSXMgdGhlIHNoaWZ0IGtleSBiZWluZyBoZWxkIGRvd24gZHVyaW5nIHRoZSBvcGVyYXRpb24uXG4gKiBAcGFyYW0gaXNCYWNrd2FyZCAtIElzIHRoZSBzZWxlY3Rpb24gYmFja3dhcmQgKHRoZSBmb2N1cyBjb21lcyBiZWZvcmUgdGhlIGFuY2hvcik/XG4gKi9cbmZ1bmN0aW9uICRtb3ZlQ2hhcmFjdGVyKHNlbGVjdGlvbiwgaXNIb2xkaW5nU2hpZnQsIGlzQmFja3dhcmQpIHtcbiAgY29uc3QgaXNSVEwgPSAkaXNQYXJlbnRFbGVtZW50UlRMKHNlbGVjdGlvbik7XG4gICRtb3ZlQ2FyZXRTZWxlY3Rpb24oc2VsZWN0aW9uLCBpc0hvbGRpbmdTaGlmdCwgaXNCYWNrd2FyZCA/ICFpc1JUTCA6IGlzUlRMLCAnY2hhcmFjdGVyJyk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCB2YWx1ZSBvZiBhIENTUyBwcm9wZXJ0eSBmb3IgTm9kZXMsIGlmIHNldC4gSWYgbm90IHNldCwgaXQgcmV0dXJucyB0aGUgZGVmYXVsdFZhbHVlLlxuICogQHBhcmFtIG5vZGUgLSBUaGUgbm9kZSB3aG9zZSBzdHlsZSB2YWx1ZSB0byBnZXQuXG4gKiBAcGFyYW0gc3R5bGVQcm9wZXJ0eSAtIFRoZSBDU1Mgc3R5bGUgcHJvcGVydHkuXG4gKiBAcGFyYW0gZGVmYXVsdFZhbHVlIC0gVGhlIGRlZmF1bHQgdmFsdWUgZm9yIHRoZSBwcm9wZXJ0eS5cbiAqIEByZXR1cm5zIFRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgZm9yIG5vZGUuXG4gKi9cbmZ1bmN0aW9uICRnZXROb2RlU3R5bGVWYWx1ZUZvclByb3BlcnR5KG5vZGUsIHN0eWxlUHJvcGVydHksIGRlZmF1bHRWYWx1ZSkge1xuICBjb25zdCBjc3MgPSBub2RlLmdldFN0eWxlKCk7XG4gIGNvbnN0IHN0eWxlT2JqZWN0ID0gZ2V0U3R5bGVPYmplY3RGcm9tQ1NTKGNzcyk7XG4gIGlmIChzdHlsZU9iamVjdCAhPT0gbnVsbCkge1xuICAgIHJldHVybiBzdHlsZU9iamVjdFtzdHlsZVByb3BlcnR5XSB8fCBkZWZhdWx0VmFsdWU7XG4gIH1cbiAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IHZhbHVlIG9mIGEgQ1NTIHByb3BlcnR5IGZvciBUZXh0Tm9kZXMgaW4gdGhlIFNlbGVjdGlvbiwgaWYgc2V0LiBJZiBub3Qgc2V0LCBpdCByZXR1cm5zIHRoZSBkZWZhdWx0VmFsdWUuXG4gKiBJZiBhbGwgVGV4dE5vZGVzIGRvIG5vdCBoYXZlIHRoZSBzYW1lIHZhbHVlLCBpdCByZXR1cm5zIGFuIGVtcHR5IHN0cmluZy5cbiAqIEBwYXJhbSBzZWxlY3Rpb24gLSBUaGUgc2VsZWN0aW9uIG9mIFRleHROb2RlcyB3aG9zZSB2YWx1ZSB0byBmaW5kLlxuICogQHBhcmFtIHN0eWxlUHJvcGVydHkgLSBUaGUgQ1NTIHN0eWxlIHByb3BlcnR5LlxuICogQHBhcmFtIGRlZmF1bHRWYWx1ZSAtIFRoZSBkZWZhdWx0IHZhbHVlIGZvciB0aGUgcHJvcGVydHksIGRlZmF1bHRzIHRvIGFuIGVtcHR5IHN0cmluZy5cbiAqIEByZXR1cm5zIFRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgZm9yIHRoZSBzZWxlY3RlZCBUZXh0Tm9kZXMuXG4gKi9cbmZ1bmN0aW9uICRnZXRTZWxlY3Rpb25TdHlsZVZhbHVlRm9yUHJvcGVydHkoc2VsZWN0aW9uLCBzdHlsZVByb3BlcnR5LCBkZWZhdWx0VmFsdWUgPSAnJykge1xuICBsZXQgc3R5bGVWYWx1ZSA9IG51bGw7XG4gIGNvbnN0IG5vZGVzID0gc2VsZWN0aW9uLmdldE5vZGVzKCk7XG4gIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICBjb25zdCBpc0JhY2t3YXJkID0gc2VsZWN0aW9uLmlzQmFja3dhcmQoKTtcbiAgY29uc3QgZW5kT2Zmc2V0ID0gaXNCYWNrd2FyZCA/IGZvY3VzLm9mZnNldCA6IGFuY2hvci5vZmZzZXQ7XG4gIGNvbnN0IGVuZE5vZGUgPSBpc0JhY2t3YXJkID8gZm9jdXMuZ2V0Tm9kZSgpIDogYW5jaG9yLmdldE5vZGUoKTtcbiAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgJiYgc2VsZWN0aW9uLnN0eWxlICE9PSAnJykge1xuICAgIGNvbnN0IGNzcyA9IHNlbGVjdGlvbi5zdHlsZTtcbiAgICBjb25zdCBzdHlsZU9iamVjdCA9IGdldFN0eWxlT2JqZWN0RnJvbUNTUyhjc3MpO1xuICAgIGlmIChzdHlsZU9iamVjdCAhPT0gbnVsbCAmJiBzdHlsZVByb3BlcnR5IGluIHN0eWxlT2JqZWN0KSB7XG4gICAgICByZXR1cm4gc3R5bGVPYmplY3Rbc3R5bGVQcm9wZXJ0eV07XG4gICAgfVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG5cbiAgICAvLyBpZiBubyBhY3R1YWwgY2hhcmFjdGVycyBpbiB0aGUgZW5kIG5vZGUgYXJlIHNlbGVjdGVkLCB3ZSBkb24ndFxuICAgIC8vIGluY2x1ZGUgaXQgaW4gdGhlIHNlbGVjdGlvbiBmb3IgcHVycG9zZXMgb2YgZGV0ZXJtaW5pbmcgc3R5bGVcbiAgICAvLyB2YWx1ZVxuICAgIGlmIChpICE9PSAwICYmIGVuZE9mZnNldCA9PT0gMCAmJiBub2RlLmlzKGVuZE5vZGUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKCRpc1RleHROb2RlKG5vZGUpKSB7XG4gICAgICBjb25zdCBub2RlU3R5bGVWYWx1ZSA9ICRnZXROb2RlU3R5bGVWYWx1ZUZvclByb3BlcnR5KG5vZGUsIHN0eWxlUHJvcGVydHksIGRlZmF1bHRWYWx1ZSk7XG4gICAgICBpZiAoc3R5bGVWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICBzdHlsZVZhbHVlID0gbm9kZVN0eWxlVmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKHN0eWxlVmFsdWUgIT09IG5vZGVTdHlsZVZhbHVlKSB7XG4gICAgICAgIC8vIG11bHRpcGxlIHRleHQgbm9kZXMgYXJlIGluIHRoZSBzZWxlY3Rpb24gYW5kIHRoZXkgZG9uJ3QgYWxsXG4gICAgICAgIC8vIGhhdmUgdGhlIHNhbWUgc3R5bGUuXG4gICAgICAgIHN0eWxlVmFsdWUgPSAnJztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHlsZVZhbHVlID09PSBudWxsID8gZGVmYXVsdFZhbHVlIDogc3R5bGVWYWx1ZTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGZvciBpbnRlcm5hbCB1c2Ugb2YgdGhlIGxpYnJhcnkuXG4gKiBQbGVhc2UgZG8gbm90IHVzZSBpdCBhcyBpdCBtYXkgY2hhbmdlIGluIHRoZSBmdXR1cmUuXG4gKi9cbmZ1bmN0aW9uIElOVEVSTkFMXyRpc0Jsb2NrKG5vZGUpIHtcbiAgaWYgKCRpc0RlY29yYXRvck5vZGUobm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCEkaXNFbGVtZW50Tm9kZShub2RlKSB8fCAkaXNSb290T3JTaGFkb3dSb290KG5vZGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGZpcnN0Q2hpbGQgPSBub2RlLmdldEZpcnN0Q2hpbGQoKTtcbiAgY29uc3QgaXNMZWFmRWxlbWVudCA9IGZpcnN0Q2hpbGQgPT09IG51bGwgfHwgJGlzTGluZUJyZWFrTm9kZShmaXJzdENoaWxkKSB8fCAkaXNUZXh0Tm9kZShmaXJzdENoaWxkKSB8fCBmaXJzdENoaWxkLmlzSW5saW5lKCk7XG4gIHJldHVybiAhbm9kZS5pc0lubGluZSgpICYmIG5vZGUuY2FuQmVFbXB0eSgpICE9PSBmYWxzZSAmJiBpc0xlYWZFbGVtZW50O1xufVxuZnVuY3Rpb24gJGdldEFuY2VzdG9yKG5vZGUsIHByZWRpY2F0ZSkge1xuICBsZXQgcGFyZW50ID0gbm9kZTtcbiAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCAmJiBwYXJlbnQuZ2V0UGFyZW50KCkgIT09IG51bGwgJiYgIXByZWRpY2F0ZShwYXJlbnQpKSB7XG4gICAgcGFyZW50ID0gcGFyZW50LmdldFBhcmVudE9yVGhyb3coKTtcbiAgfVxuICByZXR1cm4gcHJlZGljYXRlKHBhcmVudCkgPyBwYXJlbnQgOiBudWxsO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8qKiBAZGVwcmVjYXRlZCByZW5hbWVkIHRvIHtAbGluayAkdHJpbVRleHRDb250ZW50RnJvbUFuY2hvcn0gYnkgQGxleGljYWwvZXNsaW50LXBsdWdpbiBydWxlcy1vZi1sZXhpY2FsICovXG5jb25zdCB0cmltVGV4dENvbnRlbnRGcm9tQW5jaG9yID0gJHRyaW1UZXh0Q29udGVudEZyb21BbmNob3I7XG5cbmV4cG9ydCB7ICRhZGROb2RlU3R5bGUsICRmb3JFYWNoU2VsZWN0ZWRUZXh0Tm9kZSwgJGdldFNlbGVjdGlvblN0eWxlVmFsdWVGb3JQcm9wZXJ0eSwgJGlzQXROb2RlRW5kLCAkaXNQYXJlbnRFbGVtZW50UlRMLCAkbW92ZUNhcmV0U2VsZWN0aW9uLCAkbW92ZUNoYXJhY3RlciwgJHBhdGNoU3R5bGVUZXh0LCAkc2V0QmxvY2tzVHlwZSwgJHNob3VsZE92ZXJyaWRlRGVmYXVsdENoYXJhY3RlclNlbGVjdGlvbiwgJHNsaWNlU2VsZWN0ZWRUZXh0Tm9kZUNvbnRlbnQsICR0cmltVGV4dENvbnRlbnRGcm9tQW5jaG9yLCAkd3JhcE5vZGVzLCBjcmVhdGVET01SYW5nZSwgY3JlYXRlUmVjdHNGcm9tRE9NUmFuZ2UsIGdldENTU0Zyb21TdHlsZU9iamVjdCwgZ2V0U3R5bGVPYmplY3RGcm9tQ1NTLCB0cmltVGV4dENvbnRlbnRGcm9tQW5jaG9yIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/selection/LexicalSelection.dev.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/text/LexicalText.dev.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@lexical/text/LexicalText.dev.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $canShowPlaceholder: () => (/* binding */ $canShowPlaceholder),\n/* harmony export */   $canShowPlaceholderCurry: () => (/* binding */ $canShowPlaceholderCurry),\n/* harmony export */   $findTextIntersectionFromCharacters: () => (/* binding */ $findTextIntersectionFromCharacters),\n/* harmony export */   $isRootTextContentEmpty: () => (/* binding */ $isRootTextContentEmpty),\n/* harmony export */   $isRootTextContentEmptyCurry: () => (/* binding */ $isRootTextContentEmptyCurry),\n/* harmony export */   $rootTextContent: () => (/* binding */ $rootTextContent),\n/* harmony export */   registerLexicalTextEntity: () => (/* binding */ registerLexicalTextEntity)\n/* harmony export */ });\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(app-pages-browser)/./node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Returns the root's text content.\n * @returns The root's text content.\n */\nfunction $rootTextContent() {\n  const root = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)();\n  return root.getTextContent();\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Determines if the root has any text content and can trim any whitespace if it does.\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @param trim - Should the root text have its whitespaced trimmed? Defaults to true.\n * @returns true if text content is empty, false if there is text or isEditorComposing is true.\n */\nfunction $isRootTextContentEmpty(isEditorComposing, trim = true) {\n  if (isEditorComposing) {\n    return false;\n  }\n  let text = $rootTextContent();\n  if (trim) {\n    text = text.trim();\n  }\n  return text === '';\n}\n\n/**\n * Returns a function that executes {@link $isRootTextContentEmpty}\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @param trim - Should the root text have its whitespaced trimmed? Defaults to true.\n * @returns A function that executes $isRootTextContentEmpty based on arguments.\n */\nfunction $isRootTextContentEmptyCurry(isEditorComposing, trim) {\n  return () => $isRootTextContentEmpty(isEditorComposing, trim);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Determines if the input should show the placeholder. If anything is in\n * in the root the placeholder should not be shown.\n * @param isComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @returns true if the input should show the placeholder, false otherwise.\n */\nfunction $canShowPlaceholder(isComposing) {\n  if (!$isRootTextContentEmpty(isComposing, false)) {\n    return false;\n  }\n  const root = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)();\n  const children = root.getChildren();\n  const childrenLength = children.length;\n  if (childrenLength > 1) {\n    return false;\n  }\n  for (let i = 0; i < childrenLength; i++) {\n    const topBlock = children[i];\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isDecoratorNode)(topBlock)) {\n      return false;\n    }\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(topBlock)) {\n      if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isParagraphNode)(topBlock)) {\n        return false;\n      }\n      if (topBlock.__indent !== 0) {\n        return false;\n      }\n      const topBlockChildren = topBlock.getChildren();\n      const topBlockChildrenLength = topBlockChildren.length;\n      for (let s = 0; s < topBlockChildrenLength; s++) {\n        const child = topBlockChildren[i];\n        if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(child)) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * Returns a function that executes {@link $canShowPlaceholder}\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @returns A function that executes $canShowPlaceholder with arguments.\n */\nfunction $canShowPlaceholderCurry(isEditorComposing) {\n  return () => $canShowPlaceholder(isEditorComposing);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Finds a TextNode with a size larger than targetCharacters and returns\n * the node along with the remaining length of the text.\n * @param root - The RootNode.\n * @param targetCharacters - The number of characters whose TextNode must be larger than.\n * @returns The TextNode and the intersections offset, or null if no TextNode is found.\n */\nfunction $findTextIntersectionFromCharacters(root, targetCharacters) {\n  let node = root.getFirstChild();\n  let currentCharacters = 0;\n  mainLoop: while (node !== null) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node)) {\n      const child = node.getFirstChild();\n      if (child !== null) {\n        node = child;\n        continue;\n      }\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(node)) {\n      const characters = node.getTextContentSize();\n      if (currentCharacters + characters > targetCharacters) {\n        return {\n          node,\n          offset: targetCharacters - currentCharacters\n        };\n      }\n      currentCharacters += characters;\n    }\n    const sibling = node.getNextSibling();\n    if (sibling !== null) {\n      node = sibling;\n      continue;\n    }\n    let parent = node.getParent();\n    while (parent !== null) {\n      const parentSibling = parent.getNextSibling();\n      if (parentSibling !== null) {\n        node = parentSibling;\n        continue mainLoop;\n      }\n      parent = parent.getParent();\n    }\n    break;\n  }\n  return null;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Returns a tuple that can be rested (...) into mergeRegister to clean up\n * node transforms listeners that transforms text into another node, eg. a HashtagNode.\n * @example\n * ```ts\n *   useEffect(() => {\n    return mergeRegister(\n      ...registerLexicalTextEntity(editor, getMatch, targetNode, createNode),\n    );\n  }, [createNode, editor, getMatch, targetNode]);\n * ```\n * Where targetNode is the type of node containing the text you want to transform (like a text input),\n * then getMatch uses a regex to find a matching text and creates the proper node to include the matching text.\n * @param editor - The lexical editor.\n * @param getMatch - Finds a matching string that satisfies a regex expression.\n * @param targetNode - The node type that contains text to match with. eg. HashtagNode\n * @param createNode - A function that creates a new node to contain the matched text. eg createHashtagNode\n * @returns An array containing the plain text and reverse node transform listeners.\n */\nfunction registerLexicalTextEntity(editor, getMatch, targetNode, createNode) {\n  const isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n  const $replaceWithSimpleText = node => {\n    const textNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTextNode)(node.getTextContent());\n    textNode.setFormat(node.getFormat());\n    node.replace(textNode);\n  };\n  const getMode = node => {\n    return node.getLatest().__mode;\n  };\n  const $textNodeTransform = node => {\n    if (!node.isSimpleText()) {\n      return;\n    }\n    let prevSibling = node.getPreviousSibling();\n    let text = node.getTextContent();\n    let currentNode = node;\n    let match;\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(prevSibling)) {\n      const previousText = prevSibling.getTextContent();\n      const combinedText = previousText + text;\n      const prevMatch = getMatch(combinedText);\n      if (isTargetNode(prevSibling)) {\n        if (prevMatch === null || getMode(prevSibling) !== 0) {\n          $replaceWithSimpleText(prevSibling);\n          return;\n        } else {\n          const diff = prevMatch.end - previousText.length;\n          if (diff > 0) {\n            const concatText = text.slice(0, diff);\n            const newTextContent = previousText + concatText;\n            prevSibling.select();\n            prevSibling.setTextContent(newTextContent);\n            if (diff === text.length) {\n              node.remove();\n            } else {\n              const remainingText = text.slice(diff);\n              node.setTextContent(remainingText);\n            }\n            return;\n          }\n        }\n      } else if (prevMatch === null || prevMatch.start < previousText.length) {\n        return;\n      }\n    }\n    let prevMatchLengthToSkip = 0;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      match = getMatch(text);\n      let nextText = match === null ? '' : text.slice(match.end);\n      text = nextText;\n      if (nextText === '') {\n        const nextSibling = currentNode.getNextSibling();\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(nextSibling)) {\n          nextText = currentNode.getTextContent() + nextSibling.getTextContent();\n          const nextMatch = getMatch(nextText);\n          if (nextMatch === null) {\n            if (isTargetNode(nextSibling)) {\n              $replaceWithSimpleText(nextSibling);\n            } else {\n              nextSibling.markDirty();\n            }\n            return;\n          } else if (nextMatch.start !== 0) {\n            return;\n          }\n        }\n      }\n      if (match === null) {\n        return;\n      }\n      if (match.start === 0 && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(prevSibling) && prevSibling.isTextEntity()) {\n        prevMatchLengthToSkip += match.end;\n        continue;\n      }\n      let nodeToReplace;\n      if (match.start === 0) {\n        [nodeToReplace, currentNode] = currentNode.splitText(match.end);\n      } else {\n        [, nodeToReplace, currentNode] = currentNode.splitText(match.start + prevMatchLengthToSkip, match.end + prevMatchLengthToSkip);\n      }\n      if (!(nodeToReplace !== undefined)) {\n        throw Error(`${'nodeToReplace'} should not be undefined. You may want to check splitOffsets passed to the splitText.`);\n      }\n      const replacementNode = createNode(nodeToReplace);\n      replacementNode.setFormat(nodeToReplace.getFormat());\n      nodeToReplace.replace(replacementNode);\n      if (currentNode == null) {\n        return;\n      }\n      prevMatchLengthToSkip = 0;\n      prevSibling = replacementNode;\n    }\n  };\n  const $reverseNodeTransform = node => {\n    const text = node.getTextContent();\n    const match = getMatch(text);\n    if (match === null || match.start !== 0) {\n      $replaceWithSimpleText(node);\n      return;\n    }\n    if (text.length > match.end) {\n      // This will split out the rest of the text as simple text\n      node.splitText(match.end);\n      return;\n    }\n    const prevSibling = node.getPreviousSibling();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(prevSibling) && prevSibling.isTextEntity()) {\n      $replaceWithSimpleText(prevSibling);\n      $replaceWithSimpleText(node);\n    }\n    const nextSibling = node.getNextSibling();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(nextSibling) && nextSibling.isTextEntity()) {\n      $replaceWithSimpleText(nextSibling);\n\n      // This may have already been converted in the previous block\n      if (isTargetNode(node)) {\n        $replaceWithSimpleText(node);\n      }\n    }\n  };\n  const removePlainTextTransform = editor.registerNodeTransform(lexical__WEBPACK_IMPORTED_MODULE_0__.TextNode, $textNodeTransform);\n  const removeReverseNodeTransform = editor.registerNodeTransform(targetNode, $reverseNodeTransform);\n  return [removePlainTextTransform, removeReverseNodeTransform];\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC90ZXh0L0xleGljYWxUZXh0LmRldi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFK0g7O0FBRS9IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlEQUFRO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlEQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0EsUUFBUSx5REFBZ0I7QUFDeEI7QUFDQTtBQUNBLFFBQVEsdURBQWM7QUFDdEIsV0FBVyx5REFBZ0I7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNEJBQTRCO0FBQ2xEO0FBQ0EsYUFBYSxvREFBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sU0FBUyxvREFBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsd0RBQWU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0RBQVc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0RBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isb0RBQVc7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvREFBVztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0RBQVc7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLDZDQUFRO0FBQ3hFO0FBQ0E7QUFDQTs7QUFFa00iLCJzb3VyY2VzIjpbIi9Vc2Vycy9sZWkvaG9tZS91bmRlcmcvdGhlYXRyZS95My9zZWdwL21pbGt1cC9ub2RlX21vZHVsZXMvQGxleGljYWwvdGV4dC9MZXhpY2FsVGV4dC5kZXYubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuaW1wb3J0IHsgJGdldFJvb3QsICRpc0RlY29yYXRvck5vZGUsICRpc0VsZW1lbnROb2RlLCAkaXNQYXJhZ3JhcGhOb2RlLCAkaXNUZXh0Tm9kZSwgVGV4dE5vZGUsICRjcmVhdGVUZXh0Tm9kZSB9IGZyb20gJ2xleGljYWwnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8qKlxuICogUmV0dXJucyB0aGUgcm9vdCdzIHRleHQgY29udGVudC5cbiAqIEByZXR1cm5zIFRoZSByb290J3MgdGV4dCBjb250ZW50LlxuICovXG5mdW5jdGlvbiAkcm9vdFRleHRDb250ZW50KCkge1xuICBjb25zdCByb290ID0gJGdldFJvb3QoKTtcbiAgcmV0dXJuIHJvb3QuZ2V0VGV4dENvbnRlbnQoKTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIHJvb3QgaGFzIGFueSB0ZXh0IGNvbnRlbnQgYW5kIGNhbiB0cmltIGFueSB3aGl0ZXNwYWNlIGlmIGl0IGRvZXMuXG4gKiBAcGFyYW0gaXNFZGl0b3JDb21wb3NpbmcgLSBJcyB0aGUgZWRpdG9yIGluIGNvbXBvc2l0aW9uIG1vZGUgZHVlIHRvIGFuIGFjdGl2ZSBJbnB1dCBNZXRob2QgRWRpdG9yP1xuICogQHBhcmFtIHRyaW0gLSBTaG91bGQgdGhlIHJvb3QgdGV4dCBoYXZlIGl0cyB3aGl0ZXNwYWNlZCB0cmltbWVkPyBEZWZhdWx0cyB0byB0cnVlLlxuICogQHJldHVybnMgdHJ1ZSBpZiB0ZXh0IGNvbnRlbnQgaXMgZW1wdHksIGZhbHNlIGlmIHRoZXJlIGlzIHRleHQgb3IgaXNFZGl0b3JDb21wb3NpbmcgaXMgdHJ1ZS5cbiAqL1xuZnVuY3Rpb24gJGlzUm9vdFRleHRDb250ZW50RW1wdHkoaXNFZGl0b3JDb21wb3NpbmcsIHRyaW0gPSB0cnVlKSB7XG4gIGlmIChpc0VkaXRvckNvbXBvc2luZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsZXQgdGV4dCA9ICRyb290VGV4dENvbnRlbnQoKTtcbiAgaWYgKHRyaW0pIHtcbiAgICB0ZXh0ID0gdGV4dC50cmltKCk7XG4gIH1cbiAgcmV0dXJuIHRleHQgPT09ICcnO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGV4ZWN1dGVzIHtAbGluayAkaXNSb290VGV4dENvbnRlbnRFbXB0eX1cbiAqIEBwYXJhbSBpc0VkaXRvckNvbXBvc2luZyAtIElzIHRoZSBlZGl0b3IgaW4gY29tcG9zaXRpb24gbW9kZSBkdWUgdG8gYW4gYWN0aXZlIElucHV0IE1ldGhvZCBFZGl0b3I/XG4gKiBAcGFyYW0gdHJpbSAtIFNob3VsZCB0aGUgcm9vdCB0ZXh0IGhhdmUgaXRzIHdoaXRlc3BhY2VkIHRyaW1tZWQ/IERlZmF1bHRzIHRvIHRydWUuXG4gKiBAcmV0dXJucyBBIGZ1bmN0aW9uIHRoYXQgZXhlY3V0ZXMgJGlzUm9vdFRleHRDb250ZW50RW1wdHkgYmFzZWQgb24gYXJndW1lbnRzLlxuICovXG5mdW5jdGlvbiAkaXNSb290VGV4dENvbnRlbnRFbXB0eUN1cnJ5KGlzRWRpdG9yQ29tcG9zaW5nLCB0cmltKSB7XG4gIHJldHVybiAoKSA9PiAkaXNSb290VGV4dENvbnRlbnRFbXB0eShpc0VkaXRvckNvbXBvc2luZywgdHJpbSk7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBpbnB1dCBzaG91bGQgc2hvdyB0aGUgcGxhY2Vob2xkZXIuIElmIGFueXRoaW5nIGlzIGluXG4gKiBpbiB0aGUgcm9vdCB0aGUgcGxhY2Vob2xkZXIgc2hvdWxkIG5vdCBiZSBzaG93bi5cbiAqIEBwYXJhbSBpc0NvbXBvc2luZyAtIElzIHRoZSBlZGl0b3IgaW4gY29tcG9zaXRpb24gbW9kZSBkdWUgdG8gYW4gYWN0aXZlIElucHV0IE1ldGhvZCBFZGl0b3I/XG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBpbnB1dCBzaG91bGQgc2hvdyB0aGUgcGxhY2Vob2xkZXIsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gJGNhblNob3dQbGFjZWhvbGRlcihpc0NvbXBvc2luZykge1xuICBpZiAoISRpc1Jvb3RUZXh0Q29udGVudEVtcHR5KGlzQ29tcG9zaW5nLCBmYWxzZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3Qgcm9vdCA9ICRnZXRSb290KCk7XG4gIGNvbnN0IGNoaWxkcmVuID0gcm9vdC5nZXRDaGlsZHJlbigpO1xuICBjb25zdCBjaGlsZHJlbkxlbmd0aCA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB0b3BCbG9jayA9IGNoaWxkcmVuW2ldO1xuICAgIGlmICgkaXNEZWNvcmF0b3JOb2RlKHRvcEJsb2NrKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoJGlzRWxlbWVudE5vZGUodG9wQmxvY2spKSB7XG4gICAgICBpZiAoISRpc1BhcmFncmFwaE5vZGUodG9wQmxvY2spKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICh0b3BCbG9jay5fX2luZGVudCAhPT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCB0b3BCbG9ja0NoaWxkcmVuID0gdG9wQmxvY2suZ2V0Q2hpbGRyZW4oKTtcbiAgICAgIGNvbnN0IHRvcEJsb2NrQ2hpbGRyZW5MZW5ndGggPSB0b3BCbG9ja0NoaWxkcmVuLmxlbmd0aDtcbiAgICAgIGZvciAobGV0IHMgPSAwOyBzIDwgdG9wQmxvY2tDaGlsZHJlbkxlbmd0aDsgcysrKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gdG9wQmxvY2tDaGlsZHJlbltpXTtcbiAgICAgICAgaWYgKCEkaXNUZXh0Tm9kZShjaGlsZCkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgZXhlY3V0ZXMge0BsaW5rICRjYW5TaG93UGxhY2Vob2xkZXJ9XG4gKiBAcGFyYW0gaXNFZGl0b3JDb21wb3NpbmcgLSBJcyB0aGUgZWRpdG9yIGluIGNvbXBvc2l0aW9uIG1vZGUgZHVlIHRvIGFuIGFjdGl2ZSBJbnB1dCBNZXRob2QgRWRpdG9yP1xuICogQHJldHVybnMgQSBmdW5jdGlvbiB0aGF0IGV4ZWN1dGVzICRjYW5TaG93UGxhY2Vob2xkZXIgd2l0aCBhcmd1bWVudHMuXG4gKi9cbmZ1bmN0aW9uICRjYW5TaG93UGxhY2Vob2xkZXJDdXJyeShpc0VkaXRvckNvbXBvc2luZykge1xuICByZXR1cm4gKCkgPT4gJGNhblNob3dQbGFjZWhvbGRlcihpc0VkaXRvckNvbXBvc2luZyk7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLyoqXG4gKiBGaW5kcyBhIFRleHROb2RlIHdpdGggYSBzaXplIGxhcmdlciB0aGFuIHRhcmdldENoYXJhY3RlcnMgYW5kIHJldHVybnNcbiAqIHRoZSBub2RlIGFsb25nIHdpdGggdGhlIHJlbWFpbmluZyBsZW5ndGggb2YgdGhlIHRleHQuXG4gKiBAcGFyYW0gcm9vdCAtIFRoZSBSb290Tm9kZS5cbiAqIEBwYXJhbSB0YXJnZXRDaGFyYWN0ZXJzIC0gVGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIHdob3NlIFRleHROb2RlIG11c3QgYmUgbGFyZ2VyIHRoYW4uXG4gKiBAcmV0dXJucyBUaGUgVGV4dE5vZGUgYW5kIHRoZSBpbnRlcnNlY3Rpb25zIG9mZnNldCwgb3IgbnVsbCBpZiBubyBUZXh0Tm9kZSBpcyBmb3VuZC5cbiAqL1xuZnVuY3Rpb24gJGZpbmRUZXh0SW50ZXJzZWN0aW9uRnJvbUNoYXJhY3RlcnMocm9vdCwgdGFyZ2V0Q2hhcmFjdGVycykge1xuICBsZXQgbm9kZSA9IHJvb3QuZ2V0Rmlyc3RDaGlsZCgpO1xuICBsZXQgY3VycmVudENoYXJhY3RlcnMgPSAwO1xuICBtYWluTG9vcDogd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICBpZiAoJGlzRWxlbWVudE5vZGUobm9kZSkpIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gbm9kZS5nZXRGaXJzdENoaWxkKCk7XG4gICAgICBpZiAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZSA9IGNoaWxkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCRpc1RleHROb2RlKG5vZGUpKSB7XG4gICAgICBjb25zdCBjaGFyYWN0ZXJzID0gbm9kZS5nZXRUZXh0Q29udGVudFNpemUoKTtcbiAgICAgIGlmIChjdXJyZW50Q2hhcmFjdGVycyArIGNoYXJhY3RlcnMgPiB0YXJnZXRDaGFyYWN0ZXJzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbm9kZSxcbiAgICAgICAgICBvZmZzZXQ6IHRhcmdldENoYXJhY3RlcnMgLSBjdXJyZW50Q2hhcmFjdGVyc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY3VycmVudENoYXJhY3RlcnMgKz0gY2hhcmFjdGVycztcbiAgICB9XG4gICAgY29uc3Qgc2libGluZyA9IG5vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICBpZiAoc2libGluZyAhPT0gbnVsbCkge1xuICAgICAgbm9kZSA9IHNpYmxpbmc7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgbGV0IHBhcmVudCA9IG5vZGUuZ2V0UGFyZW50KCk7XG4gICAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgcGFyZW50U2libGluZyA9IHBhcmVudC5nZXROZXh0U2libGluZygpO1xuICAgICAgaWYgKHBhcmVudFNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZSA9IHBhcmVudFNpYmxpbmc7XG4gICAgICAgIGNvbnRpbnVlIG1haW5Mb29wO1xuICAgICAgfVxuICAgICAgcGFyZW50ID0gcGFyZW50LmdldFBhcmVudCgpO1xuICAgIH1cbiAgICBicmVhaztcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4vKipcbiAqIFJldHVybnMgYSB0dXBsZSB0aGF0IGNhbiBiZSByZXN0ZWQgKC4uLikgaW50byBtZXJnZVJlZ2lzdGVyIHRvIGNsZWFuIHVwXG4gKiBub2RlIHRyYW5zZm9ybXMgbGlzdGVuZXJzIHRoYXQgdHJhbnNmb3JtcyB0ZXh0IGludG8gYW5vdGhlciBub2RlLCBlZy4gYSBIYXNodGFnTm9kZS5cbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiBtZXJnZVJlZ2lzdGVyKFxuICAgICAgLi4ucmVnaXN0ZXJMZXhpY2FsVGV4dEVudGl0eShlZGl0b3IsIGdldE1hdGNoLCB0YXJnZXROb2RlLCBjcmVhdGVOb2RlKSxcbiAgICApO1xuICB9LCBbY3JlYXRlTm9kZSwgZWRpdG9yLCBnZXRNYXRjaCwgdGFyZ2V0Tm9kZV0pO1xuICogYGBgXG4gKiBXaGVyZSB0YXJnZXROb2RlIGlzIHRoZSB0eXBlIG9mIG5vZGUgY29udGFpbmluZyB0aGUgdGV4dCB5b3Ugd2FudCB0byB0cmFuc2Zvcm0gKGxpa2UgYSB0ZXh0IGlucHV0KSxcbiAqIHRoZW4gZ2V0TWF0Y2ggdXNlcyBhIHJlZ2V4IHRvIGZpbmQgYSBtYXRjaGluZyB0ZXh0IGFuZCBjcmVhdGVzIHRoZSBwcm9wZXIgbm9kZSB0byBpbmNsdWRlIHRoZSBtYXRjaGluZyB0ZXh0LlxuICogQHBhcmFtIGVkaXRvciAtIFRoZSBsZXhpY2FsIGVkaXRvci5cbiAqIEBwYXJhbSBnZXRNYXRjaCAtIEZpbmRzIGEgbWF0Y2hpbmcgc3RyaW5nIHRoYXQgc2F0aXNmaWVzIGEgcmVnZXggZXhwcmVzc2lvbi5cbiAqIEBwYXJhbSB0YXJnZXROb2RlIC0gVGhlIG5vZGUgdHlwZSB0aGF0IGNvbnRhaW5zIHRleHQgdG8gbWF0Y2ggd2l0aC4gZWcuIEhhc2h0YWdOb2RlXG4gKiBAcGFyYW0gY3JlYXRlTm9kZSAtIEEgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGEgbmV3IG5vZGUgdG8gY29udGFpbiB0aGUgbWF0Y2hlZCB0ZXh0LiBlZyBjcmVhdGVIYXNodGFnTm9kZVxuICogQHJldHVybnMgQW4gYXJyYXkgY29udGFpbmluZyB0aGUgcGxhaW4gdGV4dCBhbmQgcmV2ZXJzZSBub2RlIHRyYW5zZm9ybSBsaXN0ZW5lcnMuXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyTGV4aWNhbFRleHRFbnRpdHkoZWRpdG9yLCBnZXRNYXRjaCwgdGFyZ2V0Tm9kZSwgY3JlYXRlTm9kZSkge1xuICBjb25zdCBpc1RhcmdldE5vZGUgPSBub2RlID0+IHtcbiAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIHRhcmdldE5vZGU7XG4gIH07XG4gIGNvbnN0ICRyZXBsYWNlV2l0aFNpbXBsZVRleHQgPSBub2RlID0+IHtcbiAgICBjb25zdCB0ZXh0Tm9kZSA9ICRjcmVhdGVUZXh0Tm9kZShub2RlLmdldFRleHRDb250ZW50KCkpO1xuICAgIHRleHROb2RlLnNldEZvcm1hdChub2RlLmdldEZvcm1hdCgpKTtcbiAgICBub2RlLnJlcGxhY2UodGV4dE5vZGUpO1xuICB9O1xuICBjb25zdCBnZXRNb2RlID0gbm9kZSA9PiB7XG4gICAgcmV0dXJuIG5vZGUuZ2V0TGF0ZXN0KCkuX19tb2RlO1xuICB9O1xuICBjb25zdCAkdGV4dE5vZGVUcmFuc2Zvcm0gPSBub2RlID0+IHtcbiAgICBpZiAoIW5vZGUuaXNTaW1wbGVUZXh0KCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHByZXZTaWJsaW5nID0gbm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICBsZXQgdGV4dCA9IG5vZGUuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICBsZXQgY3VycmVudE5vZGUgPSBub2RlO1xuICAgIGxldCBtYXRjaDtcbiAgICBpZiAoJGlzVGV4dE5vZGUocHJldlNpYmxpbmcpKSB7XG4gICAgICBjb25zdCBwcmV2aW91c1RleHQgPSBwcmV2U2libGluZy5nZXRUZXh0Q29udGVudCgpO1xuICAgICAgY29uc3QgY29tYmluZWRUZXh0ID0gcHJldmlvdXNUZXh0ICsgdGV4dDtcbiAgICAgIGNvbnN0IHByZXZNYXRjaCA9IGdldE1hdGNoKGNvbWJpbmVkVGV4dCk7XG4gICAgICBpZiAoaXNUYXJnZXROb2RlKHByZXZTaWJsaW5nKSkge1xuICAgICAgICBpZiAocHJldk1hdGNoID09PSBudWxsIHx8IGdldE1vZGUocHJldlNpYmxpbmcpICE9PSAwKSB7XG4gICAgICAgICAgJHJlcGxhY2VXaXRoU2ltcGxlVGV4dChwcmV2U2libGluZyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGRpZmYgPSBwcmV2TWF0Y2guZW5kIC0gcHJldmlvdXNUZXh0Lmxlbmd0aDtcbiAgICAgICAgICBpZiAoZGlmZiA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbmNhdFRleHQgPSB0ZXh0LnNsaWNlKDAsIGRpZmYpO1xuICAgICAgICAgICAgY29uc3QgbmV3VGV4dENvbnRlbnQgPSBwcmV2aW91c1RleHQgKyBjb25jYXRUZXh0O1xuICAgICAgICAgICAgcHJldlNpYmxpbmcuc2VsZWN0KCk7XG4gICAgICAgICAgICBwcmV2U2libGluZy5zZXRUZXh0Q29udGVudChuZXdUZXh0Q29udGVudCk7XG4gICAgICAgICAgICBpZiAoZGlmZiA9PT0gdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlbWFpbmluZ1RleHQgPSB0ZXh0LnNsaWNlKGRpZmYpO1xuICAgICAgICAgICAgICBub2RlLnNldFRleHRDb250ZW50KHJlbWFpbmluZ1RleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwcmV2TWF0Y2ggPT09IG51bGwgfHwgcHJldk1hdGNoLnN0YXJ0IDwgcHJldmlvdXNUZXh0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBwcmV2TWF0Y2hMZW5ndGhUb1NraXAgPSAwO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgbWF0Y2ggPSBnZXRNYXRjaCh0ZXh0KTtcbiAgICAgIGxldCBuZXh0VGV4dCA9IG1hdGNoID09PSBudWxsID8gJycgOiB0ZXh0LnNsaWNlKG1hdGNoLmVuZCk7XG4gICAgICB0ZXh0ID0gbmV4dFRleHQ7XG4gICAgICBpZiAobmV4dFRleHQgPT09ICcnKSB7XG4gICAgICAgIGNvbnN0IG5leHRTaWJsaW5nID0gY3VycmVudE5vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICAgICAgaWYgKCRpc1RleHROb2RlKG5leHRTaWJsaW5nKSkge1xuICAgICAgICAgIG5leHRUZXh0ID0gY3VycmVudE5vZGUuZ2V0VGV4dENvbnRlbnQoKSArIG5leHRTaWJsaW5nLmdldFRleHRDb250ZW50KCk7XG4gICAgICAgICAgY29uc3QgbmV4dE1hdGNoID0gZ2V0TWF0Y2gobmV4dFRleHQpO1xuICAgICAgICAgIGlmIChuZXh0TWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChpc1RhcmdldE5vZGUobmV4dFNpYmxpbmcpKSB7XG4gICAgICAgICAgICAgICRyZXBsYWNlV2l0aFNpbXBsZVRleHQobmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV4dFNpYmxpbmcubWFya0RpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBlbHNlIGlmIChuZXh0TWF0Y2guc3RhcnQgIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAobWF0Y2guc3RhcnQgPT09IDAgJiYgJGlzVGV4dE5vZGUocHJldlNpYmxpbmcpICYmIHByZXZTaWJsaW5nLmlzVGV4dEVudGl0eSgpKSB7XG4gICAgICAgIHByZXZNYXRjaExlbmd0aFRvU2tpcCArPSBtYXRjaC5lbmQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbGV0IG5vZGVUb1JlcGxhY2U7XG4gICAgICBpZiAobWF0Y2guc3RhcnQgPT09IDApIHtcbiAgICAgICAgW25vZGVUb1JlcGxhY2UsIGN1cnJlbnROb2RlXSA9IGN1cnJlbnROb2RlLnNwbGl0VGV4dChtYXRjaC5lbmQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgWywgbm9kZVRvUmVwbGFjZSwgY3VycmVudE5vZGVdID0gY3VycmVudE5vZGUuc3BsaXRUZXh0KG1hdGNoLnN0YXJ0ICsgcHJldk1hdGNoTGVuZ3RoVG9Ta2lwLCBtYXRjaC5lbmQgKyBwcmV2TWF0Y2hMZW5ndGhUb1NraXApO1xuICAgICAgfVxuICAgICAgaWYgKCEobm9kZVRvUmVwbGFjZSAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICB0aHJvdyBFcnJvcihgJHsnbm9kZVRvUmVwbGFjZSd9IHNob3VsZCBub3QgYmUgdW5kZWZpbmVkLiBZb3UgbWF5IHdhbnQgdG8gY2hlY2sgc3BsaXRPZmZzZXRzIHBhc3NlZCB0byB0aGUgc3BsaXRUZXh0LmApO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVwbGFjZW1lbnROb2RlID0gY3JlYXRlTm9kZShub2RlVG9SZXBsYWNlKTtcbiAgICAgIHJlcGxhY2VtZW50Tm9kZS5zZXRGb3JtYXQobm9kZVRvUmVwbGFjZS5nZXRGb3JtYXQoKSk7XG4gICAgICBub2RlVG9SZXBsYWNlLnJlcGxhY2UocmVwbGFjZW1lbnROb2RlKTtcbiAgICAgIGlmIChjdXJyZW50Tm9kZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHByZXZNYXRjaExlbmd0aFRvU2tpcCA9IDA7XG4gICAgICBwcmV2U2libGluZyA9IHJlcGxhY2VtZW50Tm9kZTtcbiAgICB9XG4gIH07XG4gIGNvbnN0ICRyZXZlcnNlTm9kZVRyYW5zZm9ybSA9IG5vZGUgPT4ge1xuICAgIGNvbnN0IHRleHQgPSBub2RlLmdldFRleHRDb250ZW50KCk7XG4gICAgY29uc3QgbWF0Y2ggPSBnZXRNYXRjaCh0ZXh0KTtcbiAgICBpZiAobWF0Y2ggPT09IG51bGwgfHwgbWF0Y2guc3RhcnQgIT09IDApIHtcbiAgICAgICRyZXBsYWNlV2l0aFNpbXBsZVRleHQobm9kZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0ZXh0Lmxlbmd0aCA+IG1hdGNoLmVuZCkge1xuICAgICAgLy8gVGhpcyB3aWxsIHNwbGl0IG91dCB0aGUgcmVzdCBvZiB0aGUgdGV4dCBhcyBzaW1wbGUgdGV4dFxuICAgICAgbm9kZS5zcGxpdFRleHQobWF0Y2guZW5kKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcHJldlNpYmxpbmcgPSBub2RlLmdldFByZXZpb3VzU2libGluZygpO1xuICAgIGlmICgkaXNUZXh0Tm9kZShwcmV2U2libGluZykgJiYgcHJldlNpYmxpbmcuaXNUZXh0RW50aXR5KCkpIHtcbiAgICAgICRyZXBsYWNlV2l0aFNpbXBsZVRleHQocHJldlNpYmxpbmcpO1xuICAgICAgJHJlcGxhY2VXaXRoU2ltcGxlVGV4dChub2RlKTtcbiAgICB9XG4gICAgY29uc3QgbmV4dFNpYmxpbmcgPSBub2RlLmdldE5leHRTaWJsaW5nKCk7XG4gICAgaWYgKCRpc1RleHROb2RlKG5leHRTaWJsaW5nKSAmJiBuZXh0U2libGluZy5pc1RleHRFbnRpdHkoKSkge1xuICAgICAgJHJlcGxhY2VXaXRoU2ltcGxlVGV4dChuZXh0U2libGluZyk7XG5cbiAgICAgIC8vIFRoaXMgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIGNvbnZlcnRlZCBpbiB0aGUgcHJldmlvdXMgYmxvY2tcbiAgICAgIGlmIChpc1RhcmdldE5vZGUobm9kZSkpIHtcbiAgICAgICAgJHJlcGxhY2VXaXRoU2ltcGxlVGV4dChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IHJlbW92ZVBsYWluVGV4dFRyYW5zZm9ybSA9IGVkaXRvci5yZWdpc3Rlck5vZGVUcmFuc2Zvcm0oVGV4dE5vZGUsICR0ZXh0Tm9kZVRyYW5zZm9ybSk7XG4gIGNvbnN0IHJlbW92ZVJldmVyc2VOb2RlVHJhbnNmb3JtID0gZWRpdG9yLnJlZ2lzdGVyTm9kZVRyYW5zZm9ybSh0YXJnZXROb2RlLCAkcmV2ZXJzZU5vZGVUcmFuc2Zvcm0pO1xuICByZXR1cm4gW3JlbW92ZVBsYWluVGV4dFRyYW5zZm9ybSwgcmVtb3ZlUmV2ZXJzZU5vZGVUcmFuc2Zvcm1dO1xufVxuXG5leHBvcnQgeyAkY2FuU2hvd1BsYWNlaG9sZGVyLCAkY2FuU2hvd1BsYWNlaG9sZGVyQ3VycnksICRmaW5kVGV4dEludGVyc2VjdGlvbkZyb21DaGFyYWN0ZXJzLCAkaXNSb290VGV4dENvbnRlbnRFbXB0eSwgJGlzUm9vdFRleHRDb250ZW50RW1wdHlDdXJyeSwgJHJvb3RUZXh0Q29udGVudCwgcmVnaXN0ZXJMZXhpY2FsVGV4dEVudGl0eSB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/text/LexicalText.dev.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/utils/LexicalUtils.dev.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@lexical/utils/LexicalUtils.dev.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $descendantsMatching: () => (/* binding */ $descendantsMatching),\n/* harmony export */   $dfs: () => (/* binding */ $dfs),\n/* harmony export */   $dfsIterator: () => (/* binding */ $dfsIterator),\n/* harmony export */   $filter: () => (/* binding */ $filter),\n/* harmony export */   $findMatchingParent: () => (/* binding */ $findMatchingParent),\n/* harmony export */   $firstToLastIterator: () => (/* binding */ $firstToLastIterator),\n/* harmony export */   $getDepth: () => (/* binding */ $getDepth),\n/* harmony export */   $getNearestBlockElementAncestorOrThrow: () => (/* binding */ $getNearestBlockElementAncestorOrThrow),\n/* harmony export */   $getNearestNodeOfType: () => (/* binding */ $getNearestNodeOfType),\n/* harmony export */   $getNextRightPreorderNode: () => (/* binding */ $getNextRightPreorderNode),\n/* harmony export */   $getNextSiblingOrParentSibling: () => (/* binding */ $getNextSiblingOrParentSibling),\n/* harmony export */   $insertFirst: () => (/* binding */ $insertFirst),\n/* harmony export */   $insertNodeToNearestRoot: () => (/* binding */ $insertNodeToNearestRoot),\n/* harmony export */   $isEditorIsNestedEditor: () => (/* binding */ $isEditorIsNestedEditor),\n/* harmony export */   $lastToFirstIterator: () => (/* binding */ $lastToFirstIterator),\n/* harmony export */   $restoreEditorState: () => (/* binding */ $restoreEditorState),\n/* harmony export */   $splitNode: () => (/* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.$splitNode),\n/* harmony export */   $unwrapAndFilterDescendants: () => (/* binding */ $unwrapAndFilterDescendants),\n/* harmony export */   $unwrapNode: () => (/* binding */ $unwrapNode),\n/* harmony export */   $wrapNodeInElement: () => (/* binding */ $wrapNodeInElement),\n/* harmony export */   CAN_USE_BEFORE_INPUT: () => (/* binding */ CAN_USE_BEFORE_INPUT),\n/* harmony export */   CAN_USE_DOM: () => (/* binding */ CAN_USE_DOM),\n/* harmony export */   IS_ANDROID: () => (/* binding */ IS_ANDROID),\n/* harmony export */   IS_ANDROID_CHROME: () => (/* binding */ IS_ANDROID_CHROME),\n/* harmony export */   IS_APPLE: () => (/* binding */ IS_APPLE),\n/* harmony export */   IS_APPLE_WEBKIT: () => (/* binding */ IS_APPLE_WEBKIT),\n/* harmony export */   IS_CHROME: () => (/* binding */ IS_CHROME),\n/* harmony export */   IS_FIREFOX: () => (/* binding */ IS_FIREFOX),\n/* harmony export */   IS_IOS: () => (/* binding */ IS_IOS),\n/* harmony export */   IS_SAFARI: () => (/* binding */ IS_SAFARI),\n/* harmony export */   addClassNamesToElement: () => (/* binding */ addClassNamesToElement),\n/* harmony export */   calculateZoomLevel: () => (/* binding */ calculateZoomLevel),\n/* harmony export */   isBlockDomNode: () => (/* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.isBlockDomNode),\n/* harmony export */   isHTMLAnchorElement: () => (/* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLAnchorElement),\n/* harmony export */   isHTMLElement: () => (/* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement),\n/* harmony export */   isInlineDomNode: () => (/* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.isInlineDomNode),\n/* harmony export */   isMimeType: () => (/* binding */ isMimeType),\n/* harmony export */   markSelection: () => (/* binding */ markSelection),\n/* harmony export */   mediaFileReader: () => (/* binding */ mediaFileReader),\n/* harmony export */   mergeRegister: () => (/* binding */ mergeRegister),\n/* harmony export */   objectKlassEquals: () => (/* binding */ objectKlassEquals),\n/* harmony export */   positionNodeOnRange: () => (/* binding */ mlcPositionNodeOnRange),\n/* harmony export */   registerNestedElementResolver: () => (/* binding */ registerNestedElementResolver),\n/* harmony export */   removeClassNamesFromElement: () => (/* binding */ removeClassNamesFromElement),\n/* harmony export */   selectionAlwaysOnDisplay: () => (/* binding */ selectionAlwaysOnDisplay)\n/* harmony export */ });\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(app-pages-browser)/./node_modules/lexical/Lexical.dev.mjs\");\n/* harmony import */ var _lexical_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/selection */ \"(app-pages-browser)/./node_modules/@lexical/selection/LexicalSelection.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM$1 = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst documentMode = CAN_USE_DOM$1 && 'documentMode' in document ? document.documentMode : null;\nconst IS_APPLE$1 = CAN_USE_DOM$1 && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nconst IS_FIREFOX$1 = CAN_USE_DOM$1 && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nconst CAN_USE_BEFORE_INPUT$1 = CAN_USE_DOM$1 && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI$1 = CAN_USE_DOM$1 && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS$1 = CAN_USE_DOM$1 && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\nconst IS_ANDROID$1 = CAN_USE_DOM$1 && /Android/.test(navigator.userAgent);\n\n// Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\nconst IS_CHROME$1 = CAN_USE_DOM$1 && /^(?=.*Chrome).*/i.test(navigator.userAgent);\n// export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\nconst IS_ANDROID_CHROME$1 = CAN_USE_DOM$1 && IS_ANDROID$1 && IS_CHROME$1;\nconst IS_APPLE_WEBKIT$1 = CAN_USE_DOM$1 && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME$1;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction normalizeClassNames(...classNames) {\n  const rval = [];\n  for (const className of classNames) {\n    if (className && typeof className === 'string') {\n      for (const [s] of className.matchAll(/\\S+/g)) {\n        rval.push(s);\n      }\n    }\n  }\n  return rval;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Returns a function that will execute all functions passed when called. It is generally used\n * to register multiple lexical listeners and then tear them down with a single function call, such\n * as React's useEffect hook.\n * @example\n * ```ts\n * useEffect(() => {\n *   return mergeRegister(\n *     editor.registerCommand(...registerCommand1 logic),\n *     editor.registerCommand(...registerCommand2 logic),\n *     editor.registerCommand(...registerCommand3 logic)\n *   )\n * }, [editor])\n * ```\n * In this case, useEffect is returning the function returned by mergeRegister as a cleanup\n * function to be executed after either the useEffect runs again (due to one of its dependencies\n * updating) or the component it resides in unmounts.\n * Note the functions don't neccesarily need to be in an array as all arguments\n * are considered to be the func argument and spread from there.\n * The order of cleanup is the reverse of the argument order. Generally it is\n * expected that the first \"acquire\" will be \"released\" last (LIFO order),\n * because a later step may have some dependency on an earlier one.\n * @param func - An array of cleanup functions meant to be executed by the returned function.\n * @returns the function which executes all the passed cleanup functions.\n */\nfunction mergeRegister(...func) {\n  return () => {\n    for (let i = func.length - 1; i >= 0; i--) {\n      func[i]();\n    }\n    // Clean up the references and make future calls a no-op\n    func.length = 0;\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction px(value) {\n  return `${value}px`;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst mutationObserverConfig = {\n  attributes: true,\n  characterData: true,\n  childList: true,\n  subtree: true\n};\nfunction prependDOMNode(parent, node) {\n  parent.insertBefore(node, parent.firstChild);\n}\n\n/**\n * Place one or multiple newly created Nodes at the passed Range's position.\n * Multiple nodes will only be created when the Range spans multiple lines (aka\n * client rects).\n *\n * This function can come particularly useful to highlight particular parts of\n * the text without interfering with the EditorState, that will often replicate\n * the state across collab and clipboard.\n *\n * This function accounts for DOM updates which can modify the passed Range.\n * Hence, the function return to remove the listener.\n */\nfunction mlcPositionNodeOnRange(editor, range, onReposition) {\n  let rootDOMNode = null;\n  let parentDOMNode = null;\n  let observer = null;\n  let lastNodes = [];\n  const wrapperNode = document.createElement('div');\n  wrapperNode.style.position = 'relative';\n  function position() {\n    if (!(rootDOMNode !== null)) {\n      throw Error(`Unexpected null rootDOMNode`);\n    }\n    if (!(parentDOMNode !== null)) {\n      throw Error(`Unexpected null parentDOMNode`);\n    }\n    const {\n      left: parentLeft,\n      top: parentTop\n    } = parentDOMNode.getBoundingClientRect();\n    const rects = (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_1__.createRectsFromDOMRange)(editor, range);\n    if (!wrapperNode.isConnected) {\n      prependDOMNode(parentDOMNode, wrapperNode);\n    }\n    let hasRepositioned = false;\n    for (let i = 0; i < rects.length; i++) {\n      const rect = rects[i];\n      // Try to reuse the previously created Node when possible, no need to\n      // remove/create on the most common case reposition case\n      const rectNode = lastNodes[i] || document.createElement('div');\n      const rectNodeStyle = rectNode.style;\n      if (rectNodeStyle.position !== 'absolute') {\n        rectNodeStyle.position = 'absolute';\n        hasRepositioned = true;\n      }\n      const left = px(rect.left - parentLeft);\n      if (rectNodeStyle.left !== left) {\n        rectNodeStyle.left = left;\n        hasRepositioned = true;\n      }\n      const top = px(rect.top - parentTop);\n      if (rectNodeStyle.top !== top) {\n        rectNode.style.top = top;\n        hasRepositioned = true;\n      }\n      const width = px(rect.width);\n      if (rectNodeStyle.width !== width) {\n        rectNode.style.width = width;\n        hasRepositioned = true;\n      }\n      const height = px(rect.height);\n      if (rectNodeStyle.height !== height) {\n        rectNode.style.height = height;\n        hasRepositioned = true;\n      }\n      if (rectNode.parentNode !== wrapperNode) {\n        wrapperNode.append(rectNode);\n        hasRepositioned = true;\n      }\n      lastNodes[i] = rectNode;\n    }\n    while (lastNodes.length > rects.length) {\n      lastNodes.pop();\n    }\n    if (hasRepositioned) {\n      onReposition(lastNodes);\n    }\n  }\n  function stop() {\n    parentDOMNode = null;\n    rootDOMNode = null;\n    if (observer !== null) {\n      observer.disconnect();\n    }\n    observer = null;\n    wrapperNode.remove();\n    for (const node of lastNodes) {\n      node.remove();\n    }\n    lastNodes = [];\n  }\n  function restart() {\n    const currentRootDOMNode = editor.getRootElement();\n    if (currentRootDOMNode === null) {\n      return stop();\n    }\n    const currentParentDOMNode = currentRootDOMNode.parentElement;\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(currentParentDOMNode)) {\n      return stop();\n    }\n    stop();\n    rootDOMNode = currentRootDOMNode;\n    parentDOMNode = currentParentDOMNode;\n    observer = new MutationObserver(mutations => {\n      const nextRootDOMNode = editor.getRootElement();\n      const nextParentDOMNode = nextRootDOMNode && nextRootDOMNode.parentElement;\n      if (nextRootDOMNode !== rootDOMNode || nextParentDOMNode !== parentDOMNode) {\n        return restart();\n      }\n      for (const mutation of mutations) {\n        if (!wrapperNode.contains(mutation.target)) {\n          // TODO throttle\n          return position();\n        }\n      }\n    });\n    observer.observe(currentParentDOMNode, mutationObserverConfig);\n    position();\n  }\n  const removeRootListener = editor.registerRootListener(restart);\n  return () => {\n    removeRootListener();\n    stop();\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction rangeTargetFromPoint(point, node, dom) {\n  if (point.type === 'text' || !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node)) {\n    const textDOM = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.getDOMTextNode)(dom) || dom;\n    return [textDOM, point.offset];\n  } else {\n    const slot = node.getDOMSlot(dom);\n    return [slot.element, slot.getFirstChildOffset() + point.offset];\n  }\n}\nfunction rangeFromPoints(editor, anchor, anchorNode, anchorDOM, focus, focusNode, focusDOM) {\n  const editorDocument = editor._window ? editor._window.document : document;\n  const range = editorDocument.createRange();\n  if (focusNode.isBefore(anchorNode)) {\n    range.setStart(...rangeTargetFromPoint(focus, focusNode, focusDOM));\n    range.setEnd(...rangeTargetFromPoint(anchor, anchorNode, anchorDOM));\n  } else {\n    range.setStart(...rangeTargetFromPoint(anchor, anchorNode, anchorDOM));\n    range.setEnd(...rangeTargetFromPoint(focus, focusNode, focusDOM));\n  }\n  return range;\n}\n/**\n * Place one or multiple newly created Nodes at the current selection. Multiple\n * nodes will only be created when the selection spans multiple lines (aka\n * client rects).\n *\n * This function can come useful when you want to show the selection but the\n * editor has been focused away.\n */\nfunction markSelection(editor, onReposition) {\n  let previousAnchorNode = null;\n  let previousAnchorNodeDOM = null;\n  let previousAnchorOffset = null;\n  let previousFocusNode = null;\n  let previousFocusNodeDOM = null;\n  let previousFocusOffset = null;\n  let removeRangeListener = () => {};\n  function compute(editorState) {\n    editorState.read(() => {\n      const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n      if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n        // TODO\n        previousAnchorNode = null;\n        previousAnchorOffset = null;\n        previousFocusNode = null;\n        previousFocusOffset = null;\n        removeRangeListener();\n        removeRangeListener = () => {};\n        return;\n      }\n      const {\n        anchor,\n        focus\n      } = selection;\n      const currentAnchorNode = anchor.getNode();\n      const currentAnchorNodeKey = currentAnchorNode.getKey();\n      const currentAnchorOffset = anchor.offset;\n      const currentFocusNode = focus.getNode();\n      const currentFocusNodeKey = currentFocusNode.getKey();\n      const currentFocusOffset = focus.offset;\n      const currentAnchorNodeDOM = editor.getElementByKey(currentAnchorNodeKey);\n      const currentFocusNodeDOM = editor.getElementByKey(currentFocusNodeKey);\n      const differentAnchorDOM = previousAnchorNode === null || currentAnchorNodeDOM !== previousAnchorNodeDOM || currentAnchorOffset !== previousAnchorOffset || currentAnchorNodeKey !== previousAnchorNode.getKey();\n      const differentFocusDOM = previousFocusNode === null || currentFocusNodeDOM !== previousFocusNodeDOM || currentFocusOffset !== previousFocusOffset || currentFocusNodeKey !== previousFocusNode.getKey();\n      if ((differentAnchorDOM || differentFocusDOM) && currentAnchorNodeDOM !== null && currentFocusNodeDOM !== null) {\n        const range = rangeFromPoints(editor, anchor, currentAnchorNode, currentAnchorNodeDOM, focus, currentFocusNode, currentFocusNodeDOM);\n        removeRangeListener();\n        removeRangeListener = mlcPositionNodeOnRange(editor, range, domNodes => {\n          if (onReposition === undefined) {\n            for (const domNode of domNodes) {\n              const domNodeStyle = domNode.style;\n              if (domNodeStyle.background !== 'Highlight') {\n                domNodeStyle.background = 'Highlight';\n              }\n              if (domNodeStyle.color !== 'HighlightText') {\n                domNodeStyle.color = 'HighlightText';\n              }\n              if (domNodeStyle.marginTop !== px(-1.5)) {\n                domNodeStyle.marginTop = px(-1.5);\n              }\n              if (domNodeStyle.paddingTop !== px(4)) {\n                domNodeStyle.paddingTop = px(4);\n              }\n              if (domNodeStyle.paddingBottom !== px(0)) {\n                domNodeStyle.paddingBottom = px(0);\n              }\n            }\n          } else {\n            onReposition(domNodes);\n          }\n        });\n      }\n      previousAnchorNode = currentAnchorNode;\n      previousAnchorNodeDOM = currentAnchorNodeDOM;\n      previousAnchorOffset = currentAnchorOffset;\n      previousFocusNode = currentFocusNode;\n      previousFocusNodeDOM = currentFocusNodeDOM;\n      previousFocusOffset = currentFocusOffset;\n    });\n  }\n  compute(editor.getEditorState());\n  return mergeRegister(editor.registerUpdateListener(({\n    editorState\n  }) => compute(editorState)), () => {\n    removeRangeListener();\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction selectionAlwaysOnDisplay(editor) {\n  let removeSelectionMark = null;\n  const onSelectionChange = () => {\n    const domSelection = getSelection();\n    const domAnchorNode = domSelection && domSelection.anchorNode;\n    const editorRootElement = editor.getRootElement();\n    const isSelectionInsideEditor = domAnchorNode !== null && editorRootElement !== null && editorRootElement.contains(domAnchorNode);\n    if (isSelectionInsideEditor) {\n      if (removeSelectionMark !== null) {\n        removeSelectionMark();\n        removeSelectionMark = null;\n      }\n    } else {\n      if (removeSelectionMark === null) {\n        removeSelectionMark = markSelection(editor);\n      }\n    }\n  };\n  document.addEventListener('selectionchange', onSelectionChange);\n  return () => {\n    if (removeSelectionMark !== null) {\n      removeSelectionMark();\n    }\n    document.removeEventListener('selectionchange', onSelectionChange);\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Hotfix to export these with inlined types #5918\nconst CAN_USE_BEFORE_INPUT = CAN_USE_BEFORE_INPUT$1;\nconst CAN_USE_DOM = CAN_USE_DOM$1;\nconst IS_ANDROID = IS_ANDROID$1;\nconst IS_ANDROID_CHROME = IS_ANDROID_CHROME$1;\nconst IS_APPLE = IS_APPLE$1;\nconst IS_APPLE_WEBKIT = IS_APPLE_WEBKIT$1;\nconst IS_CHROME = IS_CHROME$1;\nconst IS_FIREFOX = IS_FIREFOX$1;\nconst IS_IOS = IS_IOS$1;\nconst IS_SAFARI = IS_SAFARI$1;\n\n/**\n * Takes an HTML element and adds the classNames passed within an array,\n * ignoring any non-string types. A space can be used to add multiple classes\n * eg. addClassNamesToElement(element, ['element-inner active', true, null])\n * will add both 'element-inner' and 'active' as classes to that element.\n * @param element - The element in which the classes are added\n * @param classNames - An array defining the class names to add to the element\n */\nfunction addClassNamesToElement(element, ...classNames) {\n  const classesToAdd = normalizeClassNames(...classNames);\n  if (classesToAdd.length > 0) {\n    element.classList.add(...classesToAdd);\n  }\n}\n\n/**\n * Takes an HTML element and removes the classNames passed within an array,\n * ignoring any non-string types. A space can be used to remove multiple classes\n * eg. removeClassNamesFromElement(element, ['active small', true, null])\n * will remove both the 'active' and 'small' classes from that element.\n * @param element - The element in which the classes are removed\n * @param classNames - An array defining the class names to remove from the element\n */\nfunction removeClassNamesFromElement(element, ...classNames) {\n  const classesToRemove = normalizeClassNames(...classNames);\n  if (classesToRemove.length > 0) {\n    element.classList.remove(...classesToRemove);\n  }\n}\n\n/**\n * Returns true if the file type matches the types passed within the acceptableMimeTypes array, false otherwise.\n * The types passed must be strings and are CASE-SENSITIVE.\n * eg. if file is of type 'text' and acceptableMimeTypes = ['TEXT', 'IMAGE'] the function will return false.\n * @param file - The file you want to type check.\n * @param acceptableMimeTypes - An array of strings of types which the file is checked against.\n * @returns true if the file is an acceptable mime type, false otherwise.\n */\nfunction isMimeType(file, acceptableMimeTypes) {\n  for (const acceptableType of acceptableMimeTypes) {\n    if (file.type.startsWith(acceptableType)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Lexical File Reader with:\n *  1. MIME type support\n *  2. batched results (HistoryPlugin compatibility)\n *  3. Order aware (respects the order when multiple Files are passed)\n *\n * const filesResult = await mediaFileReader(files, ['image/']);\n * filesResult.forEach(file => editor.dispatchCommand('INSERT_IMAGE', \\\\{\n *   src: file.result,\n * \\\\}));\n */\nfunction mediaFileReader(files, acceptableMimeTypes) {\n  const filesIterator = files[Symbol.iterator]();\n  return new Promise((resolve, reject) => {\n    const processed = [];\n    const handleNextFile = () => {\n      const {\n        done,\n        value: file\n      } = filesIterator.next();\n      if (done) {\n        return resolve(processed);\n      }\n      const fileReader = new FileReader();\n      fileReader.addEventListener('error', reject);\n      fileReader.addEventListener('load', () => {\n        const result = fileReader.result;\n        if (typeof result === 'string') {\n          processed.push({\n            file,\n            result\n          });\n        }\n        handleNextFile();\n      });\n      if (isMimeType(file, acceptableMimeTypes)) {\n        fileReader.readAsDataURL(file);\n      } else {\n        handleNextFile();\n      }\n    };\n    handleNextFile();\n  });\n}\n/**\n * \"Depth-First Search\" starts at the root/top node of a tree and goes as far as it can down a branch end\n * before backtracking and finding a new path. Consider solving a maze by hugging either wall, moving down a\n * branch until you hit a dead-end (leaf) and backtracking to find the nearest branching path and repeat.\n * It will then return all the nodes found in the search in an array of objects.\n * @param startNode - The node to start the search, if omitted, it will start at the root node.\n * @param endNode - The node to end the search, if omitted, it will find all descendants of the startingNode.\n * @returns An array of objects of all the nodes found by the search, including their depth into the tree.\n * \\\\{depth: number, node: LexicalNode\\\\} It will always return at least 1 node (the start node).\n */\nfunction $dfs(startNode, endNode) {\n  return Array.from($dfsIterator(startNode, endNode));\n}\nconst iteratorDone = {\n  done: true,\n  value: undefined\n};\nconst iteratorNotDone = value => ({\n  done: false,\n  value\n});\n\n/**\n * $dfs iterator. Tree traversal is done on the fly as new values are requested with O(1) memory.\n * @param startNode - The node to start the search, if omitted, it will start at the root node.\n * @param endNode - The node to end the search, if omitted, it will find all descendants of the startingNode.\n * @returns An iterator, each yielded value is a DFSNode. It will always return at least 1 node (the start node).\n */\nfunction $dfsIterator(startNode, endNode) {\n  const start = (startNode || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)()).getLatest();\n  const startDepth = $getDepth(start);\n  const end = endNode;\n  let node = start;\n  let depth = startDepth;\n  let isFirstNext = true;\n  const iterator = {\n    next() {\n      if (node === null) {\n        return iteratorDone;\n      }\n      if (isFirstNext) {\n        isFirstNext = false;\n        return iteratorNotDone({\n          depth,\n          node\n        });\n      }\n      if (node === end) {\n        return iteratorDone;\n      }\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && node.getChildrenSize() > 0) {\n        node = node.getFirstChild();\n        depth++;\n      } else {\n        let depthDiff;\n        [node, depthDiff] = $getNextSiblingOrParentSibling(node) || [null, 0];\n        depth += depthDiff;\n        if (end == null && depth <= startDepth) {\n          node = null;\n        }\n      }\n      if (node === null) {\n        return iteratorDone;\n      }\n      return iteratorNotDone({\n        depth,\n        node\n      });\n    },\n    [Symbol.iterator]() {\n      return iterator;\n    }\n  };\n  return iterator;\n}\n\n/**\n * Returns the Node sibling when this exists, otherwise the closest parent sibling. For example\n * R -> P -> T1, T2\n *   -> P2\n * returns T2 for node T1, P2 for node T2, and null for node P2.\n * @param node LexicalNode.\n * @returns An array (tuple) containing the found Lexical node and the depth difference, or null, if this node doesn't exist.\n */\nfunction $getNextSiblingOrParentSibling(node) {\n  let node_ = node;\n  // Find immediate sibling or nearest parent sibling\n  let sibling = null;\n  let depthDiff = 0;\n  while (sibling === null && node_ !== null) {\n    sibling = node_.getNextSibling();\n    if (sibling === null) {\n      node_ = node_.getParent();\n      depthDiff--;\n    } else {\n      node_ = sibling;\n    }\n  }\n  if (node_ === null) {\n    return null;\n  }\n  return [node_, depthDiff];\n}\nfunction $getDepth(node) {\n  let innerNode = node;\n  let depth = 0;\n  while ((innerNode = innerNode.getParent()) !== null) {\n    depth++;\n  }\n  return depth;\n}\n\n/**\n * Performs a right-to-left preorder tree traversal.\n * From the starting node it goes to the rightmost child, than backtracks to paret and finds new rightmost path.\n * It will return the next node in traversal sequence after the startingNode.\n * The traversal is similar to $dfs functions above, but the nodes are visited right-to-left, not left-to-right.\n * @param startingNode - The node to start the search.\n * @returns The next node in pre-order right to left traversal sequence or `null`, if the node does not exist\n */\nfunction $getNextRightPreorderNode(startingNode) {\n  let node = startingNode;\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && node.getChildrenSize() > 0) {\n    node = node.getLastChild();\n  } else {\n    let sibling = null;\n    while (sibling === null && node !== null) {\n      sibling = node.getPreviousSibling();\n      if (sibling === null) {\n        node = node.getParent();\n      } else {\n        node = sibling;\n      }\n    }\n  }\n  return node;\n}\n\n/**\n * Takes a node and traverses up its ancestors (toward the root node)\n * in order to find a specific type of node.\n * @param node - the node to begin searching.\n * @param klass - an instance of the type of node to look for.\n * @returns the node of type klass that was passed, or null if none exist.\n */\nfunction $getNearestNodeOfType(node, klass) {\n  let parent = node;\n  while (parent != null) {\n    if (parent instanceof klass) {\n      return parent;\n    }\n    parent = parent.getParent();\n  }\n  return null;\n}\n\n/**\n * Returns the element node of the nearest ancestor, otherwise throws an error.\n * @param startNode - The starting node of the search\n * @returns The ancestor node found\n */\nfunction $getNearestBlockElementAncestorOrThrow(startNode) {\n  const blockNode = $findMatchingParent(startNode, node => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && !node.isInline());\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(blockNode)) {\n    {\n      throw Error(`Expected node ${startNode.__key} to have closest block element node.`);\n    }\n  }\n  return blockNode;\n}\n/**\n * Starts with a node and moves up the tree (toward the root node) to find a matching node based on\n * the search parameters of the findFn. (Consider JavaScripts' .find() function where a testing function must be\n * passed as an argument. eg. if( (node) => node.__type === 'div') ) return true; otherwise return false\n * @param startingNode - The node where the search starts.\n * @param findFn - A testing function that returns true if the current node satisfies the testing parameters.\n * @returns A parent node that matches the findFn parameters, or null if one wasn't found.\n */\nconst $findMatchingParent = (startingNode, findFn) => {\n  let curr = startingNode;\n  while (curr !== (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)() && curr != null) {\n    if (findFn(curr)) {\n      return curr;\n    }\n    curr = curr.getParent();\n  }\n  return null;\n};\n\n/**\n * Attempts to resolve nested element nodes of the same type into a single node of that type.\n * It is generally used for marks/commenting\n * @param editor - The lexical editor\n * @param targetNode - The target for the nested element to be extracted from.\n * @param cloneNode - See {@link $createMarkNode}\n * @param handleOverlap - Handles any overlap between the node to extract and the targetNode\n * @returns The lexical editor\n */\nfunction registerNestedElementResolver(editor, targetNode, cloneNode, handleOverlap) {\n  const $isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n  const $findMatch = node => {\n    // First validate we don't have any children that are of the target,\n    // as we need to handle them first.\n    const children = node.getChildren();\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if ($isTargetNode(child)) {\n        return null;\n      }\n    }\n    let parentNode = node;\n    let childNode = node;\n    while (parentNode !== null) {\n      childNode = parentNode;\n      parentNode = parentNode.getParent();\n      if ($isTargetNode(parentNode)) {\n        return {\n          child: childNode,\n          parent: parentNode\n        };\n      }\n    }\n    return null;\n  };\n  const $elementNodeTransform = node => {\n    const match = $findMatch(node);\n    if (match !== null) {\n      const {\n        child,\n        parent\n      } = match;\n\n      // Simple path, we can move child out and siblings into a new parent.\n\n      if (child.is(node)) {\n        handleOverlap(parent, node);\n        const nextSiblings = child.getNextSiblings();\n        const nextSiblingsLength = nextSiblings.length;\n        parent.insertAfter(child);\n        if (nextSiblingsLength !== 0) {\n          const newParent = cloneNode(parent);\n          child.insertAfter(newParent);\n          for (let i = 0; i < nextSiblingsLength; i++) {\n            newParent.append(nextSiblings[i]);\n          }\n        }\n        if (!parent.canBeEmpty() && parent.getChildrenSize() === 0) {\n          parent.remove();\n        }\n      }\n    }\n  };\n  return editor.registerNodeTransform(targetNode, $elementNodeTransform);\n}\n\n/**\n * Clones the editor and marks it as dirty to be reconciled. If there was a selection,\n * it would be set back to its previous state, or null otherwise.\n * @param editor - The lexical editor\n * @param editorState - The editor's state\n */\nfunction $restoreEditorState(editor, editorState) {\n  const FULL_RECONCILE = 2;\n  const nodeMap = new Map();\n  const activeEditorState = editor._pendingEditorState;\n  for (const [key, node] of editorState._nodeMap) {\n    nodeMap.set(key, (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$cloneWithProperties)(node));\n  }\n  if (activeEditorState) {\n    activeEditorState._nodeMap = nodeMap;\n  }\n  editor._dirtyType = FULL_RECONCILE;\n  const selection = editorState._selection;\n  (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(selection === null ? null : selection.clone());\n}\n\n/**\n * If the selected insertion area is the root/shadow root node (see {@link lexical!$isRootOrShadowRoot}),\n * the node will be appended there, otherwise, it will be inserted before the insertion area.\n * If there is no selection where the node is to be inserted, it will be appended after any current nodes\n * within the tree, as a child of the root node. A paragraph node will then be added after the inserted node and selected.\n * @param node - The node to be inserted\n * @returns The node after its insertion\n */\nfunction $insertNodeToNearestRoot(node) {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)() || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getPreviousSelection)();\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n    const {\n      focus\n    } = selection;\n    const focusNode = focus.getNode();\n    const focusOffset = focus.offset;\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(focusNode)) {\n      const focusChild = focusNode.getChildAtIndex(focusOffset);\n      if (focusChild == null) {\n        focusNode.append(node);\n      } else {\n        focusChild.insertBefore(node);\n      }\n      node.selectNext();\n    } else {\n      let splitNode;\n      let splitOffset;\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(focusNode)) {\n        splitNode = focusNode.getParentOrThrow();\n        splitOffset = focusNode.getIndexWithinParent();\n        if (focusOffset > 0) {\n          splitOffset += 1;\n          focusNode.splitText(focusOffset);\n        }\n      } else {\n        splitNode = focusNode;\n        splitOffset = focusOffset;\n      }\n      const [, rightTree] = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$splitNode)(splitNode, splitOffset);\n      rightTree.insertBefore(node);\n      rightTree.selectStart();\n    }\n  } else {\n    if (selection != null) {\n      const nodes = selection.getNodes();\n      nodes[nodes.length - 1].getTopLevelElementOrThrow().insertAfter(node);\n    } else {\n      const root = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)();\n      root.append(node);\n    }\n    const paragraphNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n    node.insertAfter(paragraphNode);\n    paragraphNode.select();\n  }\n  return node.getLatest();\n}\n\n/**\n * Wraps the node into another node created from a createElementNode function, eg. $createParagraphNode\n * @param node - Node to be wrapped.\n * @param createElementNode - Creates a new lexical element to wrap the to-be-wrapped node and returns it.\n * @returns A new lexical element with the previous node appended within (as a child, including its children).\n */\nfunction $wrapNodeInElement(node, createElementNode) {\n  const elementNode = createElementNode();\n  node.replace(elementNode);\n  elementNode.append(node);\n  return elementNode;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n/**\n * @param object = The instance of the type\n * @param objectClass = The class of the type\n * @returns Whether the object is has the same Klass of the objectClass, ignoring the difference across window (e.g. different iframs)\n */\nfunction objectKlassEquals(object, objectClass) {\n  return object !== null ? Object.getPrototypeOf(object).constructor.name === objectClass.name : false;\n}\n\n/**\n * Filter the nodes\n * @param nodes Array of nodes that needs to be filtered\n * @param filterFn A filter function that returns node if the current node satisfies the condition otherwise null\n * @returns Array of filtered nodes\n */\n\nfunction $filter(nodes, filterFn) {\n  const result = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = filterFn(nodes[i]);\n    if (node !== null) {\n      result.push(node);\n    }\n  }\n  return result;\n}\n/**\n * Appends the node before the first child of the parent node\n * @param parent A parent node\n * @param node Node that needs to be appended\n */\nfunction $insertFirst(parent, node) {\n  const firstChild = parent.getFirstChild();\n  if (firstChild !== null) {\n    firstChild.insertBefore(node);\n  } else {\n    parent.append(node);\n  }\n}\nlet NEEDS_MANUAL_ZOOM = IS_FIREFOX || !CAN_USE_DOM ? false : undefined;\nfunction needsManualZoom() {\n  if (NEEDS_MANUAL_ZOOM === undefined) {\n    // If the browser implements standardized CSS zoom, then the client rect\n    // will be wider after zoom is applied\n    // https://chromestatus.com/feature/5198254868529152\n    // https://github.com/facebook/lexical/issues/6863\n    const div = document.createElement('div');\n    div.style.cssText = 'position: absolute; opacity: 0; width: 100px; left: -1000px;';\n    document.body.appendChild(div);\n    const noZoom = div.getBoundingClientRect();\n    div.style.setProperty('zoom', '2');\n    NEEDS_MANUAL_ZOOM = div.getBoundingClientRect().width === noZoom.width;\n    document.body.removeChild(div);\n  }\n  return NEEDS_MANUAL_ZOOM;\n}\n\n/**\n * Calculates the zoom level of an element as a result of using\n * css zoom property. For browsers that implement standardized CSS\n * zoom (Firefox, Chrome >= 128), this will always return 1.\n * @param element\n */\nfunction calculateZoomLevel(element) {\n  let zoom = 1;\n  if (needsManualZoom()) {\n    while (element) {\n      zoom *= Number(window.getComputedStyle(element).getPropertyValue('zoom'));\n      element = element.parentElement;\n    }\n  }\n  return zoom;\n}\n\n/**\n * Checks if the editor is a nested editor created by LexicalNestedComposer\n */\nfunction $isEditorIsNestedEditor(editor) {\n  return editor._parentEditor !== null;\n}\n\n/**\n * A depth first last-to-first traversal of root that stops at each node that matches\n * $predicate and ensures that its parent is root. This is typically used to discard\n * invalid or unsupported wrapping nodes. For example, a TableNode must only have\n * TableRowNode as children, but an importer might add invalid nodes based on\n * caption, tbody, thead, etc. and this will unwrap and discard those.\n *\n * @param root The root to start the traversal\n * @param $predicate Should return true for nodes that are permitted to be children of root\n * @returns true if this unwrapped or removed any nodes\n */\nfunction $unwrapAndFilterDescendants(root, $predicate) {\n  return $unwrapAndFilterDescendantsImpl(root, $predicate, null);\n}\nfunction $unwrapAndFilterDescendantsImpl(root, $predicate, $onSuccess) {\n  let didMutate = false;\n  for (const node of $lastToFirstIterator(root)) {\n    if ($predicate(node)) {\n      if ($onSuccess !== null) {\n        $onSuccess(node);\n      }\n      continue;\n    }\n    didMutate = true;\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node)) {\n      $unwrapAndFilterDescendantsImpl(node, $predicate, $onSuccess ? $onSuccess : child => node.insertAfter(child));\n    }\n    node.remove();\n  }\n  return didMutate;\n}\n\n/**\n * A depth first traversal of the children array that stops at and collects\n * each node that `$predicate` matches. This is typically used to discard\n * invalid or unsupported wrapping nodes on a children array in the `after`\n * of an {@link lexical!DOMConversionOutput}. For example, a TableNode must only have\n * TableRowNode as children, but an importer might add invalid nodes based on\n * caption, tbody, thead, etc. and this will unwrap and discard those.\n *\n * This function is read-only and performs no mutation operations, which makes\n * it suitable for import and export purposes but likely not for any in-place\n * mutation. You should use {@link $unwrapAndFilterDescendants} for in-place\n * mutations such as node transforms.\n *\n * @param children The children to traverse\n * @param $predicate Should return true for nodes that are permitted to be children of root\n * @returns The children or their descendants that match $predicate\n */\n\nfunction $descendantsMatching(children, $predicate) {\n  const result = [];\n  const stack = [...children].reverse();\n  for (let child = stack.pop(); child !== undefined; child = stack.pop()) {\n    if ($predicate(child)) {\n      result.push(child);\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(child)) {\n      for (const grandchild of $lastToFirstIterator(child)) {\n        stack.push(grandchild);\n      }\n    }\n  }\n  return result;\n}\n\n/**\n * Return an iterator that yields each child of node from first to last, taking\n * care to preserve the next sibling before yielding the value in case the caller\n * removes the yielded node.\n *\n * @param node The node whose children to iterate\n * @returns An iterator of the node's children\n */\nfunction $firstToLastIterator(node) {\n  return {\n    [Symbol.iterator]: () => $childIterator(node.getFirstChild(), child => child.getNextSibling())\n  };\n}\n\n/**\n * Return an iterator that yields each child of node from last to first, taking\n * care to preserve the previous sibling before yielding the value in case the caller\n * removes the yielded node.\n *\n * @param node The node whose children to iterate\n * @returns An iterator of the node's children\n */\nfunction $lastToFirstIterator(node) {\n  return {\n    [Symbol.iterator]: () => $childIterator(node.getLastChild(), child => child.getPreviousSibling())\n  };\n}\nfunction $childIterator(initialNode, nextNode) {\n  let state = initialNode;\n  const seen = new Set() ;\n  return {\n    next() {\n      if (state === null) {\n        return iteratorDone;\n      }\n      const rval = iteratorNotDone(state);\n      if (seen !== null) {\n        const key = state.getKey();\n        if (!!seen.has(key)) {\n          throw Error(`$childIterator: Cycle detected, node with key ${String(key)} has already been traversed`);\n        }\n        seen.add(key);\n      }\n      state = nextNode(state);\n      return rval;\n    }\n  };\n}\n\n/**\n * Insert all children before this node, and then remove it.\n *\n * @param node The ElementNode to unwrap and remove\n */\nfunction $unwrapNode(node) {\n  for (const child of $firstToLastIterator(node)) {\n    node.insertBefore(child);\n  }\n  node.remove();\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC91dGlscy9MZXhpY2FsVXRpbHMuZGV2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVvUDtBQUMxSTtBQUM3Qzs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGtCQUFrQiwyRUFBdUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxzREFBYTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQyx1REFBYztBQUM5QyxvQkFBb0IsdURBQWM7QUFDbEM7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzREFBYTtBQUNyQyxXQUFXLDBEQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxvQ0FBb0M7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsaURBQVE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx1REFBYztBQUN4QjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSx1REFBYztBQUNwQjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCx1REFBYztBQUN6RSxPQUFPLHVEQUFjO0FBQ3JCO0FBQ0EsbUNBQW1DLGlCQUFpQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaURBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix3QkFBd0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDZEQUFvQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLHNEQUFhO0FBQ2Y7O0FBRUE7QUFDQSxxRUFBcUUsa0NBQWtDO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNEQUFhLE1BQU0sOERBQXFCO0FBQzVELE1BQU0sMERBQWlCO0FBQ3ZCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVEsNERBQW1CO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFVBQVUsb0RBQVc7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtREFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLG1CQUFtQixpREFBUTtBQUMzQjtBQUNBO0FBQ0EsMEJBQTBCLDZEQUFvQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFlBQVksY0FBYyxjQUFjO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrQ0FBa0M7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixtQ0FBbUM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxxQkFBcUI7QUFDckQ7QUFDQTtBQUNBLE1BQU0sU0FBUyx1REFBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxhQUFhO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNnhCIiwic291cmNlcyI6WyIvVXNlcnMvbGVpL2hvbWUvdW5kZXJnL3RoZWF0cmUveTMvc2VncC9taWxrdXAvbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3V0aWxzL0xleGljYWxVdGlscy5kZXYubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCwgJGdldFNlbGVjdGlvbiwgJGlzUmFuZ2VTZWxlY3Rpb24sICRpc0VsZW1lbnROb2RlLCBnZXRET01UZXh0Tm9kZSwgJGdldFJvb3QsICRjbG9uZVdpdGhQcm9wZXJ0aWVzLCAkc2V0U2VsZWN0aW9uLCAkZ2V0UHJldmlvdXNTZWxlY3Rpb24sICRpc1Jvb3RPclNoYWRvd1Jvb3QsICRpc1RleHROb2RlLCAkc3BsaXROb2RlLCAkY3JlYXRlUGFyYWdyYXBoTm9kZSB9IGZyb20gJ2xleGljYWwnO1xuZXhwb3J0IHsgJHNwbGl0Tm9kZSwgaXNCbG9ja0RvbU5vZGUsIGlzSFRNTEFuY2hvckVsZW1lbnQsIGlzSFRNTEVsZW1lbnQsIGlzSW5saW5lRG9tTm9kZSB9IGZyb20gJ2xleGljYWwnO1xuaW1wb3J0IHsgY3JlYXRlUmVjdHNGcm9tRE9NUmFuZ2UgfSBmcm9tICdAbGV4aWNhbC9zZWxlY3Rpb24nO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IENBTl9VU0VfRE9NJDEgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT09ICd1bmRlZmluZWQnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IGRvY3VtZW50TW9kZSA9IENBTl9VU0VfRE9NJDEgJiYgJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQgPyBkb2N1bWVudC5kb2N1bWVudE1vZGUgOiBudWxsO1xuY29uc3QgSVNfQVBQTEUkMSA9IENBTl9VU0VfRE9NJDEgJiYgL01hY3xpUG9kfGlQaG9uZXxpUGFkLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSk7XG5jb25zdCBJU19GSVJFRk9YJDEgPSBDQU5fVVNFX0RPTSQxICYmIC9eKD8hLipTZWFtb25rZXkpKD89LipGaXJlZm94KS4qL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbmNvbnN0IENBTl9VU0VfQkVGT1JFX0lOUFVUJDEgPSBDQU5fVVNFX0RPTSQxICYmICdJbnB1dEV2ZW50JyBpbiB3aW5kb3cgJiYgIWRvY3VtZW50TW9kZSA/ICdnZXRUYXJnZXRSYW5nZXMnIGluIG5ldyB3aW5kb3cuSW5wdXRFdmVudCgnaW5wdXQnKSA6IGZhbHNlO1xuY29uc3QgSVNfU0FGQVJJJDEgPSBDQU5fVVNFX0RPTSQxICYmIC9WZXJzaW9uXFwvW1xcZC5dKy4qU2FmYXJpLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuY29uc3QgSVNfSU9TJDEgPSBDQU5fVVNFX0RPTSQxICYmIC9pUGFkfGlQaG9uZXxpUG9kLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICF3aW5kb3cuTVNTdHJlYW07XG5jb25zdCBJU19BTkRST0lEJDEgPSBDQU5fVVNFX0RPTSQxICYmIC9BbmRyb2lkLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4vLyBLZWVwIHRoZXNlIGluIGNhc2Ugd2UgbmVlZCB0byB1c2UgdGhlbSBpbiB0aGUgZnV0dXJlLlxuLy8gZXhwb3J0IGNvbnN0IElTX1dJTkRPV1M6IGJvb2xlYW4gPSBDQU5fVVNFX0RPTSAmJiAvV2luLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSk7XG5jb25zdCBJU19DSFJPTUUkMSA9IENBTl9VU0VfRE9NJDEgJiYgL14oPz0uKkNocm9tZSkuKi9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4vLyBleHBvcnQgY29uc3QgY2FuVXNlVGV4dElucHV0RXZlbnQ6IGJvb2xlYW4gPSBDQU5fVVNFX0RPTSAmJiAnVGV4dEV2ZW50JyBpbiB3aW5kb3cgJiYgIWRvY3VtZW50TW9kZTtcblxuY29uc3QgSVNfQU5EUk9JRF9DSFJPTUUkMSA9IENBTl9VU0VfRE9NJDEgJiYgSVNfQU5EUk9JRCQxICYmIElTX0NIUk9NRSQxO1xuY29uc3QgSVNfQVBQTEVfV0VCS0lUJDEgPSBDQU5fVVNFX0RPTSQxICYmIC9BcHBsZVdlYktpdFxcL1tcXGQuXSsvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgIUlTX0NIUk9NRSQxO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNsYXNzTmFtZXMoLi4uY2xhc3NOYW1lcykge1xuICBjb25zdCBydmFsID0gW107XG4gIGZvciAoY29uc3QgY2xhc3NOYW1lIG9mIGNsYXNzTmFtZXMpIHtcbiAgICBpZiAoY2xhc3NOYW1lICYmIHR5cGVvZiBjbGFzc05hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBmb3IgKGNvbnN0IFtzXSBvZiBjbGFzc05hbWUubWF0Y2hBbGwoL1xcUysvZykpIHtcbiAgICAgICAgcnZhbC5wdXNoKHMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcnZhbDtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgZXhlY3V0ZSBhbGwgZnVuY3Rpb25zIHBhc3NlZCB3aGVuIGNhbGxlZC4gSXQgaXMgZ2VuZXJhbGx5IHVzZWRcbiAqIHRvIHJlZ2lzdGVyIG11bHRpcGxlIGxleGljYWwgbGlzdGVuZXJzIGFuZCB0aGVuIHRlYXIgdGhlbSBkb3duIHdpdGggYSBzaW5nbGUgZnVuY3Rpb24gY2FsbCwgc3VjaFxuICogYXMgUmVhY3QncyB1c2VFZmZlY3QgaG9vay5cbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogdXNlRWZmZWN0KCgpID0+IHtcbiAqICAgcmV0dXJuIG1lcmdlUmVnaXN0ZXIoXG4gKiAgICAgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZCguLi5yZWdpc3RlckNvbW1hbmQxIGxvZ2ljKSxcbiAqICAgICBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKC4uLnJlZ2lzdGVyQ29tbWFuZDIgbG9naWMpLFxuICogICAgIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoLi4ucmVnaXN0ZXJDb21tYW5kMyBsb2dpYylcbiAqICAgKVxuICogfSwgW2VkaXRvcl0pXG4gKiBgYGBcbiAqIEluIHRoaXMgY2FzZSwgdXNlRWZmZWN0IGlzIHJldHVybmluZyB0aGUgZnVuY3Rpb24gcmV0dXJuZWQgYnkgbWVyZ2VSZWdpc3RlciBhcyBhIGNsZWFudXBcbiAqIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIGFmdGVyIGVpdGhlciB0aGUgdXNlRWZmZWN0IHJ1bnMgYWdhaW4gKGR1ZSB0byBvbmUgb2YgaXRzIGRlcGVuZGVuY2llc1xuICogdXBkYXRpbmcpIG9yIHRoZSBjb21wb25lbnQgaXQgcmVzaWRlcyBpbiB1bm1vdW50cy5cbiAqIE5vdGUgdGhlIGZ1bmN0aW9ucyBkb24ndCBuZWNjZXNhcmlseSBuZWVkIHRvIGJlIGluIGFuIGFycmF5IGFzIGFsbCBhcmd1bWVudHNcbiAqIGFyZSBjb25zaWRlcmVkIHRvIGJlIHRoZSBmdW5jIGFyZ3VtZW50IGFuZCBzcHJlYWQgZnJvbSB0aGVyZS5cbiAqIFRoZSBvcmRlciBvZiBjbGVhbnVwIGlzIHRoZSByZXZlcnNlIG9mIHRoZSBhcmd1bWVudCBvcmRlci4gR2VuZXJhbGx5IGl0IGlzXG4gKiBleHBlY3RlZCB0aGF0IHRoZSBmaXJzdCBcImFjcXVpcmVcIiB3aWxsIGJlIFwicmVsZWFzZWRcIiBsYXN0IChMSUZPIG9yZGVyKSxcbiAqIGJlY2F1c2UgYSBsYXRlciBzdGVwIG1heSBoYXZlIHNvbWUgZGVwZW5kZW5jeSBvbiBhbiBlYXJsaWVyIG9uZS5cbiAqIEBwYXJhbSBmdW5jIC0gQW4gYXJyYXkgb2YgY2xlYW51cCBmdW5jdGlvbnMgbWVhbnQgdG8gYmUgZXhlY3V0ZWQgYnkgdGhlIHJldHVybmVkIGZ1bmN0aW9uLlxuICogQHJldHVybnMgdGhlIGZ1bmN0aW9uIHdoaWNoIGV4ZWN1dGVzIGFsbCB0aGUgcGFzc2VkIGNsZWFudXAgZnVuY3Rpb25zLlxuICovXG5mdW5jdGlvbiBtZXJnZVJlZ2lzdGVyKC4uLmZ1bmMpIHtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBmb3IgKGxldCBpID0gZnVuYy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgZnVuY1tpXSgpO1xuICAgIH1cbiAgICAvLyBDbGVhbiB1cCB0aGUgcmVmZXJlbmNlcyBhbmQgbWFrZSBmdXR1cmUgY2FsbHMgYSBuby1vcFxuICAgIGZ1bmMubGVuZ3RoID0gMDtcbiAgfTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiBweCh2YWx1ZSkge1xuICByZXR1cm4gYCR7dmFsdWV9cHhgO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IG11dGF0aW9uT2JzZXJ2ZXJDb25maWcgPSB7XG4gIGF0dHJpYnV0ZXM6IHRydWUsXG4gIGNoYXJhY3RlckRhdGE6IHRydWUsXG4gIGNoaWxkTGlzdDogdHJ1ZSxcbiAgc3VidHJlZTogdHJ1ZVxufTtcbmZ1bmN0aW9uIHByZXBlbmRET01Ob2RlKHBhcmVudCwgbm9kZSkge1xuICBwYXJlbnQuaW5zZXJ0QmVmb3JlKG5vZGUsIHBhcmVudC5maXJzdENoaWxkKTtcbn1cblxuLyoqXG4gKiBQbGFjZSBvbmUgb3IgbXVsdGlwbGUgbmV3bHkgY3JlYXRlZCBOb2RlcyBhdCB0aGUgcGFzc2VkIFJhbmdlJ3MgcG9zaXRpb24uXG4gKiBNdWx0aXBsZSBub2RlcyB3aWxsIG9ubHkgYmUgY3JlYXRlZCB3aGVuIHRoZSBSYW5nZSBzcGFucyBtdWx0aXBsZSBsaW5lcyAoYWthXG4gKiBjbGllbnQgcmVjdHMpLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gY2FuIGNvbWUgcGFydGljdWxhcmx5IHVzZWZ1bCB0byBoaWdobGlnaHQgcGFydGljdWxhciBwYXJ0cyBvZlxuICogdGhlIHRleHQgd2l0aG91dCBpbnRlcmZlcmluZyB3aXRoIHRoZSBFZGl0b3JTdGF0ZSwgdGhhdCB3aWxsIG9mdGVuIHJlcGxpY2F0ZVxuICogdGhlIHN0YXRlIGFjcm9zcyBjb2xsYWIgYW5kIGNsaXBib2FyZC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGFjY291bnRzIGZvciBET00gdXBkYXRlcyB3aGljaCBjYW4gbW9kaWZ5IHRoZSBwYXNzZWQgUmFuZ2UuXG4gKiBIZW5jZSwgdGhlIGZ1bmN0aW9uIHJldHVybiB0byByZW1vdmUgdGhlIGxpc3RlbmVyLlxuICovXG5mdW5jdGlvbiBtbGNQb3NpdGlvbk5vZGVPblJhbmdlKGVkaXRvciwgcmFuZ2UsIG9uUmVwb3NpdGlvbikge1xuICBsZXQgcm9vdERPTU5vZGUgPSBudWxsO1xuICBsZXQgcGFyZW50RE9NTm9kZSA9IG51bGw7XG4gIGxldCBvYnNlcnZlciA9IG51bGw7XG4gIGxldCBsYXN0Tm9kZXMgPSBbXTtcbiAgY29uc3Qgd3JhcHBlck5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgd3JhcHBlck5vZGUuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICBmdW5jdGlvbiBwb3NpdGlvbigpIHtcbiAgICBpZiAoIShyb290RE9NTm9kZSAhPT0gbnVsbCkpIHtcbiAgICAgIHRocm93IEVycm9yKGBVbmV4cGVjdGVkIG51bGwgcm9vdERPTU5vZGVgKTtcbiAgICB9XG4gICAgaWYgKCEocGFyZW50RE9NTm9kZSAhPT0gbnVsbCkpIHtcbiAgICAgIHRocm93IEVycm9yKGBVbmV4cGVjdGVkIG51bGwgcGFyZW50RE9NTm9kZWApO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBsZWZ0OiBwYXJlbnRMZWZ0LFxuICAgICAgdG9wOiBwYXJlbnRUb3BcbiAgICB9ID0gcGFyZW50RE9NTm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCByZWN0cyA9IGNyZWF0ZVJlY3RzRnJvbURPTVJhbmdlKGVkaXRvciwgcmFuZ2UpO1xuICAgIGlmICghd3JhcHBlck5vZGUuaXNDb25uZWN0ZWQpIHtcbiAgICAgIHByZXBlbmRET01Ob2RlKHBhcmVudERPTU5vZGUsIHdyYXBwZXJOb2RlKTtcbiAgICB9XG4gICAgbGV0IGhhc1JlcG9zaXRpb25lZCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHJlY3QgPSByZWN0c1tpXTtcbiAgICAgIC8vIFRyeSB0byByZXVzZSB0aGUgcHJldmlvdXNseSBjcmVhdGVkIE5vZGUgd2hlbiBwb3NzaWJsZSwgbm8gbmVlZCB0b1xuICAgICAgLy8gcmVtb3ZlL2NyZWF0ZSBvbiB0aGUgbW9zdCBjb21tb24gY2FzZSByZXBvc2l0aW9uIGNhc2VcbiAgICAgIGNvbnN0IHJlY3ROb2RlID0gbGFzdE5vZGVzW2ldIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgY29uc3QgcmVjdE5vZGVTdHlsZSA9IHJlY3ROb2RlLnN0eWxlO1xuICAgICAgaWYgKHJlY3ROb2RlU3R5bGUucG9zaXRpb24gIT09ICdhYnNvbHV0ZScpIHtcbiAgICAgICAgcmVjdE5vZGVTdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIGhhc1JlcG9zaXRpb25lZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBjb25zdCBsZWZ0ID0gcHgocmVjdC5sZWZ0IC0gcGFyZW50TGVmdCk7XG4gICAgICBpZiAocmVjdE5vZGVTdHlsZS5sZWZ0ICE9PSBsZWZ0KSB7XG4gICAgICAgIHJlY3ROb2RlU3R5bGUubGVmdCA9IGxlZnQ7XG4gICAgICAgIGhhc1JlcG9zaXRpb25lZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBjb25zdCB0b3AgPSBweChyZWN0LnRvcCAtIHBhcmVudFRvcCk7XG4gICAgICBpZiAocmVjdE5vZGVTdHlsZS50b3AgIT09IHRvcCkge1xuICAgICAgICByZWN0Tm9kZS5zdHlsZS50b3AgPSB0b3A7XG4gICAgICAgIGhhc1JlcG9zaXRpb25lZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBjb25zdCB3aWR0aCA9IHB4KHJlY3Qud2lkdGgpO1xuICAgICAgaWYgKHJlY3ROb2RlU3R5bGUud2lkdGggIT09IHdpZHRoKSB7XG4gICAgICAgIHJlY3ROb2RlLnN0eWxlLndpZHRoID0gd2lkdGg7XG4gICAgICAgIGhhc1JlcG9zaXRpb25lZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBjb25zdCBoZWlnaHQgPSBweChyZWN0LmhlaWdodCk7XG4gICAgICBpZiAocmVjdE5vZGVTdHlsZS5oZWlnaHQgIT09IGhlaWdodCkge1xuICAgICAgICByZWN0Tm9kZS5zdHlsZS5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIGhhc1JlcG9zaXRpb25lZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAocmVjdE5vZGUucGFyZW50Tm9kZSAhPT0gd3JhcHBlck5vZGUpIHtcbiAgICAgICAgd3JhcHBlck5vZGUuYXBwZW5kKHJlY3ROb2RlKTtcbiAgICAgICAgaGFzUmVwb3NpdGlvbmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGxhc3ROb2Rlc1tpXSA9IHJlY3ROb2RlO1xuICAgIH1cbiAgICB3aGlsZSAobGFzdE5vZGVzLmxlbmd0aCA+IHJlY3RzLmxlbmd0aCkge1xuICAgICAgbGFzdE5vZGVzLnBvcCgpO1xuICAgIH1cbiAgICBpZiAoaGFzUmVwb3NpdGlvbmVkKSB7XG4gICAgICBvblJlcG9zaXRpb24obGFzdE5vZGVzKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICBwYXJlbnRET01Ob2RlID0gbnVsbDtcbiAgICByb290RE9NTm9kZSA9IG51bGw7XG4gICAgaWYgKG9ic2VydmVyICE9PSBudWxsKSB7XG4gICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgfVxuICAgIG9ic2VydmVyID0gbnVsbDtcbiAgICB3cmFwcGVyTm9kZS5yZW1vdmUoKTtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2YgbGFzdE5vZGVzKSB7XG4gICAgICBub2RlLnJlbW92ZSgpO1xuICAgIH1cbiAgICBsYXN0Tm9kZXMgPSBbXTtcbiAgfVxuICBmdW5jdGlvbiByZXN0YXJ0KCkge1xuICAgIGNvbnN0IGN1cnJlbnRSb290RE9NTm9kZSA9IGVkaXRvci5nZXRSb290RWxlbWVudCgpO1xuICAgIGlmIChjdXJyZW50Um9vdERPTU5vZGUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBzdG9wKCk7XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRQYXJlbnRET01Ob2RlID0gY3VycmVudFJvb3RET01Ob2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgaWYgKCFpc0hUTUxFbGVtZW50KGN1cnJlbnRQYXJlbnRET01Ob2RlKSkge1xuICAgICAgcmV0dXJuIHN0b3AoKTtcbiAgICB9XG4gICAgc3RvcCgpO1xuICAgIHJvb3RET01Ob2RlID0gY3VycmVudFJvb3RET01Ob2RlO1xuICAgIHBhcmVudERPTU5vZGUgPSBjdXJyZW50UGFyZW50RE9NTm9kZTtcbiAgICBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKG11dGF0aW9ucyA9PiB7XG4gICAgICBjb25zdCBuZXh0Um9vdERPTU5vZGUgPSBlZGl0b3IuZ2V0Um9vdEVsZW1lbnQoKTtcbiAgICAgIGNvbnN0IG5leHRQYXJlbnRET01Ob2RlID0gbmV4dFJvb3RET01Ob2RlICYmIG5leHRSb290RE9NTm9kZS5wYXJlbnRFbGVtZW50O1xuICAgICAgaWYgKG5leHRSb290RE9NTm9kZSAhPT0gcm9vdERPTU5vZGUgfHwgbmV4dFBhcmVudERPTU5vZGUgIT09IHBhcmVudERPTU5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHJlc3RhcnQoKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgbXV0YXRpb24gb2YgbXV0YXRpb25zKSB7XG4gICAgICAgIGlmICghd3JhcHBlck5vZGUuY29udGFpbnMobXV0YXRpb24udGFyZ2V0KSkge1xuICAgICAgICAgIC8vIFRPRE8gdGhyb3R0bGVcbiAgICAgICAgICByZXR1cm4gcG9zaXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIG9ic2VydmVyLm9ic2VydmUoY3VycmVudFBhcmVudERPTU5vZGUsIG11dGF0aW9uT2JzZXJ2ZXJDb25maWcpO1xuICAgIHBvc2l0aW9uKCk7XG4gIH1cbiAgY29uc3QgcmVtb3ZlUm9vdExpc3RlbmVyID0gZWRpdG9yLnJlZ2lzdGVyUm9vdExpc3RlbmVyKHJlc3RhcnQpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIHJlbW92ZVJvb3RMaXN0ZW5lcigpO1xuICAgIHN0b3AoKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiByYW5nZVRhcmdldEZyb21Qb2ludChwb2ludCwgbm9kZSwgZG9tKSB7XG4gIGlmIChwb2ludC50eXBlID09PSAndGV4dCcgfHwgISRpc0VsZW1lbnROb2RlKG5vZGUpKSB7XG4gICAgY29uc3QgdGV4dERPTSA9IGdldERPTVRleHROb2RlKGRvbSkgfHwgZG9tO1xuICAgIHJldHVybiBbdGV4dERPTSwgcG9pbnQub2Zmc2V0XTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBzbG90ID0gbm9kZS5nZXRET01TbG90KGRvbSk7XG4gICAgcmV0dXJuIFtzbG90LmVsZW1lbnQsIHNsb3QuZ2V0Rmlyc3RDaGlsZE9mZnNldCgpICsgcG9pbnQub2Zmc2V0XTtcbiAgfVxufVxuZnVuY3Rpb24gcmFuZ2VGcm9tUG9pbnRzKGVkaXRvciwgYW5jaG9yLCBhbmNob3JOb2RlLCBhbmNob3JET00sIGZvY3VzLCBmb2N1c05vZGUsIGZvY3VzRE9NKSB7XG4gIGNvbnN0IGVkaXRvckRvY3VtZW50ID0gZWRpdG9yLl93aW5kb3cgPyBlZGl0b3IuX3dpbmRvdy5kb2N1bWVudCA6IGRvY3VtZW50O1xuICBjb25zdCByYW5nZSA9IGVkaXRvckRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gIGlmIChmb2N1c05vZGUuaXNCZWZvcmUoYW5jaG9yTm9kZSkpIHtcbiAgICByYW5nZS5zZXRTdGFydCguLi5yYW5nZVRhcmdldEZyb21Qb2ludChmb2N1cywgZm9jdXNOb2RlLCBmb2N1c0RPTSkpO1xuICAgIHJhbmdlLnNldEVuZCguLi5yYW5nZVRhcmdldEZyb21Qb2ludChhbmNob3IsIGFuY2hvck5vZGUsIGFuY2hvckRPTSkpO1xuICB9IGVsc2Uge1xuICAgIHJhbmdlLnNldFN0YXJ0KC4uLnJhbmdlVGFyZ2V0RnJvbVBvaW50KGFuY2hvciwgYW5jaG9yTm9kZSwgYW5jaG9yRE9NKSk7XG4gICAgcmFuZ2Uuc2V0RW5kKC4uLnJhbmdlVGFyZ2V0RnJvbVBvaW50KGZvY3VzLCBmb2N1c05vZGUsIGZvY3VzRE9NKSk7XG4gIH1cbiAgcmV0dXJuIHJhbmdlO1xufVxuLyoqXG4gKiBQbGFjZSBvbmUgb3IgbXVsdGlwbGUgbmV3bHkgY3JlYXRlZCBOb2RlcyBhdCB0aGUgY3VycmVudCBzZWxlY3Rpb24uIE11bHRpcGxlXG4gKiBub2RlcyB3aWxsIG9ubHkgYmUgY3JlYXRlZCB3aGVuIHRoZSBzZWxlY3Rpb24gc3BhbnMgbXVsdGlwbGUgbGluZXMgKGFrYVxuICogY2xpZW50IHJlY3RzKS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGNhbiBjb21lIHVzZWZ1bCB3aGVuIHlvdSB3YW50IHRvIHNob3cgdGhlIHNlbGVjdGlvbiBidXQgdGhlXG4gKiBlZGl0b3IgaGFzIGJlZW4gZm9jdXNlZCBhd2F5LlxuICovXG5mdW5jdGlvbiBtYXJrU2VsZWN0aW9uKGVkaXRvciwgb25SZXBvc2l0aW9uKSB7XG4gIGxldCBwcmV2aW91c0FuY2hvck5vZGUgPSBudWxsO1xuICBsZXQgcHJldmlvdXNBbmNob3JOb2RlRE9NID0gbnVsbDtcbiAgbGV0IHByZXZpb3VzQW5jaG9yT2Zmc2V0ID0gbnVsbDtcbiAgbGV0IHByZXZpb3VzRm9jdXNOb2RlID0gbnVsbDtcbiAgbGV0IHByZXZpb3VzRm9jdXNOb2RlRE9NID0gbnVsbDtcbiAgbGV0IHByZXZpb3VzRm9jdXNPZmZzZXQgPSBudWxsO1xuICBsZXQgcmVtb3ZlUmFuZ2VMaXN0ZW5lciA9ICgpID0+IHt9O1xuICBmdW5jdGlvbiBjb21wdXRlKGVkaXRvclN0YXRlKSB7XG4gICAgZWRpdG9yU3RhdGUucmVhZCgoKSA9PiB7XG4gICAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgICAgLy8gVE9ET1xuICAgICAgICBwcmV2aW91c0FuY2hvck5vZGUgPSBudWxsO1xuICAgICAgICBwcmV2aW91c0FuY2hvck9mZnNldCA9IG51bGw7XG4gICAgICAgIHByZXZpb3VzRm9jdXNOb2RlID0gbnVsbDtcbiAgICAgICAgcHJldmlvdXNGb2N1c09mZnNldCA9IG51bGw7XG4gICAgICAgIHJlbW92ZVJhbmdlTGlzdGVuZXIoKTtcbiAgICAgICAgcmVtb3ZlUmFuZ2VMaXN0ZW5lciA9ICgpID0+IHt9O1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgZm9jdXNcbiAgICAgIH0gPSBzZWxlY3Rpb247XG4gICAgICBjb25zdCBjdXJyZW50QW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gICAgICBjb25zdCBjdXJyZW50QW5jaG9yTm9kZUtleSA9IGN1cnJlbnRBbmNob3JOb2RlLmdldEtleSgpO1xuICAgICAgY29uc3QgY3VycmVudEFuY2hvck9mZnNldCA9IGFuY2hvci5vZmZzZXQ7XG4gICAgICBjb25zdCBjdXJyZW50Rm9jdXNOb2RlID0gZm9jdXMuZ2V0Tm9kZSgpO1xuICAgICAgY29uc3QgY3VycmVudEZvY3VzTm9kZUtleSA9IGN1cnJlbnRGb2N1c05vZGUuZ2V0S2V5KCk7XG4gICAgICBjb25zdCBjdXJyZW50Rm9jdXNPZmZzZXQgPSBmb2N1cy5vZmZzZXQ7XG4gICAgICBjb25zdCBjdXJyZW50QW5jaG9yTm9kZURPTSA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkoY3VycmVudEFuY2hvck5vZGVLZXkpO1xuICAgICAgY29uc3QgY3VycmVudEZvY3VzTm9kZURPTSA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkoY3VycmVudEZvY3VzTm9kZUtleSk7XG4gICAgICBjb25zdCBkaWZmZXJlbnRBbmNob3JET00gPSBwcmV2aW91c0FuY2hvck5vZGUgPT09IG51bGwgfHwgY3VycmVudEFuY2hvck5vZGVET00gIT09IHByZXZpb3VzQW5jaG9yTm9kZURPTSB8fCBjdXJyZW50QW5jaG9yT2Zmc2V0ICE9PSBwcmV2aW91c0FuY2hvck9mZnNldCB8fCBjdXJyZW50QW5jaG9yTm9kZUtleSAhPT0gcHJldmlvdXNBbmNob3JOb2RlLmdldEtleSgpO1xuICAgICAgY29uc3QgZGlmZmVyZW50Rm9jdXNET00gPSBwcmV2aW91c0ZvY3VzTm9kZSA9PT0gbnVsbCB8fCBjdXJyZW50Rm9jdXNOb2RlRE9NICE9PSBwcmV2aW91c0ZvY3VzTm9kZURPTSB8fCBjdXJyZW50Rm9jdXNPZmZzZXQgIT09IHByZXZpb3VzRm9jdXNPZmZzZXQgfHwgY3VycmVudEZvY3VzTm9kZUtleSAhPT0gcHJldmlvdXNGb2N1c05vZGUuZ2V0S2V5KCk7XG4gICAgICBpZiAoKGRpZmZlcmVudEFuY2hvckRPTSB8fCBkaWZmZXJlbnRGb2N1c0RPTSkgJiYgY3VycmVudEFuY2hvck5vZGVET00gIT09IG51bGwgJiYgY3VycmVudEZvY3VzTm9kZURPTSAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCByYW5nZSA9IHJhbmdlRnJvbVBvaW50cyhlZGl0b3IsIGFuY2hvciwgY3VycmVudEFuY2hvck5vZGUsIGN1cnJlbnRBbmNob3JOb2RlRE9NLCBmb2N1cywgY3VycmVudEZvY3VzTm9kZSwgY3VycmVudEZvY3VzTm9kZURPTSk7XG4gICAgICAgIHJlbW92ZVJhbmdlTGlzdGVuZXIoKTtcbiAgICAgICAgcmVtb3ZlUmFuZ2VMaXN0ZW5lciA9IG1sY1Bvc2l0aW9uTm9kZU9uUmFuZ2UoZWRpdG9yLCByYW5nZSwgZG9tTm9kZXMgPT4ge1xuICAgICAgICAgIGlmIChvblJlcG9zaXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBkb21Ob2RlIG9mIGRvbU5vZGVzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGRvbU5vZGVTdHlsZSA9IGRvbU5vZGUuc3R5bGU7XG4gICAgICAgICAgICAgIGlmIChkb21Ob2RlU3R5bGUuYmFja2dyb3VuZCAhPT0gJ0hpZ2hsaWdodCcpIHtcbiAgICAgICAgICAgICAgICBkb21Ob2RlU3R5bGUuYmFja2dyb3VuZCA9ICdIaWdobGlnaHQnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChkb21Ob2RlU3R5bGUuY29sb3IgIT09ICdIaWdobGlnaHRUZXh0Jykge1xuICAgICAgICAgICAgICAgIGRvbU5vZGVTdHlsZS5jb2xvciA9ICdIaWdobGlnaHRUZXh0JztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZG9tTm9kZVN0eWxlLm1hcmdpblRvcCAhPT0gcHgoLTEuNSkpIHtcbiAgICAgICAgICAgICAgICBkb21Ob2RlU3R5bGUubWFyZ2luVG9wID0gcHgoLTEuNSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGRvbU5vZGVTdHlsZS5wYWRkaW5nVG9wICE9PSBweCg0KSkge1xuICAgICAgICAgICAgICAgIGRvbU5vZGVTdHlsZS5wYWRkaW5nVG9wID0gcHgoNCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGRvbU5vZGVTdHlsZS5wYWRkaW5nQm90dG9tICE9PSBweCgwKSkge1xuICAgICAgICAgICAgICAgIGRvbU5vZGVTdHlsZS5wYWRkaW5nQm90dG9tID0gcHgoMCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb25SZXBvc2l0aW9uKGRvbU5vZGVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcHJldmlvdXNBbmNob3JOb2RlID0gY3VycmVudEFuY2hvck5vZGU7XG4gICAgICBwcmV2aW91c0FuY2hvck5vZGVET00gPSBjdXJyZW50QW5jaG9yTm9kZURPTTtcbiAgICAgIHByZXZpb3VzQW5jaG9yT2Zmc2V0ID0gY3VycmVudEFuY2hvck9mZnNldDtcbiAgICAgIHByZXZpb3VzRm9jdXNOb2RlID0gY3VycmVudEZvY3VzTm9kZTtcbiAgICAgIHByZXZpb3VzRm9jdXNOb2RlRE9NID0gY3VycmVudEZvY3VzTm9kZURPTTtcbiAgICAgIHByZXZpb3VzRm9jdXNPZmZzZXQgPSBjdXJyZW50Rm9jdXNPZmZzZXQ7XG4gICAgfSk7XG4gIH1cbiAgY29tcHV0ZShlZGl0b3IuZ2V0RWRpdG9yU3RhdGUoKSk7XG4gIHJldHVybiBtZXJnZVJlZ2lzdGVyKGVkaXRvci5yZWdpc3RlclVwZGF0ZUxpc3RlbmVyKCh7XG4gICAgZWRpdG9yU3RhdGVcbiAgfSkgPT4gY29tcHV0ZShlZGl0b3JTdGF0ZSkpLCAoKSA9PiB7XG4gICAgcmVtb3ZlUmFuZ2VMaXN0ZW5lcigpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiBzZWxlY3Rpb25BbHdheXNPbkRpc3BsYXkoZWRpdG9yKSB7XG4gIGxldCByZW1vdmVTZWxlY3Rpb25NYXJrID0gbnVsbDtcbiAgY29uc3Qgb25TZWxlY3Rpb25DaGFuZ2UgPSAoKSA9PiB7XG4gICAgY29uc3QgZG9tU2VsZWN0aW9uID0gZ2V0U2VsZWN0aW9uKCk7XG4gICAgY29uc3QgZG9tQW5jaG9yTm9kZSA9IGRvbVNlbGVjdGlvbiAmJiBkb21TZWxlY3Rpb24uYW5jaG9yTm9kZTtcbiAgICBjb25zdCBlZGl0b3JSb290RWxlbWVudCA9IGVkaXRvci5nZXRSb290RWxlbWVudCgpO1xuICAgIGNvbnN0IGlzU2VsZWN0aW9uSW5zaWRlRWRpdG9yID0gZG9tQW5jaG9yTm9kZSAhPT0gbnVsbCAmJiBlZGl0b3JSb290RWxlbWVudCAhPT0gbnVsbCAmJiBlZGl0b3JSb290RWxlbWVudC5jb250YWlucyhkb21BbmNob3JOb2RlKTtcbiAgICBpZiAoaXNTZWxlY3Rpb25JbnNpZGVFZGl0b3IpIHtcbiAgICAgIGlmIChyZW1vdmVTZWxlY3Rpb25NYXJrICE9PSBudWxsKSB7XG4gICAgICAgIHJlbW92ZVNlbGVjdGlvbk1hcmsoKTtcbiAgICAgICAgcmVtb3ZlU2VsZWN0aW9uTWFyayA9IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChyZW1vdmVTZWxlY3Rpb25NYXJrID09PSBudWxsKSB7XG4gICAgICAgIHJlbW92ZVNlbGVjdGlvbk1hcmsgPSBtYXJrU2VsZWN0aW9uKGVkaXRvcik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3Rpb25jaGFuZ2UnLCBvblNlbGVjdGlvbkNoYW5nZSk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgaWYgKHJlbW92ZVNlbGVjdGlvbk1hcmsgIT09IG51bGwpIHtcbiAgICAgIHJlbW92ZVNlbGVjdGlvbk1hcmsoKTtcbiAgICB9XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2VsZWN0aW9uY2hhbmdlJywgb25TZWxlY3Rpb25DaGFuZ2UpO1xuICB9O1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8vIEhvdGZpeCB0byBleHBvcnQgdGhlc2Ugd2l0aCBpbmxpbmVkIHR5cGVzICM1OTE4XG5jb25zdCBDQU5fVVNFX0JFRk9SRV9JTlBVVCA9IENBTl9VU0VfQkVGT1JFX0lOUFVUJDE7XG5jb25zdCBDQU5fVVNFX0RPTSA9IENBTl9VU0VfRE9NJDE7XG5jb25zdCBJU19BTkRST0lEID0gSVNfQU5EUk9JRCQxO1xuY29uc3QgSVNfQU5EUk9JRF9DSFJPTUUgPSBJU19BTkRST0lEX0NIUk9NRSQxO1xuY29uc3QgSVNfQVBQTEUgPSBJU19BUFBMRSQxO1xuY29uc3QgSVNfQVBQTEVfV0VCS0lUID0gSVNfQVBQTEVfV0VCS0lUJDE7XG5jb25zdCBJU19DSFJPTUUgPSBJU19DSFJPTUUkMTtcbmNvbnN0IElTX0ZJUkVGT1ggPSBJU19GSVJFRk9YJDE7XG5jb25zdCBJU19JT1MgPSBJU19JT1MkMTtcbmNvbnN0IElTX1NBRkFSSSA9IElTX1NBRkFSSSQxO1xuXG4vKipcbiAqIFRha2VzIGFuIEhUTUwgZWxlbWVudCBhbmQgYWRkcyB0aGUgY2xhc3NOYW1lcyBwYXNzZWQgd2l0aGluIGFuIGFycmF5LFxuICogaWdub3JpbmcgYW55IG5vbi1zdHJpbmcgdHlwZXMuIEEgc3BhY2UgY2FuIGJlIHVzZWQgdG8gYWRkIG11bHRpcGxlIGNsYXNzZXNcbiAqIGVnLiBhZGRDbGFzc05hbWVzVG9FbGVtZW50KGVsZW1lbnQsIFsnZWxlbWVudC1pbm5lciBhY3RpdmUnLCB0cnVlLCBudWxsXSlcbiAqIHdpbGwgYWRkIGJvdGggJ2VsZW1lbnQtaW5uZXInIGFuZCAnYWN0aXZlJyBhcyBjbGFzc2VzIHRvIHRoYXQgZWxlbWVudC5cbiAqIEBwYXJhbSBlbGVtZW50IC0gVGhlIGVsZW1lbnQgaW4gd2hpY2ggdGhlIGNsYXNzZXMgYXJlIGFkZGVkXG4gKiBAcGFyYW0gY2xhc3NOYW1lcyAtIEFuIGFycmF5IGRlZmluaW5nIHRoZSBjbGFzcyBuYW1lcyB0byBhZGQgdG8gdGhlIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gYWRkQ2xhc3NOYW1lc1RvRWxlbWVudChlbGVtZW50LCAuLi5jbGFzc05hbWVzKSB7XG4gIGNvbnN0IGNsYXNzZXNUb0FkZCA9IG5vcm1hbGl6ZUNsYXNzTmFtZXMoLi4uY2xhc3NOYW1lcyk7XG4gIGlmIChjbGFzc2VzVG9BZGQubGVuZ3RoID4gMCkge1xuICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZCguLi5jbGFzc2VzVG9BZGQpO1xuICB9XG59XG5cbi8qKlxuICogVGFrZXMgYW4gSFRNTCBlbGVtZW50IGFuZCByZW1vdmVzIHRoZSBjbGFzc05hbWVzIHBhc3NlZCB3aXRoaW4gYW4gYXJyYXksXG4gKiBpZ25vcmluZyBhbnkgbm9uLXN0cmluZyB0eXBlcy4gQSBzcGFjZSBjYW4gYmUgdXNlZCB0byByZW1vdmUgbXVsdGlwbGUgY2xhc3Nlc1xuICogZWcuIHJlbW92ZUNsYXNzTmFtZXNGcm9tRWxlbWVudChlbGVtZW50LCBbJ2FjdGl2ZSBzbWFsbCcsIHRydWUsIG51bGxdKVxuICogd2lsbCByZW1vdmUgYm90aCB0aGUgJ2FjdGl2ZScgYW5kICdzbWFsbCcgY2xhc3NlcyBmcm9tIHRoYXQgZWxlbWVudC5cbiAqIEBwYXJhbSBlbGVtZW50IC0gVGhlIGVsZW1lbnQgaW4gd2hpY2ggdGhlIGNsYXNzZXMgYXJlIHJlbW92ZWRcbiAqIEBwYXJhbSBjbGFzc05hbWVzIC0gQW4gYXJyYXkgZGVmaW5pbmcgdGhlIGNsYXNzIG5hbWVzIHRvIHJlbW92ZSBmcm9tIHRoZSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzTmFtZXNGcm9tRWxlbWVudChlbGVtZW50LCAuLi5jbGFzc05hbWVzKSB7XG4gIGNvbnN0IGNsYXNzZXNUb1JlbW92ZSA9IG5vcm1hbGl6ZUNsYXNzTmFtZXMoLi4uY2xhc3NOYW1lcyk7XG4gIGlmIChjbGFzc2VzVG9SZW1vdmUubGVuZ3RoID4gMCkge1xuICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSguLi5jbGFzc2VzVG9SZW1vdmUpO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBmaWxlIHR5cGUgbWF0Y2hlcyB0aGUgdHlwZXMgcGFzc2VkIHdpdGhpbiB0aGUgYWNjZXB0YWJsZU1pbWVUeXBlcyBhcnJheSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICogVGhlIHR5cGVzIHBhc3NlZCBtdXN0IGJlIHN0cmluZ3MgYW5kIGFyZSBDQVNFLVNFTlNJVElWRS5cbiAqIGVnLiBpZiBmaWxlIGlzIG9mIHR5cGUgJ3RleHQnIGFuZCBhY2NlcHRhYmxlTWltZVR5cGVzID0gWydURVhUJywgJ0lNQUdFJ10gdGhlIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIGZhbHNlLlxuICogQHBhcmFtIGZpbGUgLSBUaGUgZmlsZSB5b3Ugd2FudCB0byB0eXBlIGNoZWNrLlxuICogQHBhcmFtIGFjY2VwdGFibGVNaW1lVHlwZXMgLSBBbiBhcnJheSBvZiBzdHJpbmdzIG9mIHR5cGVzIHdoaWNoIHRoZSBmaWxlIGlzIGNoZWNrZWQgYWdhaW5zdC5cbiAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGZpbGUgaXMgYW4gYWNjZXB0YWJsZSBtaW1lIHR5cGUsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNNaW1lVHlwZShmaWxlLCBhY2NlcHRhYmxlTWltZVR5cGVzKSB7XG4gIGZvciAoY29uc3QgYWNjZXB0YWJsZVR5cGUgb2YgYWNjZXB0YWJsZU1pbWVUeXBlcykge1xuICAgIGlmIChmaWxlLnR5cGUuc3RhcnRzV2l0aChhY2NlcHRhYmxlVHlwZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogTGV4aWNhbCBGaWxlIFJlYWRlciB3aXRoOlxuICogIDEuIE1JTUUgdHlwZSBzdXBwb3J0XG4gKiAgMi4gYmF0Y2hlZCByZXN1bHRzIChIaXN0b3J5UGx1Z2luIGNvbXBhdGliaWxpdHkpXG4gKiAgMy4gT3JkZXIgYXdhcmUgKHJlc3BlY3RzIHRoZSBvcmRlciB3aGVuIG11bHRpcGxlIEZpbGVzIGFyZSBwYXNzZWQpXG4gKlxuICogY29uc3QgZmlsZXNSZXN1bHQgPSBhd2FpdCBtZWRpYUZpbGVSZWFkZXIoZmlsZXMsIFsnaW1hZ2UvJ10pO1xuICogZmlsZXNSZXN1bHQuZm9yRWFjaChmaWxlID0+IGVkaXRvci5kaXNwYXRjaENvbW1hbmQoJ0lOU0VSVF9JTUFHRScsIFxcXFx7XG4gKiAgIHNyYzogZmlsZS5yZXN1bHQsXG4gKiBcXFxcfSkpO1xuICovXG5mdW5jdGlvbiBtZWRpYUZpbGVSZWFkZXIoZmlsZXMsIGFjY2VwdGFibGVNaW1lVHlwZXMpIHtcbiAgY29uc3QgZmlsZXNJdGVyYXRvciA9IGZpbGVzW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBwcm9jZXNzZWQgPSBbXTtcbiAgICBjb25zdCBoYW5kbGVOZXh0RmlsZSA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZG9uZSxcbiAgICAgICAgdmFsdWU6IGZpbGVcbiAgICAgIH0gPSBmaWxlc0l0ZXJhdG9yLm5leHQoKTtcbiAgICAgIGlmIChkb25lKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlKHByb2Nlc3NlZCk7XG4gICAgICB9XG4gICAgICBjb25zdCBmaWxlUmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgIGZpbGVSZWFkZXIuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCByZWplY3QpO1xuICAgICAgZmlsZVJlYWRlci5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgKCkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBmaWxlUmVhZGVyLnJlc3VsdDtcbiAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcHJvY2Vzc2VkLnB1c2goe1xuICAgICAgICAgICAgZmlsZSxcbiAgICAgICAgICAgIHJlc3VsdFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGhhbmRsZU5leHRGaWxlKCk7XG4gICAgICB9KTtcbiAgICAgIGlmIChpc01pbWVUeXBlKGZpbGUsIGFjY2VwdGFibGVNaW1lVHlwZXMpKSB7XG4gICAgICAgIGZpbGVSZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhbmRsZU5leHRGaWxlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBoYW5kbGVOZXh0RmlsZSgpO1xuICB9KTtcbn1cbi8qKlxuICogXCJEZXB0aC1GaXJzdCBTZWFyY2hcIiBzdGFydHMgYXQgdGhlIHJvb3QvdG9wIG5vZGUgb2YgYSB0cmVlIGFuZCBnb2VzIGFzIGZhciBhcyBpdCBjYW4gZG93biBhIGJyYW5jaCBlbmRcbiAqIGJlZm9yZSBiYWNrdHJhY2tpbmcgYW5kIGZpbmRpbmcgYSBuZXcgcGF0aC4gQ29uc2lkZXIgc29sdmluZyBhIG1hemUgYnkgaHVnZ2luZyBlaXRoZXIgd2FsbCwgbW92aW5nIGRvd24gYVxuICogYnJhbmNoIHVudGlsIHlvdSBoaXQgYSBkZWFkLWVuZCAobGVhZikgYW5kIGJhY2t0cmFja2luZyB0byBmaW5kIHRoZSBuZWFyZXN0IGJyYW5jaGluZyBwYXRoIGFuZCByZXBlYXQuXG4gKiBJdCB3aWxsIHRoZW4gcmV0dXJuIGFsbCB0aGUgbm9kZXMgZm91bmQgaW4gdGhlIHNlYXJjaCBpbiBhbiBhcnJheSBvZiBvYmplY3RzLlxuICogQHBhcmFtIHN0YXJ0Tm9kZSAtIFRoZSBub2RlIHRvIHN0YXJ0IHRoZSBzZWFyY2gsIGlmIG9taXR0ZWQsIGl0IHdpbGwgc3RhcnQgYXQgdGhlIHJvb3Qgbm9kZS5cbiAqIEBwYXJhbSBlbmROb2RlIC0gVGhlIG5vZGUgdG8gZW5kIHRoZSBzZWFyY2gsIGlmIG9taXR0ZWQsIGl0IHdpbGwgZmluZCBhbGwgZGVzY2VuZGFudHMgb2YgdGhlIHN0YXJ0aW5nTm9kZS5cbiAqIEByZXR1cm5zIEFuIGFycmF5IG9mIG9iamVjdHMgb2YgYWxsIHRoZSBub2RlcyBmb3VuZCBieSB0aGUgc2VhcmNoLCBpbmNsdWRpbmcgdGhlaXIgZGVwdGggaW50byB0aGUgdHJlZS5cbiAqIFxcXFx7ZGVwdGg6IG51bWJlciwgbm9kZTogTGV4aWNhbE5vZGVcXFxcfSBJdCB3aWxsIGFsd2F5cyByZXR1cm4gYXQgbGVhc3QgMSBub2RlICh0aGUgc3RhcnQgbm9kZSkuXG4gKi9cbmZ1bmN0aW9uICRkZnMoc3RhcnROb2RlLCBlbmROb2RlKSB7XG4gIHJldHVybiBBcnJheS5mcm9tKCRkZnNJdGVyYXRvcihzdGFydE5vZGUsIGVuZE5vZGUpKTtcbn1cbmNvbnN0IGl0ZXJhdG9yRG9uZSA9IHtcbiAgZG9uZTogdHJ1ZSxcbiAgdmFsdWU6IHVuZGVmaW5lZFxufTtcbmNvbnN0IGl0ZXJhdG9yTm90RG9uZSA9IHZhbHVlID0+ICh7XG4gIGRvbmU6IGZhbHNlLFxuICB2YWx1ZVxufSk7XG5cbi8qKlxuICogJGRmcyBpdGVyYXRvci4gVHJlZSB0cmF2ZXJzYWwgaXMgZG9uZSBvbiB0aGUgZmx5IGFzIG5ldyB2YWx1ZXMgYXJlIHJlcXVlc3RlZCB3aXRoIE8oMSkgbWVtb3J5LlxuICogQHBhcmFtIHN0YXJ0Tm9kZSAtIFRoZSBub2RlIHRvIHN0YXJ0IHRoZSBzZWFyY2gsIGlmIG9taXR0ZWQsIGl0IHdpbGwgc3RhcnQgYXQgdGhlIHJvb3Qgbm9kZS5cbiAqIEBwYXJhbSBlbmROb2RlIC0gVGhlIG5vZGUgdG8gZW5kIHRoZSBzZWFyY2gsIGlmIG9taXR0ZWQsIGl0IHdpbGwgZmluZCBhbGwgZGVzY2VuZGFudHMgb2YgdGhlIHN0YXJ0aW5nTm9kZS5cbiAqIEByZXR1cm5zIEFuIGl0ZXJhdG9yLCBlYWNoIHlpZWxkZWQgdmFsdWUgaXMgYSBERlNOb2RlLiBJdCB3aWxsIGFsd2F5cyByZXR1cm4gYXQgbGVhc3QgMSBub2RlICh0aGUgc3RhcnQgbm9kZSkuXG4gKi9cbmZ1bmN0aW9uICRkZnNJdGVyYXRvcihzdGFydE5vZGUsIGVuZE5vZGUpIHtcbiAgY29uc3Qgc3RhcnQgPSAoc3RhcnROb2RlIHx8ICRnZXRSb290KCkpLmdldExhdGVzdCgpO1xuICBjb25zdCBzdGFydERlcHRoID0gJGdldERlcHRoKHN0YXJ0KTtcbiAgY29uc3QgZW5kID0gZW5kTm9kZTtcbiAgbGV0IG5vZGUgPSBzdGFydDtcbiAgbGV0IGRlcHRoID0gc3RhcnREZXB0aDtcbiAgbGV0IGlzRmlyc3ROZXh0ID0gdHJ1ZTtcbiAgY29uc3QgaXRlcmF0b3IgPSB7XG4gICAgbmV4dCgpIHtcbiAgICAgIGlmIChub2RlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvckRvbmU7XG4gICAgICB9XG4gICAgICBpZiAoaXNGaXJzdE5leHQpIHtcbiAgICAgICAgaXNGaXJzdE5leHQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTm90RG9uZSh7XG4gICAgICAgICAgZGVwdGgsXG4gICAgICAgICAgbm9kZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlID09PSBlbmQpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yRG9uZTtcbiAgICAgIH1cbiAgICAgIGlmICgkaXNFbGVtZW50Tm9kZShub2RlKSAmJiBub2RlLmdldENoaWxkcmVuU2l6ZSgpID4gMCkge1xuICAgICAgICBub2RlID0gbm9kZS5nZXRGaXJzdENoaWxkKCk7XG4gICAgICAgIGRlcHRoKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgZGVwdGhEaWZmO1xuICAgICAgICBbbm9kZSwgZGVwdGhEaWZmXSA9ICRnZXROZXh0U2libGluZ09yUGFyZW50U2libGluZyhub2RlKSB8fCBbbnVsbCwgMF07XG4gICAgICAgIGRlcHRoICs9IGRlcHRoRGlmZjtcbiAgICAgICAgaWYgKGVuZCA9PSBudWxsICYmIGRlcHRoIDw9IHN0YXJ0RGVwdGgpIHtcbiAgICAgICAgICBub2RlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yRG9uZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpdGVyYXRvck5vdERvbmUoe1xuICAgICAgICBkZXB0aCxcbiAgICAgICAgbm9kZVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICB9XG4gIH07XG4gIHJldHVybiBpdGVyYXRvcjtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBOb2RlIHNpYmxpbmcgd2hlbiB0aGlzIGV4aXN0cywgb3RoZXJ3aXNlIHRoZSBjbG9zZXN0IHBhcmVudCBzaWJsaW5nLiBGb3IgZXhhbXBsZVxuICogUiAtPiBQIC0+IFQxLCBUMlxuICogICAtPiBQMlxuICogcmV0dXJucyBUMiBmb3Igbm9kZSBUMSwgUDIgZm9yIG5vZGUgVDIsIGFuZCBudWxsIGZvciBub2RlIFAyLlxuICogQHBhcmFtIG5vZGUgTGV4aWNhbE5vZGUuXG4gKiBAcmV0dXJucyBBbiBhcnJheSAodHVwbGUpIGNvbnRhaW5pbmcgdGhlIGZvdW5kIExleGljYWwgbm9kZSBhbmQgdGhlIGRlcHRoIGRpZmZlcmVuY2UsIG9yIG51bGwsIGlmIHRoaXMgbm9kZSBkb2Vzbid0IGV4aXN0LlxuICovXG5mdW5jdGlvbiAkZ2V0TmV4dFNpYmxpbmdPclBhcmVudFNpYmxpbmcobm9kZSkge1xuICBsZXQgbm9kZV8gPSBub2RlO1xuICAvLyBGaW5kIGltbWVkaWF0ZSBzaWJsaW5nIG9yIG5lYXJlc3QgcGFyZW50IHNpYmxpbmdcbiAgbGV0IHNpYmxpbmcgPSBudWxsO1xuICBsZXQgZGVwdGhEaWZmID0gMDtcbiAgd2hpbGUgKHNpYmxpbmcgPT09IG51bGwgJiYgbm9kZV8gIT09IG51bGwpIHtcbiAgICBzaWJsaW5nID0gbm9kZV8uZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICBpZiAoc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgbm9kZV8gPSBub2RlXy5nZXRQYXJlbnQoKTtcbiAgICAgIGRlcHRoRGlmZi0tO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlXyA9IHNpYmxpbmc7XG4gICAgfVxuICB9XG4gIGlmIChub2RlXyA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBbbm9kZV8sIGRlcHRoRGlmZl07XG59XG5mdW5jdGlvbiAkZ2V0RGVwdGgobm9kZSkge1xuICBsZXQgaW5uZXJOb2RlID0gbm9kZTtcbiAgbGV0IGRlcHRoID0gMDtcbiAgd2hpbGUgKChpbm5lck5vZGUgPSBpbm5lck5vZGUuZ2V0UGFyZW50KCkpICE9PSBudWxsKSB7XG4gICAgZGVwdGgrKztcbiAgfVxuICByZXR1cm4gZGVwdGg7XG59XG5cbi8qKlxuICogUGVyZm9ybXMgYSByaWdodC10by1sZWZ0IHByZW9yZGVyIHRyZWUgdHJhdmVyc2FsLlxuICogRnJvbSB0aGUgc3RhcnRpbmcgbm9kZSBpdCBnb2VzIHRvIHRoZSByaWdodG1vc3QgY2hpbGQsIHRoYW4gYmFja3RyYWNrcyB0byBwYXJldCBhbmQgZmluZHMgbmV3IHJpZ2h0bW9zdCBwYXRoLlxuICogSXQgd2lsbCByZXR1cm4gdGhlIG5leHQgbm9kZSBpbiB0cmF2ZXJzYWwgc2VxdWVuY2UgYWZ0ZXIgdGhlIHN0YXJ0aW5nTm9kZS5cbiAqIFRoZSB0cmF2ZXJzYWwgaXMgc2ltaWxhciB0byAkZGZzIGZ1bmN0aW9ucyBhYm92ZSwgYnV0IHRoZSBub2RlcyBhcmUgdmlzaXRlZCByaWdodC10by1sZWZ0LCBub3QgbGVmdC10by1yaWdodC5cbiAqIEBwYXJhbSBzdGFydGluZ05vZGUgLSBUaGUgbm9kZSB0byBzdGFydCB0aGUgc2VhcmNoLlxuICogQHJldHVybnMgVGhlIG5leHQgbm9kZSBpbiBwcmUtb3JkZXIgcmlnaHQgdG8gbGVmdCB0cmF2ZXJzYWwgc2VxdWVuY2Ugb3IgYG51bGxgLCBpZiB0aGUgbm9kZSBkb2VzIG5vdCBleGlzdFxuICovXG5mdW5jdGlvbiAkZ2V0TmV4dFJpZ2h0UHJlb3JkZXJOb2RlKHN0YXJ0aW5nTm9kZSkge1xuICBsZXQgbm9kZSA9IHN0YXJ0aW5nTm9kZTtcbiAgaWYgKCRpc0VsZW1lbnROb2RlKG5vZGUpICYmIG5vZGUuZ2V0Q2hpbGRyZW5TaXplKCkgPiAwKSB7XG4gICAgbm9kZSA9IG5vZGUuZ2V0TGFzdENoaWxkKCk7XG4gIH0gZWxzZSB7XG4gICAgbGV0IHNpYmxpbmcgPSBudWxsO1xuICAgIHdoaWxlIChzaWJsaW5nID09PSBudWxsICYmIG5vZGUgIT09IG51bGwpIHtcbiAgICAgIHNpYmxpbmcgPSBub2RlLmdldFByZXZpb3VzU2libGluZygpO1xuICAgICAgaWYgKHNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgbm9kZSA9IG5vZGUuZ2V0UGFyZW50KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlID0gc2libGluZztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5cbi8qKlxuICogVGFrZXMgYSBub2RlIGFuZCB0cmF2ZXJzZXMgdXAgaXRzIGFuY2VzdG9ycyAodG93YXJkIHRoZSByb290IG5vZGUpXG4gKiBpbiBvcmRlciB0byBmaW5kIGEgc3BlY2lmaWMgdHlwZSBvZiBub2RlLlxuICogQHBhcmFtIG5vZGUgLSB0aGUgbm9kZSB0byBiZWdpbiBzZWFyY2hpbmcuXG4gKiBAcGFyYW0ga2xhc3MgLSBhbiBpbnN0YW5jZSBvZiB0aGUgdHlwZSBvZiBub2RlIHRvIGxvb2sgZm9yLlxuICogQHJldHVybnMgdGhlIG5vZGUgb2YgdHlwZSBrbGFzcyB0aGF0IHdhcyBwYXNzZWQsIG9yIG51bGwgaWYgbm9uZSBleGlzdC5cbiAqL1xuZnVuY3Rpb24gJGdldE5lYXJlc3ROb2RlT2ZUeXBlKG5vZGUsIGtsYXNzKSB7XG4gIGxldCBwYXJlbnQgPSBub2RlO1xuICB3aGlsZSAocGFyZW50ICE9IG51bGwpIHtcbiAgICBpZiAocGFyZW50IGluc3RhbmNlb2Yga2xhc3MpIHtcbiAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgfVxuICAgIHBhcmVudCA9IHBhcmVudC5nZXRQYXJlbnQoKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBlbGVtZW50IG5vZGUgb2YgdGhlIG5lYXJlc3QgYW5jZXN0b3IsIG90aGVyd2lzZSB0aHJvd3MgYW4gZXJyb3IuXG4gKiBAcGFyYW0gc3RhcnROb2RlIC0gVGhlIHN0YXJ0aW5nIG5vZGUgb2YgdGhlIHNlYXJjaFxuICogQHJldHVybnMgVGhlIGFuY2VzdG9yIG5vZGUgZm91bmRcbiAqL1xuZnVuY3Rpb24gJGdldE5lYXJlc3RCbG9ja0VsZW1lbnRBbmNlc3Rvck9yVGhyb3coc3RhcnROb2RlKSB7XG4gIGNvbnN0IGJsb2NrTm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoc3RhcnROb2RlLCBub2RlID0+ICRpc0VsZW1lbnROb2RlKG5vZGUpICYmICFub2RlLmlzSW5saW5lKCkpO1xuICBpZiAoISRpc0VsZW1lbnROb2RlKGJsb2NrTm9kZSkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgbm9kZSAke3N0YXJ0Tm9kZS5fX2tleX0gdG8gaGF2ZSBjbG9zZXN0IGJsb2NrIGVsZW1lbnQgbm9kZS5gKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJsb2NrTm9kZTtcbn1cbi8qKlxuICogU3RhcnRzIHdpdGggYSBub2RlIGFuZCBtb3ZlcyB1cCB0aGUgdHJlZSAodG93YXJkIHRoZSByb290IG5vZGUpIHRvIGZpbmQgYSBtYXRjaGluZyBub2RlIGJhc2VkIG9uXG4gKiB0aGUgc2VhcmNoIHBhcmFtZXRlcnMgb2YgdGhlIGZpbmRGbi4gKENvbnNpZGVyIEphdmFTY3JpcHRzJyAuZmluZCgpIGZ1bmN0aW9uIHdoZXJlIGEgdGVzdGluZyBmdW5jdGlvbiBtdXN0IGJlXG4gKiBwYXNzZWQgYXMgYW4gYXJndW1lbnQuIGVnLiBpZiggKG5vZGUpID0+IG5vZGUuX190eXBlID09PSAnZGl2JykgKSByZXR1cm4gdHJ1ZTsgb3RoZXJ3aXNlIHJldHVybiBmYWxzZVxuICogQHBhcmFtIHN0YXJ0aW5nTm9kZSAtIFRoZSBub2RlIHdoZXJlIHRoZSBzZWFyY2ggc3RhcnRzLlxuICogQHBhcmFtIGZpbmRGbiAtIEEgdGVzdGluZyBmdW5jdGlvbiB0aGF0IHJldHVybnMgdHJ1ZSBpZiB0aGUgY3VycmVudCBub2RlIHNhdGlzZmllcyB0aGUgdGVzdGluZyBwYXJhbWV0ZXJzLlxuICogQHJldHVybnMgQSBwYXJlbnQgbm9kZSB0aGF0IG1hdGNoZXMgdGhlIGZpbmRGbiBwYXJhbWV0ZXJzLCBvciBudWxsIGlmIG9uZSB3YXNuJ3QgZm91bmQuXG4gKi9cbmNvbnN0ICRmaW5kTWF0Y2hpbmdQYXJlbnQgPSAoc3RhcnRpbmdOb2RlLCBmaW5kRm4pID0+IHtcbiAgbGV0IGN1cnIgPSBzdGFydGluZ05vZGU7XG4gIHdoaWxlIChjdXJyICE9PSAkZ2V0Um9vdCgpICYmIGN1cnIgIT0gbnVsbCkge1xuICAgIGlmIChmaW5kRm4oY3VycikpIHtcbiAgICAgIHJldHVybiBjdXJyO1xuICAgIH1cbiAgICBjdXJyID0gY3Vyci5nZXRQYXJlbnQoKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gcmVzb2x2ZSBuZXN0ZWQgZWxlbWVudCBub2RlcyBvZiB0aGUgc2FtZSB0eXBlIGludG8gYSBzaW5nbGUgbm9kZSBvZiB0aGF0IHR5cGUuXG4gKiBJdCBpcyBnZW5lcmFsbHkgdXNlZCBmb3IgbWFya3MvY29tbWVudGluZ1xuICogQHBhcmFtIGVkaXRvciAtIFRoZSBsZXhpY2FsIGVkaXRvclxuICogQHBhcmFtIHRhcmdldE5vZGUgLSBUaGUgdGFyZ2V0IGZvciB0aGUgbmVzdGVkIGVsZW1lbnQgdG8gYmUgZXh0cmFjdGVkIGZyb20uXG4gKiBAcGFyYW0gY2xvbmVOb2RlIC0gU2VlIHtAbGluayAkY3JlYXRlTWFya05vZGV9XG4gKiBAcGFyYW0gaGFuZGxlT3ZlcmxhcCAtIEhhbmRsZXMgYW55IG92ZXJsYXAgYmV0d2VlbiB0aGUgbm9kZSB0byBleHRyYWN0IGFuZCB0aGUgdGFyZ2V0Tm9kZVxuICogQHJldHVybnMgVGhlIGxleGljYWwgZWRpdG9yXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyTmVzdGVkRWxlbWVudFJlc29sdmVyKGVkaXRvciwgdGFyZ2V0Tm9kZSwgY2xvbmVOb2RlLCBoYW5kbGVPdmVybGFwKSB7XG4gIGNvbnN0ICRpc1RhcmdldE5vZGUgPSBub2RlID0+IHtcbiAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIHRhcmdldE5vZGU7XG4gIH07XG4gIGNvbnN0ICRmaW5kTWF0Y2ggPSBub2RlID0+IHtcbiAgICAvLyBGaXJzdCB2YWxpZGF0ZSB3ZSBkb24ndCBoYXZlIGFueSBjaGlsZHJlbiB0aGF0IGFyZSBvZiB0aGUgdGFyZ2V0LFxuICAgIC8vIGFzIHdlIG5lZWQgdG8gaGFuZGxlIHRoZW0gZmlyc3QuXG4gICAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmdldENoaWxkcmVuKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIGlmICgkaXNUYXJnZXROb2RlKGNoaWxkKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHBhcmVudE5vZGUgPSBub2RlO1xuICAgIGxldCBjaGlsZE5vZGUgPSBub2RlO1xuICAgIHdoaWxlIChwYXJlbnROb2RlICE9PSBudWxsKSB7XG4gICAgICBjaGlsZE5vZGUgPSBwYXJlbnROb2RlO1xuICAgICAgcGFyZW50Tm9kZSA9IHBhcmVudE5vZGUuZ2V0UGFyZW50KCk7XG4gICAgICBpZiAoJGlzVGFyZ2V0Tm9kZShwYXJlbnROb2RlKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNoaWxkOiBjaGlsZE5vZGUsXG4gICAgICAgICAgcGFyZW50OiBwYXJlbnROb2RlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O1xuICBjb25zdCAkZWxlbWVudE5vZGVUcmFuc2Zvcm0gPSBub2RlID0+IHtcbiAgICBjb25zdCBtYXRjaCA9ICRmaW5kTWF0Y2gobm9kZSk7XG4gICAgaWYgKG1hdGNoICE9PSBudWxsKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNoaWxkLFxuICAgICAgICBwYXJlbnRcbiAgICAgIH0gPSBtYXRjaDtcblxuICAgICAgLy8gU2ltcGxlIHBhdGgsIHdlIGNhbiBtb3ZlIGNoaWxkIG91dCBhbmQgc2libGluZ3MgaW50byBhIG5ldyBwYXJlbnQuXG5cbiAgICAgIGlmIChjaGlsZC5pcyhub2RlKSkge1xuICAgICAgICBoYW5kbGVPdmVybGFwKHBhcmVudCwgbm9kZSk7XG4gICAgICAgIGNvbnN0IG5leHRTaWJsaW5ncyA9IGNoaWxkLmdldE5leHRTaWJsaW5ncygpO1xuICAgICAgICBjb25zdCBuZXh0U2libGluZ3NMZW5ndGggPSBuZXh0U2libGluZ3MubGVuZ3RoO1xuICAgICAgICBwYXJlbnQuaW5zZXJ0QWZ0ZXIoY2hpbGQpO1xuICAgICAgICBpZiAobmV4dFNpYmxpbmdzTGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgY29uc3QgbmV3UGFyZW50ID0gY2xvbmVOb2RlKHBhcmVudCk7XG4gICAgICAgICAgY2hpbGQuaW5zZXJ0QWZ0ZXIobmV3UGFyZW50KTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5leHRTaWJsaW5nc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBuZXdQYXJlbnQuYXBwZW5kKG5leHRTaWJsaW5nc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyZW50LmNhbkJlRW1wdHkoKSAmJiBwYXJlbnQuZ2V0Q2hpbGRyZW5TaXplKCkgPT09IDApIHtcbiAgICAgICAgICBwYXJlbnQucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiBlZGl0b3IucmVnaXN0ZXJOb2RlVHJhbnNmb3JtKHRhcmdldE5vZGUsICRlbGVtZW50Tm9kZVRyYW5zZm9ybSk7XG59XG5cbi8qKlxuICogQ2xvbmVzIHRoZSBlZGl0b3IgYW5kIG1hcmtzIGl0IGFzIGRpcnR5IHRvIGJlIHJlY29uY2lsZWQuIElmIHRoZXJlIHdhcyBhIHNlbGVjdGlvbixcbiAqIGl0IHdvdWxkIGJlIHNldCBiYWNrIHRvIGl0cyBwcmV2aW91cyBzdGF0ZSwgb3IgbnVsbCBvdGhlcndpc2UuXG4gKiBAcGFyYW0gZWRpdG9yIC0gVGhlIGxleGljYWwgZWRpdG9yXG4gKiBAcGFyYW0gZWRpdG9yU3RhdGUgLSBUaGUgZWRpdG9yJ3Mgc3RhdGVcbiAqL1xuZnVuY3Rpb24gJHJlc3RvcmVFZGl0b3JTdGF0ZShlZGl0b3IsIGVkaXRvclN0YXRlKSB7XG4gIGNvbnN0IEZVTExfUkVDT05DSUxFID0gMjtcbiAgY29uc3Qgbm9kZU1hcCA9IG5ldyBNYXAoKTtcbiAgY29uc3QgYWN0aXZlRWRpdG9yU3RhdGUgPSBlZGl0b3IuX3BlbmRpbmdFZGl0b3JTdGF0ZTtcbiAgZm9yIChjb25zdCBba2V5LCBub2RlXSBvZiBlZGl0b3JTdGF0ZS5fbm9kZU1hcCkge1xuICAgIG5vZGVNYXAuc2V0KGtleSwgJGNsb25lV2l0aFByb3BlcnRpZXMobm9kZSkpO1xuICB9XG4gIGlmIChhY3RpdmVFZGl0b3JTdGF0ZSkge1xuICAgIGFjdGl2ZUVkaXRvclN0YXRlLl9ub2RlTWFwID0gbm9kZU1hcDtcbiAgfVxuICBlZGl0b3IuX2RpcnR5VHlwZSA9IEZVTExfUkVDT05DSUxFO1xuICBjb25zdCBzZWxlY3Rpb24gPSBlZGl0b3JTdGF0ZS5fc2VsZWN0aW9uO1xuICAkc2V0U2VsZWN0aW9uKHNlbGVjdGlvbiA9PT0gbnVsbCA/IG51bGwgOiBzZWxlY3Rpb24uY2xvbmUoKSk7XG59XG5cbi8qKlxuICogSWYgdGhlIHNlbGVjdGVkIGluc2VydGlvbiBhcmVhIGlzIHRoZSByb290L3NoYWRvdyByb290IG5vZGUgKHNlZSB7QGxpbmsgbGV4aWNhbCEkaXNSb290T3JTaGFkb3dSb290fSksXG4gKiB0aGUgbm9kZSB3aWxsIGJlIGFwcGVuZGVkIHRoZXJlLCBvdGhlcndpc2UsIGl0IHdpbGwgYmUgaW5zZXJ0ZWQgYmVmb3JlIHRoZSBpbnNlcnRpb24gYXJlYS5cbiAqIElmIHRoZXJlIGlzIG5vIHNlbGVjdGlvbiB3aGVyZSB0aGUgbm9kZSBpcyB0byBiZSBpbnNlcnRlZCwgaXQgd2lsbCBiZSBhcHBlbmRlZCBhZnRlciBhbnkgY3VycmVudCBub2Rlc1xuICogd2l0aGluIHRoZSB0cmVlLCBhcyBhIGNoaWxkIG9mIHRoZSByb290IG5vZGUuIEEgcGFyYWdyYXBoIG5vZGUgd2lsbCB0aGVuIGJlIGFkZGVkIGFmdGVyIHRoZSBpbnNlcnRlZCBub2RlIGFuZCBzZWxlY3RlZC5cbiAqIEBwYXJhbSBub2RlIC0gVGhlIG5vZGUgdG8gYmUgaW5zZXJ0ZWRcbiAqIEByZXR1cm5zIFRoZSBub2RlIGFmdGVyIGl0cyBpbnNlcnRpb25cbiAqL1xuZnVuY3Rpb24gJGluc2VydE5vZGVUb05lYXJlc3RSb290KG5vZGUpIHtcbiAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpIHx8ICRnZXRQcmV2aW91c1NlbGVjdGlvbigpO1xuICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGZvY3VzXG4gICAgfSA9IHNlbGVjdGlvbjtcbiAgICBjb25zdCBmb2N1c05vZGUgPSBmb2N1cy5nZXROb2RlKCk7XG4gICAgY29uc3QgZm9jdXNPZmZzZXQgPSBmb2N1cy5vZmZzZXQ7XG4gICAgaWYgKCRpc1Jvb3RPclNoYWRvd1Jvb3QoZm9jdXNOb2RlKSkge1xuICAgICAgY29uc3QgZm9jdXNDaGlsZCA9IGZvY3VzTm9kZS5nZXRDaGlsZEF0SW5kZXgoZm9jdXNPZmZzZXQpO1xuICAgICAgaWYgKGZvY3VzQ2hpbGQgPT0gbnVsbCkge1xuICAgICAgICBmb2N1c05vZGUuYXBwZW5kKG5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9jdXNDaGlsZC5pbnNlcnRCZWZvcmUobm9kZSk7XG4gICAgICB9XG4gICAgICBub2RlLnNlbGVjdE5leHQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHNwbGl0Tm9kZTtcbiAgICAgIGxldCBzcGxpdE9mZnNldDtcbiAgICAgIGlmICgkaXNUZXh0Tm9kZShmb2N1c05vZGUpKSB7XG4gICAgICAgIHNwbGl0Tm9kZSA9IGZvY3VzTm9kZS5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgICAgIHNwbGl0T2Zmc2V0ID0gZm9jdXNOb2RlLmdldEluZGV4V2l0aGluUGFyZW50KCk7XG4gICAgICAgIGlmIChmb2N1c09mZnNldCA+IDApIHtcbiAgICAgICAgICBzcGxpdE9mZnNldCArPSAxO1xuICAgICAgICAgIGZvY3VzTm9kZS5zcGxpdFRleHQoZm9jdXNPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzcGxpdE5vZGUgPSBmb2N1c05vZGU7XG4gICAgICAgIHNwbGl0T2Zmc2V0ID0gZm9jdXNPZmZzZXQ7XG4gICAgICB9XG4gICAgICBjb25zdCBbLCByaWdodFRyZWVdID0gJHNwbGl0Tm9kZShzcGxpdE5vZGUsIHNwbGl0T2Zmc2V0KTtcbiAgICAgIHJpZ2h0VHJlZS5pbnNlcnRCZWZvcmUobm9kZSk7XG4gICAgICByaWdodFRyZWUuc2VsZWN0U3RhcnQoKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHNlbGVjdGlvbiAhPSBudWxsKSB7XG4gICAgICBjb25zdCBub2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpO1xuICAgICAgbm9kZXNbbm9kZXMubGVuZ3RoIC0gMV0uZ2V0VG9wTGV2ZWxFbGVtZW50T3JUaHJvdygpLmluc2VydEFmdGVyKG5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByb290ID0gJGdldFJvb3QoKTtcbiAgICAgIHJvb3QuYXBwZW5kKG5vZGUpO1xuICAgIH1cbiAgICBjb25zdCBwYXJhZ3JhcGhOb2RlID0gJGNyZWF0ZVBhcmFncmFwaE5vZGUoKTtcbiAgICBub2RlLmluc2VydEFmdGVyKHBhcmFncmFwaE5vZGUpO1xuICAgIHBhcmFncmFwaE5vZGUuc2VsZWN0KCk7XG4gIH1cbiAgcmV0dXJuIG5vZGUuZ2V0TGF0ZXN0KCk7XG59XG5cbi8qKlxuICogV3JhcHMgdGhlIG5vZGUgaW50byBhbm90aGVyIG5vZGUgY3JlYXRlZCBmcm9tIGEgY3JlYXRlRWxlbWVudE5vZGUgZnVuY3Rpb24sIGVnLiAkY3JlYXRlUGFyYWdyYXBoTm9kZVxuICogQHBhcmFtIG5vZGUgLSBOb2RlIHRvIGJlIHdyYXBwZWQuXG4gKiBAcGFyYW0gY3JlYXRlRWxlbWVudE5vZGUgLSBDcmVhdGVzIGEgbmV3IGxleGljYWwgZWxlbWVudCB0byB3cmFwIHRoZSB0by1iZS13cmFwcGVkIG5vZGUgYW5kIHJldHVybnMgaXQuXG4gKiBAcmV0dXJucyBBIG5ldyBsZXhpY2FsIGVsZW1lbnQgd2l0aCB0aGUgcHJldmlvdXMgbm9kZSBhcHBlbmRlZCB3aXRoaW4gKGFzIGEgY2hpbGQsIGluY2x1ZGluZyBpdHMgY2hpbGRyZW4pLlxuICovXG5mdW5jdGlvbiAkd3JhcE5vZGVJbkVsZW1lbnQobm9kZSwgY3JlYXRlRWxlbWVudE5vZGUpIHtcbiAgY29uc3QgZWxlbWVudE5vZGUgPSBjcmVhdGVFbGVtZW50Tm9kZSgpO1xuICBub2RlLnJlcGxhY2UoZWxlbWVudE5vZGUpO1xuICBlbGVtZW50Tm9kZS5hcHBlbmQobm9kZSk7XG4gIHJldHVybiBlbGVtZW50Tm9kZTtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcblxuLyoqXG4gKiBAcGFyYW0gb2JqZWN0ID0gVGhlIGluc3RhbmNlIG9mIHRoZSB0eXBlXG4gKiBAcGFyYW0gb2JqZWN0Q2xhc3MgPSBUaGUgY2xhc3Mgb2YgdGhlIHR5cGVcbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIG9iamVjdCBpcyBoYXMgdGhlIHNhbWUgS2xhc3Mgb2YgdGhlIG9iamVjdENsYXNzLCBpZ25vcmluZyB0aGUgZGlmZmVyZW5jZSBhY3Jvc3Mgd2luZG93IChlLmcuIGRpZmZlcmVudCBpZnJhbXMpXG4gKi9cbmZ1bmN0aW9uIG9iamVjdEtsYXNzRXF1YWxzKG9iamVjdCwgb2JqZWN0Q2xhc3MpIHtcbiAgcmV0dXJuIG9iamVjdCAhPT0gbnVsbCA/IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpLmNvbnN0cnVjdG9yLm5hbWUgPT09IG9iamVjdENsYXNzLm5hbWUgOiBmYWxzZTtcbn1cblxuLyoqXG4gKiBGaWx0ZXIgdGhlIG5vZGVzXG4gKiBAcGFyYW0gbm9kZXMgQXJyYXkgb2Ygbm9kZXMgdGhhdCBuZWVkcyB0byBiZSBmaWx0ZXJlZFxuICogQHBhcmFtIGZpbHRlckZuIEEgZmlsdGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBub2RlIGlmIHRoZSBjdXJyZW50IG5vZGUgc2F0aXNmaWVzIHRoZSBjb25kaXRpb24gb3RoZXJ3aXNlIG51bGxcbiAqIEByZXR1cm5zIEFycmF5IG9mIGZpbHRlcmVkIG5vZGVzXG4gKi9cblxuZnVuY3Rpb24gJGZpbHRlcihub2RlcywgZmlsdGVyRm4pIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBub2RlID0gZmlsdGVyRm4obm9kZXNbaV0pO1xuICAgIGlmIChub2RlICE9PSBudWxsKSB7XG4gICAgICByZXN1bHQucHVzaChub2RlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQXBwZW5kcyB0aGUgbm9kZSBiZWZvcmUgdGhlIGZpcnN0IGNoaWxkIG9mIHRoZSBwYXJlbnQgbm9kZVxuICogQHBhcmFtIHBhcmVudCBBIHBhcmVudCBub2RlXG4gKiBAcGFyYW0gbm9kZSBOb2RlIHRoYXQgbmVlZHMgdG8gYmUgYXBwZW5kZWRcbiAqL1xuZnVuY3Rpb24gJGluc2VydEZpcnN0KHBhcmVudCwgbm9kZSkge1xuICBjb25zdCBmaXJzdENoaWxkID0gcGFyZW50LmdldEZpcnN0Q2hpbGQoKTtcbiAgaWYgKGZpcnN0Q2hpbGQgIT09IG51bGwpIHtcbiAgICBmaXJzdENoaWxkLmluc2VydEJlZm9yZShub2RlKTtcbiAgfSBlbHNlIHtcbiAgICBwYXJlbnQuYXBwZW5kKG5vZGUpO1xuICB9XG59XG5sZXQgTkVFRFNfTUFOVUFMX1pPT00gPSBJU19GSVJFRk9YIHx8ICFDQU5fVVNFX0RPTSA/IGZhbHNlIDogdW5kZWZpbmVkO1xuZnVuY3Rpb24gbmVlZHNNYW51YWxab29tKCkge1xuICBpZiAoTkVFRFNfTUFOVUFMX1pPT00gPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIElmIHRoZSBicm93c2VyIGltcGxlbWVudHMgc3RhbmRhcmRpemVkIENTUyB6b29tLCB0aGVuIHRoZSBjbGllbnQgcmVjdFxuICAgIC8vIHdpbGwgYmUgd2lkZXIgYWZ0ZXIgem9vbSBpcyBhcHBsaWVkXG4gICAgLy8gaHR0cHM6Ly9jaHJvbWVzdGF0dXMuY29tL2ZlYXR1cmUvNTE5ODI1NDg2ODUyOTE1MlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9sZXhpY2FsL2lzc3Vlcy82ODYzXG4gICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGl2LnN0eWxlLmNzc1RleHQgPSAncG9zaXRpb246IGFic29sdXRlOyBvcGFjaXR5OiAwOyB3aWR0aDogMTAwcHg7IGxlZnQ6IC0xMDAwcHg7JztcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpdik7XG4gICAgY29uc3Qgbm9ab29tID0gZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGRpdi5zdHlsZS5zZXRQcm9wZXJ0eSgnem9vbScsICcyJyk7XG4gICAgTkVFRFNfTUFOVUFMX1pPT00gPSBkaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggPT09IG5vWm9vbS53aWR0aDtcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGRpdik7XG4gIH1cbiAgcmV0dXJuIE5FRURTX01BTlVBTF9aT09NO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHpvb20gbGV2ZWwgb2YgYW4gZWxlbWVudCBhcyBhIHJlc3VsdCBvZiB1c2luZ1xuICogY3NzIHpvb20gcHJvcGVydHkuIEZvciBicm93c2VycyB0aGF0IGltcGxlbWVudCBzdGFuZGFyZGl6ZWQgQ1NTXG4gKiB6b29tIChGaXJlZm94LCBDaHJvbWUgPj0gMTI4KSwgdGhpcyB3aWxsIGFsd2F5cyByZXR1cm4gMS5cbiAqIEBwYXJhbSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZVpvb21MZXZlbChlbGVtZW50KSB7XG4gIGxldCB6b29tID0gMTtcbiAgaWYgKG5lZWRzTWFudWFsWm9vbSgpKSB7XG4gICAgd2hpbGUgKGVsZW1lbnQpIHtcbiAgICAgIHpvb20gKj0gTnVtYmVyKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUoJ3pvb20nKSk7XG4gICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgIH1cbiAgfVxuICByZXR1cm4gem9vbTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGVkaXRvciBpcyBhIG5lc3RlZCBlZGl0b3IgY3JlYXRlZCBieSBMZXhpY2FsTmVzdGVkQ29tcG9zZXJcbiAqL1xuZnVuY3Rpb24gJGlzRWRpdG9ySXNOZXN0ZWRFZGl0b3IoZWRpdG9yKSB7XG4gIHJldHVybiBlZGl0b3IuX3BhcmVudEVkaXRvciAhPT0gbnVsbDtcbn1cblxuLyoqXG4gKiBBIGRlcHRoIGZpcnN0IGxhc3QtdG8tZmlyc3QgdHJhdmVyc2FsIG9mIHJvb3QgdGhhdCBzdG9wcyBhdCBlYWNoIG5vZGUgdGhhdCBtYXRjaGVzXG4gKiAkcHJlZGljYXRlIGFuZCBlbnN1cmVzIHRoYXQgaXRzIHBhcmVudCBpcyByb290LiBUaGlzIGlzIHR5cGljYWxseSB1c2VkIHRvIGRpc2NhcmRcbiAqIGludmFsaWQgb3IgdW5zdXBwb3J0ZWQgd3JhcHBpbmcgbm9kZXMuIEZvciBleGFtcGxlLCBhIFRhYmxlTm9kZSBtdXN0IG9ubHkgaGF2ZVxuICogVGFibGVSb3dOb2RlIGFzIGNoaWxkcmVuLCBidXQgYW4gaW1wb3J0ZXIgbWlnaHQgYWRkIGludmFsaWQgbm9kZXMgYmFzZWQgb25cbiAqIGNhcHRpb24sIHRib2R5LCB0aGVhZCwgZXRjLiBhbmQgdGhpcyB3aWxsIHVud3JhcCBhbmQgZGlzY2FyZCB0aG9zZS5cbiAqXG4gKiBAcGFyYW0gcm9vdCBUaGUgcm9vdCB0byBzdGFydCB0aGUgdHJhdmVyc2FsXG4gKiBAcGFyYW0gJHByZWRpY2F0ZSBTaG91bGQgcmV0dXJuIHRydWUgZm9yIG5vZGVzIHRoYXQgYXJlIHBlcm1pdHRlZCB0byBiZSBjaGlsZHJlbiBvZiByb290XG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoaXMgdW53cmFwcGVkIG9yIHJlbW92ZWQgYW55IG5vZGVzXG4gKi9cbmZ1bmN0aW9uICR1bndyYXBBbmRGaWx0ZXJEZXNjZW5kYW50cyhyb290LCAkcHJlZGljYXRlKSB7XG4gIHJldHVybiAkdW53cmFwQW5kRmlsdGVyRGVzY2VuZGFudHNJbXBsKHJvb3QsICRwcmVkaWNhdGUsIG51bGwpO1xufVxuZnVuY3Rpb24gJHVud3JhcEFuZEZpbHRlckRlc2NlbmRhbnRzSW1wbChyb290LCAkcHJlZGljYXRlLCAkb25TdWNjZXNzKSB7XG4gIGxldCBkaWRNdXRhdGUgPSBmYWxzZTtcbiAgZm9yIChjb25zdCBub2RlIG9mICRsYXN0VG9GaXJzdEl0ZXJhdG9yKHJvb3QpKSB7XG4gICAgaWYgKCRwcmVkaWNhdGUobm9kZSkpIHtcbiAgICAgIGlmICgkb25TdWNjZXNzICE9PSBudWxsKSB7XG4gICAgICAgICRvblN1Y2Nlc3Mobm9kZSk7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgZGlkTXV0YXRlID0gdHJ1ZTtcbiAgICBpZiAoJGlzRWxlbWVudE5vZGUobm9kZSkpIHtcbiAgICAgICR1bndyYXBBbmRGaWx0ZXJEZXNjZW5kYW50c0ltcGwobm9kZSwgJHByZWRpY2F0ZSwgJG9uU3VjY2VzcyA/ICRvblN1Y2Nlc3MgOiBjaGlsZCA9PiBub2RlLmluc2VydEFmdGVyKGNoaWxkKSk7XG4gICAgfVxuICAgIG5vZGUucmVtb3ZlKCk7XG4gIH1cbiAgcmV0dXJuIGRpZE11dGF0ZTtcbn1cblxuLyoqXG4gKiBBIGRlcHRoIGZpcnN0IHRyYXZlcnNhbCBvZiB0aGUgY2hpbGRyZW4gYXJyYXkgdGhhdCBzdG9wcyBhdCBhbmQgY29sbGVjdHNcbiAqIGVhY2ggbm9kZSB0aGF0IGAkcHJlZGljYXRlYCBtYXRjaGVzLiBUaGlzIGlzIHR5cGljYWxseSB1c2VkIHRvIGRpc2NhcmRcbiAqIGludmFsaWQgb3IgdW5zdXBwb3J0ZWQgd3JhcHBpbmcgbm9kZXMgb24gYSBjaGlsZHJlbiBhcnJheSBpbiB0aGUgYGFmdGVyYFxuICogb2YgYW4ge0BsaW5rIGxleGljYWwhRE9NQ29udmVyc2lvbk91dHB1dH0uIEZvciBleGFtcGxlLCBhIFRhYmxlTm9kZSBtdXN0IG9ubHkgaGF2ZVxuICogVGFibGVSb3dOb2RlIGFzIGNoaWxkcmVuLCBidXQgYW4gaW1wb3J0ZXIgbWlnaHQgYWRkIGludmFsaWQgbm9kZXMgYmFzZWQgb25cbiAqIGNhcHRpb24sIHRib2R5LCB0aGVhZCwgZXRjLiBhbmQgdGhpcyB3aWxsIHVud3JhcCBhbmQgZGlzY2FyZCB0aG9zZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHJlYWQtb25seSBhbmQgcGVyZm9ybXMgbm8gbXV0YXRpb24gb3BlcmF0aW9ucywgd2hpY2ggbWFrZXNcbiAqIGl0IHN1aXRhYmxlIGZvciBpbXBvcnQgYW5kIGV4cG9ydCBwdXJwb3NlcyBidXQgbGlrZWx5IG5vdCBmb3IgYW55IGluLXBsYWNlXG4gKiBtdXRhdGlvbi4gWW91IHNob3VsZCB1c2Uge0BsaW5rICR1bndyYXBBbmRGaWx0ZXJEZXNjZW5kYW50c30gZm9yIGluLXBsYWNlXG4gKiBtdXRhdGlvbnMgc3VjaCBhcyBub2RlIHRyYW5zZm9ybXMuXG4gKlxuICogQHBhcmFtIGNoaWxkcmVuIFRoZSBjaGlsZHJlbiB0byB0cmF2ZXJzZVxuICogQHBhcmFtICRwcmVkaWNhdGUgU2hvdWxkIHJldHVybiB0cnVlIGZvciBub2RlcyB0aGF0IGFyZSBwZXJtaXR0ZWQgdG8gYmUgY2hpbGRyZW4gb2Ygcm9vdFxuICogQHJldHVybnMgVGhlIGNoaWxkcmVuIG9yIHRoZWlyIGRlc2NlbmRhbnRzIHRoYXQgbWF0Y2ggJHByZWRpY2F0ZVxuICovXG5cbmZ1bmN0aW9uICRkZXNjZW5kYW50c01hdGNoaW5nKGNoaWxkcmVuLCAkcHJlZGljYXRlKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBjb25zdCBzdGFjayA9IFsuLi5jaGlsZHJlbl0ucmV2ZXJzZSgpO1xuICBmb3IgKGxldCBjaGlsZCA9IHN0YWNrLnBvcCgpOyBjaGlsZCAhPT0gdW5kZWZpbmVkOyBjaGlsZCA9IHN0YWNrLnBvcCgpKSB7XG4gICAgaWYgKCRwcmVkaWNhdGUoY2hpbGQpKSB7XG4gICAgICByZXN1bHQucHVzaChjaGlsZCk7XG4gICAgfSBlbHNlIGlmICgkaXNFbGVtZW50Tm9kZShjaGlsZCkpIHtcbiAgICAgIGZvciAoY29uc3QgZ3JhbmRjaGlsZCBvZiAkbGFzdFRvRmlyc3RJdGVyYXRvcihjaGlsZCkpIHtcbiAgICAgICAgc3RhY2sucHVzaChncmFuZGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYW4gaXRlcmF0b3IgdGhhdCB5aWVsZHMgZWFjaCBjaGlsZCBvZiBub2RlIGZyb20gZmlyc3QgdG8gbGFzdCwgdGFraW5nXG4gKiBjYXJlIHRvIHByZXNlcnZlIHRoZSBuZXh0IHNpYmxpbmcgYmVmb3JlIHlpZWxkaW5nIHRoZSB2YWx1ZSBpbiBjYXNlIHRoZSBjYWxsZXJcbiAqIHJlbW92ZXMgdGhlIHlpZWxkZWQgbm9kZS5cbiAqXG4gKiBAcGFyYW0gbm9kZSBUaGUgbm9kZSB3aG9zZSBjaGlsZHJlbiB0byBpdGVyYXRlXG4gKiBAcmV0dXJucyBBbiBpdGVyYXRvciBvZiB0aGUgbm9kZSdzIGNoaWxkcmVuXG4gKi9cbmZ1bmN0aW9uICRmaXJzdFRvTGFzdEl0ZXJhdG9yKG5vZGUpIHtcbiAgcmV0dXJuIHtcbiAgICBbU3ltYm9sLml0ZXJhdG9yXTogKCkgPT4gJGNoaWxkSXRlcmF0b3Iobm9kZS5nZXRGaXJzdENoaWxkKCksIGNoaWxkID0+IGNoaWxkLmdldE5leHRTaWJsaW5nKCkpXG4gIH07XG59XG5cbi8qKlxuICogUmV0dXJuIGFuIGl0ZXJhdG9yIHRoYXQgeWllbGRzIGVhY2ggY2hpbGQgb2Ygbm9kZSBmcm9tIGxhc3QgdG8gZmlyc3QsIHRha2luZ1xuICogY2FyZSB0byBwcmVzZXJ2ZSB0aGUgcHJldmlvdXMgc2libGluZyBiZWZvcmUgeWllbGRpbmcgdGhlIHZhbHVlIGluIGNhc2UgdGhlIGNhbGxlclxuICogcmVtb3ZlcyB0aGUgeWllbGRlZCBub2RlLlxuICpcbiAqIEBwYXJhbSBub2RlIFRoZSBub2RlIHdob3NlIGNoaWxkcmVuIHRvIGl0ZXJhdGVcbiAqIEByZXR1cm5zIEFuIGl0ZXJhdG9yIG9mIHRoZSBub2RlJ3MgY2hpbGRyZW5cbiAqL1xuZnVuY3Rpb24gJGxhc3RUb0ZpcnN0SXRlcmF0b3Iobm9kZSkge1xuICByZXR1cm4ge1xuICAgIFtTeW1ib2wuaXRlcmF0b3JdOiAoKSA9PiAkY2hpbGRJdGVyYXRvcihub2RlLmdldExhc3RDaGlsZCgpLCBjaGlsZCA9PiBjaGlsZC5nZXRQcmV2aW91c1NpYmxpbmcoKSlcbiAgfTtcbn1cbmZ1bmN0aW9uICRjaGlsZEl0ZXJhdG9yKGluaXRpYWxOb2RlLCBuZXh0Tm9kZSkge1xuICBsZXQgc3RhdGUgPSBpbml0aWFsTm9kZTtcbiAgY29uc3Qgc2VlbiA9IG5ldyBTZXQoKSA7XG4gIHJldHVybiB7XG4gICAgbmV4dCgpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JEb25lO1xuICAgICAgfVxuICAgICAgY29uc3QgcnZhbCA9IGl0ZXJhdG9yTm90RG9uZShzdGF0ZSk7XG4gICAgICBpZiAoc2VlbiAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBrZXkgPSBzdGF0ZS5nZXRLZXkoKTtcbiAgICAgICAgaWYgKCEhc2Vlbi5oYXMoa2V5KSkge1xuICAgICAgICAgIHRocm93IEVycm9yKGAkY2hpbGRJdGVyYXRvcjogQ3ljbGUgZGV0ZWN0ZWQsIG5vZGUgd2l0aCBrZXkgJHtTdHJpbmcoa2V5KX0gaGFzIGFscmVhZHkgYmVlbiB0cmF2ZXJzZWRgKTtcbiAgICAgICAgfVxuICAgICAgICBzZWVuLmFkZChrZXkpO1xuICAgICAgfVxuICAgICAgc3RhdGUgPSBuZXh0Tm9kZShzdGF0ZSk7XG4gICAgICByZXR1cm4gcnZhbDtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogSW5zZXJ0IGFsbCBjaGlsZHJlbiBiZWZvcmUgdGhpcyBub2RlLCBhbmQgdGhlbiByZW1vdmUgaXQuXG4gKlxuICogQHBhcmFtIG5vZGUgVGhlIEVsZW1lbnROb2RlIHRvIHVud3JhcCBhbmQgcmVtb3ZlXG4gKi9cbmZ1bmN0aW9uICR1bndyYXBOb2RlKG5vZGUpIHtcbiAgZm9yIChjb25zdCBjaGlsZCBvZiAkZmlyc3RUb0xhc3RJdGVyYXRvcihub2RlKSkge1xuICAgIG5vZGUuaW5zZXJ0QmVmb3JlKGNoaWxkKTtcbiAgfVxuICBub2RlLnJlbW92ZSgpO1xufVxuXG5leHBvcnQgeyAkZGVzY2VuZGFudHNNYXRjaGluZywgJGRmcywgJGRmc0l0ZXJhdG9yLCAkZmlsdGVyLCAkZmluZE1hdGNoaW5nUGFyZW50LCAkZmlyc3RUb0xhc3RJdGVyYXRvciwgJGdldERlcHRoLCAkZ2V0TmVhcmVzdEJsb2NrRWxlbWVudEFuY2VzdG9yT3JUaHJvdywgJGdldE5lYXJlc3ROb2RlT2ZUeXBlLCAkZ2V0TmV4dFJpZ2h0UHJlb3JkZXJOb2RlLCAkZ2V0TmV4dFNpYmxpbmdPclBhcmVudFNpYmxpbmcsICRpbnNlcnRGaXJzdCwgJGluc2VydE5vZGVUb05lYXJlc3RSb290LCAkaXNFZGl0b3JJc05lc3RlZEVkaXRvciwgJGxhc3RUb0ZpcnN0SXRlcmF0b3IsICRyZXN0b3JlRWRpdG9yU3RhdGUsICR1bndyYXBBbmRGaWx0ZXJEZXNjZW5kYW50cywgJHVud3JhcE5vZGUsICR3cmFwTm9kZUluRWxlbWVudCwgQ0FOX1VTRV9CRUZPUkVfSU5QVVQsIENBTl9VU0VfRE9NLCBJU19BTkRST0lELCBJU19BTkRST0lEX0NIUk9NRSwgSVNfQVBQTEUsIElTX0FQUExFX1dFQktJVCwgSVNfQ0hST01FLCBJU19GSVJFRk9YLCBJU19JT1MsIElTX1NBRkFSSSwgYWRkQ2xhc3NOYW1lc1RvRWxlbWVudCwgY2FsY3VsYXRlWm9vbUxldmVsLCBpc01pbWVUeXBlLCBtYXJrU2VsZWN0aW9uLCBtZWRpYUZpbGVSZWFkZXIsIG1lcmdlUmVnaXN0ZXIsIG9iamVjdEtsYXNzRXF1YWxzLCBtbGNQb3NpdGlvbk5vZGVPblJhbmdlIGFzIHBvc2l0aW9uTm9kZU9uUmFuZ2UsIHJlZ2lzdGVyTmVzdGVkRWxlbWVudFJlc29sdmVyLCByZW1vdmVDbGFzc05hbWVzRnJvbUVsZW1lbnQsIHNlbGVjdGlvbkFsd2F5c09uRGlzcGxheSB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/utils/LexicalUtils.dev.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lexical/Lexical.dev.mjs":
/*!**********************************************!*\
  !*** ./node_modules/lexical/Lexical.dev.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $addUpdateTag: () => (/* binding */ $addUpdateTag),\n/* harmony export */   $applyNodeReplacement: () => (/* binding */ $applyNodeReplacement),\n/* harmony export */   $cloneWithProperties: () => (/* binding */ $cloneWithProperties),\n/* harmony export */   $copyNode: () => (/* binding */ $copyNode),\n/* harmony export */   $createLineBreakNode: () => (/* binding */ $createLineBreakNode),\n/* harmony export */   $createNodeSelection: () => (/* binding */ $createNodeSelection),\n/* harmony export */   $createParagraphNode: () => (/* binding */ $createParagraphNode),\n/* harmony export */   $createPoint: () => (/* binding */ $createPoint),\n/* harmony export */   $createRangeSelection: () => (/* binding */ $createRangeSelection),\n/* harmony export */   $createRangeSelectionFromDom: () => (/* binding */ $createRangeSelectionFromDom),\n/* harmony export */   $createTabNode: () => (/* binding */ $createTabNode),\n/* harmony export */   $createTextNode: () => (/* binding */ $createTextNode),\n/* harmony export */   $getAdjacentNode: () => (/* binding */ $getAdjacentNode),\n/* harmony export */   $getCharacterOffsets: () => (/* binding */ $getCharacterOffsets),\n/* harmony export */   $getEditor: () => (/* binding */ $getEditor),\n/* harmony export */   $getNearestNodeFromDOMNode: () => (/* binding */ $getNearestNodeFromDOMNode),\n/* harmony export */   $getNearestRootOrShadowRoot: () => (/* binding */ $getNearestRootOrShadowRoot),\n/* harmony export */   $getNodeByKey: () => (/* binding */ $getNodeByKey),\n/* harmony export */   $getNodeByKeyOrThrow: () => (/* binding */ $getNodeByKeyOrThrow),\n/* harmony export */   $getPreviousSelection: () => (/* binding */ $getPreviousSelection),\n/* harmony export */   $getRoot: () => (/* binding */ $getRoot),\n/* harmony export */   $getSelection: () => (/* binding */ $getSelection),\n/* harmony export */   $getTextContent: () => (/* binding */ $getTextContent),\n/* harmony export */   $hasAncestor: () => (/* binding */ $hasAncestor),\n/* harmony export */   $hasUpdateTag: () => (/* binding */ $hasUpdateTag),\n/* harmony export */   $insertNodes: () => (/* binding */ $insertNodes),\n/* harmony export */   $isBlockElementNode: () => (/* binding */ $isBlockElementNode),\n/* harmony export */   $isDecoratorNode: () => (/* binding */ $isDecoratorNode),\n/* harmony export */   $isElementNode: () => (/* binding */ $isElementNode),\n/* harmony export */   $isInlineElementOrDecoratorNode: () => (/* binding */ $isInlineElementOrDecoratorNode),\n/* harmony export */   $isLeafNode: () => (/* binding */ $isLeafNode),\n/* harmony export */   $isLineBreakNode: () => (/* binding */ $isLineBreakNode),\n/* harmony export */   $isNodeSelection: () => (/* binding */ $isNodeSelection),\n/* harmony export */   $isParagraphNode: () => (/* binding */ $isParagraphNode),\n/* harmony export */   $isRangeSelection: () => (/* binding */ $isRangeSelection),\n/* harmony export */   $isRootNode: () => (/* binding */ $isRootNode),\n/* harmony export */   $isRootOrShadowRoot: () => (/* binding */ $isRootOrShadowRoot),\n/* harmony export */   $isTabNode: () => (/* binding */ $isTabNode),\n/* harmony export */   $isTextNode: () => (/* binding */ $isTextNode),\n/* harmony export */   $isTokenOrSegmented: () => (/* binding */ $isTokenOrSegmented),\n/* harmony export */   $nodesOfType: () => (/* binding */ $nodesOfType),\n/* harmony export */   $normalizeSelection__EXPERIMENTAL: () => (/* binding */ $normalizeSelection),\n/* harmony export */   $onUpdate: () => (/* binding */ $onUpdate),\n/* harmony export */   $parseSerializedNode: () => (/* binding */ $parseSerializedNode),\n/* harmony export */   $selectAll: () => (/* binding */ $selectAll),\n/* harmony export */   $setCompositionKey: () => (/* binding */ $setCompositionKey),\n/* harmony export */   $setSelection: () => (/* binding */ $setSelection),\n/* harmony export */   $splitNode: () => (/* binding */ $splitNode),\n/* harmony export */   ArtificialNode__DO_NOT_USE: () => (/* binding */ ArtificialNode__DO_NOT_USE),\n/* harmony export */   BLUR_COMMAND: () => (/* binding */ BLUR_COMMAND),\n/* harmony export */   CAN_REDO_COMMAND: () => (/* binding */ CAN_REDO_COMMAND),\n/* harmony export */   CAN_UNDO_COMMAND: () => (/* binding */ CAN_UNDO_COMMAND),\n/* harmony export */   CLEAR_EDITOR_COMMAND: () => (/* binding */ CLEAR_EDITOR_COMMAND),\n/* harmony export */   CLEAR_HISTORY_COMMAND: () => (/* binding */ CLEAR_HISTORY_COMMAND),\n/* harmony export */   CLICK_COMMAND: () => (/* binding */ CLICK_COMMAND),\n/* harmony export */   COMMAND_PRIORITY_CRITICAL: () => (/* binding */ COMMAND_PRIORITY_CRITICAL),\n/* harmony export */   COMMAND_PRIORITY_EDITOR: () => (/* binding */ COMMAND_PRIORITY_EDITOR),\n/* harmony export */   COMMAND_PRIORITY_HIGH: () => (/* binding */ COMMAND_PRIORITY_HIGH),\n/* harmony export */   COMMAND_PRIORITY_LOW: () => (/* binding */ COMMAND_PRIORITY_LOW),\n/* harmony export */   COMMAND_PRIORITY_NORMAL: () => (/* binding */ COMMAND_PRIORITY_NORMAL),\n/* harmony export */   CONTROLLED_TEXT_INSERTION_COMMAND: () => (/* binding */ CONTROLLED_TEXT_INSERTION_COMMAND),\n/* harmony export */   COPY_COMMAND: () => (/* binding */ COPY_COMMAND),\n/* harmony export */   CUT_COMMAND: () => (/* binding */ CUT_COMMAND),\n/* harmony export */   DELETE_CHARACTER_COMMAND: () => (/* binding */ DELETE_CHARACTER_COMMAND),\n/* harmony export */   DELETE_LINE_COMMAND: () => (/* binding */ DELETE_LINE_COMMAND),\n/* harmony export */   DELETE_WORD_COMMAND: () => (/* binding */ DELETE_WORD_COMMAND),\n/* harmony export */   DRAGEND_COMMAND: () => (/* binding */ DRAGEND_COMMAND),\n/* harmony export */   DRAGOVER_COMMAND: () => (/* binding */ DRAGOVER_COMMAND),\n/* harmony export */   DRAGSTART_COMMAND: () => (/* binding */ DRAGSTART_COMMAND),\n/* harmony export */   DROP_COMMAND: () => (/* binding */ DROP_COMMAND),\n/* harmony export */   DecoratorNode: () => (/* binding */ DecoratorNode),\n/* harmony export */   ElementNode: () => (/* binding */ ElementNode),\n/* harmony export */   FOCUS_COMMAND: () => (/* binding */ FOCUS_COMMAND),\n/* harmony export */   FORMAT_ELEMENT_COMMAND: () => (/* binding */ FORMAT_ELEMENT_COMMAND),\n/* harmony export */   FORMAT_TEXT_COMMAND: () => (/* binding */ FORMAT_TEXT_COMMAND),\n/* harmony export */   INDENT_CONTENT_COMMAND: () => (/* binding */ INDENT_CONTENT_COMMAND),\n/* harmony export */   INSERT_LINE_BREAK_COMMAND: () => (/* binding */ INSERT_LINE_BREAK_COMMAND),\n/* harmony export */   INSERT_PARAGRAPH_COMMAND: () => (/* binding */ INSERT_PARAGRAPH_COMMAND),\n/* harmony export */   INSERT_TAB_COMMAND: () => (/* binding */ INSERT_TAB_COMMAND),\n/* harmony export */   IS_ALL_FORMATTING: () => (/* binding */ IS_ALL_FORMATTING),\n/* harmony export */   IS_BOLD: () => (/* binding */ IS_BOLD),\n/* harmony export */   IS_CODE: () => (/* binding */ IS_CODE),\n/* harmony export */   IS_HIGHLIGHT: () => (/* binding */ IS_HIGHLIGHT),\n/* harmony export */   IS_ITALIC: () => (/* binding */ IS_ITALIC),\n/* harmony export */   IS_STRIKETHROUGH: () => (/* binding */ IS_STRIKETHROUGH),\n/* harmony export */   IS_SUBSCRIPT: () => (/* binding */ IS_SUBSCRIPT),\n/* harmony export */   IS_SUPERSCRIPT: () => (/* binding */ IS_SUPERSCRIPT),\n/* harmony export */   IS_UNDERLINE: () => (/* binding */ IS_UNDERLINE),\n/* harmony export */   KEY_ARROW_DOWN_COMMAND: () => (/* binding */ KEY_ARROW_DOWN_COMMAND),\n/* harmony export */   KEY_ARROW_LEFT_COMMAND: () => (/* binding */ KEY_ARROW_LEFT_COMMAND),\n/* harmony export */   KEY_ARROW_RIGHT_COMMAND: () => (/* binding */ KEY_ARROW_RIGHT_COMMAND),\n/* harmony export */   KEY_ARROW_UP_COMMAND: () => (/* binding */ KEY_ARROW_UP_COMMAND),\n/* harmony export */   KEY_BACKSPACE_COMMAND: () => (/* binding */ KEY_BACKSPACE_COMMAND),\n/* harmony export */   KEY_DELETE_COMMAND: () => (/* binding */ KEY_DELETE_COMMAND),\n/* harmony export */   KEY_DOWN_COMMAND: () => (/* binding */ KEY_DOWN_COMMAND),\n/* harmony export */   KEY_ENTER_COMMAND: () => (/* binding */ KEY_ENTER_COMMAND),\n/* harmony export */   KEY_ESCAPE_COMMAND: () => (/* binding */ KEY_ESCAPE_COMMAND),\n/* harmony export */   KEY_MODIFIER_COMMAND: () => (/* binding */ KEY_MODIFIER_COMMAND),\n/* harmony export */   KEY_SPACE_COMMAND: () => (/* binding */ KEY_SPACE_COMMAND),\n/* harmony export */   KEY_TAB_COMMAND: () => (/* binding */ KEY_TAB_COMMAND),\n/* harmony export */   LineBreakNode: () => (/* binding */ LineBreakNode),\n/* harmony export */   MOVE_TO_END: () => (/* binding */ MOVE_TO_END),\n/* harmony export */   MOVE_TO_START: () => (/* binding */ MOVE_TO_START),\n/* harmony export */   OUTDENT_CONTENT_COMMAND: () => (/* binding */ OUTDENT_CONTENT_COMMAND),\n/* harmony export */   PASTE_COMMAND: () => (/* binding */ PASTE_COMMAND),\n/* harmony export */   ParagraphNode: () => (/* binding */ ParagraphNode),\n/* harmony export */   REDO_COMMAND: () => (/* binding */ REDO_COMMAND),\n/* harmony export */   REMOVE_TEXT_COMMAND: () => (/* binding */ REMOVE_TEXT_COMMAND),\n/* harmony export */   RootNode: () => (/* binding */ RootNode),\n/* harmony export */   SELECTION_CHANGE_COMMAND: () => (/* binding */ SELECTION_CHANGE_COMMAND),\n/* harmony export */   SELECTION_INSERT_CLIPBOARD_NODES_COMMAND: () => (/* binding */ SELECTION_INSERT_CLIPBOARD_NODES_COMMAND),\n/* harmony export */   SELECT_ALL_COMMAND: () => (/* binding */ SELECT_ALL_COMMAND),\n/* harmony export */   TEXT_TYPE_TO_FORMAT: () => (/* binding */ TEXT_TYPE_TO_FORMAT),\n/* harmony export */   TabNode: () => (/* binding */ TabNode),\n/* harmony export */   TextNode: () => (/* binding */ TextNode),\n/* harmony export */   UNDO_COMMAND: () => (/* binding */ UNDO_COMMAND),\n/* harmony export */   createCommand: () => (/* binding */ createCommand),\n/* harmony export */   createEditor: () => (/* binding */ createEditor),\n/* harmony export */   getDOMOwnerDocument: () => (/* binding */ getDOMOwnerDocument),\n/* harmony export */   getDOMSelection: () => (/* binding */ getDOMSelection),\n/* harmony export */   getDOMSelectionFromTarget: () => (/* binding */ getDOMSelectionFromTarget),\n/* harmony export */   getDOMTextNode: () => (/* binding */ getDOMTextNode),\n/* harmony export */   getEditorPropertyFromDOMNode: () => (/* binding */ getEditorPropertyFromDOMNode),\n/* harmony export */   getNearestEditorFromDOMNode: () => (/* binding */ getNearestEditorFromDOMNode),\n/* harmony export */   isBlockDomNode: () => (/* binding */ isBlockDomNode),\n/* harmony export */   isCurrentlyReadOnlyMode: () => (/* binding */ isCurrentlyReadOnlyMode),\n/* harmony export */   isDOMDocumentNode: () => (/* binding */ isDOMDocumentNode),\n/* harmony export */   isDOMNode: () => (/* binding */ isDOMNode),\n/* harmony export */   isDOMTextNode: () => (/* binding */ isDOMTextNode),\n/* harmony export */   isDOMUnmanaged: () => (/* binding */ isDOMUnmanaged),\n/* harmony export */   isDocumentFragment: () => (/* binding */ isDocumentFragment),\n/* harmony export */   isHTMLAnchorElement: () => (/* binding */ isHTMLAnchorElement),\n/* harmony export */   isHTMLElement: () => (/* binding */ isHTMLElement),\n/* harmony export */   isInlineDomNode: () => (/* binding */ isInlineDomNode),\n/* harmony export */   isLexicalEditor: () => (/* binding */ isLexicalEditor),\n/* harmony export */   isSelectionCapturedInDecoratorInput: () => (/* binding */ isSelectionCapturedInDecoratorInput),\n/* harmony export */   isSelectionWithinEditor: () => (/* binding */ isSelectionWithinEditor),\n/* harmony export */   resetRandomKey: () => (/* binding */ resetRandomKey),\n/* harmony export */   setDOMUnmanaged: () => (/* binding */ setDOMUnmanaged),\n/* harmony export */   setNodeIndentFromDOM: () => (/* binding */ setNodeIndentFromDOM)\n/* harmony export */ });\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction createCommand(type) {\n  return {\n    type\n  } ;\n}\nconst SELECTION_CHANGE_COMMAND = createCommand('SELECTION_CHANGE_COMMAND');\nconst SELECTION_INSERT_CLIPBOARD_NODES_COMMAND = createCommand('SELECTION_INSERT_CLIPBOARD_NODES_COMMAND');\nconst CLICK_COMMAND = createCommand('CLICK_COMMAND');\nconst DELETE_CHARACTER_COMMAND = createCommand('DELETE_CHARACTER_COMMAND');\nconst INSERT_LINE_BREAK_COMMAND = createCommand('INSERT_LINE_BREAK_COMMAND');\nconst INSERT_PARAGRAPH_COMMAND = createCommand('INSERT_PARAGRAPH_COMMAND');\nconst CONTROLLED_TEXT_INSERTION_COMMAND = createCommand('CONTROLLED_TEXT_INSERTION_COMMAND');\nconst PASTE_COMMAND = createCommand('PASTE_COMMAND');\nconst REMOVE_TEXT_COMMAND = createCommand('REMOVE_TEXT_COMMAND');\nconst DELETE_WORD_COMMAND = createCommand('DELETE_WORD_COMMAND');\nconst DELETE_LINE_COMMAND = createCommand('DELETE_LINE_COMMAND');\nconst FORMAT_TEXT_COMMAND = createCommand('FORMAT_TEXT_COMMAND');\nconst UNDO_COMMAND = createCommand('UNDO_COMMAND');\nconst REDO_COMMAND = createCommand('REDO_COMMAND');\nconst KEY_DOWN_COMMAND = createCommand('KEYDOWN_COMMAND');\nconst KEY_ARROW_RIGHT_COMMAND = createCommand('KEY_ARROW_RIGHT_COMMAND');\nconst MOVE_TO_END = createCommand('MOVE_TO_END');\nconst KEY_ARROW_LEFT_COMMAND = createCommand('KEY_ARROW_LEFT_COMMAND');\nconst MOVE_TO_START = createCommand('MOVE_TO_START');\nconst KEY_ARROW_UP_COMMAND = createCommand('KEY_ARROW_UP_COMMAND');\nconst KEY_ARROW_DOWN_COMMAND = createCommand('KEY_ARROW_DOWN_COMMAND');\nconst KEY_ENTER_COMMAND = createCommand('KEY_ENTER_COMMAND');\nconst KEY_SPACE_COMMAND = createCommand('KEY_SPACE_COMMAND');\nconst KEY_BACKSPACE_COMMAND = createCommand('KEY_BACKSPACE_COMMAND');\nconst KEY_ESCAPE_COMMAND = createCommand('KEY_ESCAPE_COMMAND');\nconst KEY_DELETE_COMMAND = createCommand('KEY_DELETE_COMMAND');\nconst KEY_TAB_COMMAND = createCommand('KEY_TAB_COMMAND');\nconst INSERT_TAB_COMMAND = createCommand('INSERT_TAB_COMMAND');\nconst INDENT_CONTENT_COMMAND = createCommand('INDENT_CONTENT_COMMAND');\nconst OUTDENT_CONTENT_COMMAND = createCommand('OUTDENT_CONTENT_COMMAND');\nconst DROP_COMMAND = createCommand('DROP_COMMAND');\nconst FORMAT_ELEMENT_COMMAND = createCommand('FORMAT_ELEMENT_COMMAND');\nconst DRAGSTART_COMMAND = createCommand('DRAGSTART_COMMAND');\nconst DRAGOVER_COMMAND = createCommand('DRAGOVER_COMMAND');\nconst DRAGEND_COMMAND = createCommand('DRAGEND_COMMAND');\nconst COPY_COMMAND = createCommand('COPY_COMMAND');\nconst CUT_COMMAND = createCommand('CUT_COMMAND');\nconst SELECT_ALL_COMMAND = createCommand('SELECT_ALL_COMMAND');\nconst CLEAR_EDITOR_COMMAND = createCommand('CLEAR_EDITOR_COMMAND');\nconst CLEAR_HISTORY_COMMAND = createCommand('CLEAR_HISTORY_COMMAND');\nconst CAN_REDO_COMMAND = createCommand('CAN_REDO_COMMAND');\nconst CAN_UNDO_COMMAND = createCommand('CAN_UNDO_COMMAND');\nconst FOCUS_COMMAND = createCommand('FOCUS_COMMAND');\nconst BLUR_COMMAND = createCommand('BLUR_COMMAND');\nconst KEY_MODIFIER_COMMAND = createCommand('KEY_MODIFIER_COMMAND');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nconst IS_APPLE = CAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nconst IS_FIREFOX = CAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nconst CAN_USE_BEFORE_INPUT = CAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\nconst IS_ANDROID = CAN_USE_DOM && /Android/.test(navigator.userAgent);\n\n// Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\nconst IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent);\n// export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\nconst IS_ANDROID_CHROME = CAN_USE_DOM && IS_ANDROID && IS_CHROME;\nconst IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// DOM\nconst DOM_ELEMENT_TYPE = 1;\nconst DOM_TEXT_TYPE = 3;\nconst DOM_DOCUMENT_TYPE = 9;\nconst DOM_DOCUMENT_FRAGMENT_TYPE = 11;\n\n// Reconciling\nconst NO_DIRTY_NODES = 0;\nconst HAS_DIRTY_NODES = 1;\nconst FULL_RECONCILE = 2;\n\n// Text node modes\nconst IS_NORMAL = 0;\nconst IS_TOKEN = 1;\nconst IS_SEGMENTED = 2;\n// IS_INERT = 3\n\n// Text node formatting\nconst IS_BOLD = 1;\nconst IS_ITALIC = 1 << 1;\nconst IS_STRIKETHROUGH = 1 << 2;\nconst IS_UNDERLINE = 1 << 3;\nconst IS_CODE = 1 << 4;\nconst IS_SUBSCRIPT = 1 << 5;\nconst IS_SUPERSCRIPT = 1 << 6;\nconst IS_HIGHLIGHT = 1 << 7;\nconst IS_LOWERCASE = 1 << 8;\nconst IS_UPPERCASE = 1 << 9;\nconst IS_CAPITALIZE = 1 << 10;\nconst IS_ALL_FORMATTING = IS_BOLD | IS_ITALIC | IS_STRIKETHROUGH | IS_UNDERLINE | IS_CODE | IS_SUBSCRIPT | IS_SUPERSCRIPT | IS_HIGHLIGHT | IS_LOWERCASE | IS_UPPERCASE | IS_CAPITALIZE;\n\n// Text node details\nconst IS_DIRECTIONLESS = 1;\nconst IS_UNMERGEABLE = 1 << 1;\n\n// Element node formatting\nconst IS_ALIGN_LEFT = 1;\nconst IS_ALIGN_CENTER = 2;\nconst IS_ALIGN_RIGHT = 3;\nconst IS_ALIGN_JUSTIFY = 4;\nconst IS_ALIGN_START = 5;\nconst IS_ALIGN_END = 6;\n\n// Reconciliation\nconst NON_BREAKING_SPACE = '\\u00A0';\nconst ZERO_WIDTH_SPACE = '\\u200b';\n\n// For iOS/Safari we use a non breaking space, otherwise the cursor appears\n// overlapping the composed text.\nconst COMPOSITION_SUFFIX = IS_SAFARI || IS_IOS || IS_APPLE_WEBKIT ? NON_BREAKING_SPACE : ZERO_WIDTH_SPACE;\nconst DOUBLE_LINE_BREAK = '\\n\\n';\n\n// For FF, we need to use a non-breaking space, or it gets composition\n// in a stuck state.\nconst COMPOSITION_START_CHAR = IS_FIREFOX ? NON_BREAKING_SPACE : COMPOSITION_SUFFIX;\nconst RTL = '\\u0591-\\u07FF\\uFB1D-\\uFDFD\\uFE70-\\uFEFC';\nconst LTR = 'A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6' + '\\u00F8-\\u02B8\\u0300-\\u0590\\u0800-\\u1FFF\\u200E\\u2C00-\\uFB1C' + '\\uFE00-\\uFE6F\\uFEFD-\\uFFFF';\n\n// eslint-disable-next-line no-misleading-character-class\nconst RTL_REGEX = new RegExp('^[^' + LTR + ']*[' + RTL + ']');\n// eslint-disable-next-line no-misleading-character-class\nconst LTR_REGEX = new RegExp('^[^' + RTL + ']*[' + LTR + ']');\nconst TEXT_TYPE_TO_FORMAT = {\n  bold: IS_BOLD,\n  capitalize: IS_CAPITALIZE,\n  code: IS_CODE,\n  highlight: IS_HIGHLIGHT,\n  italic: IS_ITALIC,\n  lowercase: IS_LOWERCASE,\n  strikethrough: IS_STRIKETHROUGH,\n  subscript: IS_SUBSCRIPT,\n  superscript: IS_SUPERSCRIPT,\n  underline: IS_UNDERLINE,\n  uppercase: IS_UPPERCASE\n};\nconst DETAIL_TYPE_TO_DETAIL = {\n  directionless: IS_DIRECTIONLESS,\n  unmergeable: IS_UNMERGEABLE\n};\nconst ELEMENT_TYPE_TO_FORMAT = {\n  center: IS_ALIGN_CENTER,\n  end: IS_ALIGN_END,\n  justify: IS_ALIGN_JUSTIFY,\n  left: IS_ALIGN_LEFT,\n  right: IS_ALIGN_RIGHT,\n  start: IS_ALIGN_START\n};\nconst ELEMENT_FORMAT_TO_TYPE = {\n  [IS_ALIGN_CENTER]: 'center',\n  [IS_ALIGN_END]: 'end',\n  [IS_ALIGN_JUSTIFY]: 'justify',\n  [IS_ALIGN_LEFT]: 'left',\n  [IS_ALIGN_RIGHT]: 'right',\n  [IS_ALIGN_START]: 'start'\n};\nconst TEXT_MODE_TO_TYPE = {\n  normal: IS_NORMAL,\n  segmented: IS_SEGMENTED,\n  token: IS_TOKEN\n};\nconst TEXT_TYPE_TO_MODE = {\n  [IS_NORMAL]: 'normal',\n  [IS_SEGMENTED]: 'segmented',\n  [IS_TOKEN]: 'token'\n};\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction normalizeClassNames(...classNames) {\n  const rval = [];\n  for (const className of classNames) {\n    if (className && typeof className === 'string') {\n      for (const [s] of className.matchAll(/\\S+/g)) {\n        rval.push(s);\n      }\n    }\n  }\n  return rval;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// The time between a text entry event and the mutation observer firing.\nconst TEXT_MUTATION_VARIANCE = 100;\nlet isProcessingMutations = false;\nlet lastTextEntryTimeStamp = 0;\nfunction getIsProcessingMutations() {\n  return isProcessingMutations;\n}\nfunction updateTimeStamp(event) {\n  lastTextEntryTimeStamp = event.timeStamp;\n}\nfunction initTextEntryListener(editor) {\n  if (lastTextEntryTimeStamp === 0) {\n    getWindow(editor).addEventListener('textInput', updateTimeStamp, true);\n  }\n}\nfunction isManagedLineBreak(dom, target, editor) {\n  const isBR = dom.nodeName === 'BR';\n  const lexicalLineBreak = target.__lexicalLineBreak;\n  return lexicalLineBreak && (dom === lexicalLineBreak || isBR && dom.previousSibling === lexicalLineBreak) || isBR && getNodeKeyFromDOMNode(dom, editor) !== undefined;\n}\nfunction getLastSelection(editor) {\n  return editor.getEditorState().read(() => {\n    const selection = $getSelection();\n    return selection !== null ? selection.clone() : null;\n  });\n}\nfunction $handleTextMutation(target, node, editor) {\n  const domSelection = getDOMSelection(editor._window);\n  let anchorOffset = null;\n  let focusOffset = null;\n  if (domSelection !== null && domSelection.anchorNode === target) {\n    anchorOffset = domSelection.anchorOffset;\n    focusOffset = domSelection.focusOffset;\n  }\n  const text = target.nodeValue;\n  if (text !== null) {\n    $updateTextNodeFromDOMContent(node, text, anchorOffset, focusOffset, false);\n  }\n}\nfunction shouldUpdateTextNodeFromMutation(selection, targetDOM, targetNode) {\n  if ($isRangeSelection(selection)) {\n    const anchorNode = selection.anchor.getNode();\n    if (anchorNode.is(targetNode) && selection.format !== anchorNode.getFormat()) {\n      return false;\n    }\n  }\n  return isDOMTextNode(targetDOM) && targetNode.isAttached();\n}\nfunction $getNearestManagedNodePairFromDOMNode(startingDOM, editor, editorState, rootElement) {\n  for (let dom = startingDOM; dom && !isDOMUnmanaged(dom); dom = getParentElement(dom)) {\n    const key = getNodeKeyFromDOMNode(dom, editor);\n    if (key !== undefined) {\n      const node = $getNodeByKey(key, editorState);\n      if (node) {\n        // All decorator nodes are unmanaged\n        return $isDecoratorNode(node) || !isHTMLElement(dom) ? undefined : [dom, node];\n      }\n    } else if (dom === rootElement) {\n      return [rootElement, internalGetRoot(editorState)];\n    }\n  }\n}\nfunction $flushMutations$1(editor, mutations, observer) {\n  isProcessingMutations = true;\n  const shouldFlushTextMutations = performance.now() - lastTextEntryTimeStamp > TEXT_MUTATION_VARIANCE;\n  try {\n    updateEditor(editor, () => {\n      const selection = $getSelection() || getLastSelection(editor);\n      const badDOMTargets = new Map();\n      const rootElement = editor.getRootElement();\n      // We use the current editor state, as that reflects what is\n      // actually \"on screen\".\n      const currentEditorState = editor._editorState;\n      const blockCursorElement = editor._blockCursorElement;\n      let shouldRevertSelection = false;\n      let possibleTextForFirefoxPaste = '';\n      for (let i = 0; i < mutations.length; i++) {\n        const mutation = mutations[i];\n        const type = mutation.type;\n        const targetDOM = mutation.target;\n        const pair = $getNearestManagedNodePairFromDOMNode(targetDOM, editor, currentEditorState, rootElement);\n        if (!pair) {\n          continue;\n        }\n        const [nodeDOM, targetNode] = pair;\n        if (type === 'characterData') {\n          // Text mutations are deferred and passed to mutation listeners to be\n          // processed outside of the Lexical engine.\n          if (shouldFlushTextMutations && $isTextNode(targetNode) && isDOMTextNode(targetDOM) && shouldUpdateTextNodeFromMutation(selection, targetDOM, targetNode)) {\n            $handleTextMutation(targetDOM, targetNode, editor);\n          }\n        } else if (type === 'childList') {\n          shouldRevertSelection = true;\n          // We attempt to \"undo\" any changes that have occurred outside\n          // of Lexical. We want Lexical's editor state to be source of truth.\n          // To the user, these will look like no-ops.\n          const addedDOMs = mutation.addedNodes;\n          for (let s = 0; s < addedDOMs.length; s++) {\n            const addedDOM = addedDOMs[s];\n            const node = $getNodeFromDOMNode(addedDOM);\n            const parentDOM = addedDOM.parentNode;\n            if (parentDOM != null && addedDOM !== blockCursorElement && node === null && !isManagedLineBreak(addedDOM, parentDOM, editor)) {\n              if (IS_FIREFOX) {\n                const possibleText = (isHTMLElement(addedDOM) ? addedDOM.innerText : null) || addedDOM.nodeValue;\n                if (possibleText) {\n                  possibleTextForFirefoxPaste += possibleText;\n                }\n              }\n              parentDOM.removeChild(addedDOM);\n            }\n          }\n          const removedDOMs = mutation.removedNodes;\n          const removedDOMsLength = removedDOMs.length;\n          if (removedDOMsLength > 0) {\n            let unremovedBRs = 0;\n            for (let s = 0; s < removedDOMsLength; s++) {\n              const removedDOM = removedDOMs[s];\n              if (isManagedLineBreak(removedDOM, targetDOM, editor) || blockCursorElement === removedDOM) {\n                targetDOM.appendChild(removedDOM);\n                unremovedBRs++;\n              }\n            }\n            if (removedDOMsLength !== unremovedBRs) {\n              badDOMTargets.set(nodeDOM, targetNode);\n            }\n          }\n        }\n      }\n\n      // Now we process each of the unique target nodes, attempting\n      // to restore their contents back to the source of truth, which\n      // is Lexical's \"current\" editor state. This is basically like\n      // an internal revert on the DOM.\n      if (badDOMTargets.size > 0) {\n        for (const [nodeDOM, targetNode] of badDOMTargets) {\n          targetNode.reconcileObservedMutation(nodeDOM, editor);\n        }\n      }\n\n      // Capture all the mutations made during this function. This\n      // also prevents us having to process them on the next cycle\n      // of onMutation, as these mutations were made by us.\n      const records = observer.takeRecords();\n\n      // Check for any random auto-added <br> elements, and remove them.\n      // These get added by the browser when we undo the above mutations\n      // and this can lead to a broken UI.\n      if (records.length > 0) {\n        for (let i = 0; i < records.length; i++) {\n          const record = records[i];\n          const addedNodes = record.addedNodes;\n          const target = record.target;\n          for (let s = 0; s < addedNodes.length; s++) {\n            const addedDOM = addedNodes[s];\n            const parentDOM = addedDOM.parentNode;\n            if (parentDOM != null && addedDOM.nodeName === 'BR' && !isManagedLineBreak(addedDOM, target, editor)) {\n              parentDOM.removeChild(addedDOM);\n            }\n          }\n        }\n\n        // Clear any of those removal mutations\n        observer.takeRecords();\n      }\n      if (selection !== null) {\n        if (shouldRevertSelection) {\n          selection.dirty = true;\n          $setSelection(selection);\n        }\n        if (IS_FIREFOX && isFirefoxClipboardEvents(editor)) {\n          selection.insertRawText(possibleTextForFirefoxPaste);\n        }\n      }\n    });\n  } finally {\n    isProcessingMutations = false;\n  }\n}\nfunction $flushRootMutations(editor) {\n  const observer = editor._observer;\n  if (observer !== null) {\n    const mutations = observer.takeRecords();\n    $flushMutations$1(editor, mutations, observer);\n  }\n}\nfunction initMutationObserver(editor) {\n  initTextEntryListener(editor);\n  editor._observer = new MutationObserver((mutations, observer) => {\n    $flushMutations$1(editor, mutations, observer);\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $canSimpleTextNodesBeMerged(node1, node2) {\n  const node1Mode = node1.__mode;\n  const node1Format = node1.__format;\n  const node1Style = node1.__style;\n  const node2Mode = node2.__mode;\n  const node2Format = node2.__format;\n  const node2Style = node2.__style;\n  return (node1Mode === null || node1Mode === node2Mode) && (node1Format === null || node1Format === node2Format) && (node1Style === null || node1Style === node2Style);\n}\nfunction $mergeTextNodes(node1, node2) {\n  const writableNode1 = node1.mergeWithSibling(node2);\n  const normalizedNodes = getActiveEditor()._normalizedNodes;\n  normalizedNodes.add(node1.__key);\n  normalizedNodes.add(node2.__key);\n  return writableNode1;\n}\nfunction $normalizeTextNode(textNode) {\n  let node = textNode;\n  if (node.__text === '' && node.isSimpleText() && !node.isUnmergeable()) {\n    node.remove();\n    return;\n  }\n\n  // Backward\n  let previousNode;\n  while ((previousNode = node.getPreviousSibling()) !== null && $isTextNode(previousNode) && previousNode.isSimpleText() && !previousNode.isUnmergeable()) {\n    if (previousNode.__text === '') {\n      previousNode.remove();\n    } else if ($canSimpleTextNodesBeMerged(previousNode, node)) {\n      node = $mergeTextNodes(previousNode, node);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Forward\n  let nextNode;\n  while ((nextNode = node.getNextSibling()) !== null && $isTextNode(nextNode) && nextNode.isSimpleText() && !nextNode.isUnmergeable()) {\n    if (nextNode.__text === '') {\n      nextNode.remove();\n    } else if ($canSimpleTextNodesBeMerged(node, nextNode)) {\n      node = $mergeTextNodes(node, nextNode);\n      break;\n    } else {\n      break;\n    }\n  }\n}\nfunction $normalizeSelection(selection) {\n  $normalizePoint(selection.anchor);\n  $normalizePoint(selection.focus);\n  return selection;\n}\nfunction $normalizePoint(point) {\n  while (point.type === 'element') {\n    const node = point.getNode();\n    const offset = point.offset;\n    let nextNode;\n    let nextOffsetAtEnd;\n    if (offset === node.getChildrenSize()) {\n      nextNode = node.getChildAtIndex(offset - 1);\n      nextOffsetAtEnd = true;\n    } else {\n      nextNode = node.getChildAtIndex(offset);\n      nextOffsetAtEnd = false;\n    }\n    if ($isTextNode(nextNode)) {\n      point.set(nextNode.__key, nextOffsetAtEnd ? nextNode.getTextContentSize() : 0, 'text');\n      break;\n    } else if (!$isElementNode(nextNode)) {\n      break;\n    }\n    point.set(nextNode.__key, nextOffsetAtEnd ? nextNode.getChildrenSize() : 0, 'element');\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nlet keyCounter = 1;\nfunction resetRandomKey() {\n  keyCounter = 1;\n}\nfunction generateRandomKey() {\n  return '' + keyCounter++;\n}\nfunction getRegisteredNodeOrThrow(editor, nodeType) {\n  const registeredNode = editor._nodes.get(nodeType);\n  if (registeredNode === undefined) {\n    {\n      throw Error(`registeredNode: Type ${nodeType} not found`);\n    }\n  }\n  return registeredNode;\n}\nconst scheduleMicroTask = typeof queueMicrotask === 'function' ? queueMicrotask : fn => {\n  // No window prefix intended (#1400)\n  Promise.resolve().then(fn);\n};\nfunction $isSelectionCapturedInDecorator(node) {\n  return $isDecoratorNode($getNearestNodeFromDOMNode(node));\n}\nfunction isSelectionCapturedInDecoratorInput(anchorDOM) {\n  const activeElement = document.activeElement;\n  if (!isHTMLElement(activeElement)) {\n    return false;\n  }\n  const nodeName = activeElement.nodeName;\n  return $isDecoratorNode($getNearestNodeFromDOMNode(anchorDOM)) && (nodeName === 'INPUT' || nodeName === 'TEXTAREA' || activeElement.contentEditable === 'true' && getEditorPropertyFromDOMNode(activeElement) == null);\n}\nfunction isSelectionWithinEditor(editor, anchorDOM, focusDOM) {\n  const rootElement = editor.getRootElement();\n  try {\n    return rootElement !== null && rootElement.contains(anchorDOM) && rootElement.contains(focusDOM) &&\n    // Ignore if selection is within nested editor\n    anchorDOM !== null && !isSelectionCapturedInDecoratorInput(anchorDOM) && getNearestEditorFromDOMNode(anchorDOM) === editor;\n  } catch (error) {\n    return false;\n  }\n}\n\n/**\n * @returns true if the given argument is a LexicalEditor instance from this build of Lexical\n */\nfunction isLexicalEditor(editor) {\n  // Check instanceof to prevent issues with multiple embedded Lexical installations\n  return editor instanceof LexicalEditor;\n}\nfunction getNearestEditorFromDOMNode(node) {\n  let currentNode = node;\n  while (currentNode != null) {\n    const editor = getEditorPropertyFromDOMNode(currentNode);\n    if (isLexicalEditor(editor)) {\n      return editor;\n    }\n    currentNode = getParentElement(currentNode);\n  }\n  return null;\n}\n\n/** @internal */\nfunction getEditorPropertyFromDOMNode(node) {\n  // @ts-expect-error: internal field\n  return node ? node.__lexicalEditor : null;\n}\nfunction getTextDirection(text) {\n  if (RTL_REGEX.test(text)) {\n    return 'rtl';\n  }\n  if (LTR_REGEX.test(text)) {\n    return 'ltr';\n  }\n  return null;\n}\nfunction $isTokenOrSegmented(node) {\n  return node.isToken() || node.isSegmented();\n}\n\n/**\n * @param node - The element being tested\n * @returns Returns true if node is an DOM Text node, false otherwise.\n */\nfunction isDOMTextNode(node) {\n  return isDOMNode(node) && node.nodeType === DOM_TEXT_TYPE;\n}\n\n/**\n * @param node - The element being tested\n * @returns Returns true if node is an DOM Document node, false otherwise.\n */\nfunction isDOMDocumentNode(node) {\n  return isDOMNode(node) && node.nodeType === DOM_DOCUMENT_TYPE;\n}\nfunction getDOMTextNode(element) {\n  let node = element;\n  while (node != null) {\n    if (isDOMTextNode(node)) {\n      return node;\n    }\n    node = node.firstChild;\n  }\n  return null;\n}\nfunction toggleTextFormatType(format, type, alignWithFormat) {\n  const activeFormat = TEXT_TYPE_TO_FORMAT[type];\n  if (alignWithFormat !== null && (format & activeFormat) === (alignWithFormat & activeFormat)) {\n    return format;\n  }\n  let newFormat = format ^ activeFormat;\n  if (type === 'subscript') {\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.superscript;\n  } else if (type === 'superscript') {\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.subscript;\n  } else if (type === 'lowercase') {\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.uppercase;\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.capitalize;\n  } else if (type === 'uppercase') {\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.lowercase;\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.capitalize;\n  } else if (type === 'capitalize') {\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.lowercase;\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.uppercase;\n  }\n  return newFormat;\n}\nfunction $isLeafNode(node) {\n  return $isTextNode(node) || $isLineBreakNode(node) || $isDecoratorNode(node);\n}\nfunction $setNodeKey(node, existingKey) {\n  if (existingKey != null) {\n    {\n      errorOnNodeKeyConstructorMismatch(node, existingKey);\n    }\n    node.__key = existingKey;\n    return;\n  }\n  errorOnReadOnly();\n  errorOnInfiniteTransforms();\n  const editor = getActiveEditor();\n  const editorState = getActiveEditorState();\n  const key = generateRandomKey();\n  editorState._nodeMap.set(key, node);\n  // TODO Split this function into leaf/element\n  if ($isElementNode(node)) {\n    editor._dirtyElements.set(key, true);\n  } else {\n    editor._dirtyLeaves.add(key);\n  }\n  editor._cloneNotNeeded.add(key);\n  editor._dirtyType = HAS_DIRTY_NODES;\n  node.__key = key;\n}\nfunction errorOnNodeKeyConstructorMismatch(node, existingKey) {\n  const editorState = internalGetActiveEditorState();\n  if (!editorState) {\n    // tests expect to be able to do this kind of clone without an active editor state\n    return;\n  }\n  const existingNode = editorState._nodeMap.get(existingKey);\n  if (existingNode && existingNode.constructor !== node.constructor) {\n    // Lifted condition to if statement because the inverted logic is a bit confusing\n    if (node.constructor.name !== existingNode.constructor.name) {\n      {\n        throw Error(`Lexical node with constructor ${node.constructor.name} attempted to re-use key from node in active editor state with constructor ${existingNode.constructor.name}. Keys must not be re-used when the type is changed.`);\n      }\n    } else {\n      {\n        throw Error(`Lexical node with constructor ${node.constructor.name} attempted to re-use key from node in active editor state with different constructor with the same name (possibly due to invalid Hot Module Replacement). Keys must not be re-used when the type is changed.`);\n      }\n    }\n  }\n}\nfunction internalMarkParentElementsAsDirty(parentKey, nodeMap, dirtyElements) {\n  let nextParentKey = parentKey;\n  while (nextParentKey !== null) {\n    if (dirtyElements.has(nextParentKey)) {\n      return;\n    }\n    const node = nodeMap.get(nextParentKey);\n    if (node === undefined) {\n      break;\n    }\n    dirtyElements.set(nextParentKey, false);\n    nextParentKey = node.__parent;\n  }\n}\n\n// TODO #6031 this function or their callers have to adjust selection (i.e. insertBefore)\nfunction removeFromParent(node) {\n  const oldParent = node.getParent();\n  if (oldParent !== null) {\n    const writableNode = node.getWritable();\n    const writableParent = oldParent.getWritable();\n    const prevSibling = node.getPreviousSibling();\n    const nextSibling = node.getNextSibling();\n    // TODO: this function duplicates a bunch of operations, can be simplified.\n    if (prevSibling === null) {\n      if (nextSibling !== null) {\n        const writableNextSibling = nextSibling.getWritable();\n        writableParent.__first = nextSibling.__key;\n        writableNextSibling.__prev = null;\n      } else {\n        writableParent.__first = null;\n      }\n    } else {\n      const writablePrevSibling = prevSibling.getWritable();\n      if (nextSibling !== null) {\n        const writableNextSibling = nextSibling.getWritable();\n        writableNextSibling.__prev = writablePrevSibling.__key;\n        writablePrevSibling.__next = writableNextSibling.__key;\n      } else {\n        writablePrevSibling.__next = null;\n      }\n      writableNode.__prev = null;\n    }\n    if (nextSibling === null) {\n      if (prevSibling !== null) {\n        const writablePrevSibling = prevSibling.getWritable();\n        writableParent.__last = prevSibling.__key;\n        writablePrevSibling.__next = null;\n      } else {\n        writableParent.__last = null;\n      }\n    } else {\n      const writableNextSibling = nextSibling.getWritable();\n      if (prevSibling !== null) {\n        const writablePrevSibling = prevSibling.getWritable();\n        writablePrevSibling.__next = writableNextSibling.__key;\n        writableNextSibling.__prev = writablePrevSibling.__key;\n      } else {\n        writableNextSibling.__prev = null;\n      }\n      writableNode.__next = null;\n    }\n    writableParent.__size--;\n    writableNode.__parent = null;\n  }\n}\n\n// Never use this function directly! It will break\n// the cloning heuristic. Instead use node.getWritable().\nfunction internalMarkNodeAsDirty(node) {\n  errorOnInfiniteTransforms();\n  const latest = node.getLatest();\n  const parent = latest.__parent;\n  const editorState = getActiveEditorState();\n  const editor = getActiveEditor();\n  const nodeMap = editorState._nodeMap;\n  const dirtyElements = editor._dirtyElements;\n  if (parent !== null) {\n    internalMarkParentElementsAsDirty(parent, nodeMap, dirtyElements);\n  }\n  const key = latest.__key;\n  editor._dirtyType = HAS_DIRTY_NODES;\n  if ($isElementNode(node)) {\n    dirtyElements.set(key, true);\n  } else {\n    // TODO split internally MarkNodeAsDirty into two dedicated Element/leave functions\n    editor._dirtyLeaves.add(key);\n  }\n}\nfunction internalMarkSiblingsAsDirty(node) {\n  const previousNode = node.getPreviousSibling();\n  const nextNode = node.getNextSibling();\n  if (previousNode !== null) {\n    internalMarkNodeAsDirty(previousNode);\n  }\n  if (nextNode !== null) {\n    internalMarkNodeAsDirty(nextNode);\n  }\n}\nfunction $setCompositionKey(compositionKey) {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  const previousCompositionKey = editor._compositionKey;\n  if (compositionKey !== previousCompositionKey) {\n    editor._compositionKey = compositionKey;\n    if (previousCompositionKey !== null) {\n      const node = $getNodeByKey(previousCompositionKey);\n      if (node !== null) {\n        node.getWritable();\n      }\n    }\n    if (compositionKey !== null) {\n      const node = $getNodeByKey(compositionKey);\n      if (node !== null) {\n        node.getWritable();\n      }\n    }\n  }\n}\nfunction $getCompositionKey() {\n  if (isCurrentlyReadOnlyMode()) {\n    return null;\n  }\n  const editor = getActiveEditor();\n  return editor._compositionKey;\n}\nfunction $getNodeByKey(key, _editorState) {\n  const editorState = _editorState || getActiveEditorState();\n  const node = editorState._nodeMap.get(key);\n  if (node === undefined) {\n    return null;\n  }\n  return node;\n}\nfunction $getNodeFromDOMNode(dom, editorState) {\n  const editor = getActiveEditor();\n  const key = getNodeKeyFromDOMNode(dom, editor);\n  if (key !== undefined) {\n    return $getNodeByKey(key, editorState);\n  }\n  return null;\n}\nfunction setNodeKeyOnDOMNode(dom, editor, key) {\n  const prop = `__lexicalKey_${editor._key}`;\n  dom[prop] = key;\n}\nfunction getNodeKeyFromDOMNode(dom, editor) {\n  const prop = `__lexicalKey_${editor._key}`;\n  return dom[prop];\n}\nfunction $getNearestNodeFromDOMNode(startingDOM, editorState) {\n  let dom = startingDOM;\n  while (dom != null) {\n    const node = $getNodeFromDOMNode(dom, editorState);\n    if (node !== null) {\n      return node;\n    }\n    dom = getParentElement(dom);\n  }\n  return null;\n}\nfunction cloneDecorators(editor) {\n  const currentDecorators = editor._decorators;\n  const pendingDecorators = Object.assign({}, currentDecorators);\n  editor._pendingDecorators = pendingDecorators;\n  return pendingDecorators;\n}\nfunction getEditorStateTextContent(editorState) {\n  return editorState.read(() => $getRoot().getTextContent());\n}\nfunction markNodesWithTypesAsDirty(editor, types) {\n  // We only need to mark nodes dirty if they were in the previous state.\n  // If they aren't, then they are by definition dirty already.\n  const cachedMap = getCachedTypeToNodeMap(editor.getEditorState());\n  const dirtyNodeMaps = [];\n  for (const type of types) {\n    const nodeMap = cachedMap.get(type);\n    if (nodeMap) {\n      // By construction these are non-empty\n      dirtyNodeMaps.push(nodeMap);\n    }\n  }\n  // Nothing to mark dirty, no update necessary\n  if (dirtyNodeMaps.length === 0) {\n    return;\n  }\n  editor.update(() => {\n    for (const nodeMap of dirtyNodeMaps) {\n      for (const nodeKey of nodeMap.keys()) {\n        // We are only concerned with nodes that are still in the latest NodeMap,\n        // if they no longer exist then markDirty would raise an exception\n        const latest = $getNodeByKey(nodeKey);\n        if (latest) {\n          latest.markDirty();\n        }\n      }\n    }\n  }, editor._pendingEditorState === null ? {\n    tag: 'history-merge'\n  } : undefined);\n}\nfunction $getRoot() {\n  return internalGetRoot(getActiveEditorState());\n}\nfunction internalGetRoot(editorState) {\n  return editorState._nodeMap.get('root');\n}\nfunction $setSelection(selection) {\n  errorOnReadOnly();\n  const editorState = getActiveEditorState();\n  if (selection !== null) {\n    {\n      if (Object.isFrozen(selection)) {\n        {\n          throw Error(`$setSelection called on frozen selection object. Ensure selection is cloned before passing in.`);\n        }\n      }\n    }\n    selection.dirty = true;\n    selection.setCachedNodes(null);\n  }\n  editorState._selection = selection;\n}\nfunction $flushMutations() {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  $flushRootMutations(editor);\n}\nfunction $getNodeFromDOM(dom) {\n  const editor = getActiveEditor();\n  const nodeKey = getNodeKeyFromDOMTree(dom, editor);\n  if (nodeKey === null) {\n    const rootElement = editor.getRootElement();\n    if (dom === rootElement) {\n      return $getNodeByKey('root');\n    }\n    return null;\n  }\n  return $getNodeByKey(nodeKey);\n}\nfunction getTextNodeOffset(node, moveSelectionToEnd) {\n  return moveSelectionToEnd ? node.getTextContentSize() : 0;\n}\nfunction getNodeKeyFromDOMTree(\n// Note that node here refers to a DOM Node, not an Lexical Node\ndom, editor) {\n  let node = dom;\n  while (node != null) {\n    const key = getNodeKeyFromDOMNode(node, editor);\n    if (key !== undefined) {\n      return key;\n    }\n    node = getParentElement(node);\n  }\n  return null;\n}\nfunction doesContainGrapheme(str) {\n  return /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g.test(str);\n}\nfunction getEditorsToPropagate(editor) {\n  const editorsToPropagate = [];\n  let currentEditor = editor;\n  while (currentEditor !== null) {\n    editorsToPropagate.push(currentEditor);\n    currentEditor = currentEditor._parentEditor;\n  }\n  return editorsToPropagate;\n}\nfunction createUID() {\n  return Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, 5);\n}\nfunction getAnchorTextFromDOM(anchorNode) {\n  return isDOMTextNode(anchorNode) ? anchorNode.nodeValue : null;\n}\nfunction $updateSelectedTextFromDOM(isCompositionEnd, editor, data) {\n  // Update the text content with the latest composition text\n  const domSelection = getDOMSelection(editor._window);\n  if (domSelection === null) {\n    return;\n  }\n  const anchorNode = domSelection.anchorNode;\n  let {\n    anchorOffset,\n    focusOffset\n  } = domSelection;\n  if (anchorNode !== null) {\n    let textContent = getAnchorTextFromDOM(anchorNode);\n    const node = $getNearestNodeFromDOMNode(anchorNode);\n    if (textContent !== null && $isTextNode(node)) {\n      // Data is intentionally truthy, as we check for boolean, null and empty string.\n      if (textContent === COMPOSITION_SUFFIX && data) {\n        const offset = data.length;\n        textContent = data;\n        anchorOffset = offset;\n        focusOffset = offset;\n      }\n      if (textContent !== null) {\n        $updateTextNodeFromDOMContent(node, textContent, anchorOffset, focusOffset, isCompositionEnd);\n      }\n    }\n  }\n}\nfunction $updateTextNodeFromDOMContent(textNode, textContent, anchorOffset, focusOffset, compositionEnd) {\n  let node = textNode;\n  if (node.isAttached() && (compositionEnd || !node.isDirty())) {\n    const isComposing = node.isComposing();\n    let normalizedTextContent = textContent;\n    if ((isComposing || compositionEnd) && textContent[textContent.length - 1] === COMPOSITION_SUFFIX) {\n      normalizedTextContent = textContent.slice(0, -1);\n    }\n    const prevTextContent = node.getTextContent();\n    if (compositionEnd || normalizedTextContent !== prevTextContent) {\n      if (normalizedTextContent === '') {\n        $setCompositionKey(null);\n        if (!IS_SAFARI && !IS_IOS && !IS_APPLE_WEBKIT) {\n          // For composition (mainly Android), we have to remove the node on a later update\n          const editor = getActiveEditor();\n          setTimeout(() => {\n            editor.update(() => {\n              if (node.isAttached()) {\n                node.remove();\n              }\n            });\n          }, 20);\n        } else {\n          node.remove();\n        }\n        return;\n      }\n      const parent = node.getParent();\n      const prevSelection = $getPreviousSelection();\n      const prevTextContentSize = node.getTextContentSize();\n      const compositionKey = $getCompositionKey();\n      const nodeKey = node.getKey();\n      if (node.isToken() || compositionKey !== null && nodeKey === compositionKey && !isComposing ||\n      // Check if character was added at the start or boundaries when not insertable, and we need\n      // to clear this input from occurring as that action wasn't permitted.\n      $isRangeSelection(prevSelection) && (parent !== null && !parent.canInsertTextBefore() && prevSelection.anchor.offset === 0 || prevSelection.anchor.key === textNode.__key && prevSelection.anchor.offset === 0 && !node.canInsertTextBefore() && !isComposing || prevSelection.focus.key === textNode.__key && prevSelection.focus.offset === prevTextContentSize && !node.canInsertTextAfter() && !isComposing)) {\n        node.markDirty();\n        return;\n      }\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection) || anchorOffset === null || focusOffset === null) {\n        node.setTextContent(normalizedTextContent);\n        return;\n      }\n      selection.setTextNodeRange(node, anchorOffset, node, focusOffset);\n      if (node.isSegmented()) {\n        const originalTextContent = node.getTextContent();\n        const replacement = $createTextNode(originalTextContent);\n        node.replace(replacement);\n        node = replacement;\n      }\n      node.setTextContent(normalizedTextContent);\n    }\n  }\n}\nfunction $previousSiblingDoesNotAcceptText(node) {\n  const previousSibling = node.getPreviousSibling();\n  return ($isTextNode(previousSibling) || $isElementNode(previousSibling) && previousSibling.isInline()) && !previousSibling.canInsertTextAfter();\n}\n\n// This function is connected to $shouldPreventDefaultAndInsertText and determines whether the\n// TextNode boundaries are writable or we should use the previous/next sibling instead. For example,\n// in the case of a LinkNode, boundaries are not writable.\nfunction $shouldInsertTextAfterOrBeforeTextNode(selection, node) {\n  if (node.isSegmented()) {\n    return true;\n  }\n  if (!selection.isCollapsed()) {\n    return false;\n  }\n  const offset = selection.anchor.offset;\n  const parent = node.getParentOrThrow();\n  const isToken = node.isToken();\n  if (offset === 0) {\n    return !node.canInsertTextBefore() || !parent.canInsertTextBefore() && !node.isComposing() || isToken || $previousSiblingDoesNotAcceptText(node);\n  } else if (offset === node.getTextContentSize()) {\n    return !node.canInsertTextAfter() || !parent.canInsertTextAfter() && !node.isComposing() || isToken;\n  } else {\n    return false;\n  }\n}\nfunction isTab(key, altKey, ctrlKey, metaKey) {\n  return key === 'Tab' && !altKey && !ctrlKey && !metaKey;\n}\nfunction isBold(key, altKey, metaKey, ctrlKey) {\n  return key.toLowerCase() === 'b' && !altKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isItalic(key, altKey, metaKey, ctrlKey) {\n  return key.toLowerCase() === 'i' && !altKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isUnderline(key, altKey, metaKey, ctrlKey) {\n  return key.toLowerCase() === 'u' && !altKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isParagraph(key, shiftKey) {\n  return isReturn(key) && !shiftKey;\n}\nfunction isLineBreak(key, shiftKey) {\n  return isReturn(key) && shiftKey;\n}\n\n// Inserts a new line after the selection\n\nfunction isOpenLineBreak(key, ctrlKey) {\n  // 79 = KeyO\n  return IS_APPLE && ctrlKey && key.toLowerCase() === 'o';\n}\nfunction isDeleteWordBackward(key, altKey, ctrlKey) {\n  return isBackspace(key) && (IS_APPLE ? altKey : ctrlKey);\n}\nfunction isDeleteWordForward(key, altKey, ctrlKey) {\n  return isDelete(key) && (IS_APPLE ? altKey : ctrlKey);\n}\nfunction isDeleteLineBackward(key, metaKey) {\n  return IS_APPLE && metaKey && isBackspace(key);\n}\nfunction isDeleteLineForward(key, metaKey) {\n  return IS_APPLE && metaKey && isDelete(key);\n}\nfunction isDeleteBackward(key, altKey, metaKey, ctrlKey) {\n  if (IS_APPLE) {\n    if (altKey || metaKey) {\n      return false;\n    }\n    return isBackspace(key) || key.toLowerCase() === 'h' && ctrlKey;\n  }\n  if (ctrlKey || altKey || metaKey) {\n    return false;\n  }\n  return isBackspace(key);\n}\nfunction isDeleteForward(key, ctrlKey, shiftKey, altKey, metaKey) {\n  if (IS_APPLE) {\n    if (shiftKey || altKey || metaKey) {\n      return false;\n    }\n    return isDelete(key) || key.toLowerCase() === 'd' && ctrlKey;\n  }\n  if (ctrlKey || altKey || metaKey) {\n    return false;\n  }\n  return isDelete(key);\n}\nfunction isUndo(key, shiftKey, metaKey, ctrlKey) {\n  return key.toLowerCase() === 'z' && !shiftKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isRedo(key, shiftKey, metaKey, ctrlKey) {\n  if (IS_APPLE) {\n    return key.toLowerCase() === 'z' && metaKey && shiftKey;\n  }\n  return key.toLowerCase() === 'y' && ctrlKey || key.toLowerCase() === 'z' && ctrlKey && shiftKey;\n}\nfunction isCopy(key, shiftKey, metaKey, ctrlKey) {\n  if (shiftKey) {\n    return false;\n  }\n  if (key.toLowerCase() === 'c') {\n    return IS_APPLE ? metaKey : ctrlKey;\n  }\n  return false;\n}\nfunction isCut(key, shiftKey, metaKey, ctrlKey) {\n  if (shiftKey) {\n    return false;\n  }\n  if (key.toLowerCase() === 'x') {\n    return IS_APPLE ? metaKey : ctrlKey;\n  }\n  return false;\n}\nfunction isArrowLeft(key) {\n  return key === 'ArrowLeft';\n}\nfunction isArrowRight(key) {\n  return key === 'ArrowRight';\n}\nfunction isArrowUp(key) {\n  return key === 'ArrowUp';\n}\nfunction isArrowDown(key) {\n  return key === 'ArrowDown';\n}\nfunction isMoveBackward(key, ctrlKey, altKey, metaKey) {\n  return isArrowLeft(key) && !ctrlKey && !metaKey && !altKey;\n}\nfunction isMoveToStart(key, ctrlKey, shiftKey, altKey, metaKey) {\n  return isArrowLeft(key) && !altKey && !shiftKey && (ctrlKey || metaKey);\n}\nfunction isMoveForward(key, ctrlKey, altKey, metaKey) {\n  return isArrowRight(key) && !ctrlKey && !metaKey && !altKey;\n}\nfunction isMoveToEnd(key, ctrlKey, shiftKey, altKey, metaKey) {\n  return isArrowRight(key) && !altKey && !shiftKey && (ctrlKey || metaKey);\n}\nfunction isMoveUp(key, ctrlKey, metaKey) {\n  return isArrowUp(key) && !ctrlKey && !metaKey;\n}\nfunction isMoveDown(key, ctrlKey, metaKey) {\n  return isArrowDown(key) && !ctrlKey && !metaKey;\n}\nfunction isModifier(ctrlKey, shiftKey, altKey, metaKey) {\n  return ctrlKey || shiftKey || altKey || metaKey;\n}\nfunction isSpace(key) {\n  return key === ' ';\n}\nfunction controlOrMeta(metaKey, ctrlKey) {\n  if (IS_APPLE) {\n    return metaKey;\n  }\n  return ctrlKey;\n}\nfunction isReturn(key) {\n  return key === 'Enter';\n}\nfunction isBackspace(key) {\n  return key === 'Backspace';\n}\nfunction isEscape(key) {\n  return key === 'Escape';\n}\nfunction isDelete(key) {\n  return key === 'Delete';\n}\nfunction isSelectAll(key, metaKey, ctrlKey) {\n  return key.toLowerCase() === 'a' && controlOrMeta(metaKey, ctrlKey);\n}\nfunction $selectAll(selection) {\n  const root = $getRoot();\n  if ($isRangeSelection(selection)) {\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    const anchorNode = anchor.getNode();\n    const topParent = anchorNode.getTopLevelElementOrThrow();\n    const rootNode = topParent.getParentOrThrow();\n    anchor.set(rootNode.getKey(), 0, 'element');\n    focus.set(rootNode.getKey(), rootNode.getChildrenSize(), 'element');\n    $normalizeSelection(selection);\n    return selection;\n  } else {\n    // Create a new RangeSelection\n    const newSelection = root.select(0, root.getChildrenSize());\n    $setSelection($normalizeSelection(newSelection));\n    return newSelection;\n  }\n}\nfunction getCachedClassNameArray(classNamesTheme, classNameThemeType) {\n  if (classNamesTheme.__lexicalClassNameCache === undefined) {\n    classNamesTheme.__lexicalClassNameCache = {};\n  }\n  const classNamesCache = classNamesTheme.__lexicalClassNameCache;\n  const cachedClassNames = classNamesCache[classNameThemeType];\n  if (cachedClassNames !== undefined) {\n    return cachedClassNames;\n  }\n  const classNames = classNamesTheme[classNameThemeType];\n  // As we're using classList, we need\n  // to handle className tokens that have spaces.\n  // The easiest way to do this to convert the\n  // className tokens to an array that can be\n  // applied to classList.add()/remove().\n  if (typeof classNames === 'string') {\n    const classNamesArr = normalizeClassNames(classNames);\n    classNamesCache[classNameThemeType] = classNamesArr;\n    return classNamesArr;\n  }\n  return classNames;\n}\nfunction setMutatedNode(mutatedNodes, registeredNodes, mutationListeners, node, mutation) {\n  if (mutationListeners.size === 0) {\n    return;\n  }\n  const nodeType = node.__type;\n  const nodeKey = node.__key;\n  const registeredNode = registeredNodes.get(nodeType);\n  if (registeredNode === undefined) {\n    {\n      throw Error(`Type ${nodeType} not in registeredNodes`);\n    }\n  }\n  const klass = registeredNode.klass;\n  let mutatedNodesByType = mutatedNodes.get(klass);\n  if (mutatedNodesByType === undefined) {\n    mutatedNodesByType = new Map();\n    mutatedNodes.set(klass, mutatedNodesByType);\n  }\n  const prevMutation = mutatedNodesByType.get(nodeKey);\n  // If the node has already been \"destroyed\", yet we are\n  // re-making it, then this means a move likely happened.\n  // We should change the mutation to be that of \"updated\"\n  // instead.\n  const isMove = prevMutation === 'destroyed' && mutation === 'created';\n  if (prevMutation === undefined || isMove) {\n    mutatedNodesByType.set(nodeKey, isMove ? 'updated' : mutation);\n  }\n}\n/**\n * @deprecated Use {@link LexicalEditor.registerMutationListener} with `skipInitialization: false` instead.\n */\nfunction $nodesOfType(klass) {\n  const klassType = klass.getType();\n  const editorState = getActiveEditorState();\n  if (editorState._readOnly) {\n    const nodes = getCachedTypeToNodeMap(editorState).get(klassType);\n    return nodes ? Array.from(nodes.values()) : [];\n  }\n  const nodes = editorState._nodeMap;\n  const nodesOfType = [];\n  for (const [, node] of nodes) {\n    if (node instanceof klass && node.__type === klassType && node.isAttached()) {\n      nodesOfType.push(node);\n    }\n  }\n  return nodesOfType;\n}\nfunction resolveElement(element, isBackward, focusOffset) {\n  const parent = element.getParent();\n  let offset = focusOffset;\n  let block = element;\n  if (parent !== null) {\n    if (isBackward && focusOffset === 0) {\n      offset = block.getIndexWithinParent();\n      block = parent;\n    } else if (!isBackward && focusOffset === block.getChildrenSize()) {\n      offset = block.getIndexWithinParent() + 1;\n      block = parent;\n    }\n  }\n  return block.getChildAtIndex(isBackward ? offset - 1 : offset);\n}\nfunction $getAdjacentNode(focus, isBackward) {\n  const focusOffset = focus.offset;\n  if (focus.type === 'element') {\n    const block = focus.getNode();\n    return resolveElement(block, isBackward, focusOffset);\n  } else {\n    const focusNode = focus.getNode();\n    if (isBackward && focusOffset === 0 || !isBackward && focusOffset === focusNode.getTextContentSize()) {\n      const possibleNode = isBackward ? focusNode.getPreviousSibling() : focusNode.getNextSibling();\n      if (possibleNode === null) {\n        return resolveElement(focusNode.getParentOrThrow(), isBackward, focusNode.getIndexWithinParent() + (isBackward ? 0 : 1));\n      }\n      return possibleNode;\n    }\n  }\n  return null;\n}\nfunction isFirefoxClipboardEvents(editor) {\n  const event = getWindow(editor).event;\n  const inputType = event && event.inputType;\n  return inputType === 'insertFromPaste' || inputType === 'insertFromPasteAsQuotation';\n}\nfunction dispatchCommand(editor, command, payload) {\n  return triggerCommandListeners(editor, command, payload);\n}\nfunction $textContentRequiresDoubleLinebreakAtEnd(node) {\n  return !$isRootNode(node) && !node.isLastChild() && !node.isInline();\n}\nfunction getElementByKeyOrThrow(editor, key) {\n  const element = editor._keyToDOMMap.get(key);\n  if (element === undefined) {\n    {\n      throw Error(`Reconciliation: could not find DOM element for node key ${key}`);\n    }\n  }\n  return element;\n}\nfunction getParentElement(node) {\n  const parentElement = node.assignedSlot || node.parentElement;\n  return isDocumentFragment(parentElement) ? parentElement.host : parentElement;\n}\nfunction getDOMOwnerDocument(target) {\n  return isDOMDocumentNode(target) ? target : isHTMLElement(target) ? target.ownerDocument : null;\n}\nfunction scrollIntoViewIfNeeded(editor, selectionRect, rootElement) {\n  const doc = getDOMOwnerDocument(rootElement);\n  const defaultView = getDefaultView(doc);\n  if (doc === null || defaultView === null) {\n    return;\n  }\n  let {\n    top: currentTop,\n    bottom: currentBottom\n  } = selectionRect;\n  let targetTop = 0;\n  let targetBottom = 0;\n  let element = rootElement;\n  while (element !== null) {\n    const isBodyElement = element === doc.body;\n    if (isBodyElement) {\n      targetTop = 0;\n      targetBottom = getWindow(editor).innerHeight;\n    } else {\n      const targetRect = element.getBoundingClientRect();\n      targetTop = targetRect.top;\n      targetBottom = targetRect.bottom;\n    }\n    let diff = 0;\n    if (currentTop < targetTop) {\n      diff = -(targetTop - currentTop);\n    } else if (currentBottom > targetBottom) {\n      diff = currentBottom - targetBottom;\n    }\n    if (diff !== 0) {\n      if (isBodyElement) {\n        // Only handles scrolling of Y axis\n        defaultView.scrollBy(0, diff);\n      } else {\n        const scrollTop = element.scrollTop;\n        element.scrollTop += diff;\n        const yOffset = element.scrollTop - scrollTop;\n        currentTop -= yOffset;\n        currentBottom -= yOffset;\n      }\n    }\n    if (isBodyElement) {\n      break;\n    }\n    element = getParentElement(element);\n  }\n}\nfunction $hasUpdateTag(tag) {\n  const editor = getActiveEditor();\n  return editor._updateTags.has(tag);\n}\nfunction $addUpdateTag(tag) {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  editor._updateTags.add(tag);\n}\n\n/**\n * Add a function to run after the current update. This will run after any\n * `onUpdate` function already supplied to `editor.update()`, as well as any\n * functions added with previous calls to `$onUpdate`.\n *\n * @param updateFn The function to run after the current update.\n */\nfunction $onUpdate(updateFn) {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  editor._deferred.push(updateFn);\n}\nfunction $maybeMoveChildrenSelectionToParent(parentNode) {\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection) || !$isElementNode(parentNode)) {\n    return selection;\n  }\n  const {\n    anchor,\n    focus\n  } = selection;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if ($hasAncestor(anchorNode, parentNode)) {\n    anchor.set(parentNode.__key, 0, 'element');\n  }\n  if ($hasAncestor(focusNode, parentNode)) {\n    focus.set(parentNode.__key, 0, 'element');\n  }\n  return selection;\n}\nfunction $hasAncestor(child, targetNode) {\n  let parent = child.getParent();\n  while (parent !== null) {\n    if (parent.is(targetNode)) {\n      return true;\n    }\n    parent = parent.getParent();\n  }\n  return false;\n}\nfunction getDefaultView(domElem) {\n  const ownerDoc = getDOMOwnerDocument(domElem);\n  return ownerDoc ? ownerDoc.defaultView : null;\n}\nfunction getWindow(editor) {\n  const windowObj = editor._window;\n  if (windowObj === null) {\n    {\n      throw Error(`window object not found`);\n    }\n  }\n  return windowObj;\n}\nfunction $isInlineElementOrDecoratorNode(node) {\n  return $isElementNode(node) && node.isInline() || $isDecoratorNode(node) && node.isInline();\n}\nfunction $getNearestRootOrShadowRoot(node) {\n  let parent = node.getParentOrThrow();\n  while (parent !== null) {\n    if ($isRootOrShadowRoot(parent)) {\n      return parent;\n    }\n    parent = parent.getParentOrThrow();\n  }\n  return parent;\n}\nfunction $isRootOrShadowRoot(node) {\n  return $isRootNode(node) || $isElementNode(node) && node.isShadowRoot();\n}\n\n/**\n * Returns a shallow clone of node with a new key\n *\n * @param node - The node to be copied.\n * @returns The copy of the node.\n */\nfunction $copyNode(node) {\n  const copy = node.constructor.clone(node);\n  $setNodeKey(copy, null);\n  return copy;\n}\nfunction $applyNodeReplacement(node) {\n  const editor = getActiveEditor();\n  const nodeType = node.constructor.getType();\n  const registeredNode = editor._nodes.get(nodeType);\n  if (!(registeredNode !== undefined)) {\n    throw Error(`$applyNodeReplacement node ${node.constructor.name} with type ${nodeType} must be registered to the editor. You can do this by passing the node class via the \"nodes\" array in the editor config.`);\n  }\n  const {\n    replace,\n    replaceWithKlass\n  } = registeredNode;\n  if (replace !== null) {\n    const replacementNode = replace(node);\n    const replacementNodeKlass = replacementNode.constructor;\n    if (replaceWithKlass !== null) {\n      if (!(replacementNode instanceof replaceWithKlass)) {\n        throw Error(`$applyNodeReplacement failed. Expected replacement node to be an instance of ${replaceWithKlass.name} with type ${replaceWithKlass.getType()} but returned ${replacementNodeKlass.name} with type ${replacementNodeKlass.getType()} from original node ${node.constructor.name} with type ${nodeType}`);\n      }\n    } else {\n      if (!(replacementNode instanceof node.constructor && replacementNodeKlass !== node.constructor)) {\n        throw Error(`$applyNodeReplacement failed. Ensure replacement node ${replacementNodeKlass.name} with type ${replacementNodeKlass.getType()} is a subclass of the original node ${node.constructor.name} with type ${nodeType}.`);\n      }\n    }\n    if (!(replacementNode.__key !== node.__key)) {\n      throw Error(`$applyNodeReplacement failed. Ensure that the key argument is *not* used in your replace function (from node ${node.constructor.name} with type ${nodeType} to node ${replacementNodeKlass.name} with type ${replacementNodeKlass.getType()}), Node keys must never be re-used except by the static clone method.`);\n    }\n    return replacementNode;\n  }\n  return node;\n}\nfunction errorOnInsertTextNodeOnRoot(node, insertNode) {\n  const parentNode = node.getParent();\n  if ($isRootNode(parentNode) && !$isElementNode(insertNode) && !$isDecoratorNode(insertNode)) {\n    {\n      throw Error(`Only element or decorator nodes can be inserted in to the root node`);\n    }\n  }\n}\nfunction $getNodeByKeyOrThrow(key) {\n  const node = $getNodeByKey(key);\n  if (node === null) {\n    {\n      throw Error(`Expected node with key ${key} to exist but it's not in the nodeMap.`);\n    }\n  }\n  return node;\n}\nfunction createBlockCursorElement(editorConfig) {\n  const theme = editorConfig.theme;\n  const element = document.createElement('div');\n  element.contentEditable = 'false';\n  element.setAttribute('data-lexical-cursor', 'true');\n  let blockCursorTheme = theme.blockCursor;\n  if (blockCursorTheme !== undefined) {\n    if (typeof blockCursorTheme === 'string') {\n      const classNamesArr = normalizeClassNames(blockCursorTheme);\n      // @ts-expect-error: intentional\n      blockCursorTheme = theme.blockCursor = classNamesArr;\n    }\n    if (blockCursorTheme !== undefined) {\n      element.classList.add(...blockCursorTheme);\n    }\n  }\n  return element;\n}\nfunction needsBlockCursor(node) {\n  return ($isDecoratorNode(node) || $isElementNode(node) && !node.canBeEmpty()) && !node.isInline();\n}\nfunction removeDOMBlockCursorElement(blockCursorElement, editor, rootElement) {\n  rootElement.style.removeProperty('caret-color');\n  editor._blockCursorElement = null;\n  const parentElement = blockCursorElement.parentElement;\n  if (parentElement !== null) {\n    parentElement.removeChild(blockCursorElement);\n  }\n}\nfunction updateDOMBlockCursorElement(editor, rootElement, nextSelection) {\n  let blockCursorElement = editor._blockCursorElement;\n  if ($isRangeSelection(nextSelection) && nextSelection.isCollapsed() && nextSelection.anchor.type === 'element' && rootElement.contains(document.activeElement)) {\n    const anchor = nextSelection.anchor;\n    const elementNode = anchor.getNode();\n    const offset = anchor.offset;\n    const elementNodeSize = elementNode.getChildrenSize();\n    let isBlockCursor = false;\n    let insertBeforeElement = null;\n    if (offset === elementNodeSize) {\n      const child = elementNode.getChildAtIndex(offset - 1);\n      if (needsBlockCursor(child)) {\n        isBlockCursor = true;\n      }\n    } else {\n      const child = elementNode.getChildAtIndex(offset);\n      if (child !== null && needsBlockCursor(child)) {\n        const sibling = child.getPreviousSibling();\n        if (sibling === null || needsBlockCursor(sibling)) {\n          isBlockCursor = true;\n          insertBeforeElement = editor.getElementByKey(child.__key);\n        }\n      }\n    }\n    if (isBlockCursor) {\n      const elementDOM = editor.getElementByKey(elementNode.__key);\n      if (blockCursorElement === null) {\n        editor._blockCursorElement = blockCursorElement = createBlockCursorElement(editor._config);\n      }\n      rootElement.style.caretColor = 'transparent';\n      if (insertBeforeElement === null) {\n        elementDOM.appendChild(blockCursorElement);\n      } else {\n        elementDOM.insertBefore(blockCursorElement, insertBeforeElement);\n      }\n      return;\n    }\n  }\n  // Remove cursor\n  if (blockCursorElement !== null) {\n    removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\n  }\n}\n\n/**\n * Returns the selection for the given window, or the global window if null.\n * Will return null if {@link CAN_USE_DOM} is false.\n *\n * @param targetWindow The window to get the selection from\n * @returns a Selection or null\n */\nfunction getDOMSelection(targetWindow) {\n  return !CAN_USE_DOM ? null : (targetWindow || window).getSelection();\n}\n\n/**\n * Returns the selection for the defaultView of the ownerDocument of given EventTarget.\n *\n * @param eventTarget The node to get the selection from\n * @returns a Selection or null\n */\nfunction getDOMSelectionFromTarget(eventTarget) {\n  const defaultView = getDefaultView(eventTarget);\n  return defaultView ? defaultView.getSelection() : null;\n}\nfunction $splitNode(node, offset) {\n  let startNode = node.getChildAtIndex(offset);\n  if (startNode == null) {\n    startNode = node;\n  }\n  if (!!$isRootOrShadowRoot(node)) {\n    throw Error(`Can not call $splitNode() on root element`);\n  }\n  const recurse = currentNode => {\n    const parent = currentNode.getParentOrThrow();\n    const isParentRoot = $isRootOrShadowRoot(parent);\n    // The node we start split from (leaf) is moved, but its recursive\n    // parents are copied to create separate tree\n    const nodeToMove = currentNode === startNode && !isParentRoot ? currentNode : $copyNode(currentNode);\n    if (isParentRoot) {\n      if (!($isElementNode(currentNode) && $isElementNode(nodeToMove))) {\n        throw Error(`Children of a root must be ElementNode`);\n      }\n      currentNode.insertAfter(nodeToMove);\n      return [currentNode, nodeToMove, nodeToMove];\n    } else {\n      const [leftTree, rightTree, newParent] = recurse(parent);\n      const nextSiblings = currentNode.getNextSiblings();\n      newParent.append(nodeToMove, ...nextSiblings);\n      return [leftTree, rightTree, nodeToMove];\n    }\n  };\n  const [leftTree, rightTree] = recurse(startNode);\n  return [leftTree, rightTree];\n}\n\n/**\n * @param x - The element being tested\n * @returns Returns true if x is an HTML anchor tag, false otherwise\n */\nfunction isHTMLAnchorElement(x) {\n  return isHTMLElement(x) && x.tagName === 'A';\n}\n\n/**\n * @param x - The element being tested\n * @returns Returns true if x is an HTML element, false otherwise.\n */\nfunction isHTMLElement(x) {\n  return isDOMNode(x) && x.nodeType === DOM_ELEMENT_TYPE;\n}\n\n/**\n * @param x - The element being tested\n * @returns Returns true if x is a DOM Node, false otherwise.\n */\nfunction isDOMNode(x) {\n  return typeof x === 'object' && x !== null && 'nodeType' in x && typeof x.nodeType === 'number';\n}\n\n/**\n * @param x - The element being testing\n * @returns Returns true if x is a document fragment, false otherwise.\n */\nfunction isDocumentFragment(x) {\n  return isDOMNode(x) && x.nodeType === DOM_DOCUMENT_FRAGMENT_TYPE;\n}\n\n/**\n *\n * @param node - the Dom Node to check\n * @returns if the Dom Node is an inline node\n */\nfunction isInlineDomNode(node) {\n  const inlineNodes = new RegExp(/^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var|#text)$/, 'i');\n  return node.nodeName.match(inlineNodes) !== null;\n}\n\n/**\n *\n * @param node - the Dom Node to check\n * @returns if the Dom Node is a block node\n */\nfunction isBlockDomNode(node) {\n  const blockNodes = new RegExp(/^(address|article|aside|blockquote|canvas|dd|div|dl|dt|fieldset|figcaption|figure|footer|form|h1|h2|h3|h4|h5|h6|header|hr|li|main|nav|noscript|ol|p|pre|section|table|td|tfoot|ul|video)$/, 'i');\n  return node.nodeName.match(blockNodes) !== null;\n}\n\n/**\n * This function is for internal use of the library.\n * Please do not use it as it may change in the future.\n */\nfunction INTERNAL_$isBlock(node) {\n  if ($isDecoratorNode(node) && !node.isInline()) {\n    return true;\n  }\n  if (!$isElementNode(node) || $isRootOrShadowRoot(node)) {\n    return false;\n  }\n  const firstChild = node.getFirstChild();\n  const isLeafElement = firstChild === null || $isLineBreakNode(firstChild) || $isTextNode(firstChild) || firstChild.isInline();\n  return !node.isInline() && node.canBeEmpty() !== false && isLeafElement;\n}\nfunction $getAncestor(node, predicate) {\n  let parent = node;\n  while (parent !== null && parent.getParent() !== null && !predicate(parent)) {\n    parent = parent.getParentOrThrow();\n  }\n  return predicate(parent) ? parent : null;\n}\n\n/**\n * Utility function for accessing current active editor instance.\n * @returns Current active editor\n */\nfunction $getEditor() {\n  return getActiveEditor();\n}\n\n/** @internal */\n\n/**\n * @internal\n * Compute a cached Map of node type to nodes for a frozen EditorState\n */\nconst cachedNodeMaps = new WeakMap();\nconst EMPTY_TYPE_TO_NODE_MAP = new Map();\nfunction getCachedTypeToNodeMap(editorState) {\n  // If this is a new Editor it may have a writable this._editorState\n  // with only a 'root' entry.\n  if (!editorState._readOnly && editorState.isEmpty()) {\n    return EMPTY_TYPE_TO_NODE_MAP;\n  }\n  if (!editorState._readOnly) {\n    throw Error(`getCachedTypeToNodeMap called with a writable EditorState`);\n  }\n  let typeToNodeMap = cachedNodeMaps.get(editorState);\n  if (!typeToNodeMap) {\n    typeToNodeMap = computeTypeToNodeMap(editorState);\n    cachedNodeMaps.set(editorState, typeToNodeMap);\n  }\n  return typeToNodeMap;\n}\n\n/**\n * @internal\n * Compute a Map of node type to nodes for an EditorState\n */\nfunction computeTypeToNodeMap(editorState) {\n  const typeToNodeMap = new Map();\n  for (const [nodeKey, node] of editorState._nodeMap) {\n    const nodeType = node.__type;\n    let nodeMap = typeToNodeMap.get(nodeType);\n    if (!nodeMap) {\n      nodeMap = new Map();\n      typeToNodeMap.set(nodeType, nodeMap);\n    }\n    nodeMap.set(nodeKey, node);\n  }\n  return typeToNodeMap;\n}\n\n/**\n * Returns a clone of a node using `node.constructor.clone()` followed by\n * `clone.afterCloneFrom(node)`. The resulting clone must have the same key,\n * parent/next/prev pointers, and other properties that are not set by\n * `node.constructor.clone` (format, style, etc.). This is primarily used by\n * {@link LexicalNode.getWritable} to create a writable version of an\n * existing node. The clone is the same logical node as the original node,\n * do not try and use this function to duplicate or copy an existing node.\n *\n * Does not mutate the EditorState.\n * @param node - The node to be cloned.\n * @returns The clone of the node.\n */\nfunction $cloneWithProperties(latestNode) {\n  const constructor = latestNode.constructor;\n  const mutableNode = constructor.clone(latestNode);\n  mutableNode.afterCloneFrom(latestNode);\n  {\n    if (!(mutableNode.__key === latestNode.__key)) {\n      throw Error(`$cloneWithProperties: ${constructor.name}.clone(node) (with type '${constructor.getType()}') did not return a node with the same key, make sure to specify node.__key as the last argument to the constructor`);\n    }\n    if (!(mutableNode.__parent === latestNode.__parent && mutableNode.__next === latestNode.__next && mutableNode.__prev === latestNode.__prev)) {\n      throw Error(`$cloneWithProperties: ${constructor.name}.clone(node) (with type '${constructor.getType()}') overrided afterCloneFrom but did not call super.afterCloneFrom(prevNode)`);\n    }\n  }\n  return mutableNode;\n}\nfunction setNodeIndentFromDOM(elementDom, elementNode) {\n  const indentSize = parseInt(elementDom.style.paddingInlineStart, 10) || 0;\n  const indent = indentSize / 40;\n  elementNode.setIndent(indent);\n}\n\n/**\n * @internal\n *\n * Mark this node as unmanaged by lexical's mutation observer like\n * decorator nodes\n */\nfunction setDOMUnmanaged(elementDom) {\n  const el = elementDom;\n  el.__lexicalUnmanaged = true;\n}\n\n/**\n * @internal\n *\n * True if this DOM node was marked with {@link setDOMUnmanaged}\n */\nfunction isDOMUnmanaged(elementDom) {\n  const el = elementDom;\n  return el.__lexicalUnmanaged === true;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $garbageCollectDetachedDecorators(editor, pendingEditorState) {\n  const currentDecorators = editor._decorators;\n  const pendingDecorators = editor._pendingDecorators;\n  let decorators = pendingDecorators || currentDecorators;\n  const nodeMap = pendingEditorState._nodeMap;\n  let key;\n  for (key in decorators) {\n    if (!nodeMap.has(key)) {\n      if (decorators === currentDecorators) {\n        decorators = cloneDecorators(editor);\n      }\n      delete decorators[key];\n    }\n  }\n}\nfunction $garbageCollectDetachedDeepChildNodes(node, parentKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyNodes) {\n  let child = node.getFirstChild();\n  while (child !== null) {\n    const childKey = child.__key;\n    // TODO Revise condition below, redundant? LexicalNode already cleans up children when moving Nodes\n    if (child.__parent === parentKey) {\n      if ($isElementNode(child)) {\n        $garbageCollectDetachedDeepChildNodes(child, childKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyNodes);\n      }\n\n      // If we have created a node and it was dereferenced, then also\n      // remove it from out dirty nodes Set.\n      if (!prevNodeMap.has(childKey)) {\n        dirtyNodes.delete(childKey);\n      }\n      nodeMapDelete.push(childKey);\n    }\n    child = child.getNextSibling();\n  }\n}\nfunction $garbageCollectDetachedNodes(prevEditorState, editorState, dirtyLeaves, dirtyElements) {\n  const prevNodeMap = prevEditorState._nodeMap;\n  const nodeMap = editorState._nodeMap;\n  // Store dirtyElements in a queue for later deletion; deleting dirty subtrees too early will\n  // hinder accessing .__next on child nodes\n  const nodeMapDelete = [];\n  for (const [nodeKey] of dirtyElements) {\n    const node = nodeMap.get(nodeKey);\n    if (node !== undefined) {\n      // Garbage collect node and its children if they exist\n      if (!node.isAttached()) {\n        if ($isElementNode(node)) {\n          $garbageCollectDetachedDeepChildNodes(node, nodeKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyElements);\n        }\n        // If we have created a node and it was dereferenced, then also\n        // remove it from out dirty nodes Set.\n        if (!prevNodeMap.has(nodeKey)) {\n          dirtyElements.delete(nodeKey);\n        }\n        nodeMapDelete.push(nodeKey);\n      }\n    }\n  }\n  for (const nodeKey of nodeMapDelete) {\n    nodeMap.delete(nodeKey);\n  }\n  for (const nodeKey of dirtyLeaves) {\n    const node = nodeMap.get(nodeKey);\n    if (node !== undefined && !node.isAttached()) {\n      if (!prevNodeMap.has(nodeKey)) {\n        dirtyLeaves.delete(nodeKey);\n      }\n      nodeMap.delete(nodeKey);\n    }\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nlet subTreeTextContent = '';\nlet subTreeDirectionedTextContent = '';\nlet subTreeTextFormat = null;\nlet subTreeTextStyle = '';\nlet editorTextContent = '';\nlet activeEditorConfig;\nlet activeEditor$1;\nlet activeEditorNodes;\nlet treatAllNodesAsDirty = false;\nlet activeEditorStateReadOnly = false;\nlet activeMutationListeners;\nlet activeTextDirection = null;\nlet activeDirtyElements;\nlet activeDirtyLeaves;\nlet activePrevNodeMap;\nlet activeNextNodeMap;\nlet activePrevKeyToDOMMap;\nlet mutatedNodes;\nfunction destroyNode(key, parentDOM) {\n  const node = activePrevNodeMap.get(key);\n  if (parentDOM !== null) {\n    const dom = getPrevElementByKeyOrThrow(key);\n    if (dom.parentNode === parentDOM) {\n      parentDOM.removeChild(dom);\n    }\n  }\n\n  // This logic is really important, otherwise we will leak DOM nodes\n  // when their corresponding LexicalNodes are removed from the editor state.\n  if (!activeNextNodeMap.has(key)) {\n    activeEditor$1._keyToDOMMap.delete(key);\n  }\n  if ($isElementNode(node)) {\n    const children = createChildrenArray(node, activePrevNodeMap);\n    destroyChildren(children, 0, children.length - 1, null);\n  }\n  if (node !== undefined) {\n    setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node, 'destroyed');\n  }\n}\nfunction destroyChildren(children, _startIndex, endIndex, dom) {\n  let startIndex = _startIndex;\n  for (; startIndex <= endIndex; ++startIndex) {\n    const child = children[startIndex];\n    if (child !== undefined) {\n      destroyNode(child, dom);\n    }\n  }\n}\nfunction setTextAlign(domStyle, value) {\n  domStyle.setProperty('text-align', value);\n}\nconst DEFAULT_INDENT_VALUE = '40px';\nfunction setElementIndent(dom, indent) {\n  const indentClassName = activeEditorConfig.theme.indent;\n  if (typeof indentClassName === 'string') {\n    const elementHasClassName = dom.classList.contains(indentClassName);\n    if (indent > 0 && !elementHasClassName) {\n      dom.classList.add(indentClassName);\n    } else if (indent < 1 && elementHasClassName) {\n      dom.classList.remove(indentClassName);\n    }\n  }\n  const indentationBaseValue = getComputedStyle(dom).getPropertyValue('--lexical-indent-base-value') || DEFAULT_INDENT_VALUE;\n  dom.style.setProperty('padding-inline-start', indent === 0 ? '' : `calc(${indent} * ${indentationBaseValue})`);\n}\nfunction setElementFormat(dom, format) {\n  const domStyle = dom.style;\n  if (format === 0) {\n    setTextAlign(domStyle, '');\n  } else if (format === IS_ALIGN_LEFT) {\n    setTextAlign(domStyle, 'left');\n  } else if (format === IS_ALIGN_CENTER) {\n    setTextAlign(domStyle, 'center');\n  } else if (format === IS_ALIGN_RIGHT) {\n    setTextAlign(domStyle, 'right');\n  } else if (format === IS_ALIGN_JUSTIFY) {\n    setTextAlign(domStyle, 'justify');\n  } else if (format === IS_ALIGN_START) {\n    setTextAlign(domStyle, 'start');\n  } else if (format === IS_ALIGN_END) {\n    setTextAlign(domStyle, 'end');\n  }\n}\nfunction $createNode(key, slot) {\n  const node = activeNextNodeMap.get(key);\n  if (node === undefined) {\n    {\n      throw Error(`createNode: node does not exist in nodeMap`);\n    }\n  }\n  const dom = node.createDOM(activeEditorConfig, activeEditor$1);\n  storeDOMWithKey(key, dom, activeEditor$1);\n\n  // This helps preserve the text, and stops spell check tools from\n  // merging or break the spans (which happens if they are missing\n  // this attribute).\n  if ($isTextNode(node)) {\n    dom.setAttribute('data-lexical-text', 'true');\n  } else if ($isDecoratorNode(node)) {\n    dom.setAttribute('data-lexical-decorator', 'true');\n  }\n  if ($isElementNode(node)) {\n    const indent = node.__indent;\n    const childrenSize = node.__size;\n    if (indent !== 0) {\n      setElementIndent(dom, indent);\n    }\n    if (childrenSize !== 0) {\n      const endIndex = childrenSize - 1;\n      const children = createChildrenArray(node, activeNextNodeMap);\n      $createChildrenWithDirection(children, endIndex, node, dom);\n    }\n    const format = node.__format;\n    if (format !== 0) {\n      setElementFormat(dom, format);\n    }\n    if (!node.isInline()) {\n      reconcileElementTerminatingLineBreak(null, node, dom);\n    }\n    if ($textContentRequiresDoubleLinebreakAtEnd(node)) {\n      subTreeTextContent += DOUBLE_LINE_BREAK;\n      editorTextContent += DOUBLE_LINE_BREAK;\n    }\n  } else {\n    const text = node.getTextContent();\n    if ($isDecoratorNode(node)) {\n      const decorator = node.decorate(activeEditor$1, activeEditorConfig);\n      if (decorator !== null) {\n        reconcileDecorator(key, decorator);\n      }\n      // Decorators are always non editable\n      dom.contentEditable = 'false';\n    } else if ($isTextNode(node)) {\n      if (!node.isDirectionless()) {\n        subTreeDirectionedTextContent += text;\n      }\n    }\n    subTreeTextContent += text;\n    editorTextContent += text;\n  }\n  if (slot !== null) {\n    slot.insertChild(dom);\n  }\n  {\n    // Freeze the node in DEV to prevent accidental mutations\n    Object.freeze(node);\n  }\n  setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node, 'created');\n  return dom;\n}\nfunction $createChildrenWithDirection(children, endIndex, element, dom) {\n  const previousSubTreeDirectionedTextContent = subTreeDirectionedTextContent;\n  subTreeDirectionedTextContent = '';\n  $createChildren(children, element, 0, endIndex, element.getDOMSlot(dom));\n  reconcileBlockDirection(element, dom);\n  subTreeDirectionedTextContent = previousSubTreeDirectionedTextContent;\n}\nfunction $createChildren(children, element, _startIndex, endIndex, slot) {\n  const previousSubTreeTextContent = subTreeTextContent;\n  subTreeTextContent = '';\n  let startIndex = _startIndex;\n  for (; startIndex <= endIndex; ++startIndex) {\n    $createNode(children[startIndex], slot);\n    const node = activeNextNodeMap.get(children[startIndex]);\n    if (node !== null && $isTextNode(node)) {\n      if (subTreeTextFormat === null) {\n        subTreeTextFormat = node.getFormat();\n      }\n      if (subTreeTextStyle === '') {\n        subTreeTextStyle = node.getStyle();\n      }\n    }\n  }\n  if ($textContentRequiresDoubleLinebreakAtEnd(element)) {\n    subTreeTextContent += DOUBLE_LINE_BREAK;\n  }\n  const dom = slot.element;\n  dom.__lexicalTextContent = subTreeTextContent;\n  subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;\n}\nfunction isLastChildLineBreakOrDecorator(element, nodeMap) {\n  if (element) {\n    const lastKey = element.__last;\n    if (lastKey) {\n      const node = nodeMap.get(lastKey);\n      if (node) {\n        return $isLineBreakNode(node) ? 'line-break' : $isDecoratorNode(node) && node.isInline() ? 'decorator' : null;\n      }\n    }\n    return 'empty';\n  }\n  return null;\n}\n\n// If we end an element with a LineBreakNode, then we need to add an additional <br>\nfunction reconcileElementTerminatingLineBreak(prevElement, nextElement, dom) {\n  const prevLineBreak = isLastChildLineBreakOrDecorator(prevElement, activePrevNodeMap);\n  const nextLineBreak = isLastChildLineBreakOrDecorator(nextElement, activeNextNodeMap);\n  if (prevLineBreak !== nextLineBreak) {\n    nextElement.getDOMSlot(dom).setManagedLineBreak(nextLineBreak);\n  }\n}\nfunction reconcileTextFormat(element) {\n  if (subTreeTextFormat != null && subTreeTextFormat !== element.__textFormat && !activeEditorStateReadOnly) {\n    element.setTextFormat(subTreeTextFormat);\n    element.setTextStyle(subTreeTextStyle);\n  }\n}\nfunction reconcileTextStyle(element) {\n  if (subTreeTextStyle !== '' && subTreeTextStyle !== element.__textStyle && !activeEditorStateReadOnly) {\n    element.setTextStyle(subTreeTextStyle);\n  }\n}\nfunction reconcileBlockDirection(element, dom) {\n  const previousSubTreeDirectionTextContent = dom.__lexicalDirTextContent || '';\n  const previousDirection = dom.__lexicalDir || '';\n  if (previousSubTreeDirectionTextContent !== subTreeDirectionedTextContent || previousDirection !== activeTextDirection) {\n    const hasEmptyDirectionedTextContent = subTreeDirectionedTextContent === '';\n    const direction = hasEmptyDirectionedTextContent ? activeTextDirection : getTextDirection(subTreeDirectionedTextContent);\n    if (direction !== previousDirection) {\n      const classList = dom.classList;\n      const theme = activeEditorConfig.theme;\n      let previousDirectionTheme = previousDirection !== null ? theme[previousDirection] : undefined;\n      let nextDirectionTheme = direction !== null ? theme[direction] : undefined;\n\n      // Remove the old theme classes if they exist\n      if (previousDirectionTheme !== undefined) {\n        if (typeof previousDirectionTheme === 'string') {\n          const classNamesArr = normalizeClassNames(previousDirectionTheme);\n          previousDirectionTheme = theme[previousDirection] = classNamesArr;\n        }\n\n        // @ts-ignore: intentional\n        classList.remove(...previousDirectionTheme);\n      }\n      if (direction === null || hasEmptyDirectionedTextContent && direction === 'ltr') {\n        // Remove direction\n        dom.removeAttribute('dir');\n      } else {\n        // Apply the new theme classes if they exist\n        if (nextDirectionTheme !== undefined) {\n          if (typeof nextDirectionTheme === 'string') {\n            const classNamesArr = normalizeClassNames(nextDirectionTheme);\n            // @ts-expect-error: intentional\n            nextDirectionTheme = theme[direction] = classNamesArr;\n          }\n          if (nextDirectionTheme !== undefined) {\n            classList.add(...nextDirectionTheme);\n          }\n        }\n\n        // Update direction\n        dom.dir = direction;\n      }\n      if (!activeEditorStateReadOnly) {\n        const writableNode = element.getWritable();\n        writableNode.__dir = direction;\n      }\n    }\n    activeTextDirection = direction;\n    dom.__lexicalDirTextContent = subTreeDirectionedTextContent;\n    dom.__lexicalDir = direction;\n  }\n}\nfunction $reconcileChildrenWithDirection(prevElement, nextElement, dom) {\n  const previousSubTreeDirectionTextContent = subTreeDirectionedTextContent;\n  subTreeDirectionedTextContent = '';\n  subTreeTextFormat = null;\n  subTreeTextStyle = '';\n  $reconcileChildren(prevElement, nextElement, nextElement.getDOMSlot(dom));\n  reconcileBlockDirection(nextElement, dom);\n  reconcileTextFormat(nextElement);\n  reconcileTextStyle(nextElement);\n  subTreeDirectionedTextContent = previousSubTreeDirectionTextContent;\n}\nfunction createChildrenArray(element, nodeMap) {\n  const children = [];\n  let nodeKey = element.__first;\n  while (nodeKey !== null) {\n    const node = nodeMap.get(nodeKey);\n    if (node === undefined) {\n      {\n        throw Error(`createChildrenArray: node does not exist in nodeMap`);\n      }\n    }\n    children.push(nodeKey);\n    nodeKey = node.__next;\n  }\n  return children;\n}\nfunction $reconcileChildren(prevElement, nextElement, slot) {\n  const previousSubTreeTextContent = subTreeTextContent;\n  const prevChildrenSize = prevElement.__size;\n  const nextChildrenSize = nextElement.__size;\n  subTreeTextContent = '';\n  const dom = slot.element;\n  if (prevChildrenSize === 1 && nextChildrenSize === 1) {\n    const prevFirstChildKey = prevElement.__first;\n    const nextFirstChildKey = nextElement.__first;\n    if (prevFirstChildKey === nextFirstChildKey) {\n      $reconcileNode(prevFirstChildKey, dom);\n    } else {\n      const lastDOM = getPrevElementByKeyOrThrow(prevFirstChildKey);\n      const replacementDOM = $createNode(nextFirstChildKey, null);\n      try {\n        dom.replaceChild(replacementDOM, lastDOM);\n      } catch (error) {\n        if (typeof error === 'object' && error != null) {\n          const msg = `${error.toString()} Parent: ${dom.tagName}, new child: {tag: ${replacementDOM.tagName} key: ${nextFirstChildKey}}, old child: {tag: ${lastDOM.tagName}, key: ${prevFirstChildKey}}.`;\n          throw new Error(msg);\n        } else {\n          throw error;\n        }\n      }\n      destroyNode(prevFirstChildKey, null);\n    }\n    const nextChildNode = activeNextNodeMap.get(nextFirstChildKey);\n    if ($isTextNode(nextChildNode)) {\n      if (subTreeTextFormat === null) {\n        subTreeTextFormat = nextChildNode.getFormat();\n      }\n      if (subTreeTextStyle === '') {\n        subTreeTextStyle = nextChildNode.getStyle();\n      }\n    }\n  } else {\n    const prevChildren = createChildrenArray(prevElement, activePrevNodeMap);\n    const nextChildren = createChildrenArray(nextElement, activeNextNodeMap);\n    if (!(prevChildren.length === prevChildrenSize)) {\n      throw Error(`$reconcileChildren: prevChildren.length !== prevChildrenSize`);\n    }\n    if (!(nextChildren.length === nextChildrenSize)) {\n      throw Error(`$reconcileChildren: nextChildren.length !== nextChildrenSize`);\n    }\n    if (prevChildrenSize === 0) {\n      if (nextChildrenSize !== 0) {\n        $createChildren(nextChildren, nextElement, 0, nextChildrenSize - 1, slot);\n      }\n    } else if (nextChildrenSize === 0) {\n      if (prevChildrenSize !== 0) {\n        const canUseFastPath = slot.after == null && slot.before == null && slot.element.__lexicalLineBreak == null;\n        destroyChildren(prevChildren, 0, prevChildrenSize - 1, canUseFastPath ? null : dom);\n        if (canUseFastPath) {\n          // Fast path for removing DOM nodes\n          dom.textContent = '';\n        }\n      }\n    } else {\n      $reconcileNodeChildren(nextElement, prevChildren, nextChildren, prevChildrenSize, nextChildrenSize, slot);\n    }\n  }\n  if ($textContentRequiresDoubleLinebreakAtEnd(nextElement)) {\n    subTreeTextContent += DOUBLE_LINE_BREAK;\n  }\n  dom.__lexicalTextContent = subTreeTextContent;\n  subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;\n}\nfunction $reconcileNode(key, parentDOM) {\n  const prevNode = activePrevNodeMap.get(key);\n  let nextNode = activeNextNodeMap.get(key);\n  if (prevNode === undefined || nextNode === undefined) {\n    {\n      throw Error(`reconcileNode: prevNode or nextNode does not exist in nodeMap`);\n    }\n  }\n  const isDirty = treatAllNodesAsDirty || activeDirtyLeaves.has(key) || activeDirtyElements.has(key);\n  const dom = getElementByKeyOrThrow(activeEditor$1, key);\n\n  // If the node key points to the same instance in both states\n  // and isn't dirty, we just update the text content cache\n  // and return the existing DOM Node.\n  if (prevNode === nextNode && !isDirty) {\n    if ($isElementNode(prevNode)) {\n      const previousSubTreeTextContent = dom.__lexicalTextContent;\n      if (previousSubTreeTextContent !== undefined) {\n        subTreeTextContent += previousSubTreeTextContent;\n        editorTextContent += previousSubTreeTextContent;\n      }\n      const previousSubTreeDirectionTextContent = dom.__lexicalDirTextContent;\n      if (previousSubTreeDirectionTextContent !== undefined) {\n        subTreeDirectionedTextContent += previousSubTreeDirectionTextContent;\n      }\n    } else {\n      const text = prevNode.getTextContent();\n      if ($isTextNode(prevNode) && !prevNode.isDirectionless()) {\n        subTreeDirectionedTextContent += text;\n      }\n      editorTextContent += text;\n      subTreeTextContent += text;\n    }\n    return dom;\n  }\n  // If the node key doesn't point to the same instance in both maps,\n  // it means it were cloned. If they're also dirty, we mark them as mutated.\n  if (prevNode !== nextNode && isDirty) {\n    setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, nextNode, 'updated');\n  }\n\n  // Update node. If it returns true, we need to unmount and re-create the node\n  if (nextNode.updateDOM(prevNode, dom, activeEditorConfig)) {\n    const replacementDOM = $createNode(key, null);\n    if (parentDOM === null) {\n      {\n        throw Error(`reconcileNode: parentDOM is null`);\n      }\n    }\n    parentDOM.replaceChild(replacementDOM, dom);\n    destroyNode(key, null);\n    return replacementDOM;\n  }\n  if ($isElementNode(prevNode) && $isElementNode(nextNode)) {\n    // Reconcile element children\n    const nextIndent = nextNode.__indent;\n    if (nextIndent !== prevNode.__indent) {\n      setElementIndent(dom, nextIndent);\n    }\n    const nextFormat = nextNode.__format;\n    if (nextFormat !== prevNode.__format) {\n      setElementFormat(dom, nextFormat);\n    }\n    if (isDirty) {\n      $reconcileChildrenWithDirection(prevNode, nextNode, dom);\n      if (!$isRootNode(nextNode) && !nextNode.isInline()) {\n        reconcileElementTerminatingLineBreak(prevNode, nextNode, dom);\n      }\n    }\n    if ($textContentRequiresDoubleLinebreakAtEnd(nextNode)) {\n      subTreeTextContent += DOUBLE_LINE_BREAK;\n      editorTextContent += DOUBLE_LINE_BREAK;\n    }\n  } else {\n    const text = nextNode.getTextContent();\n    if ($isDecoratorNode(nextNode)) {\n      const decorator = nextNode.decorate(activeEditor$1, activeEditorConfig);\n      if (decorator !== null) {\n        reconcileDecorator(key, decorator);\n      }\n    } else if ($isTextNode(nextNode) && !nextNode.isDirectionless()) {\n      // Handle text content, for LTR, LTR cases.\n      subTreeDirectionedTextContent += text;\n    }\n    subTreeTextContent += text;\n    editorTextContent += text;\n  }\n  if (!activeEditorStateReadOnly && $isRootNode(nextNode) && nextNode.__cachedText !== editorTextContent) {\n    // Cache the latest text content.\n    const nextRootNode = nextNode.getWritable();\n    nextRootNode.__cachedText = editorTextContent;\n    nextNode = nextRootNode;\n  }\n  {\n    // Freeze the node in DEV to prevent accidental mutations\n    Object.freeze(nextNode);\n  }\n  return dom;\n}\nfunction reconcileDecorator(key, decorator) {\n  let pendingDecorators = activeEditor$1._pendingDecorators;\n  const currentDecorators = activeEditor$1._decorators;\n  if (pendingDecorators === null) {\n    if (currentDecorators[key] === decorator) {\n      return;\n    }\n    pendingDecorators = cloneDecorators(activeEditor$1);\n  }\n  pendingDecorators[key] = decorator;\n}\nfunction getNextSibling(element) {\n  let nextSibling = element.nextSibling;\n  if (nextSibling !== null && nextSibling === activeEditor$1._blockCursorElement) {\n    nextSibling = nextSibling.nextSibling;\n  }\n  return nextSibling;\n}\nfunction $reconcileNodeChildren(nextElement, prevChildren, nextChildren, prevChildrenLength, nextChildrenLength, slot) {\n  const prevEndIndex = prevChildrenLength - 1;\n  const nextEndIndex = nextChildrenLength - 1;\n  let prevChildrenSet;\n  let nextChildrenSet;\n  let siblingDOM = slot.getFirstChild();\n  let prevIndex = 0;\n  let nextIndex = 0;\n  while (prevIndex <= prevEndIndex && nextIndex <= nextEndIndex) {\n    const prevKey = prevChildren[prevIndex];\n    const nextKey = nextChildren[nextIndex];\n    if (prevKey === nextKey) {\n      siblingDOM = getNextSibling($reconcileNode(nextKey, slot.element));\n      prevIndex++;\n      nextIndex++;\n    } else {\n      if (prevChildrenSet === undefined) {\n        prevChildrenSet = new Set(prevChildren);\n      }\n      if (nextChildrenSet === undefined) {\n        nextChildrenSet = new Set(nextChildren);\n      }\n      const nextHasPrevKey = nextChildrenSet.has(prevKey);\n      const prevHasNextKey = prevChildrenSet.has(nextKey);\n      if (!nextHasPrevKey) {\n        // Remove prev\n        siblingDOM = getNextSibling(getPrevElementByKeyOrThrow(prevKey));\n        destroyNode(prevKey, slot.element);\n        prevIndex++;\n      } else if (!prevHasNextKey) {\n        // Create next\n        $createNode(nextKey, slot.withBefore(siblingDOM));\n        nextIndex++;\n      } else {\n        // Move next\n        const childDOM = getElementByKeyOrThrow(activeEditor$1, nextKey);\n        if (childDOM === siblingDOM) {\n          siblingDOM = getNextSibling($reconcileNode(nextKey, slot.element));\n        } else {\n          slot.withBefore(siblingDOM).insertChild(childDOM);\n          $reconcileNode(nextKey, slot.element);\n        }\n        prevIndex++;\n        nextIndex++;\n      }\n    }\n    const node = activeNextNodeMap.get(nextKey);\n    if (node !== null && $isTextNode(node)) {\n      if (subTreeTextFormat === null) {\n        subTreeTextFormat = node.getFormat();\n      }\n      if (subTreeTextStyle === '') {\n        subTreeTextStyle = node.getStyle();\n      }\n    }\n  }\n  const appendNewChildren = prevIndex > prevEndIndex;\n  const removeOldChildren = nextIndex > nextEndIndex;\n  if (appendNewChildren && !removeOldChildren) {\n    const previousNode = nextChildren[nextEndIndex + 1];\n    const insertDOM = previousNode === undefined ? null : activeEditor$1.getElementByKey(previousNode);\n    $createChildren(nextChildren, nextElement, nextIndex, nextEndIndex, slot.withBefore(insertDOM));\n  } else if (removeOldChildren && !appendNewChildren) {\n    destroyChildren(prevChildren, prevIndex, prevEndIndex, slot.element);\n  }\n}\nfunction $reconcileRoot(prevEditorState, nextEditorState, editor, dirtyType, dirtyElements, dirtyLeaves) {\n  // We cache text content to make retrieval more efficient.\n  // The cache must be rebuilt during reconciliation to account for any changes.\n  subTreeTextContent = '';\n  editorTextContent = '';\n  subTreeDirectionedTextContent = '';\n  // Rather than pass around a load of arguments through the stack recursively\n  // we instead set them as bindings within the scope of the module.\n  treatAllNodesAsDirty = dirtyType === FULL_RECONCILE;\n  activeTextDirection = null;\n  activeEditor$1 = editor;\n  activeEditorConfig = editor._config;\n  activeEditorNodes = editor._nodes;\n  activeMutationListeners = activeEditor$1._listeners.mutation;\n  activeDirtyElements = dirtyElements;\n  activeDirtyLeaves = dirtyLeaves;\n  activePrevNodeMap = prevEditorState._nodeMap;\n  activeNextNodeMap = nextEditorState._nodeMap;\n  activeEditorStateReadOnly = nextEditorState._readOnly;\n  activePrevKeyToDOMMap = new Map(editor._keyToDOMMap);\n  // We keep track of mutated nodes so we can trigger mutation\n  // listeners later in the update cycle.\n  const currentMutatedNodes = new Map();\n  mutatedNodes = currentMutatedNodes;\n  $reconcileNode('root', null);\n  // We don't want a bunch of void checks throughout the scope\n  // so instead we make it seem that these values are always set.\n  // We also want to make sure we clear them down, otherwise we\n  // can leak memory.\n  // @ts-ignore\n  activeEditor$1 = undefined;\n  // @ts-ignore\n  activeEditorNodes = undefined;\n  // @ts-ignore\n  activeDirtyElements = undefined;\n  // @ts-ignore\n  activeDirtyLeaves = undefined;\n  // @ts-ignore\n  activePrevNodeMap = undefined;\n  // @ts-ignore\n  activeNextNodeMap = undefined;\n  // @ts-ignore\n  activeEditorConfig = undefined;\n  // @ts-ignore\n  activePrevKeyToDOMMap = undefined;\n  // @ts-ignore\n  mutatedNodes = undefined;\n  return currentMutatedNodes;\n}\nfunction storeDOMWithKey(key, dom, editor) {\n  const keyToDOMMap = editor._keyToDOMMap;\n  setNodeKeyOnDOMNode(dom, editor, key);\n  keyToDOMMap.set(key, dom);\n}\nfunction getPrevElementByKeyOrThrow(key) {\n  const element = activePrevKeyToDOMMap.get(key);\n  if (element === undefined) {\n    {\n      throw Error(`Reconciliation: could not find DOM element for node key ${key}`);\n    }\n  }\n  return element;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst PASS_THROUGH_COMMAND = Object.freeze({});\nconst ANDROID_COMPOSITION_LATENCY = 30;\nconst rootElementEvents = [['keydown', onKeyDown], ['pointerdown', onPointerDown], ['compositionstart', onCompositionStart], ['compositionend', onCompositionEnd], ['input', onInput], ['click', onClick], ['cut', PASS_THROUGH_COMMAND], ['copy', PASS_THROUGH_COMMAND], ['dragstart', PASS_THROUGH_COMMAND], ['dragover', PASS_THROUGH_COMMAND], ['dragend', PASS_THROUGH_COMMAND], ['paste', PASS_THROUGH_COMMAND], ['focus', PASS_THROUGH_COMMAND], ['blur', PASS_THROUGH_COMMAND], ['drop', PASS_THROUGH_COMMAND]];\nif (CAN_USE_BEFORE_INPUT) {\n  rootElementEvents.push(['beforeinput', (event, editor) => onBeforeInput(event, editor)]);\n}\nlet lastKeyDownTimeStamp = 0;\nlet lastKeyCode = null;\nlet lastBeforeInputInsertTextTimeStamp = 0;\nlet unprocessedBeforeInputData = null;\nconst rootElementsRegistered = new WeakMap();\nlet isSelectionChangeFromDOMUpdate = false;\nlet isSelectionChangeFromMouseDown = false;\nlet isInsertLineBreak = false;\nlet isFirefoxEndingComposition = false;\nlet collapsedSelectionFormat = [0, '', 0, 'root', 0];\n\n// This function is used to determine if Lexical should attempt to override\n// the default browser behavior for insertion of text and use its own internal\n// heuristics. This is an extremely important function, and makes much of Lexical\n// work as intended between different browsers and across word, line and character\n// boundary/formats. It also is important for text replacement, node schemas and\n// composition mechanics.\n\nfunction $shouldPreventDefaultAndInsertText(selection, domTargetRange, text, timeStamp, isBeforeInput) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const editor = getActiveEditor();\n  const domSelection = getDOMSelection(editor._window);\n  const domAnchorNode = domSelection !== null ? domSelection.anchorNode : null;\n  const anchorKey = anchor.key;\n  const backingAnchorElement = editor.getElementByKey(anchorKey);\n  const textLength = text.length;\n  return anchorKey !== focus.key ||\n  // If we're working with a non-text node.\n  !$isTextNode(anchorNode) ||\n  // If we are replacing a range with a single character or grapheme, and not composing.\n  (!isBeforeInput && (!CAN_USE_BEFORE_INPUT ||\n  // We check to see if there has been\n  // a recent beforeinput event for \"textInput\". If there has been one in the last\n  // 50ms then we proceed as normal. However, if there is not, then this is likely\n  // a dangling `input` event caused by execCommand('insertText').\n  lastBeforeInputInsertTextTimeStamp < timeStamp + 50) || anchorNode.isDirty() && textLength < 2 || doesContainGrapheme(text)) && anchor.offset !== focus.offset && !anchorNode.isComposing() ||\n  // Any non standard text node.\n  $isTokenOrSegmented(anchorNode) ||\n  // If the text length is more than a single character and we're either\n  // dealing with this in \"beforeinput\" or where the node has already recently\n  // been changed (thus is dirty).\n  anchorNode.isDirty() && textLength > 1 ||\n  // If the DOM selection element is not the same as the backing node during beforeinput.\n  (isBeforeInput || !CAN_USE_BEFORE_INPUT) && backingAnchorElement !== null && !anchorNode.isComposing() && domAnchorNode !== getDOMTextNode(backingAnchorElement) ||\n  // If TargetRange is not the same as the DOM selection; browser trying to edit random parts\n  // of the editor.\n  domSelection !== null && domTargetRange !== null && (!domTargetRange.collapsed || domTargetRange.startContainer !== domSelection.anchorNode || domTargetRange.startOffset !== domSelection.anchorOffset) ||\n  // Check if we're changing from bold to italics, or some other format.\n  anchorNode.getFormat() !== selection.format || anchorNode.getStyle() !== selection.style ||\n  // One last set of heuristics to check against.\n  $shouldInsertTextAfterOrBeforeTextNode(selection, anchorNode);\n}\nfunction shouldSkipSelectionChange(domNode, offset) {\n  return isDOMTextNode(domNode) && domNode.nodeValue !== null && offset !== 0 && offset !== domNode.nodeValue.length;\n}\nfunction onSelectionChange(domSelection, editor, isActive) {\n  const {\n    anchorNode: anchorDOM,\n    anchorOffset,\n    focusNode: focusDOM,\n    focusOffset\n  } = domSelection;\n  if (isSelectionChangeFromDOMUpdate) {\n    isSelectionChangeFromDOMUpdate = false;\n\n    // If native DOM selection is on a DOM element, then\n    // we should continue as usual, as Lexical's selection\n    // may have normalized to a better child. If the DOM\n    // element is a text node, we can safely apply this\n    // optimization and skip the selection change entirely.\n    // We also need to check if the offset is at the boundary,\n    // because in this case, we might need to normalize to a\n    // sibling instead.\n    if (shouldSkipSelectionChange(anchorDOM, anchorOffset) && shouldSkipSelectionChange(focusDOM, focusOffset)) {\n      return;\n    }\n  }\n  updateEditor(editor, () => {\n    // Non-active editor don't need any extra logic for selection, it only needs update\n    // to reconcile selection (set it to null) to ensure that only one editor has non-null selection.\n    if (!isActive) {\n      $setSelection(null);\n      return;\n    }\n    if (!isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n      return;\n    }\n    const selection = $getSelection();\n\n    // Update the selection format\n    if ($isRangeSelection(selection)) {\n      const anchor = selection.anchor;\n      const anchorNode = anchor.getNode();\n      if (selection.isCollapsed()) {\n        // Badly interpreted range selection when collapsed - #1482\n        if (domSelection.type === 'Range' && domSelection.anchorNode === domSelection.focusNode) {\n          selection.dirty = true;\n        }\n\n        // If we have marked a collapsed selection format, and we're\n        // within the given time range – then attempt to use that format\n        // instead of getting the format from the anchor node.\n        const windowEvent = getWindow(editor).event;\n        const currentTimeStamp = windowEvent ? windowEvent.timeStamp : performance.now();\n        const [lastFormat, lastStyle, lastOffset, lastKey, timeStamp] = collapsedSelectionFormat;\n        const root = $getRoot();\n        const isRootTextContentEmpty = editor.isComposing() === false && root.getTextContent() === '';\n        if (currentTimeStamp < timeStamp + 200 && anchor.offset === lastOffset && anchor.key === lastKey) {\n          selection.format = lastFormat;\n          selection.style = lastStyle;\n        } else {\n          if (anchor.type === 'text') {\n            if (!$isTextNode(anchorNode)) {\n              throw Error(`Point.getNode() must return TextNode when type is text`);\n            }\n            selection.format = anchorNode.getFormat();\n            selection.style = anchorNode.getStyle();\n          } else if (anchor.type === 'element' && !isRootTextContentEmpty) {\n            if (!$isElementNode(anchorNode)) {\n              throw Error(`Point.getNode() must return ElementNode when type is element`);\n            }\n            const lastNode = anchor.getNode();\n            selection.style = '';\n            if (\n            // This previously applied to all ParagraphNode\n            lastNode.isEmpty()) {\n              selection.format = lastNode.getTextFormat();\n              selection.style = lastNode.getTextStyle();\n            } else {\n              selection.format = 0;\n            }\n          }\n        }\n      } else {\n        const anchorKey = anchor.key;\n        const focus = selection.focus;\n        const focusKey = focus.key;\n        const nodes = selection.getNodes();\n        const nodesLength = nodes.length;\n        const isBackward = selection.isBackward();\n        const startOffset = isBackward ? focusOffset : anchorOffset;\n        const endOffset = isBackward ? anchorOffset : focusOffset;\n        const startKey = isBackward ? focusKey : anchorKey;\n        const endKey = isBackward ? anchorKey : focusKey;\n        let combinedFormat = IS_ALL_FORMATTING;\n        let hasTextNodes = false;\n        for (let i = 0; i < nodesLength; i++) {\n          const node = nodes[i];\n          const textContentSize = node.getTextContentSize();\n          if ($isTextNode(node) && textContentSize !== 0 &&\n          // Exclude empty text nodes at boundaries resulting from user's selection\n          !(i === 0 && node.__key === startKey && startOffset === textContentSize || i === nodesLength - 1 && node.__key === endKey && endOffset === 0)) {\n            // TODO: what about style?\n            hasTextNodes = true;\n            combinedFormat &= node.getFormat();\n            if (combinedFormat === 0) {\n              break;\n            }\n          }\n        }\n        selection.format = hasTextNodes ? combinedFormat : 0;\n      }\n    }\n    dispatchCommand(editor, SELECTION_CHANGE_COMMAND, undefined);\n  });\n}\n\n// This is a work-around is mainly Chrome specific bug where if you select\n// the contents of an empty block, you cannot easily unselect anything.\n// This results in a tiny selection box that looks buggy/broken. This can\n// also help other browsers when selection might \"appear\" lost, when it\n// really isn't.\nfunction onClick(event, editor) {\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n    const domSelection = getDOMSelection(editor._window);\n    const lastSelection = $getPreviousSelection();\n    if (domSelection) {\n      if ($isRangeSelection(selection)) {\n        const anchor = selection.anchor;\n        const anchorNode = anchor.getNode();\n        if (anchor.type === 'element' && anchor.offset === 0 && selection.isCollapsed() && !$isRootNode(anchorNode) && $getRoot().getChildrenSize() === 1 && anchorNode.getTopLevelElementOrThrow().isEmpty() && lastSelection !== null && selection.is(lastSelection)) {\n          domSelection.removeAllRanges();\n          selection.dirty = true;\n        } else if (event.detail === 3 && !selection.isCollapsed()) {\n          // Triple click causing selection to overflow into the nearest element. In that\n          // case visually it looks like a single element content is selected, focus node\n          // is actually at the beginning of the next element (if present) and any manipulations\n          // with selection (formatting) are affecting second element as well\n          const focus = selection.focus;\n          const focusNode = focus.getNode();\n          if (anchorNode !== focusNode) {\n            if ($isElementNode(anchorNode)) {\n              anchorNode.select(0);\n            } else {\n              anchorNode.getParentOrThrow().select(0);\n            }\n          }\n        }\n      } else if (event.pointerType === 'touch') {\n        // This is used to update the selection on touch devices when the user clicks on text after a\n        // node selection. See isSelectionChangeFromMouseDown for the inverse\n        const domAnchorNode = domSelection.anchorNode;\n        // If the user is attempting to click selection back onto text, then\n        // we should attempt create a range selection.\n        // When we click on an empty paragraph node or the end of a paragraph that ends\n        // with an image/poll, the nodeType will be ELEMENT_NODE\n        if (isHTMLElement(domAnchorNode) || isDOMTextNode(domAnchorNode)) {\n          const newSelection = $internalCreateRangeSelection(lastSelection, domSelection, editor, event);\n          $setSelection(newSelection);\n        }\n      }\n    }\n    dispatchCommand(editor, CLICK_COMMAND, event);\n  });\n}\nfunction onPointerDown(event, editor) {\n  // TODO implement text drag & drop\n  const target = event.target;\n  const pointerType = event.pointerType;\n  if (isDOMNode(target) && pointerType !== 'touch' && event.button === 0) {\n    updateEditor(editor, () => {\n      // Drag & drop should not recompute selection until mouse up; otherwise the initially\n      // selected content is lost.\n      if (!$isSelectionCapturedInDecorator(target)) {\n        isSelectionChangeFromMouseDown = true;\n      }\n    });\n  }\n}\nfunction getTargetRange(event) {\n  if (!event.getTargetRanges) {\n    return null;\n  }\n  const targetRanges = event.getTargetRanges();\n  if (targetRanges.length === 0) {\n    return null;\n  }\n  return targetRanges[0];\n}\nfunction $canRemoveText(anchorNode, focusNode) {\n  return anchorNode !== focusNode || $isElementNode(anchorNode) || $isElementNode(focusNode) || !anchorNode.isToken() || !focusNode.isToken();\n}\nfunction isPossiblyAndroidKeyPress(timeStamp) {\n  return lastKeyCode === 'MediaLast' && timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY;\n}\nfunction onBeforeInput(event, editor) {\n  const inputType = event.inputType;\n  const targetRange = getTargetRange(event);\n\n  // We let the browser do its own thing for composition.\n  if (inputType === 'deleteCompositionText' ||\n  // If we're pasting in FF, we shouldn't get this event\n  // as the `paste` event should have triggered, unless the\n  // user has dom.event.clipboardevents.enabled disabled in\n  // about:config. In that case, we need to process the\n  // pasted content in the DOM mutation phase.\n  IS_FIREFOX && isFirefoxClipboardEvents(editor)) {\n    return;\n  } else if (inputType === 'insertCompositionText') {\n    return;\n  }\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n    if (inputType === 'deleteContentBackward') {\n      if (selection === null) {\n        // Use previous selection\n        const prevSelection = $getPreviousSelection();\n        if (!$isRangeSelection(prevSelection)) {\n          return;\n        }\n        $setSelection(prevSelection.clone());\n      }\n      if ($isRangeSelection(selection)) {\n        const isSelectionAnchorSameAsFocus = selection.anchor.key === selection.focus.key;\n        if (isPossiblyAndroidKeyPress(event.timeStamp) && editor.isComposing() && isSelectionAnchorSameAsFocus) {\n          $setCompositionKey(null);\n          lastKeyDownTimeStamp = 0;\n          // Fixes an Android bug where selection flickers when backspacing\n          setTimeout(() => {\n            updateEditor(editor, () => {\n              $setCompositionKey(null);\n            });\n          }, ANDROID_COMPOSITION_LATENCY);\n          if ($isRangeSelection(selection)) {\n            const anchorNode = selection.anchor.getNode();\n            anchorNode.markDirty();\n            selection.format = anchorNode.getFormat();\n            if (!$isTextNode(anchorNode)) {\n              throw Error(`Anchor node must be a TextNode`);\n            }\n            selection.style = anchorNode.getStyle();\n          }\n        } else {\n          $setCompositionKey(null);\n          event.preventDefault();\n          // Chromium Android at the moment seems to ignore the preventDefault\n          // on 'deleteContentBackward' and still deletes the content. Which leads\n          // to multiple deletions. So we let the browser handle the deletion in this case.\n          const selectedNode = selection.anchor.getNode();\n          const selectedNodeText = selectedNode.getTextContent();\n          // When the target node has `canInsertTextAfter` set to false, the first deletion\n          // doesn't have an effect, so we need to handle it with Lexical.\n          const selectedNodeCanInsertTextAfter = selectedNode.canInsertTextAfter();\n          const hasSelectedAllTextInNode = selection.anchor.offset === 0 && selection.focus.offset === selectedNodeText.length;\n          const shouldLetBrowserHandleDelete = IS_ANDROID_CHROME && isSelectionAnchorSameAsFocus && !hasSelectedAllTextInNode && selectedNodeCanInsertTextAfter;\n          if (!shouldLetBrowserHandleDelete) {\n            dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);\n          }\n        }\n        return;\n      }\n    }\n    if (!$isRangeSelection(selection)) {\n      return;\n    }\n    const data = event.data;\n\n    // This represents the case when two beforeinput events are triggered at the same time (without a\n    // full event loop ending at input). This happens with MacOS with the default keyboard settings,\n    // a combination of autocorrection + autocapitalization.\n    // Having Lexical run everything in controlled mode would fix the issue without additional code\n    // but this would kill the massive performance win from the most common typing event.\n    // Alternatively, when this happens we can prematurely update our EditorState based on the DOM\n    // content, a job that would usually be the input event's responsibility.\n    if (unprocessedBeforeInputData !== null) {\n      $updateSelectedTextFromDOM(false, editor, unprocessedBeforeInputData);\n    }\n    if ((!selection.dirty || unprocessedBeforeInputData !== null) && selection.isCollapsed() && !$isRootNode(selection.anchor.getNode()) && targetRange !== null) {\n      selection.applyDOMRange(targetRange);\n    }\n    unprocessedBeforeInputData = null;\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    if (inputType === 'insertText' || inputType === 'insertTranspose') {\n      if (data === '\\n') {\n        event.preventDefault();\n        dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\n      } else if (data === DOUBLE_LINE_BREAK) {\n        event.preventDefault();\n        dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND, undefined);\n      } else if (data == null && event.dataTransfer) {\n        // Gets around a Safari text replacement bug.\n        const text = event.dataTransfer.getData('text/plain');\n        event.preventDefault();\n        selection.insertRawText(text);\n      } else if (data != null && $shouldPreventDefaultAndInsertText(selection, targetRange, data, event.timeStamp, true)) {\n        event.preventDefault();\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, data);\n      } else {\n        unprocessedBeforeInputData = data;\n      }\n      lastBeforeInputInsertTextTimeStamp = event.timeStamp;\n      return;\n    }\n\n    // Prevent the browser from carrying out\n    // the input event, so we can control the\n    // output.\n    event.preventDefault();\n    switch (inputType) {\n      case 'insertFromYank':\n      case 'insertFromDrop':\n      case 'insertReplacementText':\n        {\n          dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, event);\n          break;\n        }\n      case 'insertFromComposition':\n        {\n          // This is the end of composition\n          $setCompositionKey(null);\n          dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, event);\n          break;\n        }\n      case 'insertLineBreak':\n        {\n          // Used for Android\n          $setCompositionKey(null);\n          dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\n          break;\n        }\n      case 'insertParagraph':\n        {\n          // Used for Android\n          $setCompositionKey(null);\n\n          // Safari does not provide the type \"insertLineBreak\".\n          // So instead, we need to infer it from the keyboard event.\n          // We do not apply this logic to iOS to allow newline auto-capitalization\n          // work without creating linebreaks when pressing Enter\n          if (isInsertLineBreak && !IS_IOS) {\n            isInsertLineBreak = false;\n            dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\n          } else {\n            dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND, undefined);\n          }\n          break;\n        }\n      case 'insertFromPaste':\n      case 'insertFromPasteAsQuotation':\n        {\n          dispatchCommand(editor, PASTE_COMMAND, event);\n          break;\n        }\n      case 'deleteByComposition':\n        {\n          if ($canRemoveText(anchorNode, focusNode)) {\n            dispatchCommand(editor, REMOVE_TEXT_COMMAND, event);\n          }\n          break;\n        }\n      case 'deleteByDrag':\n      case 'deleteByCut':\n        {\n          dispatchCommand(editor, REMOVE_TEXT_COMMAND, event);\n          break;\n        }\n      case 'deleteContent':\n        {\n          dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);\n          break;\n        }\n      case 'deleteWordBackward':\n        {\n          dispatchCommand(editor, DELETE_WORD_COMMAND, true);\n          break;\n        }\n      case 'deleteWordForward':\n        {\n          dispatchCommand(editor, DELETE_WORD_COMMAND, false);\n          break;\n        }\n      case 'deleteHardLineBackward':\n      case 'deleteSoftLineBackward':\n        {\n          dispatchCommand(editor, DELETE_LINE_COMMAND, true);\n          break;\n        }\n      case 'deleteContentForward':\n      case 'deleteHardLineForward':\n      case 'deleteSoftLineForward':\n        {\n          dispatchCommand(editor, DELETE_LINE_COMMAND, false);\n          break;\n        }\n      case 'formatStrikeThrough':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'strikethrough');\n          break;\n        }\n      case 'formatBold':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'bold');\n          break;\n        }\n      case 'formatItalic':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'italic');\n          break;\n        }\n      case 'formatUnderline':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'underline');\n          break;\n        }\n      case 'historyUndo':\n        {\n          dispatchCommand(editor, UNDO_COMMAND, undefined);\n          break;\n        }\n      case 'historyRedo':\n        {\n          dispatchCommand(editor, REDO_COMMAND, undefined);\n          break;\n        }\n      // NO-OP\n    }\n  });\n}\nfunction onInput(event, editor) {\n  // We don't want the onInput to bubble, in the case of nested editors.\n  event.stopPropagation();\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n    const data = event.data;\n    const targetRange = getTargetRange(event);\n    if (data != null && $isRangeSelection(selection) && $shouldPreventDefaultAndInsertText(selection, targetRange, data, event.timeStamp, false)) {\n      // Given we're over-riding the default behavior, we will need\n      // to ensure to disable composition before dispatching the\n      // insertText command for when changing the sequence for FF.\n      if (isFirefoxEndingComposition) {\n        $onCompositionEndImpl(editor, data);\n        isFirefoxEndingComposition = false;\n      }\n      const anchor = selection.anchor;\n      const anchorNode = anchor.getNode();\n      const domSelection = getDOMSelection(editor._window);\n      if (domSelection === null) {\n        return;\n      }\n      const isBackward = selection.isBackward();\n      const startOffset = isBackward ? selection.anchor.offset : selection.focus.offset;\n      const endOffset = isBackward ? selection.focus.offset : selection.anchor.offset;\n      // If the content is the same as inserted, then don't dispatch an insertion.\n      // Given onInput doesn't take the current selection (it uses the previous)\n      // we can compare that against what the DOM currently says.\n      if (!CAN_USE_BEFORE_INPUT || selection.isCollapsed() || !$isTextNode(anchorNode) || domSelection.anchorNode === null || anchorNode.getTextContent().slice(0, startOffset) + data + anchorNode.getTextContent().slice(startOffset + endOffset) !== getAnchorTextFromDOM(domSelection.anchorNode)) {\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, data);\n      }\n      const textLength = data.length;\n\n      // Another hack for FF, as it's possible that the IME is still\n      // open, even though compositionend has already fired (sigh).\n      if (IS_FIREFOX && textLength > 1 && event.inputType === 'insertCompositionText' && !editor.isComposing()) {\n        selection.anchor.offset -= textLength;\n      }\n\n      // This ensures consistency on Android.\n      if (!IS_SAFARI && !IS_IOS && !IS_APPLE_WEBKIT && editor.isComposing()) {\n        lastKeyDownTimeStamp = 0;\n        $setCompositionKey(null);\n      }\n    } else {\n      const characterData = data !== null ? data : undefined;\n      $updateSelectedTextFromDOM(false, editor, characterData);\n\n      // onInput always fires after onCompositionEnd for FF.\n      if (isFirefoxEndingComposition) {\n        $onCompositionEndImpl(editor, data || undefined);\n        isFirefoxEndingComposition = false;\n      }\n    }\n\n    // Also flush any other mutations that might have occurred\n    // since the change.\n    $flushMutations();\n  });\n  unprocessedBeforeInputData = null;\n}\nfunction onCompositionStart(event, editor) {\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n    if ($isRangeSelection(selection) && !editor.isComposing()) {\n      const anchor = selection.anchor;\n      const node = selection.anchor.getNode();\n      $setCompositionKey(anchor.key);\n      if (\n      // If it has been 30ms since the last keydown, then we should\n      // apply the empty space heuristic. We can't do this for Safari,\n      // as the keydown fires after composition start.\n      event.timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY ||\n      // FF has issues around composing multibyte characters, so we also\n      // need to invoke the empty space heuristic below.\n      anchor.type === 'element' || !selection.isCollapsed() || node.getFormat() !== selection.format || $isTextNode(node) && node.getStyle() !== selection.style) {\n        // We insert a zero width character, ready for the composition\n        // to get inserted into the new node we create. If\n        // we don't do this, Safari will fail on us because\n        // there is no text node matching the selection.\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, COMPOSITION_START_CHAR);\n      }\n    }\n  });\n}\nfunction $onCompositionEndImpl(editor, data) {\n  const compositionKey = editor._compositionKey;\n  $setCompositionKey(null);\n\n  // Handle termination of composition.\n  if (compositionKey !== null && data != null) {\n    // Composition can sometimes move to an adjacent DOM node when backspacing.\n    // So check for the empty case.\n    if (data === '') {\n      const node = $getNodeByKey(compositionKey);\n      const textNode = getDOMTextNode(editor.getElementByKey(compositionKey));\n      if (textNode !== null && textNode.nodeValue !== null && $isTextNode(node)) {\n        $updateTextNodeFromDOMContent(node, textNode.nodeValue, null, null, true);\n      }\n      return;\n    }\n\n    // Composition can sometimes be that of a new line. In which case, we need to\n    // handle that accordingly.\n    if (data[data.length - 1] === '\\n') {\n      const selection = $getSelection();\n      if ($isRangeSelection(selection)) {\n        // If the last character is a line break, we also need to insert\n        // a line break.\n        const focus = selection.focus;\n        selection.anchor.set(focus.key, focus.offset, focus.type);\n        dispatchCommand(editor, KEY_ENTER_COMMAND, null);\n        return;\n      }\n    }\n  }\n  $updateSelectedTextFromDOM(true, editor, data);\n}\nfunction onCompositionEnd(event, editor) {\n  // Firefox fires onCompositionEnd before onInput, but Chrome/Webkit,\n  // fire onInput before onCompositionEnd. To ensure the sequence works\n  // like Chrome/Webkit we use the isFirefoxEndingComposition flag to\n  // defer handling of onCompositionEnd in Firefox till we have processed\n  // the logic in onInput.\n  if (IS_FIREFOX) {\n    isFirefoxEndingComposition = true;\n  } else {\n    updateEditor(editor, () => {\n      $onCompositionEndImpl(editor, event.data);\n    });\n  }\n}\nfunction onKeyDown(event, editor) {\n  lastKeyDownTimeStamp = event.timeStamp;\n  lastKeyCode = event.key;\n  if (editor.isComposing()) {\n    return;\n  }\n  const {\n    key,\n    shiftKey,\n    ctrlKey,\n    metaKey,\n    altKey\n  } = event;\n  if (dispatchCommand(editor, KEY_DOWN_COMMAND, event)) {\n    return;\n  }\n  if (key == null) {\n    return;\n  }\n  if (isMoveForward(key, ctrlKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_RIGHT_COMMAND, event);\n  } else if (isMoveToEnd(key, ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, MOVE_TO_END, event);\n  } else if (isMoveBackward(key, ctrlKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_LEFT_COMMAND, event);\n  } else if (isMoveToStart(key, ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, MOVE_TO_START, event);\n  } else if (isMoveUp(key, ctrlKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_UP_COMMAND, event);\n  } else if (isMoveDown(key, ctrlKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_DOWN_COMMAND, event);\n  } else if (isLineBreak(key, shiftKey)) {\n    isInsertLineBreak = true;\n    dispatchCommand(editor, KEY_ENTER_COMMAND, event);\n  } else if (isSpace(key)) {\n    dispatchCommand(editor, KEY_SPACE_COMMAND, event);\n  } else if (isOpenLineBreak(key, ctrlKey)) {\n    event.preventDefault();\n    isInsertLineBreak = true;\n    dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, true);\n  } else if (isParagraph(key, shiftKey)) {\n    isInsertLineBreak = false;\n    dispatchCommand(editor, KEY_ENTER_COMMAND, event);\n  } else if (isDeleteBackward(key, altKey, metaKey, ctrlKey)) {\n    if (isBackspace(key)) {\n      dispatchCommand(editor, KEY_BACKSPACE_COMMAND, event);\n    } else {\n      event.preventDefault();\n      dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);\n    }\n  } else if (isEscape(key)) {\n    dispatchCommand(editor, KEY_ESCAPE_COMMAND, event);\n  } else if (isDeleteForward(key, ctrlKey, shiftKey, altKey, metaKey)) {\n    if (isDelete(key)) {\n      dispatchCommand(editor, KEY_DELETE_COMMAND, event);\n    } else {\n      event.preventDefault();\n      dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);\n    }\n  } else if (isDeleteWordBackward(key, altKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_WORD_COMMAND, true);\n  } else if (isDeleteWordForward(key, altKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_WORD_COMMAND, false);\n  } else if (isDeleteLineBackward(key, metaKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_LINE_COMMAND, true);\n  } else if (isDeleteLineForward(key, metaKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_LINE_COMMAND, false);\n  } else if (isBold(key, altKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'bold');\n  } else if (isUnderline(key, altKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'underline');\n  } else if (isItalic(key, altKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'italic');\n  } else if (isTab(key, altKey, ctrlKey, metaKey)) {\n    dispatchCommand(editor, KEY_TAB_COMMAND, event);\n  } else if (isUndo(key, shiftKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, UNDO_COMMAND, undefined);\n  } else if (isRedo(key, shiftKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, REDO_COMMAND, undefined);\n  } else {\n    const prevSelection = editor._editorState._selection;\n    if (prevSelection !== null && !$isRangeSelection(prevSelection)) {\n      // Only RangeSelection can use the native cut/copy/select all\n      if (isCopy(key, shiftKey, metaKey, ctrlKey)) {\n        event.preventDefault();\n        dispatchCommand(editor, COPY_COMMAND, event);\n      } else if (isCut(key, shiftKey, metaKey, ctrlKey)) {\n        event.preventDefault();\n        dispatchCommand(editor, CUT_COMMAND, event);\n      } else if (isSelectAll(key, metaKey, ctrlKey)) {\n        event.preventDefault();\n        dispatchCommand(editor, SELECT_ALL_COMMAND, event);\n      }\n      // FF does it well (no need to override behavior)\n    } else if (!IS_FIREFOX && isSelectAll(key, metaKey, ctrlKey)) {\n      event.preventDefault();\n      dispatchCommand(editor, SELECT_ALL_COMMAND, event);\n    }\n  }\n  if (isModifier(ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_MODIFIER_COMMAND, event);\n  }\n}\nfunction getRootElementRemoveHandles(rootElement) {\n  // @ts-expect-error: internal field\n  let eventHandles = rootElement.__lexicalEventHandles;\n  if (eventHandles === undefined) {\n    eventHandles = [];\n    // @ts-expect-error: internal field\n    rootElement.__lexicalEventHandles = eventHandles;\n  }\n  return eventHandles;\n}\n\n// Mapping root editors to their active nested editors, contains nested editors\n// mapping only, so if root editor is selected map will have no reference to free up memory\nconst activeNestedEditorsMap = new Map();\nfunction onDocumentSelectionChange(event) {\n  const domSelection = getDOMSelectionFromTarget(event.target);\n  if (domSelection === null) {\n    return;\n  }\n  const nextActiveEditor = getNearestEditorFromDOMNode(domSelection.anchorNode);\n  if (nextActiveEditor === null) {\n    return;\n  }\n  if (isSelectionChangeFromMouseDown) {\n    isSelectionChangeFromMouseDown = false;\n    updateEditor(nextActiveEditor, () => {\n      const lastSelection = $getPreviousSelection();\n      const domAnchorNode = domSelection.anchorNode;\n      if (isHTMLElement(domAnchorNode) || isDOMTextNode(domAnchorNode)) {\n        // If the user is attempting to click selection back onto text, then\n        // we should attempt create a range selection.\n        // When we click on an empty paragraph node or the end of a paragraph that ends\n        // with an image/poll, the nodeType will be ELEMENT_NODE\n        const newSelection = $internalCreateRangeSelection(lastSelection, domSelection, nextActiveEditor, event);\n        $setSelection(newSelection);\n      }\n    });\n  }\n\n  // When editor receives selection change event, we're checking if\n  // it has any sibling editors (within same parent editor) that were active\n  // before, and trigger selection change on it to nullify selection.\n  const editors = getEditorsToPropagate(nextActiveEditor);\n  const rootEditor = editors[editors.length - 1];\n  const rootEditorKey = rootEditor._key;\n  const activeNestedEditor = activeNestedEditorsMap.get(rootEditorKey);\n  const prevActiveEditor = activeNestedEditor || rootEditor;\n  if (prevActiveEditor !== nextActiveEditor) {\n    onSelectionChange(domSelection, prevActiveEditor, false);\n  }\n  onSelectionChange(domSelection, nextActiveEditor, true);\n\n  // If newly selected editor is nested, then add it to the map, clean map otherwise\n  if (nextActiveEditor !== rootEditor) {\n    activeNestedEditorsMap.set(rootEditorKey, nextActiveEditor);\n  } else if (activeNestedEditor) {\n    activeNestedEditorsMap.delete(rootEditorKey);\n  }\n}\nfunction stopLexicalPropagation(event) {\n  // We attach a special property to ensure the same event doesn't re-fire\n  // for parent editors.\n  // @ts-ignore\n  event._lexicalHandled = true;\n}\nfunction hasStoppedLexicalPropagation(event) {\n  // @ts-ignore\n  const stopped = event._lexicalHandled === true;\n  return stopped;\n}\nfunction addRootElementEvents(rootElement, editor) {\n  // We only want to have a single global selectionchange event handler, shared\n  // between all editor instances.\n  const doc = rootElement.ownerDocument;\n  const documentRootElementsCount = rootElementsRegistered.get(doc);\n  if (documentRootElementsCount === undefined || documentRootElementsCount < 1) {\n    doc.addEventListener('selectionchange', onDocumentSelectionChange);\n  }\n  rootElementsRegistered.set(doc, (documentRootElementsCount || 0) + 1);\n\n  // @ts-expect-error: internal field\n  rootElement.__lexicalEditor = editor;\n  const removeHandles = getRootElementRemoveHandles(rootElement);\n  for (let i = 0; i < rootElementEvents.length; i++) {\n    const [eventName, onEvent] = rootElementEvents[i];\n    const eventHandler = typeof onEvent === 'function' ? event => {\n      if (hasStoppedLexicalPropagation(event)) {\n        return;\n      }\n      stopLexicalPropagation(event);\n      if (editor.isEditable() || eventName === 'click') {\n        onEvent(event, editor);\n      }\n    } : event => {\n      if (hasStoppedLexicalPropagation(event)) {\n        return;\n      }\n      stopLexicalPropagation(event);\n      const isEditable = editor.isEditable();\n      switch (eventName) {\n        case 'cut':\n          return isEditable && dispatchCommand(editor, CUT_COMMAND, event);\n        case 'copy':\n          return dispatchCommand(editor, COPY_COMMAND, event);\n        case 'paste':\n          return isEditable && dispatchCommand(editor, PASTE_COMMAND, event);\n        case 'dragstart':\n          return isEditable && dispatchCommand(editor, DRAGSTART_COMMAND, event);\n        case 'dragover':\n          return isEditable && dispatchCommand(editor, DRAGOVER_COMMAND, event);\n        case 'dragend':\n          return isEditable && dispatchCommand(editor, DRAGEND_COMMAND, event);\n        case 'focus':\n          return isEditable && dispatchCommand(editor, FOCUS_COMMAND, event);\n        case 'blur':\n          {\n            return isEditable && dispatchCommand(editor, BLUR_COMMAND, event);\n          }\n        case 'drop':\n          return isEditable && dispatchCommand(editor, DROP_COMMAND, event);\n      }\n    };\n    rootElement.addEventListener(eventName, eventHandler);\n    removeHandles.push(() => {\n      rootElement.removeEventListener(eventName, eventHandler);\n    });\n  }\n}\nfunction removeRootElementEvents(rootElement) {\n  const doc = rootElement.ownerDocument;\n  const documentRootElementsCount = rootElementsRegistered.get(doc);\n  if (!(documentRootElementsCount !== undefined)) {\n    throw Error(`Root element not registered`);\n  } // We only want to have a single global selectionchange event handler, shared\n  // between all editor instances.\n  const newCount = documentRootElementsCount - 1;\n  if (!(newCount >= 0)) {\n    throw Error(`Root element count less than 0`);\n  }\n  rootElementsRegistered.set(doc, newCount);\n  if (newCount === 0) {\n    doc.removeEventListener('selectionchange', onDocumentSelectionChange);\n  }\n  const editor = getEditorPropertyFromDOMNode(rootElement);\n  if (isLexicalEditor(editor)) {\n    cleanActiveNestedEditorsMap(editor);\n    // @ts-expect-error: internal field\n    rootElement.__lexicalEditor = null;\n  } else if (editor) {\n    {\n      throw Error(`Attempted to remove event handlers from a node that does not belong to this build of Lexical`);\n    }\n  }\n  const removeHandles = getRootElementRemoveHandles(rootElement);\n  for (let i = 0; i < removeHandles.length; i++) {\n    removeHandles[i]();\n  }\n\n  // @ts-expect-error: internal field\n  rootElement.__lexicalEventHandles = [];\n}\nfunction cleanActiveNestedEditorsMap(editor) {\n  if (editor._parentEditor !== null) {\n    // For nested editor cleanup map if this editor was marked as active\n    const editors = getEditorsToPropagate(editor);\n    const rootEditor = editors[editors.length - 1];\n    const rootEditorKey = rootEditor._key;\n    if (activeNestedEditorsMap.get(rootEditorKey) === editor) {\n      activeNestedEditorsMap.delete(rootEditorKey);\n    }\n  } else {\n    // For top-level editors cleanup map\n    activeNestedEditorsMap.delete(editor._key);\n  }\n}\nfunction markSelectionChangeFromDOMUpdate() {\n  isSelectionChangeFromDOMUpdate = true;\n}\nfunction markCollapsedSelectionFormat(format, style, offset, key, timeStamp) {\n  collapsedSelectionFormat = [format, style, offset, key, timeStamp];\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n/**\n * The base type for all serialized nodes\n */\n\n/**\n * Omit the children, type, and version properties from the given SerializedLexicalNode definition.\n */\n\n/** @internal */\n\nfunction $removeNode(nodeToRemove, restoreSelection, preserveEmptyParent) {\n  errorOnReadOnly();\n  const key = nodeToRemove.__key;\n  const parent = nodeToRemove.getParent();\n  if (parent === null) {\n    return;\n  }\n  const selection = $maybeMoveChildrenSelectionToParent(nodeToRemove);\n  let selectionMoved = false;\n  if ($isRangeSelection(selection) && restoreSelection) {\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    if (anchor.key === key) {\n      moveSelectionPointToSibling(anchor, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());\n      selectionMoved = true;\n    }\n    if (focus.key === key) {\n      moveSelectionPointToSibling(focus, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());\n      selectionMoved = true;\n    }\n  } else if ($isNodeSelection(selection) && restoreSelection && nodeToRemove.isSelected()) {\n    nodeToRemove.selectPrevious();\n  }\n  if ($isRangeSelection(selection) && restoreSelection && !selectionMoved) {\n    // Doing this is O(n) so lets avoid it unless we need to do it\n    const index = nodeToRemove.getIndexWithinParent();\n    removeFromParent(nodeToRemove);\n    $updateElementSelectionOnCreateDeleteNode(selection, parent, index, -1);\n  } else {\n    removeFromParent(nodeToRemove);\n  }\n  if (!preserveEmptyParent && !$isRootOrShadowRoot(parent) && !parent.canBeEmpty() && parent.isEmpty()) {\n    $removeNode(parent, restoreSelection);\n  }\n  if (restoreSelection && $isRootNode(parent) && parent.isEmpty()) {\n    parent.selectEnd();\n  }\n}\nclass LexicalNode {\n  // Allow us to look up the type including static props\n\n  /** @internal */\n\n  /** @internal */\n  //@ts-ignore We set the key in the constructor.\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  // Flow doesn't support abstract classes unfortunately, so we can't _force_\n  // subclasses of Node to implement statics. All subclasses of Node should have\n  // a static getType and clone method though. We define getType and clone here so we can call it\n  // on any  Node, and we throw this error by default since the subclass should provide\n  // their own implementation.\n  /**\n   * Returns the string type of this node. Every node must\n   * implement this and it MUST BE UNIQUE amongst nodes registered\n   * on the editor.\n   *\n   */\n  static getType() {\n    {\n      throw Error(`LexicalNode: Node ${this.name} does not implement .getType().`);\n    }\n  }\n\n  /**\n   * Clones this node, creating a new node with a different key\n   * and adding it to the EditorState (but not attaching it anywhere!). All nodes must\n   * implement this method.\n   *\n   */\n  static clone(_data) {\n    {\n      throw Error(`LexicalNode: Node ${this.name} does not implement .clone().`);\n    }\n  }\n\n  /**\n   * Perform any state updates on the clone of prevNode that are not already\n   * handled by the constructor call in the static clone method. If you have\n   * state to update in your clone that is not handled directly by the\n   * constructor, it is advisable to override this method but it is required\n   * to include a call to `super.afterCloneFrom(prevNode)` in your\n   * implementation. This is only intended to be called by\n   * {@link $cloneWithProperties} function or via a super call.\n   *\n   * @example\n   * ```ts\n   * class ClassesTextNode extends TextNode {\n   *   // Not shown: static getType, static importJSON, exportJSON, createDOM, updateDOM\n   *   __classes = new Set<string>();\n   *   static clone(node: ClassesTextNode): ClassesTextNode {\n   *     // The inherited TextNode constructor is used here, so\n   *     // classes is not set by this method.\n   *     return new ClassesTextNode(node.__text, node.__key);\n   *   }\n   *   afterCloneFrom(node: this): void {\n   *     // This calls TextNode.afterCloneFrom and LexicalNode.afterCloneFrom\n   *     // for necessary state updates\n   *     super.afterCloneFrom(node);\n   *     this.__addClasses(node.__classes);\n   *   }\n   *   // This method is a private implementation detail, it is not\n   *   // suitable for the public API because it does not call getWritable\n   *   __addClasses(classNames: Iterable<string>): this {\n   *     for (const className of classNames) {\n   *       this.__classes.add(className);\n   *     }\n   *     return this;\n   *   }\n   *   addClass(...classNames: string[]): this {\n   *     return this.getWritable().__addClasses(classNames);\n   *   }\n   *   removeClass(...classNames: string[]): this {\n   *     const node = this.getWritable();\n   *     for (const className of classNames) {\n   *       this.__classes.delete(className);\n   *     }\n   *     return this;\n   *   }\n   *   getClasses(): Set<string> {\n   *     return this.getLatest().__classes;\n   *   }\n   * }\n   * ```\n   *\n   */\n  afterCloneFrom(prevNode) {\n    this.__parent = prevNode.__parent;\n    this.__next = prevNode.__next;\n    this.__prev = prevNode.__prev;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n  constructor(key) {\n    this.__type = this.constructor.getType();\n    this.__parent = null;\n    this.__prev = null;\n    this.__next = null;\n    $setNodeKey(this, key);\n    {\n      if (this.__type !== 'root') {\n        errorOnReadOnly();\n        errorOnTypeKlassMismatch(this.__type, this.constructor);\n      }\n    }\n  }\n  // Getters and Traversers\n\n  /**\n   * Returns the string type of this node.\n   */\n  getType() {\n    return this.__type;\n  }\n  isInline() {\n    {\n      throw Error(`LexicalNode: Node ${this.constructor.name} does not implement .isInline().`);\n    }\n  }\n\n  /**\n   * Returns true if there is a path between this node and the RootNode, false otherwise.\n   * This is a way of determining if the node is \"attached\" EditorState. Unattached nodes\n   * won't be reconciled and will ultimatelt be cleaned up by the Lexical GC.\n   */\n  isAttached() {\n    let nodeKey = this.__key;\n    while (nodeKey !== null) {\n      if (nodeKey === 'root') {\n        return true;\n      }\n      const node = $getNodeByKey(nodeKey);\n      if (node === null) {\n        break;\n      }\n      nodeKey = node.__parent;\n    }\n    return false;\n  }\n\n  /**\n   * Returns true if this node is contained within the provided Selection., false otherwise.\n   * Relies on the algorithms implemented in {@link BaseSelection.getNodes} to determine\n   * what's included.\n   *\n   * @param selection - The selection that we want to determine if the node is in.\n   */\n  isSelected(selection) {\n    const targetSelection = selection || $getSelection();\n    if (targetSelection == null) {\n      return false;\n    }\n    const isSelected = targetSelection.getNodes().some(n => n.__key === this.__key);\n    if ($isTextNode(this)) {\n      return isSelected;\n    }\n    // For inline images inside of element nodes.\n    // Without this change the image will be selected if the cursor is before or after it.\n    const isElementRangeSelection = $isRangeSelection(targetSelection) && targetSelection.anchor.type === 'element' && targetSelection.focus.type === 'element';\n    if (isElementRangeSelection) {\n      if (targetSelection.isCollapsed()) {\n        return false;\n      }\n      const parentNode = this.getParent();\n      if ($isDecoratorNode(this) && this.isInline() && parentNode) {\n        const firstPoint = targetSelection.isBackward() ? targetSelection.focus : targetSelection.anchor;\n        const firstElement = firstPoint.getNode();\n        if (firstPoint.offset === firstElement.getChildrenSize() && firstElement.is(parentNode) && firstElement.getLastChildOrThrow().is(this)) {\n          return false;\n        }\n      }\n    }\n    return isSelected;\n  }\n\n  /**\n   * Returns this nodes key.\n   */\n  getKey() {\n    // Key is stable between copies\n    return this.__key;\n  }\n\n  /**\n   * Returns the zero-based index of this node within the parent.\n   */\n  getIndexWithinParent() {\n    const parent = this.getParent();\n    if (parent === null) {\n      return -1;\n    }\n    let node = parent.getFirstChild();\n    let index = 0;\n    while (node !== null) {\n      if (this.is(node)) {\n        return index;\n      }\n      index++;\n      node = node.getNextSibling();\n    }\n    return -1;\n  }\n\n  /**\n   * Returns the parent of this node, or null if none is found.\n   */\n  getParent() {\n    const parent = this.getLatest().__parent;\n    if (parent === null) {\n      return null;\n    }\n    return $getNodeByKey(parent);\n  }\n\n  /**\n   * Returns the parent of this node, or throws if none is found.\n   */\n  getParentOrThrow() {\n    const parent = this.getParent();\n    if (parent === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a parent.`);\n      }\n    }\n    return parent;\n  }\n\n  /**\n   * Returns the highest (in the EditorState tree)\n   * non-root ancestor of this node, or null if none is found. See {@link lexical!$isRootOrShadowRoot}\n   * for more information on which Elements comprise \"roots\".\n   */\n  getTopLevelElement() {\n    let node = this;\n    while (node !== null) {\n      const parent = node.getParent();\n      if ($isRootOrShadowRoot(parent)) {\n        if (!($isElementNode(node) || node === this && $isDecoratorNode(node))) {\n          throw Error(`Children of root nodes must be elements or decorators`);\n        }\n        return node;\n      }\n      node = parent;\n    }\n    return null;\n  }\n\n  /**\n   * Returns the highest (in the EditorState tree)\n   * non-root ancestor of this node, or throws if none is found. See {@link lexical!$isRootOrShadowRoot}\n   * for more information on which Elements comprise \"roots\".\n   */\n  getTopLevelElementOrThrow() {\n    const parent = this.getTopLevelElement();\n    if (parent === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a top parent element.`);\n      }\n    }\n    return parent;\n  }\n\n  /**\n   * Returns a list of the every ancestor of this node,\n   * all the way up to the RootNode.\n   *\n   */\n  getParents() {\n    const parents = [];\n    let node = this.getParent();\n    while (node !== null) {\n      parents.push(node);\n      node = node.getParent();\n    }\n    return parents;\n  }\n\n  /**\n   * Returns a list of the keys of every ancestor of this node,\n   * all the way up to the RootNode.\n   *\n   */\n  getParentKeys() {\n    const parents = [];\n    let node = this.getParent();\n    while (node !== null) {\n      parents.push(node.__key);\n      node = node.getParent();\n    }\n    return parents;\n  }\n\n  /**\n   * Returns the \"previous\" siblings - that is, the node that comes\n   * before this one in the same parent.\n   *\n   */\n  getPreviousSibling() {\n    const self = this.getLatest();\n    const prevKey = self.__prev;\n    return prevKey === null ? null : $getNodeByKey(prevKey);\n  }\n\n  /**\n   * Returns the \"previous\" siblings - that is, the nodes that come between\n   * this one and the first child of it's parent, inclusive.\n   *\n   */\n  getPreviousSiblings() {\n    const siblings = [];\n    const parent = this.getParent();\n    if (parent === null) {\n      return siblings;\n    }\n    let node = parent.getFirstChild();\n    while (node !== null) {\n      if (node.is(this)) {\n        break;\n      }\n      siblings.push(node);\n      node = node.getNextSibling();\n    }\n    return siblings;\n  }\n\n  /**\n   * Returns the \"next\" siblings - that is, the node that comes\n   * after this one in the same parent\n   *\n   */\n  getNextSibling() {\n    const self = this.getLatest();\n    const nextKey = self.__next;\n    return nextKey === null ? null : $getNodeByKey(nextKey);\n  }\n\n  /**\n   * Returns all \"next\" siblings - that is, the nodes that come between this\n   * one and the last child of it's parent, inclusive.\n   *\n   */\n  getNextSiblings() {\n    const siblings = [];\n    let node = this.getNextSibling();\n    while (node !== null) {\n      siblings.push(node);\n      node = node.getNextSibling();\n    }\n    return siblings;\n  }\n\n  /**\n   * Returns the closest common ancestor of this node and the provided one or null\n   * if one cannot be found.\n   *\n   * @param node - the other node to find the common ancestor of.\n   */\n  getCommonAncestor(node) {\n    const a = this.getParents();\n    const b = node.getParents();\n    if ($isElementNode(this)) {\n      a.unshift(this);\n    }\n    if ($isElementNode(node)) {\n      b.unshift(node);\n    }\n    const aLength = a.length;\n    const bLength = b.length;\n    if (aLength === 0 || bLength === 0 || a[aLength - 1] !== b[bLength - 1]) {\n      return null;\n    }\n    const bSet = new Set(b);\n    for (let i = 0; i < aLength; i++) {\n      const ancestor = a[i];\n      if (bSet.has(ancestor)) {\n        return ancestor;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Returns true if the provided node is the exact same one as this node, from Lexical's perspective.\n   * Always use this instead of referential equality.\n   *\n   * @param object - the node to perform the equality comparison on.\n   */\n  is(object) {\n    if (object == null) {\n      return false;\n    }\n    return this.__key === object.__key;\n  }\n\n  /**\n   * Returns true if this node logical precedes the target node in the editor state.\n   *\n   * @param targetNode - the node we're testing to see if it's after this one.\n   */\n  isBefore(targetNode) {\n    if (this === targetNode) {\n      return false;\n    }\n    if (targetNode.isParentOf(this)) {\n      return true;\n    }\n    if (this.isParentOf(targetNode)) {\n      return false;\n    }\n    const commonAncestor = this.getCommonAncestor(targetNode);\n    let indexA = 0;\n    let indexB = 0;\n    let node = this;\n    while (true) {\n      const parent = node.getParentOrThrow();\n      if (parent === commonAncestor) {\n        indexA = node.getIndexWithinParent();\n        break;\n      }\n      node = parent;\n    }\n    node = targetNode;\n    while (true) {\n      const parent = node.getParentOrThrow();\n      if (parent === commonAncestor) {\n        indexB = node.getIndexWithinParent();\n        break;\n      }\n      node = parent;\n    }\n    return indexA < indexB;\n  }\n\n  /**\n   * Returns true if this node is the parent of the target node, false otherwise.\n   *\n   * @param targetNode - the would-be child node.\n   */\n  isParentOf(targetNode) {\n    const key = this.__key;\n    if (key === targetNode.__key) {\n      return false;\n    }\n    let node = targetNode;\n    while (node !== null) {\n      if (node.__key === key) {\n        return true;\n      }\n      node = node.getParent();\n    }\n    return false;\n  }\n\n  // TO-DO: this function can be simplified a lot\n  /**\n   * Returns a list of nodes that are between this node and\n   * the target node in the EditorState.\n   *\n   * @param targetNode - the node that marks the other end of the range of nodes to be returned.\n   */\n  getNodesBetween(targetNode) {\n    const isBefore = this.isBefore(targetNode);\n    const nodes = [];\n    const visited = new Set();\n    let node = this;\n    while (true) {\n      if (node === null) {\n        break;\n      }\n      const key = node.__key;\n      if (!visited.has(key)) {\n        visited.add(key);\n        nodes.push(node);\n      }\n      if (node === targetNode) {\n        break;\n      }\n      const child = $isElementNode(node) ? isBefore ? node.getFirstChild() : node.getLastChild() : null;\n      if (child !== null) {\n        node = child;\n        continue;\n      }\n      const nextSibling = isBefore ? node.getNextSibling() : node.getPreviousSibling();\n      if (nextSibling !== null) {\n        node = nextSibling;\n        continue;\n      }\n      const parent = node.getParentOrThrow();\n      if (!visited.has(parent.__key)) {\n        nodes.push(parent);\n      }\n      if (parent === targetNode) {\n        break;\n      }\n      let parentSibling = null;\n      let ancestor = parent;\n      do {\n        if (ancestor === null) {\n          {\n            throw Error(`getNodesBetween: ancestor is null`);\n          }\n        }\n        parentSibling = isBefore ? ancestor.getNextSibling() : ancestor.getPreviousSibling();\n        ancestor = ancestor.getParent();\n        if (ancestor !== null) {\n          if (parentSibling === null && !visited.has(ancestor.__key)) {\n            nodes.push(ancestor);\n          }\n        } else {\n          break;\n        }\n      } while (parentSibling === null);\n      node = parentSibling;\n    }\n    if (!isBefore) {\n      nodes.reverse();\n    }\n    return nodes;\n  }\n\n  /**\n   * Returns true if this node has been marked dirty during this update cycle.\n   *\n   */\n  isDirty() {\n    const editor = getActiveEditor();\n    const dirtyLeaves = editor._dirtyLeaves;\n    return dirtyLeaves !== null && dirtyLeaves.has(this.__key);\n  }\n\n  /**\n   * Returns the latest version of the node from the active EditorState.\n   * This is used to avoid getting values from stale node references.\n   *\n   */\n  getLatest() {\n    const latest = $getNodeByKey(this.__key);\n    if (latest === null) {\n      {\n        throw Error(`Lexical node does not exist in active editor state. Avoid using the same node references between nested closures from editorState.read/editor.update.`);\n      }\n    }\n    return latest;\n  }\n\n  /**\n   * Returns a mutable version of the node using {@link $cloneWithProperties}\n   * if necessary. Will throw an error if called outside of a Lexical Editor\n   * {@link LexicalEditor.update} callback.\n   *\n   */\n  getWritable() {\n    errorOnReadOnly();\n    const editorState = getActiveEditorState();\n    const editor = getActiveEditor();\n    const nodeMap = editorState._nodeMap;\n    const key = this.__key;\n    // Ensure we get the latest node from pending state\n    const latestNode = this.getLatest();\n    const cloneNotNeeded = editor._cloneNotNeeded;\n    const selection = $getSelection();\n    if (selection !== null) {\n      selection.setCachedNodes(null);\n    }\n    if (cloneNotNeeded.has(key)) {\n      // Transforms clear the dirty node set on each iteration to keep track on newly dirty nodes\n      internalMarkNodeAsDirty(latestNode);\n      return latestNode;\n    }\n    const mutableNode = $cloneWithProperties(latestNode);\n    cloneNotNeeded.add(key);\n    internalMarkNodeAsDirty(mutableNode);\n    // Update reference in node map\n    nodeMap.set(key, mutableNode);\n    return mutableNode;\n  }\n\n  /**\n   * Returns the text content of the node. Override this for\n   * custom nodes that should have a representation in plain text\n   * format (for copy + paste, for example)\n   *\n   */\n  getTextContent() {\n    return '';\n  }\n\n  /**\n   * Returns the length of the string produced by calling getTextContent on this node.\n   *\n   */\n  getTextContentSize() {\n    return this.getTextContent().length;\n  }\n\n  // View\n\n  /**\n   * Called during the reconciliation process to determine which nodes\n   * to insert into the DOM for this Lexical Node.\n   *\n   * This method must return exactly one HTMLElement. Nested elements are not supported.\n   *\n   * Do not attempt to update the Lexical EditorState during this phase of the update lifecyle.\n   *\n   * @param _config - allows access to things like the EditorTheme (to apply classes) during reconciliation.\n   * @param _editor - allows access to the editor for context during reconciliation.\n   *\n   * */\n  createDOM(_config, _editor) {\n    {\n      throw Error(`createDOM: base method not extended`);\n    }\n  }\n\n  /**\n   * Called when a node changes and should update the DOM\n   * in whatever way is necessary to make it align with any changes that might\n   * have happened during the update.\n   *\n   * Returning \"true\" here will cause lexical to unmount and recreate the DOM node\n   * (by calling createDOM). You would need to do this if the element tag changes,\n   * for instance.\n   *\n   * */\n  updateDOM(_prevNode, _dom, _config) {\n    {\n      throw Error(`updateDOM: base method not extended`);\n    }\n  }\n\n  /**\n   * Controls how the this node is serialized to HTML. This is important for\n   * copy and paste between Lexical and non-Lexical editors, or Lexical editors with different namespaces,\n   * in which case the primary transfer format is HTML. It's also important if you're serializing\n   * to HTML for any other reason via {@link @lexical/html!$generateHtmlFromNodes}. You could\n   * also use this method to build your own HTML renderer.\n   *\n   * */\n  exportDOM(editor) {\n    const element = this.createDOM(editor._config, editor);\n    return {\n      element\n    };\n  }\n\n  /**\n   * Controls how the this node is serialized to JSON. This is important for\n   * copy and paste between Lexical editors sharing the same namespace. It's also important\n   * if you're serializing to JSON for persistent storage somewhere.\n   * See [Serialization & Deserialization](https://lexical.dev/docs/concepts/serialization#lexical---html).\n   *\n   * */\n  exportJSON() {\n    return {\n      type: this.__type,\n      version: 1\n    };\n  }\n\n  /**\n   * Controls how the this node is deserialized from JSON. This is usually boilerplate,\n   * but provides an abstraction between the node implementation and serialized interface that can\n   * be important if you ever make breaking changes to a node schema (by adding or removing properties).\n   * See [Serialization & Deserialization](https://lexical.dev/docs/concepts/serialization#lexical---html).\n   *\n   * */\n  static importJSON(_serializedNode) {\n    {\n      throw Error(`LexicalNode: Node ${this.name} does not implement .importJSON().`);\n    }\n  }\n\n  /**\n   * Update this LexicalNode instance from serialized JSON. It's recommended\n   * to implement as much logic as possible in this method instead of the\n   * static importJSON method, so that the functionality can be inherited in subclasses.\n   *\n   * The LexicalUpdateJSON utility type should be used to ignore any type, version,\n   * or children properties in the JSON so that the extended JSON from subclasses\n   * are acceptable parameters for the super call.\n   *\n   * If overridden, this method must call super.\n   *\n   * @example\n   * ```ts\n   * class MyTextNode extends TextNode {\n   *   // ...\n   *   static importJSON(serializedNode: SerializedMyTextNode): MyTextNode {\n   *     return $createMyTextNode()\n   *       .updateFromJSON(serializedNode);\n   *   }\n   *   updateFromJSON(\n   *     serializedNode: LexicalUpdateJSON<SerializedMyTextNode>,\n   *   ): this {\n   *     return super.updateFromJSON(serializedNode)\n   *       .setMyProperty(serializedNode.myProperty);\n   *   }\n   * }\n   * ```\n   **/\n  updateFromJSON(serializedNode) {\n    return this;\n  }\n\n  /**\n   * @experimental\n   *\n   * Registers the returned function as a transform on the node during\n   * Editor initialization. Most such use cases should be addressed via\n   * the {@link LexicalEditor.registerNodeTransform} API.\n   *\n   * Experimental - use at your own risk.\n   */\n  static transform() {\n    return null;\n  }\n\n  // Setters and mutators\n\n  /**\n   * Removes this LexicalNode from the EditorState. If the node isn't re-inserted\n   * somewhere, the Lexical garbage collector will eventually clean it up.\n   *\n   * @param preserveEmptyParent - If falsy, the node's parent will be removed if\n   * it's empty after the removal operation. This is the default behavior, subject to\n   * other node heuristics such as {@link ElementNode#canBeEmpty}\n   * */\n  remove(preserveEmptyParent) {\n    $removeNode(this, true, preserveEmptyParent);\n  }\n\n  /**\n   * Replaces this LexicalNode with the provided node, optionally transferring the children\n   * of the replaced node to the replacing node.\n   *\n   * @param replaceWith - The node to replace this one with.\n   * @param includeChildren - Whether or not to transfer the children of this node to the replacing node.\n   * */\n  replace(replaceWith, includeChildren) {\n    errorOnReadOnly();\n    let selection = $getSelection();\n    if (selection !== null) {\n      selection = selection.clone();\n    }\n    errorOnInsertTextNodeOnRoot(this, replaceWith);\n    const self = this.getLatest();\n    const toReplaceKey = this.__key;\n    const key = replaceWith.__key;\n    const writableReplaceWith = replaceWith.getWritable();\n    const writableParent = this.getParentOrThrow().getWritable();\n    const size = writableParent.__size;\n    removeFromParent(writableReplaceWith);\n    const prevSibling = self.getPreviousSibling();\n    const nextSibling = self.getNextSibling();\n    const prevKey = self.__prev;\n    const nextKey = self.__next;\n    const parentKey = self.__parent;\n    $removeNode(self, false, true);\n    if (prevSibling === null) {\n      writableParent.__first = key;\n    } else {\n      const writablePrevSibling = prevSibling.getWritable();\n      writablePrevSibling.__next = key;\n    }\n    writableReplaceWith.__prev = prevKey;\n    if (nextSibling === null) {\n      writableParent.__last = key;\n    } else {\n      const writableNextSibling = nextSibling.getWritable();\n      writableNextSibling.__prev = key;\n    }\n    writableReplaceWith.__next = nextKey;\n    writableReplaceWith.__parent = parentKey;\n    writableParent.__size = size;\n    if (includeChildren) {\n      if (!($isElementNode(this) && $isElementNode(writableReplaceWith))) {\n        throw Error(`includeChildren should only be true for ElementNodes`);\n      }\n      this.getChildren().forEach(child => {\n        writableReplaceWith.append(child);\n      });\n    }\n    if ($isRangeSelection(selection)) {\n      $setSelection(selection);\n      const anchor = selection.anchor;\n      const focus = selection.focus;\n      if (anchor.key === toReplaceKey) {\n        $moveSelectionPointToEnd(anchor, writableReplaceWith);\n      }\n      if (focus.key === toReplaceKey) {\n        $moveSelectionPointToEnd(focus, writableReplaceWith);\n      }\n    }\n    if ($getCompositionKey() === toReplaceKey) {\n      $setCompositionKey(key);\n    }\n    return writableReplaceWith;\n  }\n\n  /**\n   * Inserts a node after this LexicalNode (as the next sibling).\n   *\n   * @param nodeToInsert - The node to insert after this one.\n   * @param restoreSelection - Whether or not to attempt to resolve the\n   * selection to the appropriate place after the operation is complete.\n   * */\n  insertAfter(nodeToInsert, restoreSelection = true) {\n    errorOnReadOnly();\n    errorOnInsertTextNodeOnRoot(this, nodeToInsert);\n    const writableSelf = this.getWritable();\n    const writableNodeToInsert = nodeToInsert.getWritable();\n    const oldParent = writableNodeToInsert.getParent();\n    const selection = $getSelection();\n    let elementAnchorSelectionOnNode = false;\n    let elementFocusSelectionOnNode = false;\n    if (oldParent !== null) {\n      // TODO: this is O(n), can we improve?\n      const oldIndex = nodeToInsert.getIndexWithinParent();\n      removeFromParent(writableNodeToInsert);\n      if ($isRangeSelection(selection)) {\n        const oldParentKey = oldParent.__key;\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        elementAnchorSelectionOnNode = anchor.type === 'element' && anchor.key === oldParentKey && anchor.offset === oldIndex + 1;\n        elementFocusSelectionOnNode = focus.type === 'element' && focus.key === oldParentKey && focus.offset === oldIndex + 1;\n      }\n    }\n    const nextSibling = this.getNextSibling();\n    const writableParent = this.getParentOrThrow().getWritable();\n    const insertKey = writableNodeToInsert.__key;\n    const nextKey = writableSelf.__next;\n    if (nextSibling === null) {\n      writableParent.__last = insertKey;\n    } else {\n      const writableNextSibling = nextSibling.getWritable();\n      writableNextSibling.__prev = insertKey;\n    }\n    writableParent.__size++;\n    writableSelf.__next = insertKey;\n    writableNodeToInsert.__next = nextKey;\n    writableNodeToInsert.__prev = writableSelf.__key;\n    writableNodeToInsert.__parent = writableSelf.__parent;\n    if (restoreSelection && $isRangeSelection(selection)) {\n      const index = this.getIndexWithinParent();\n      $updateElementSelectionOnCreateDeleteNode(selection, writableParent, index + 1);\n      const writableParentKey = writableParent.__key;\n      if (elementAnchorSelectionOnNode) {\n        selection.anchor.set(writableParentKey, index + 2, 'element');\n      }\n      if (elementFocusSelectionOnNode) {\n        selection.focus.set(writableParentKey, index + 2, 'element');\n      }\n    }\n    return nodeToInsert;\n  }\n\n  /**\n   * Inserts a node before this LexicalNode (as the previous sibling).\n   *\n   * @param nodeToInsert - The node to insert before this one.\n   * @param restoreSelection - Whether or not to attempt to resolve the\n   * selection to the appropriate place after the operation is complete.\n   * */\n  insertBefore(nodeToInsert, restoreSelection = true) {\n    errorOnReadOnly();\n    errorOnInsertTextNodeOnRoot(this, nodeToInsert);\n    const writableSelf = this.getWritable();\n    const writableNodeToInsert = nodeToInsert.getWritable();\n    const insertKey = writableNodeToInsert.__key;\n    removeFromParent(writableNodeToInsert);\n    const prevSibling = this.getPreviousSibling();\n    const writableParent = this.getParentOrThrow().getWritable();\n    const prevKey = writableSelf.__prev;\n    // TODO: this is O(n), can we improve?\n    const index = this.getIndexWithinParent();\n    if (prevSibling === null) {\n      writableParent.__first = insertKey;\n    } else {\n      const writablePrevSibling = prevSibling.getWritable();\n      writablePrevSibling.__next = insertKey;\n    }\n    writableParent.__size++;\n    writableSelf.__prev = insertKey;\n    writableNodeToInsert.__prev = prevKey;\n    writableNodeToInsert.__next = writableSelf.__key;\n    writableNodeToInsert.__parent = writableSelf.__parent;\n    const selection = $getSelection();\n    if (restoreSelection && $isRangeSelection(selection)) {\n      const parent = this.getParentOrThrow();\n      $updateElementSelectionOnCreateDeleteNode(selection, parent, index);\n    }\n    return nodeToInsert;\n  }\n\n  /**\n   * Whether or not this node has a required parent. Used during copy + paste operations\n   * to normalize nodes that would otherwise be orphaned. For example, ListItemNodes without\n   * a ListNode parent or TextNodes with a ParagraphNode parent.\n   *\n   * */\n  isParentRequired() {\n    return false;\n  }\n\n  /**\n   * The creation logic for any required parent. Should be implemented if {@link isParentRequired} returns true.\n   *\n   * */\n  createParentElementNode() {\n    return $createParagraphNode();\n  }\n  selectStart() {\n    return this.selectPrevious();\n  }\n  selectEnd() {\n    return this.selectNext(0, 0);\n  }\n\n  /**\n   * Moves selection to the previous sibling of this node, at the specified offsets.\n   *\n   * @param anchorOffset - The anchor offset for selection.\n   * @param focusOffset -  The focus offset for selection\n   * */\n  selectPrevious(anchorOffset, focusOffset) {\n    errorOnReadOnly();\n    const prevSibling = this.getPreviousSibling();\n    const parent = this.getParentOrThrow();\n    if (prevSibling === null) {\n      return parent.select(0, 0);\n    }\n    if ($isElementNode(prevSibling)) {\n      return prevSibling.select();\n    } else if (!$isTextNode(prevSibling)) {\n      const index = prevSibling.getIndexWithinParent() + 1;\n      return parent.select(index, index);\n    }\n    return prevSibling.select(anchorOffset, focusOffset);\n  }\n\n  /**\n   * Moves selection to the next sibling of this node, at the specified offsets.\n   *\n   * @param anchorOffset - The anchor offset for selection.\n   * @param focusOffset -  The focus offset for selection\n   * */\n  selectNext(anchorOffset, focusOffset) {\n    errorOnReadOnly();\n    const nextSibling = this.getNextSibling();\n    const parent = this.getParentOrThrow();\n    if (nextSibling === null) {\n      return parent.select();\n    }\n    if ($isElementNode(nextSibling)) {\n      return nextSibling.select(0, 0);\n    } else if (!$isTextNode(nextSibling)) {\n      const index = nextSibling.getIndexWithinParent();\n      return parent.select(index, index);\n    }\n    return nextSibling.select(anchorOffset, focusOffset);\n  }\n\n  /**\n   * Marks a node dirty, triggering transforms and\n   * forcing it to be reconciled during the update cycle.\n   *\n   * */\n  markDirty() {\n    this.getWritable();\n  }\n\n  /**\n   * @internal\n   *\n   * When the reconciler detects that a node was mutated, this method\n   * may be called to restore the node to a known good state.\n   */\n  reconcileObservedMutation(dom, editor) {\n    this.markDirty();\n  }\n}\nfunction errorOnTypeKlassMismatch(type, klass) {\n  const registeredNode = getActiveEditor()._nodes.get(type);\n  // Common error - split in its own invariant\n  if (registeredNode === undefined) {\n    {\n      throw Error(`Create node: Attempted to create node ${klass.name} that was not configured to be used on the editor.`);\n    }\n  }\n  const editorKlass = registeredNode.klass;\n  if (editorKlass !== klass) {\n    {\n      throw Error(`Create node: Type ${type} in node ${klass.name} does not match registered node ${editorKlass.name} with the same type`);\n    }\n  }\n}\n\n/**\n * Insert a series of nodes after this LexicalNode (as next siblings)\n *\n * @param firstToInsert - The first node to insert after this one.\n * @param lastToInsert - The last node to insert after this one. Must be a\n * later sibling of FirstNode. If not provided, it will be its last sibling.\n */\nfunction insertRangeAfter(node, firstToInsert, lastToInsert) {\n  const lastToInsert2 = firstToInsert.getParentOrThrow().getLastChild();\n  let current = firstToInsert;\n  const nodesToInsert = [firstToInsert];\n  while (current !== lastToInsert2) {\n    if (!current.getNextSibling()) {\n      {\n        throw Error(`insertRangeAfter: lastToInsert must be a later sibling of firstToInsert`);\n      }\n    }\n    current = current.getNextSibling();\n    nodesToInsert.push(current);\n  }\n  let currentNode = node;\n  for (const nodeToInsert of nodesToInsert) {\n    currentNode = currentNode.insertAfter(nodeToInsert);\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass LineBreakNode extends LexicalNode {\n  static getType() {\n    return 'linebreak';\n  }\n  static clone(node) {\n    return new LineBreakNode(node.__key);\n  }\n  constructor(key) {\n    super(key);\n  }\n  getTextContent() {\n    return '\\n';\n  }\n  createDOM() {\n    return document.createElement('br');\n  }\n  updateDOM() {\n    return false;\n  }\n  static importDOM() {\n    return {\n      br: node => {\n        if (isOnlyChildInBlockNode(node) || isLastChildInBlockNode(node)) {\n          return null;\n        }\n        return {\n          conversion: $convertLineBreakElement,\n          priority: 0\n        };\n      }\n    };\n  }\n  static importJSON(serializedLineBreakNode) {\n    return $createLineBreakNode().updateFromJSON(serializedLineBreakNode);\n  }\n}\nfunction $convertLineBreakElement(node) {\n  return {\n    node: $createLineBreakNode()\n  };\n}\nfunction $createLineBreakNode() {\n  return $applyNodeReplacement(new LineBreakNode());\n}\nfunction $isLineBreakNode(node) {\n  return node instanceof LineBreakNode;\n}\nfunction isOnlyChildInBlockNode(node) {\n  const parentElement = node.parentElement;\n  if (parentElement !== null && isBlockDomNode(parentElement)) {\n    const firstChild = parentElement.firstChild;\n    if (firstChild === node || firstChild.nextSibling === node && isWhitespaceDomTextNode(firstChild)) {\n      const lastChild = parentElement.lastChild;\n      if (lastChild === node || lastChild.previousSibling === node && isWhitespaceDomTextNode(lastChild)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\nfunction isLastChildInBlockNode(node) {\n  const parentElement = node.parentElement;\n  if (parentElement !== null && isBlockDomNode(parentElement)) {\n    // check if node is first child, because only childs dont count\n    const firstChild = parentElement.firstChild;\n    if (firstChild === node || firstChild.nextSibling === node && isWhitespaceDomTextNode(firstChild)) {\n      return false;\n    }\n\n    // check if its last child\n    const lastChild = parentElement.lastChild;\n    if (lastChild === node || lastChild.previousSibling === node && isWhitespaceDomTextNode(lastChild)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction isWhitespaceDomTextNode(node) {\n  return isDOMTextNode(node) && /^( |\\t|\\r?\\n)+$/.test(node.textContent || '');\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction getElementOuterTag(node, format) {\n  if (format & IS_CODE) {\n    return 'code';\n  }\n  if (format & IS_HIGHLIGHT) {\n    return 'mark';\n  }\n  if (format & IS_SUBSCRIPT) {\n    return 'sub';\n  }\n  if (format & IS_SUPERSCRIPT) {\n    return 'sup';\n  }\n  return null;\n}\nfunction getElementInnerTag(node, format) {\n  if (format & IS_BOLD) {\n    return 'strong';\n  }\n  if (format & IS_ITALIC) {\n    return 'em';\n  }\n  return 'span';\n}\nfunction setTextThemeClassNames(tag, prevFormat, nextFormat, dom, textClassNames) {\n  const domClassList = dom.classList;\n  // Firstly we handle the base theme.\n  let classNames = getCachedClassNameArray(textClassNames, 'base');\n  if (classNames !== undefined) {\n    domClassList.add(...classNames);\n  }\n  // Secondly we handle the special case: underline + strikethrough.\n  // We have to do this as we need a way to compose the fact that\n  // the same CSS property will need to be used: text-decoration.\n  // In an ideal world we shouldn't have to do this, but there's no\n  // easy workaround for many atomic CSS systems today.\n  classNames = getCachedClassNameArray(textClassNames, 'underlineStrikethrough');\n  let hasUnderlineStrikethrough = false;\n  const prevUnderlineStrikethrough = prevFormat & IS_UNDERLINE && prevFormat & IS_STRIKETHROUGH;\n  const nextUnderlineStrikethrough = nextFormat & IS_UNDERLINE && nextFormat & IS_STRIKETHROUGH;\n  if (classNames !== undefined) {\n    if (nextUnderlineStrikethrough) {\n      hasUnderlineStrikethrough = true;\n      if (!prevUnderlineStrikethrough) {\n        domClassList.add(...classNames);\n      }\n    } else if (prevUnderlineStrikethrough) {\n      domClassList.remove(...classNames);\n    }\n  }\n  for (const key in TEXT_TYPE_TO_FORMAT) {\n    const format = key;\n    const flag = TEXT_TYPE_TO_FORMAT[format];\n    classNames = getCachedClassNameArray(textClassNames, key);\n    if (classNames !== undefined) {\n      if (nextFormat & flag) {\n        if (hasUnderlineStrikethrough && (key === 'underline' || key === 'strikethrough')) {\n          if (prevFormat & flag) {\n            domClassList.remove(...classNames);\n          }\n          continue;\n        }\n        if ((prevFormat & flag) === 0 || prevUnderlineStrikethrough && key === 'underline' || key === 'strikethrough') {\n          domClassList.add(...classNames);\n        }\n      } else if (prevFormat & flag) {\n        domClassList.remove(...classNames);\n      }\n    }\n  }\n}\nfunction diffComposedText(a, b) {\n  const aLength = a.length;\n  const bLength = b.length;\n  let left = 0;\n  let right = 0;\n  while (left < aLength && left < bLength && a[left] === b[left]) {\n    left++;\n  }\n  while (right + left < aLength && right + left < bLength && a[aLength - right - 1] === b[bLength - right - 1]) {\n    right++;\n  }\n  return [left, aLength - left - right, b.slice(left, bLength - right)];\n}\nfunction setTextContent(nextText, dom, node) {\n  const firstChild = dom.firstChild;\n  const isComposing = node.isComposing();\n  // Always add a suffix if we're composing a node\n  const suffix = isComposing ? COMPOSITION_SUFFIX : '';\n  const text = nextText + suffix;\n  if (firstChild == null) {\n    dom.textContent = text;\n  } else {\n    const nodeValue = firstChild.nodeValue;\n    if (nodeValue !== text) {\n      if (isComposing || IS_FIREFOX) {\n        // We also use the diff composed text for general text in FF to avoid\n        // the spellcheck red line from flickering.\n        const [index, remove, insert] = diffComposedText(nodeValue, text);\n        if (remove !== 0) {\n          // @ts-expect-error\n          firstChild.deleteData(index, remove);\n        }\n        // @ts-expect-error\n        firstChild.insertData(index, insert);\n      } else {\n        firstChild.nodeValue = text;\n      }\n    }\n  }\n}\nfunction createTextInnerDOM(innerDOM, node, innerTag, format, text, config) {\n  setTextContent(text, innerDOM, node);\n  const theme = config.theme;\n  // Apply theme class names\n  const textClassNames = theme.text;\n  if (textClassNames !== undefined) {\n    setTextThemeClassNames(innerTag, 0, format, innerDOM, textClassNames);\n  }\n}\nfunction wrapElementWith(element, tag) {\n  const el = document.createElement(tag);\n  el.appendChild(element);\n  return el;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\n\n/** @noInheritDoc */\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nclass TextNode extends LexicalNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'text';\n  }\n  static clone(node) {\n    return new TextNode(node.__text, node.__key);\n  }\n  afterCloneFrom(prevNode) {\n    super.afterCloneFrom(prevNode);\n    this.__text = prevNode.__text;\n    this.__format = prevNode.__format;\n    this.__style = prevNode.__style;\n    this.__mode = prevNode.__mode;\n    this.__detail = prevNode.__detail;\n  }\n  constructor(text = '', key) {\n    super(key);\n    this.__text = text;\n    this.__format = 0;\n    this.__style = '';\n    this.__mode = 0;\n    this.__detail = 0;\n  }\n\n  /**\n   * Returns a 32-bit integer that represents the TextFormatTypes currently applied to the\n   * TextNode. You probably don't want to use this method directly - consider using TextNode.hasFormat instead.\n   *\n   * @returns a number representing the format of the text node.\n   */\n  getFormat() {\n    const self = this.getLatest();\n    return self.__format;\n  }\n\n  /**\n   * Returns a 32-bit integer that represents the TextDetailTypes currently applied to the\n   * TextNode. You probably don't want to use this method directly - consider using TextNode.isDirectionless\n   * or TextNode.isUnmergeable instead.\n   *\n   * @returns a number representing the detail of the text node.\n   */\n  getDetail() {\n    const self = this.getLatest();\n    return self.__detail;\n  }\n\n  /**\n   * Returns the mode (TextModeType) of the TextNode, which may be \"normal\", \"token\", or \"segmented\"\n   *\n   * @returns TextModeType.\n   */\n  getMode() {\n    const self = this.getLatest();\n    return TEXT_TYPE_TO_MODE[self.__mode];\n  }\n\n  /**\n   * Returns the styles currently applied to the node. This is analogous to CSSText in the DOM.\n   *\n   * @returns CSSText-like string of styles applied to the underlying DOM node.\n   */\n  getStyle() {\n    const self = this.getLatest();\n    return self.__style;\n  }\n\n  /**\n   * Returns whether or not the node is in \"token\" mode. TextNodes in token mode can be navigated through character-by-character\n   * with a RangeSelection, but are deleted as a single entity (not invdividually by character).\n   *\n   * @returns true if the node is in token mode, false otherwise.\n   */\n  isToken() {\n    const self = this.getLatest();\n    return self.__mode === IS_TOKEN;\n  }\n\n  /**\n   *\n   * @returns true if Lexical detects that an IME or other 3rd-party script is attempting to\n   * mutate the TextNode, false otherwise.\n   */\n  isComposing() {\n    return this.__key === $getCompositionKey();\n  }\n\n  /**\n   * Returns whether or not the node is in \"segemented\" mode. TextNodes in segemented mode can be navigated through character-by-character\n   * with a RangeSelection, but are deleted in space-delimited \"segments\".\n   *\n   * @returns true if the node is in segmented mode, false otherwise.\n   */\n  isSegmented() {\n    const self = this.getLatest();\n    return self.__mode === IS_SEGMENTED;\n  }\n  /**\n   * Returns whether or not the node is \"directionless\". Directionless nodes don't respect changes between RTL and LTR modes.\n   *\n   * @returns true if the node is directionless, false otherwise.\n   */\n  isDirectionless() {\n    const self = this.getLatest();\n    return (self.__detail & IS_DIRECTIONLESS) !== 0;\n  }\n  /**\n   * Returns whether or not the node is unmergeable. In some scenarios, Lexical tries to merge\n   * adjacent TextNodes into a single TextNode. If a TextNode is unmergeable, this won't happen.\n   *\n   * @returns true if the node is unmergeable, false otherwise.\n   */\n  isUnmergeable() {\n    const self = this.getLatest();\n    return (self.__detail & IS_UNMERGEABLE) !== 0;\n  }\n\n  /**\n   * Returns whether or not the node has the provided format applied. Use this with the human-readable TextFormatType\n   * string values to get the format of a TextNode.\n   *\n   * @param type - the TextFormatType to check for.\n   *\n   * @returns true if the node has the provided format, false otherwise.\n   */\n  hasFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return (this.getFormat() & formatFlag) !== 0;\n  }\n\n  /**\n   * Returns whether or not the node is simple text. Simple text is defined as a TextNode that has the string type \"text\"\n   * (i.e., not a subclass) and has no mode applied to it (i.e., not segmented or token).\n   *\n   * @returns true if the node is simple text, false otherwise.\n   */\n  isSimpleText() {\n    return this.__type === 'text' && this.__mode === 0;\n  }\n\n  /**\n   * Returns the text content of the node as a string.\n   *\n   * @returns a string representing the text content of the node.\n   */\n  getTextContent() {\n    const self = this.getLatest();\n    return self.__text;\n  }\n\n  /**\n   * Returns the format flags applied to the node as a 32-bit integer.\n   *\n   * @returns a number representing the TextFormatTypes applied to the node.\n   */\n  getFormatFlags(type, alignWithFormat) {\n    const self = this.getLatest();\n    const format = self.__format;\n    return toggleTextFormatType(format, type, alignWithFormat);\n  }\n\n  /**\n   *\n   * @returns true if the text node supports font styling, false otherwise.\n   */\n  canHaveFormat() {\n    return true;\n  }\n\n  // View\n\n  createDOM(config, editor) {\n    const format = this.__format;\n    const outerTag = getElementOuterTag(this, format);\n    const innerTag = getElementInnerTag(this, format);\n    const tag = outerTag === null ? innerTag : outerTag;\n    const dom = document.createElement(tag);\n    let innerDOM = dom;\n    if (this.hasFormat('code')) {\n      dom.setAttribute('spellcheck', 'false');\n    }\n    if (outerTag !== null) {\n      innerDOM = document.createElement(innerTag);\n      dom.appendChild(innerDOM);\n    }\n    const text = this.__text;\n    createTextInnerDOM(innerDOM, this, innerTag, format, text, config);\n    const style = this.__style;\n    if (style !== '') {\n      dom.style.cssText = style;\n    }\n    return dom;\n  }\n  updateDOM(prevNode, dom, config) {\n    const nextText = this.__text;\n    const prevFormat = prevNode.__format;\n    const nextFormat = this.__format;\n    const prevOuterTag = getElementOuterTag(this, prevFormat);\n    const nextOuterTag = getElementOuterTag(this, nextFormat);\n    const prevInnerTag = getElementInnerTag(this, prevFormat);\n    const nextInnerTag = getElementInnerTag(this, nextFormat);\n    const prevTag = prevOuterTag === null ? prevInnerTag : prevOuterTag;\n    const nextTag = nextOuterTag === null ? nextInnerTag : nextOuterTag;\n    if (prevTag !== nextTag) {\n      return true;\n    }\n    if (prevOuterTag === nextOuterTag && prevInnerTag !== nextInnerTag) {\n      // should always be an element\n      const prevInnerDOM = dom.firstChild;\n      if (prevInnerDOM == null) {\n        {\n          throw Error(`updateDOM: prevInnerDOM is null or undefined`);\n        }\n      }\n      const nextInnerDOM = document.createElement(nextInnerTag);\n      createTextInnerDOM(nextInnerDOM, this, nextInnerTag, nextFormat, nextText, config);\n      dom.replaceChild(nextInnerDOM, prevInnerDOM);\n      return false;\n    }\n    let innerDOM = dom;\n    if (nextOuterTag !== null) {\n      if (prevOuterTag !== null) {\n        innerDOM = dom.firstChild;\n        if (innerDOM == null) {\n          {\n            throw Error(`updateDOM: innerDOM is null or undefined`);\n          }\n        }\n      }\n    }\n    setTextContent(nextText, innerDOM, this);\n    const theme = config.theme;\n    // Apply theme class names\n    const textClassNames = theme.text;\n    if (textClassNames !== undefined && prevFormat !== nextFormat) {\n      setTextThemeClassNames(nextInnerTag, prevFormat, nextFormat, innerDOM, textClassNames);\n    }\n    const prevStyle = prevNode.__style;\n    const nextStyle = this.__style;\n    if (prevStyle !== nextStyle) {\n      dom.style.cssText = nextStyle;\n    }\n    return false;\n  }\n  static importDOM() {\n    return {\n      '#text': () => ({\n        conversion: $convertTextDOMNode,\n        priority: 0\n      }),\n      b: () => ({\n        conversion: convertBringAttentionToElement,\n        priority: 0\n      }),\n      code: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      em: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      i: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      s: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      span: () => ({\n        conversion: convertSpanElement,\n        priority: 0\n      }),\n      strong: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      sub: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      sup: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      u: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createTextNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setTextContent(serializedNode.text).setFormat(serializedNode.format).setDetail(serializedNode.detail).setMode(serializedNode.mode).setStyle(serializedNode.style);\n  }\n\n  // This improves Lexical's basic text output in copy+paste plus\n  // for headless mode where people might use Lexical to generate\n  // HTML content and not have the ability to use CSS classes.\n  exportDOM(editor) {\n    let {\n      element\n    } = super.exportDOM(editor);\n    if (!isHTMLElement(element)) {\n      throw Error(`Expected TextNode createDOM to always return a HTMLElement`);\n    }\n    element.style.whiteSpace = 'pre-wrap';\n    // This is the only way to properly add support for most clients,\n    // even if it's semantically incorrect to have to resort to using\n    // <b>, <u>, <s>, <i> elements.\n    if (this.hasFormat('bold')) {\n      element = wrapElementWith(element, 'b');\n    }\n    if (this.hasFormat('italic')) {\n      element = wrapElementWith(element, 'i');\n    }\n    if (this.hasFormat('strikethrough')) {\n      element = wrapElementWith(element, 's');\n    }\n    if (this.hasFormat('underline')) {\n      element = wrapElementWith(element, 'u');\n    }\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      detail: this.getDetail(),\n      format: this.getFormat(),\n      mode: this.getMode(),\n      style: this.getStyle(),\n      text: this.getTextContent(),\n      // As an exception here we invoke super at the end for historical reasons.\n      // Namely, to preserve the order of the properties and not to break the tests\n      // that use the serialized string representation.\n      ...super.exportJSON()\n    };\n  }\n\n  // Mutators\n  selectionTransform(prevSelection, nextSelection) {\n    return;\n  }\n\n  /**\n   * Sets the node format to the provided TextFormatType or 32-bit integer. Note that the TextFormatType\n   * version of the argument can only specify one format and doing so will remove all other formats that\n   * may be applied to the node. For toggling behavior, consider using {@link TextNode.toggleFormat}\n   *\n   * @param format - TextFormatType or 32-bit integer representing the node format.\n   *\n   * @returns this TextNode.\n   * // TODO 0.12 This should just be a `string`.\n   */\n  setFormat(format) {\n    const self = this.getWritable();\n    self.__format = typeof format === 'string' ? TEXT_TYPE_TO_FORMAT[format] : format;\n    return self;\n  }\n\n  /**\n   * Sets the node detail to the provided TextDetailType or 32-bit integer. Note that the TextDetailType\n   * version of the argument can only specify one detail value and doing so will remove all other detail values that\n   * may be applied to the node. For toggling behavior, consider using {@link TextNode.toggleDirectionless}\n   * or {@link TextNode.toggleUnmergeable}\n   *\n   * @param detail - TextDetailType or 32-bit integer representing the node detail.\n   *\n   * @returns this TextNode.\n   * // TODO 0.12 This should just be a `string`.\n   */\n  setDetail(detail) {\n    const self = this.getWritable();\n    self.__detail = typeof detail === 'string' ? DETAIL_TYPE_TO_DETAIL[detail] : detail;\n    return self;\n  }\n\n  /**\n   * Sets the node style to the provided CSSText-like string. Set this property as you\n   * would an HTMLElement style attribute to apply inline styles to the underlying DOM Element.\n   *\n   * @param style - CSSText to be applied to the underlying HTMLElement.\n   *\n   * @returns this TextNode.\n   */\n  setStyle(style) {\n    const self = this.getWritable();\n    self.__style = style;\n    return self;\n  }\n\n  /**\n   * Applies the provided format to this TextNode if it's not present. Removes it if it's present.\n   * The subscript and superscript formats are mutually exclusive.\n   * Prefer using this method to turn specific formats on and off.\n   *\n   * @param type - TextFormatType to toggle.\n   *\n   * @returns this TextNode.\n   */\n  toggleFormat(type) {\n    const format = this.getFormat();\n    const newFormat = toggleTextFormatType(format, type, null);\n    return this.setFormat(newFormat);\n  }\n\n  /**\n   * Toggles the directionless detail value of the node. Prefer using this method over setDetail.\n   *\n   * @returns this TextNode.\n   */\n  toggleDirectionless() {\n    const self = this.getWritable();\n    self.__detail ^= IS_DIRECTIONLESS;\n    return self;\n  }\n\n  /**\n   * Toggles the unmergeable detail value of the node. Prefer using this method over setDetail.\n   *\n   * @returns this TextNode.\n   */\n  toggleUnmergeable() {\n    const self = this.getWritable();\n    self.__detail ^= IS_UNMERGEABLE;\n    return self;\n  }\n\n  /**\n   * Sets the mode of the node.\n   *\n   * @returns this TextNode.\n   */\n  setMode(type) {\n    const mode = TEXT_MODE_TO_TYPE[type];\n    if (this.__mode === mode) {\n      return this;\n    }\n    const self = this.getWritable();\n    self.__mode = mode;\n    return self;\n  }\n\n  /**\n   * Sets the text content of the node.\n   *\n   * @param text - the string to set as the text value of the node.\n   *\n   * @returns this TextNode.\n   */\n  setTextContent(text) {\n    if (this.__text === text) {\n      return this;\n    }\n    const self = this.getWritable();\n    self.__text = text;\n    return self;\n  }\n\n  /**\n   * Sets the current Lexical selection to be a RangeSelection with anchor and focus on this TextNode at the provided offsets.\n   *\n   * @param _anchorOffset - the offset at which the Selection anchor will be placed.\n   * @param _focusOffset - the offset at which the Selection focus will be placed.\n   *\n   * @returns the new RangeSelection.\n   */\n  select(_anchorOffset, _focusOffset) {\n    errorOnReadOnly();\n    let anchorOffset = _anchorOffset;\n    let focusOffset = _focusOffset;\n    const selection = $getSelection();\n    const text = this.getTextContent();\n    const key = this.__key;\n    if (typeof text === 'string') {\n      const lastOffset = text.length;\n      if (anchorOffset === undefined) {\n        anchorOffset = lastOffset;\n      }\n      if (focusOffset === undefined) {\n        focusOffset = lastOffset;\n      }\n    } else {\n      anchorOffset = 0;\n      focusOffset = 0;\n    }\n    if (!$isRangeSelection(selection)) {\n      return $internalMakeRangeSelection(key, anchorOffset, key, focusOffset, 'text', 'text');\n    } else {\n      const compositionKey = $getCompositionKey();\n      if (compositionKey === selection.anchor.key || compositionKey === selection.focus.key) {\n        $setCompositionKey(key);\n      }\n      selection.setTextNodeRange(this, anchorOffset, this, focusOffset);\n    }\n    return selection;\n  }\n  selectStart() {\n    return this.select(0, 0);\n  }\n  selectEnd() {\n    const size = this.getTextContentSize();\n    return this.select(size, size);\n  }\n\n  /**\n   * Inserts the provided text into this TextNode at the provided offset, deleting the number of characters\n   * specified. Can optionally calculate a new selection after the operation is complete.\n   *\n   * @param offset - the offset at which the splice operation should begin.\n   * @param delCount - the number of characters to delete, starting from the offset.\n   * @param newText - the text to insert into the TextNode at the offset.\n   * @param moveSelection - optional, whether or not to move selection to the end of the inserted substring.\n   *\n   * @returns this TextNode.\n   */\n  spliceText(offset, delCount, newText, moveSelection) {\n    const writableSelf = this.getWritable();\n    const text = writableSelf.__text;\n    const handledTextLength = newText.length;\n    let index = offset;\n    if (index < 0) {\n      index = handledTextLength + index;\n      if (index < 0) {\n        index = 0;\n      }\n    }\n    const selection = $getSelection();\n    if (moveSelection && $isRangeSelection(selection)) {\n      const newOffset = offset + handledTextLength;\n      selection.setTextNodeRange(writableSelf, newOffset, writableSelf, newOffset);\n    }\n    const updatedText = text.slice(0, index) + newText + text.slice(index + delCount);\n    writableSelf.__text = updatedText;\n    return writableSelf;\n  }\n\n  /**\n   * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes\n   * when a user event would cause text to be inserted before them in the editor. If true, Lexical will attempt\n   * to insert text into this node. If false, it will insert the text in a new sibling node.\n   *\n   * @returns true if text can be inserted before the node, false otherwise.\n   */\n  canInsertTextBefore() {\n    return true;\n  }\n\n  /**\n   * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes\n   * when a user event would cause text to be inserted after them in the editor. If true, Lexical will attempt\n   * to insert text into this node. If false, it will insert the text in a new sibling node.\n   *\n   * @returns true if text can be inserted after the node, false otherwise.\n   */\n  canInsertTextAfter() {\n    return true;\n  }\n\n  /**\n   * Splits this TextNode at the provided character offsets, forming new TextNodes from the substrings\n   * formed by the split, and inserting those new TextNodes into the editor, replacing the one that was split.\n   *\n   * @param splitOffsets - rest param of the text content character offsets at which this node should be split.\n   *\n   * @returns an Array containing the newly-created TextNodes.\n   */\n  splitText(...splitOffsets) {\n    errorOnReadOnly();\n    const self = this.getLatest();\n    const textContent = self.getTextContent();\n    const key = self.__key;\n    const compositionKey = $getCompositionKey();\n    const offsetsSet = new Set(splitOffsets);\n    const parts = [];\n    const textLength = textContent.length;\n    let string = '';\n    for (let i = 0; i < textLength; i++) {\n      if (string !== '' && offsetsSet.has(i)) {\n        parts.push(string);\n        string = '';\n      }\n      string += textContent[i];\n    }\n    if (string !== '') {\n      parts.push(string);\n    }\n    const partsLength = parts.length;\n    if (partsLength === 0) {\n      return [];\n    } else if (parts[0] === textContent) {\n      return [self];\n    }\n    const firstPart = parts[0];\n    const parent = self.getParent();\n    let writableNode;\n    const format = self.getFormat();\n    const style = self.getStyle();\n    const detail = self.__detail;\n    let hasReplacedSelf = false;\n    if (self.isSegmented()) {\n      // Create a new TextNode\n      writableNode = $createTextNode(firstPart);\n      writableNode.__format = format;\n      writableNode.__style = style;\n      writableNode.__detail = detail;\n      hasReplacedSelf = true;\n    } else {\n      // For the first part, update the existing node\n      writableNode = self.getWritable();\n      writableNode.__text = firstPart;\n    }\n\n    // Handle selection\n    const selection = $getSelection();\n\n    // Then handle all other parts\n    const splitNodes = [writableNode];\n    let textSize = firstPart.length;\n    for (let i = 1; i < partsLength; i++) {\n      const part = parts[i];\n      const partSize = part.length;\n      const sibling = $createTextNode(part).getWritable();\n      sibling.__format = format;\n      sibling.__style = style;\n      sibling.__detail = detail;\n      const siblingKey = sibling.__key;\n      const nextTextSize = textSize + partSize;\n      if ($isRangeSelection(selection)) {\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        if (anchor.key === key && anchor.type === 'text' && anchor.offset > textSize && anchor.offset <= nextTextSize) {\n          anchor.key = siblingKey;\n          anchor.offset -= textSize;\n          selection.dirty = true;\n        }\n        if (focus.key === key && focus.type === 'text' && focus.offset > textSize && focus.offset <= nextTextSize) {\n          focus.key = siblingKey;\n          focus.offset -= textSize;\n          selection.dirty = true;\n        }\n      }\n      if (compositionKey === key) {\n        $setCompositionKey(siblingKey);\n      }\n      textSize = nextTextSize;\n      splitNodes.push(sibling);\n    }\n\n    // Insert the nodes into the parent's children\n    if (parent !== null) {\n      internalMarkSiblingsAsDirty(this);\n      const writableParent = parent.getWritable();\n      const insertionIndex = this.getIndexWithinParent();\n      if (hasReplacedSelf) {\n        writableParent.splice(insertionIndex, 0, splitNodes);\n        this.remove();\n      } else {\n        writableParent.splice(insertionIndex, 1, splitNodes);\n      }\n      if ($isRangeSelection(selection)) {\n        $updateElementSelectionOnCreateDeleteNode(selection, parent, insertionIndex, partsLength - 1);\n      }\n    }\n    return splitNodes;\n  }\n\n  /**\n   * Merges the target TextNode into this TextNode, removing the target node.\n   *\n   * @param target - the TextNode to merge into this one.\n   *\n   * @returns this TextNode.\n   */\n  mergeWithSibling(target) {\n    const isBefore = target === this.getPreviousSibling();\n    if (!isBefore && target !== this.getNextSibling()) {\n      {\n        throw Error(`mergeWithSibling: sibling must be a previous or next sibling`);\n      }\n    }\n    const key = this.__key;\n    const targetKey = target.__key;\n    const text = this.__text;\n    const textLength = text.length;\n    const compositionKey = $getCompositionKey();\n    if (compositionKey === targetKey) {\n      $setCompositionKey(key);\n    }\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      const anchor = selection.anchor;\n      const focus = selection.focus;\n      if (anchor !== null && anchor.key === targetKey) {\n        adjustPointOffsetForMergedSibling(anchor, isBefore, key, target, textLength);\n        selection.dirty = true;\n      }\n      if (focus !== null && focus.key === targetKey) {\n        adjustPointOffsetForMergedSibling(focus, isBefore, key, target, textLength);\n        selection.dirty = true;\n      }\n    }\n    const targetText = target.__text;\n    const newText = isBefore ? targetText + text : text + targetText;\n    this.setTextContent(newText);\n    const writableSelf = this.getWritable();\n    target.remove();\n    return writableSelf;\n  }\n\n  /**\n   * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes\n   * when used with the registerLexicalTextEntity function. If you're using registerLexicalTextEntity, the\n   * node class that you create and replace matched text with should return true from this method.\n   *\n   * @returns true if the node is to be treated as a \"text entity\", false otherwise.\n   */\n  isTextEntity() {\n    return false;\n  }\n}\nfunction convertSpanElement(domNode) {\n  // domNode is a <span> since we matched it by nodeName\n  const span = domNode;\n  const style = span.style;\n  return {\n    forChild: applyTextFormatFromStyle(style),\n    node: null\n  };\n}\nfunction convertBringAttentionToElement(domNode) {\n  // domNode is a <b> since we matched it by nodeName\n  const b = domNode;\n  // Google Docs wraps all copied HTML in a <b> with font-weight normal\n  const hasNormalFontWeight = b.style.fontWeight === 'normal';\n  return {\n    forChild: applyTextFormatFromStyle(b.style, hasNormalFontWeight ? undefined : 'bold'),\n    node: null\n  };\n}\nconst preParentCache = new WeakMap();\nfunction isNodePre(node) {\n  if (!isHTMLElement(node)) {\n    return false;\n  } else if (node.nodeName === 'PRE') {\n    return true;\n  }\n  const whiteSpace = node.style.whiteSpace;\n  return typeof whiteSpace === 'string' && whiteSpace.startsWith('pre');\n}\nfunction findParentPreDOMNode(node) {\n  let cached;\n  let parent = node.parentNode;\n  const visited = [node];\n  while (parent !== null && (cached = preParentCache.get(parent)) === undefined && !isNodePre(parent)) {\n    visited.push(parent);\n    parent = parent.parentNode;\n  }\n  const resultNode = cached === undefined ? parent : cached;\n  for (let i = 0; i < visited.length; i++) {\n    preParentCache.set(visited[i], resultNode);\n  }\n  return resultNode;\n}\nfunction $convertTextDOMNode(domNode) {\n  const domNode_ = domNode;\n  const parentDom = domNode.parentElement;\n  if (!(parentDom !== null)) {\n    throw Error(`Expected parentElement of Text not to be null`);\n  }\n  let textContent = domNode_.textContent || '';\n  // No collapse and preserve segment break for pre, pre-wrap and pre-line\n  if (findParentPreDOMNode(domNode_) !== null) {\n    const parts = textContent.split(/(\\r?\\n|\\t)/);\n    const nodes = [];\n    const length = parts.length;\n    for (let i = 0; i < length; i++) {\n      const part = parts[i];\n      if (part === '\\n' || part === '\\r\\n') {\n        nodes.push($createLineBreakNode());\n      } else if (part === '\\t') {\n        nodes.push($createTabNode());\n      } else if (part !== '') {\n        nodes.push($createTextNode(part));\n      }\n    }\n    return {\n      node: nodes\n    };\n  }\n  textContent = textContent.replace(/\\r/g, '').replace(/[ \\t\\n]+/g, ' ');\n  if (textContent === '') {\n    return {\n      node: null\n    };\n  }\n  if (textContent[0] === ' ') {\n    // Traverse backward while in the same line. If content contains new line or tab -> pontential\n    // delete, other elements can borrow from this one. Deletion depends on whether it's also the\n    // last space (see next condition: textContent[textContent.length - 1] === ' '))\n    let previousText = domNode_;\n    let isStartOfLine = true;\n    while (previousText !== null && (previousText = findTextInLine(previousText, false)) !== null) {\n      const previousTextContent = previousText.textContent || '';\n      if (previousTextContent.length > 0) {\n        if (/[ \\t\\n]$/.test(previousTextContent)) {\n          textContent = textContent.slice(1);\n        }\n        isStartOfLine = false;\n        break;\n      }\n    }\n    if (isStartOfLine) {\n      textContent = textContent.slice(1);\n    }\n  }\n  if (textContent[textContent.length - 1] === ' ') {\n    // Traverse forward while in the same line, preserve if next inline will require a space\n    let nextText = domNode_;\n    let isEndOfLine = true;\n    while (nextText !== null && (nextText = findTextInLine(nextText, true)) !== null) {\n      const nextTextContent = (nextText.textContent || '').replace(/^( |\\t|\\r?\\n)+/, '');\n      if (nextTextContent.length > 0) {\n        isEndOfLine = false;\n        break;\n      }\n    }\n    if (isEndOfLine) {\n      textContent = textContent.slice(0, textContent.length - 1);\n    }\n  }\n  if (textContent === '') {\n    return {\n      node: null\n    };\n  }\n  return {\n    node: $createTextNode(textContent)\n  };\n}\nfunction findTextInLine(text, forward) {\n  let node = text;\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    let sibling;\n    while ((sibling = forward ? node.nextSibling : node.previousSibling) === null) {\n      const parentElement = node.parentElement;\n      if (parentElement === null) {\n        return null;\n      }\n      node = parentElement;\n    }\n    node = sibling;\n    if (isHTMLElement(node)) {\n      const display = node.style.display;\n      if (display === '' && !isInlineDomNode(node) || display !== '' && !display.startsWith('inline')) {\n        return null;\n      }\n    }\n    let descendant = node;\n    while ((descendant = forward ? node.firstChild : node.lastChild) !== null) {\n      node = descendant;\n    }\n    if (isDOMTextNode(node)) {\n      return node;\n    } else if (node.nodeName === 'BR') {\n      return null;\n    }\n  }\n}\nconst nodeNameToTextFormat = {\n  code: 'code',\n  em: 'italic',\n  i: 'italic',\n  s: 'strikethrough',\n  strong: 'bold',\n  sub: 'subscript',\n  sup: 'superscript',\n  u: 'underline'\n};\nfunction convertTextFormatElement(domNode) {\n  const format = nodeNameToTextFormat[domNode.nodeName.toLowerCase()];\n  if (format === undefined) {\n    return {\n      node: null\n    };\n  }\n  return {\n    forChild: applyTextFormatFromStyle(domNode.style, format),\n    node: null\n  };\n}\nfunction $createTextNode(text = '') {\n  return $applyNodeReplacement(new TextNode(text));\n}\nfunction $isTextNode(node) {\n  return node instanceof TextNode;\n}\nfunction applyTextFormatFromStyle(style, shouldApply) {\n  const fontWeight = style.fontWeight;\n  const textDecoration = style.textDecoration.split(' ');\n  // Google Docs uses span tags + font-weight for bold text\n  const hasBoldFontWeight = fontWeight === '700' || fontWeight === 'bold';\n  // Google Docs uses span tags + text-decoration: line-through for strikethrough text\n  const hasLinethroughTextDecoration = textDecoration.includes('line-through');\n  // Google Docs uses span tags + font-style for italic text\n  const hasItalicFontStyle = style.fontStyle === 'italic';\n  // Google Docs uses span tags + text-decoration: underline for underline text\n  const hasUnderlineTextDecoration = textDecoration.includes('underline');\n  // Google Docs uses span tags + vertical-align to specify subscript and superscript\n  const verticalAlign = style.verticalAlign;\n  return lexicalNode => {\n    if (!$isTextNode(lexicalNode)) {\n      return lexicalNode;\n    }\n    if (hasBoldFontWeight && !lexicalNode.hasFormat('bold')) {\n      lexicalNode.toggleFormat('bold');\n    }\n    if (hasLinethroughTextDecoration && !lexicalNode.hasFormat('strikethrough')) {\n      lexicalNode.toggleFormat('strikethrough');\n    }\n    if (hasItalicFontStyle && !lexicalNode.hasFormat('italic')) {\n      lexicalNode.toggleFormat('italic');\n    }\n    if (hasUnderlineTextDecoration && !lexicalNode.hasFormat('underline')) {\n      lexicalNode.toggleFormat('underline');\n    }\n    if (verticalAlign === 'sub' && !lexicalNode.hasFormat('subscript')) {\n      lexicalNode.toggleFormat('subscript');\n    }\n    if (verticalAlign === 'super' && !lexicalNode.hasFormat('superscript')) {\n      lexicalNode.toggleFormat('superscript');\n    }\n    if (shouldApply && !lexicalNode.hasFormat(shouldApply)) {\n      lexicalNode.toggleFormat(shouldApply);\n    }\n    return lexicalNode;\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass TabNode extends TextNode {\n  static getType() {\n    return 'tab';\n  }\n  static clone(node) {\n    return new TabNode(node.__key);\n  }\n  constructor(key) {\n    super('\\t', key);\n    this.__detail = IS_UNMERGEABLE;\n  }\n  static importDOM() {\n    return null;\n  }\n  createDOM(config) {\n    const dom = super.createDOM(config);\n    const classNames = getCachedClassNameArray(config.theme, 'tab');\n    if (classNames !== undefined) {\n      const domClassList = dom.classList;\n      domClassList.add(...classNames);\n    }\n    return dom;\n  }\n  static importJSON(serializedTabNode) {\n    return $createTabNode().updateFromJSON(serializedTabNode);\n  }\n  setTextContent(text) {\n    if (!(text === '\\t' || text === '')) {\n      throw Error(`TabNode does not support setTextContent`);\n    }\n    return super.setTextContent(text);\n  }\n  setDetail(detail) {\n    if (!(detail === IS_UNMERGEABLE)) {\n      throw Error(`TabNode does not support setDetail`);\n    }\n    return this;\n  }\n  setMode(type) {\n    if (!(type === 'normal')) {\n      throw Error(`TabNode does not support setMode`);\n    }\n    return this;\n  }\n  canInsertTextBefore() {\n    return false;\n  }\n  canInsertTextAfter() {\n    return false;\n  }\n}\nfunction $createTabNode() {\n  return $applyNodeReplacement(new TabNode());\n}\nfunction $isTabNode(node) {\n  return node instanceof TabNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nclass Point {\n  constructor(key, offset, type) {\n    {\n      // This prevents a circular reference error when serialized as JSON,\n      // which happens on unit test failures\n      Object.defineProperty(this, '_selection', {\n        enumerable: false,\n        writable: true\n      });\n    }\n    this._selection = null;\n    this.key = key;\n    this.offset = offset;\n    this.type = type;\n  }\n  is(point) {\n    return this.key === point.key && this.offset === point.offset && this.type === point.type;\n  }\n  isBefore(b) {\n    let aNode = this.getNode();\n    let bNode = b.getNode();\n    const aOffset = this.offset;\n    const bOffset = b.offset;\n    if ($isElementNode(aNode)) {\n      const aNodeDescendant = aNode.getDescendantByIndex(aOffset);\n      aNode = aNodeDescendant != null ? aNodeDescendant : aNode;\n    }\n    if ($isElementNode(bNode)) {\n      const bNodeDescendant = bNode.getDescendantByIndex(bOffset);\n      bNode = bNodeDescendant != null ? bNodeDescendant : bNode;\n    }\n    if (aNode === bNode) {\n      return aOffset < bOffset;\n    }\n    return aNode.isBefore(bNode);\n  }\n  getNode() {\n    const key = this.key;\n    const node = $getNodeByKey(key);\n    if (node === null) {\n      {\n        throw Error(`Point.getNode: node not found`);\n      }\n    }\n    return node;\n  }\n  set(key, offset, type) {\n    const selection = this._selection;\n    const oldKey = this.key;\n    this.key = key;\n    this.offset = offset;\n    this.type = type;\n    if (!isCurrentlyReadOnlyMode()) {\n      if ($getCompositionKey() === oldKey) {\n        $setCompositionKey(key);\n      }\n      if (selection !== null) {\n        selection.setCachedNodes(null);\n        selection.dirty = true;\n      }\n    }\n  }\n}\nfunction $createPoint(key, offset, type) {\n  // @ts-expect-error: intentionally cast as we use a class for perf reasons\n  return new Point(key, offset, type);\n}\nfunction selectPointOnNode(point, node) {\n  let key = node.__key;\n  let offset = point.offset;\n  let type = 'element';\n  if ($isTextNode(node)) {\n    type = 'text';\n    const textContentLength = node.getTextContentSize();\n    if (offset > textContentLength) {\n      offset = textContentLength;\n    }\n  } else if (!$isElementNode(node)) {\n    const nextSibling = node.getNextSibling();\n    if ($isTextNode(nextSibling)) {\n      key = nextSibling.__key;\n      offset = 0;\n      type = 'text';\n    } else {\n      const parentNode = node.getParent();\n      if (parentNode) {\n        key = parentNode.__key;\n        offset = node.getIndexWithinParent() + 1;\n      }\n    }\n  }\n  point.set(key, offset, type);\n}\nfunction $moveSelectionPointToEnd(point, node) {\n  if ($isElementNode(node)) {\n    const lastNode = node.getLastDescendant();\n    if ($isElementNode(lastNode) || $isTextNode(lastNode)) {\n      selectPointOnNode(point, lastNode);\n    } else {\n      selectPointOnNode(point, node);\n    }\n  } else {\n    selectPointOnNode(point, node);\n  }\n}\nfunction $transferStartingElementPointToTextPoint(start, end, format, style) {\n  const element = start.getNode();\n  const placementNode = element.getChildAtIndex(start.offset);\n  const textNode = $createTextNode();\n  const target = $isRootNode(element) ? $createParagraphNode().append(textNode) : textNode;\n  textNode.setFormat(format);\n  textNode.setStyle(style);\n  if (placementNode === null) {\n    element.append(target);\n  } else {\n    placementNode.insertBefore(target);\n  }\n  // Transfer the element point to a text point.\n  if (start.is(end)) {\n    end.set(textNode.__key, 0, 'text');\n  }\n  start.set(textNode.__key, 0, 'text');\n}\nfunction $setPointValues(point, key, offset, type) {\n  point.key = key;\n  point.offset = offset;\n  point.type = type;\n}\nclass NodeSelection {\n  constructor(objects) {\n    this._cachedNodes = null;\n    this._nodes = objects;\n    this.dirty = false;\n  }\n  getCachedNodes() {\n    return this._cachedNodes;\n  }\n  setCachedNodes(nodes) {\n    this._cachedNodes = nodes;\n  }\n  is(selection) {\n    if (!$isNodeSelection(selection)) {\n      return false;\n    }\n    const a = this._nodes;\n    const b = selection._nodes;\n    return a.size === b.size && Array.from(a).every(key => b.has(key));\n  }\n  isCollapsed() {\n    return false;\n  }\n  isBackward() {\n    return false;\n  }\n  getStartEndPoints() {\n    return null;\n  }\n  add(key) {\n    this.dirty = true;\n    this._nodes.add(key);\n    this._cachedNodes = null;\n  }\n  delete(key) {\n    this.dirty = true;\n    this._nodes.delete(key);\n    this._cachedNodes = null;\n  }\n  clear() {\n    this.dirty = true;\n    this._nodes.clear();\n    this._cachedNodes = null;\n  }\n  has(key) {\n    return this._nodes.has(key);\n  }\n  clone() {\n    return new NodeSelection(new Set(this._nodes));\n  }\n  extract() {\n    return this.getNodes();\n  }\n  insertRawText(text) {\n    // Do nothing?\n  }\n  insertText() {\n    // Do nothing?\n  }\n  insertNodes(nodes) {\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    const lastSelectedNode = selectedNodes[selectedNodesLength - 1];\n    let selectionAtEnd;\n    // Insert nodes\n    if ($isTextNode(lastSelectedNode)) {\n      selectionAtEnd = lastSelectedNode.select();\n    } else {\n      const index = lastSelectedNode.getIndexWithinParent() + 1;\n      selectionAtEnd = lastSelectedNode.getParentOrThrow().select(index, index);\n    }\n    selectionAtEnd.insertNodes(nodes);\n    // Remove selected nodes\n    for (let i = 0; i < selectedNodesLength; i++) {\n      selectedNodes[i].remove();\n    }\n  }\n  getNodes() {\n    const cachedNodes = this._cachedNodes;\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n    const objects = this._nodes;\n    const nodes = [];\n    for (const object of objects) {\n      const node = $getNodeByKey(object);\n      if (node !== null) {\n        nodes.push(node);\n      }\n    }\n    if (!isCurrentlyReadOnlyMode()) {\n      this._cachedNodes = nodes;\n    }\n    return nodes;\n  }\n  getTextContent() {\n    const nodes = this.getNodes();\n    let textContent = '';\n    for (let i = 0; i < nodes.length; i++) {\n      textContent += nodes[i].getTextContent();\n    }\n    return textContent;\n  }\n}\nfunction $isRangeSelection(x) {\n  return x instanceof RangeSelection;\n}\nclass RangeSelection {\n  constructor(anchor, focus, format, style) {\n    this.anchor = anchor;\n    this.focus = focus;\n    anchor._selection = this;\n    focus._selection = this;\n    this._cachedNodes = null;\n    this.format = format;\n    this.style = style;\n    this.dirty = false;\n  }\n  getCachedNodes() {\n    return this._cachedNodes;\n  }\n  setCachedNodes(nodes) {\n    this._cachedNodes = nodes;\n  }\n\n  /**\n   * Used to check if the provided selections is equal to this one by value,\n   * inluding anchor, focus, format, and style properties.\n   * @param selection - the Selection to compare this one to.\n   * @returns true if the Selections are equal, false otherwise.\n   */\n  is(selection) {\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    return this.anchor.is(selection.anchor) && this.focus.is(selection.focus) && this.format === selection.format && this.style === selection.style;\n  }\n\n  /**\n   * Returns whether the Selection is \"collapsed\", meaning the anchor and focus are\n   * the same node and have the same offset.\n   *\n   * @returns true if the Selection is collapsed, false otherwise.\n   */\n  isCollapsed() {\n    return this.anchor.is(this.focus);\n  }\n\n  /**\n   * Gets all the nodes in the Selection. Uses caching to make it generally suitable\n   * for use in hot paths.\n   *\n   * @returns an Array containing all the nodes in the Selection\n   */\n  getNodes() {\n    const cachedNodes = this._cachedNodes;\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBefore = anchor.isBefore(focus);\n    const firstPoint = isBefore ? anchor : focus;\n    const lastPoint = isBefore ? focus : anchor;\n    let firstNode = firstPoint.getNode();\n    let lastNode = lastPoint.getNode();\n    const overselectedFirstNode = $isElementNode(firstNode) && firstPoint.offset > 0 && firstPoint.offset >= firstNode.getChildrenSize();\n    const startOffset = firstPoint.offset;\n    const endOffset = lastPoint.offset;\n    if ($isElementNode(firstNode)) {\n      const firstNodeDescendant = firstNode.getDescendantByIndex(startOffset);\n      firstNode = firstNodeDescendant != null ? firstNodeDescendant : firstNode;\n    }\n    if ($isElementNode(lastNode)) {\n      let lastNodeDescendant = lastNode.getDescendantByIndex(endOffset);\n      // We don't want to over-select, as node selection infers the child before\n      // the last descendant, not including that descendant.\n      if (lastNodeDescendant !== null && lastNodeDescendant !== firstNode && lastNode.getChildAtIndex(endOffset) === lastNodeDescendant) {\n        lastNodeDescendant = lastNodeDescendant.getPreviousSibling();\n      }\n      lastNode = lastNodeDescendant != null ? lastNodeDescendant : lastNode;\n    }\n    let nodes;\n    if (firstNode.is(lastNode)) {\n      if ($isElementNode(firstNode) && firstNode.getChildrenSize() > 0) {\n        nodes = [];\n      } else {\n        nodes = [firstNode];\n      }\n    } else {\n      nodes = firstNode.getNodesBetween(lastNode);\n      // Prevent over-selection due to the edge case of getDescendantByIndex always returning something #6974\n      if (overselectedFirstNode) {\n        const deleteCount = nodes.findIndex(node => !node.is(firstNode) && !node.isBefore(firstNode));\n        nodes.splice(0, deleteCount);\n      }\n    }\n    if (!isCurrentlyReadOnlyMode()) {\n      this._cachedNodes = nodes;\n    }\n    return nodes;\n  }\n\n  /**\n   * Sets this Selection to be of type \"text\" at the provided anchor and focus values.\n   *\n   * @param anchorNode - the anchor node to set on the Selection\n   * @param anchorOffset - the offset to set on the Selection\n   * @param focusNode - the focus node to set on the Selection\n   * @param focusOffset - the focus offset to set on the Selection\n   */\n  setTextNodeRange(anchorNode, anchorOffset, focusNode, focusOffset) {\n    $setPointValues(this.anchor, anchorNode.__key, anchorOffset, 'text');\n    $setPointValues(this.focus, focusNode.__key, focusOffset, 'text');\n    this._cachedNodes = null;\n    this.dirty = true;\n  }\n\n  /**\n   * Gets the (plain) text content of all the nodes in the selection.\n   *\n   * @returns a string representing the text content of all the nodes in the Selection\n   */\n  getTextContent() {\n    const nodes = this.getNodes();\n    if (nodes.length === 0) {\n      return '';\n    }\n    const firstNode = nodes[0];\n    const lastNode = nodes[nodes.length - 1];\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBefore = anchor.isBefore(focus);\n    const [anchorOffset, focusOffset] = $getCharacterOffsets(this);\n    let textContent = '';\n    let prevWasElement = true;\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if ($isElementNode(node) && !node.isInline()) {\n        if (!prevWasElement) {\n          textContent += '\\n';\n        }\n        if (node.isEmpty()) {\n          prevWasElement = false;\n        } else {\n          prevWasElement = true;\n        }\n      } else {\n        prevWasElement = false;\n        if ($isTextNode(node)) {\n          let text = node.getTextContent();\n          if (node === firstNode) {\n            if (node === lastNode) {\n              if (anchor.type !== 'element' || focus.type !== 'element' || focus.offset === anchor.offset) {\n                text = anchorOffset < focusOffset ? text.slice(anchorOffset, focusOffset) : text.slice(focusOffset, anchorOffset);\n              }\n            } else {\n              text = isBefore ? text.slice(anchorOffset) : text.slice(focusOffset);\n            }\n          } else if (node === lastNode) {\n            text = isBefore ? text.slice(0, focusOffset) : text.slice(0, anchorOffset);\n          }\n          textContent += text;\n        } else if (($isDecoratorNode(node) || $isLineBreakNode(node)) && (node !== lastNode || !this.isCollapsed())) {\n          textContent += node.getTextContent();\n        }\n      }\n    }\n    return textContent;\n  }\n\n  /**\n   * Attempts to map a DOM selection range onto this Lexical Selection,\n   * setting the anchor, focus, and type accordingly\n   *\n   * @param range a DOM Selection range conforming to the StaticRange interface.\n   */\n  applyDOMRange(range) {\n    const editor = getActiveEditor();\n    const currentEditorState = editor.getEditorState();\n    const lastSelection = currentEditorState._selection;\n    const resolvedSelectionPoints = $internalResolveSelectionPoints(range.startContainer, range.startOffset, range.endContainer, range.endOffset, editor, lastSelection);\n    if (resolvedSelectionPoints === null) {\n      return;\n    }\n    const [anchorPoint, focusPoint] = resolvedSelectionPoints;\n    $setPointValues(this.anchor, anchorPoint.key, anchorPoint.offset, anchorPoint.type);\n    $setPointValues(this.focus, focusPoint.key, focusPoint.offset, focusPoint.type);\n    this._cachedNodes = null;\n  }\n\n  /**\n   * Creates a new RangeSelection, copying over all the property values from this one.\n   *\n   * @returns a new RangeSelection with the same property values as this one.\n   */\n  clone() {\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const selection = new RangeSelection($createPoint(anchor.key, anchor.offset, anchor.type), $createPoint(focus.key, focus.offset, focus.type), this.format, this.style);\n    return selection;\n  }\n\n  /**\n   * Toggles the provided format on all the TextNodes in the Selection.\n   *\n   * @param format a string TextFormatType to toggle on the TextNodes in the selection\n   */\n  toggleFormat(format) {\n    this.format = toggleTextFormatType(this.format, format, null);\n    this.dirty = true;\n  }\n\n  /**\n   * Sets the value of the style property on the Selection\n   *\n   * @param style - the style to set at the value of the style property.\n   */\n  setStyle(style) {\n    this.style = style;\n    this.dirty = true;\n  }\n\n  /**\n   * Returns whether the provided TextFormatType is present on the Selection. This will be true if any node in the Selection\n   * has the specified format.\n   *\n   * @param type the TextFormatType to check for.\n   * @returns true if the provided format is currently toggled on on the Selection, false otherwise.\n   */\n  hasFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return (this.format & formatFlag) !== 0;\n  }\n\n  /**\n   * Attempts to insert the provided text into the EditorState at the current Selection.\n   * converts tabs, newlines, and carriage returns into LexicalNodes.\n   *\n   * @param text the text to insert into the Selection\n   */\n  insertRawText(text) {\n    const parts = text.split(/(\\r?\\n|\\t)/);\n    const nodes = [];\n    const length = parts.length;\n    for (let i = 0; i < length; i++) {\n      const part = parts[i];\n      if (part === '\\n' || part === '\\r\\n') {\n        nodes.push($createLineBreakNode());\n      } else if (part === '\\t') {\n        nodes.push($createTabNode());\n      } else {\n        nodes.push($createTextNode(part));\n      }\n    }\n    this.insertNodes(nodes);\n  }\n\n  /**\n   * Insert the provided text into the EditorState at the current Selection.\n   *\n   * @param text the text to insert into the Selection\n   */\n  insertText(text) {\n    // Now that \"removeText\" has been improved and does not depend on\n    // insertText, insertText can be greatly simplified. The next\n    // commented version is a WIP (about 5 tests fail).\n    //\n    // this.removeText();\n    // if (text === '') {\n    //   return;\n    // }\n    // const anchorNode = this.anchor.getNode();\n    // const textNode = $createTextNode(text);\n    // textNode.setFormat(this.format);\n    // textNode.setStyle(this.style);\n    // if ($isTextNode(anchorNode)) {\n    //   const parent = anchorNode.getParentOrThrow();\n    //   if (this.anchor.offset === 0) {\n    //     if (parent.isInline() && !anchorNode.__prev) {\n    //       parent.insertBefore(textNode);\n    //     } else {\n    //       anchorNode.insertBefore(textNode);\n    //     }\n    //   } else if (this.anchor.offset === anchorNode.getTextContentSize()) {\n    //     if (parent.isInline() && !anchorNode.__next) {\n    //       parent.insertAfter(textNode);\n    //     } else {\n    //       anchorNode.insertAfter(textNode);\n    //     }\n    //   } else {\n    //     const [before] = anchorNode.splitText(this.anchor.offset);\n    //     before.insertAfter(textNode);\n    //   }\n    // } else {\n    //   anchorNode.splice(this.anchor.offset, 0, [textNode]);\n    // }\n    // const nodeToSelect = textNode.isAttached() ? textNode : anchorNode;\n    // nodeToSelect.selectEnd();\n    // // When composing, we need to adjust the anchor offset so that\n    // // we correctly replace that right range.\n    // if (\n    //   textNode.isComposing() &&\n    //   this.anchor.type === 'text' &&\n    //   anchorNode.getTextContent() !== ''\n    // ) {\n    //   this.anchor.offset -= text.length;\n    // }\n\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const format = this.format;\n    const style = this.style;\n    let firstPoint = anchor;\n    let endPoint = focus;\n    if (!this.isCollapsed() && focus.isBefore(anchor)) {\n      firstPoint = focus;\n      endPoint = anchor;\n    }\n    if (firstPoint.type === 'element') {\n      $transferStartingElementPointToTextPoint(firstPoint, endPoint, format, style);\n    }\n    const startOffset = firstPoint.offset;\n    let endOffset = endPoint.offset;\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    let firstNode = selectedNodes[0];\n    if (!$isTextNode(firstNode)) {\n      {\n        throw Error(`insertText: first node is not a text node`);\n      }\n    }\n    const firstNodeText = firstNode.getTextContent();\n    const firstNodeTextLength = firstNodeText.length;\n    const firstNodeParent = firstNode.getParentOrThrow();\n    const lastIndex = selectedNodesLength - 1;\n    let lastNode = selectedNodes[lastIndex];\n    if (selectedNodesLength === 1 && endPoint.type === 'element') {\n      endOffset = firstNodeTextLength;\n      endPoint.set(firstPoint.key, endOffset, 'text');\n    }\n    if (this.isCollapsed() && startOffset === firstNodeTextLength && (firstNode.isSegmented() || firstNode.isToken() || !firstNode.canInsertTextAfter() || !firstNodeParent.canInsertTextAfter() && firstNode.getNextSibling() === null)) {\n      let nextSibling = firstNode.getNextSibling();\n      if (!$isTextNode(nextSibling) || !nextSibling.canInsertTextBefore() || $isTokenOrSegmented(nextSibling)) {\n        nextSibling = $createTextNode();\n        nextSibling.setFormat(format);\n        nextSibling.setStyle(style);\n        if (!firstNodeParent.canInsertTextAfter()) {\n          firstNodeParent.insertAfter(nextSibling);\n        } else {\n          firstNode.insertAfter(nextSibling);\n        }\n      }\n      nextSibling.select(0, 0);\n      firstNode = nextSibling;\n      if (text !== '') {\n        this.insertText(text);\n        return;\n      }\n    } else if (this.isCollapsed() && startOffset === 0 && (firstNode.isSegmented() || firstNode.isToken() || !firstNode.canInsertTextBefore() || !firstNodeParent.canInsertTextBefore() && firstNode.getPreviousSibling() === null)) {\n      let prevSibling = firstNode.getPreviousSibling();\n      if (!$isTextNode(prevSibling) || $isTokenOrSegmented(prevSibling)) {\n        prevSibling = $createTextNode();\n        prevSibling.setFormat(format);\n        if (!firstNodeParent.canInsertTextBefore()) {\n          firstNodeParent.insertBefore(prevSibling);\n        } else {\n          firstNode.insertBefore(prevSibling);\n        }\n      }\n      prevSibling.select();\n      firstNode = prevSibling;\n      if (text !== '') {\n        this.insertText(text);\n        return;\n      }\n    } else if (firstNode.isSegmented() && startOffset !== firstNodeTextLength) {\n      const textNode = $createTextNode(firstNode.getTextContent());\n      textNode.setFormat(format);\n      firstNode.replace(textNode);\n      firstNode = textNode;\n    } else if (!this.isCollapsed() && text !== '') {\n      // When the firstNode or lastNode parents are elements that\n      // do not allow text to be inserted before or after, we first\n      // clear the content. Then we normalize selection, then insert\n      // the new content.\n      const lastNodeParent = lastNode.getParent();\n      if (!firstNodeParent.canInsertTextBefore() || !firstNodeParent.canInsertTextAfter() || $isElementNode(lastNodeParent) && (!lastNodeParent.canInsertTextBefore() || !lastNodeParent.canInsertTextAfter())) {\n        this.insertText('');\n        $normalizeSelectionPointsForBoundaries(this.anchor, this.focus, null);\n        this.insertText(text);\n        return;\n      }\n    }\n    if (selectedNodesLength === 1) {\n      if (firstNode.isToken()) {\n        const textNode = $createTextNode(text);\n        textNode.select();\n        firstNode.replace(textNode);\n        return;\n      }\n      const firstNodeFormat = firstNode.getFormat();\n      const firstNodeStyle = firstNode.getStyle();\n      if (startOffset === endOffset && (firstNodeFormat !== format || firstNodeStyle !== style)) {\n        if (firstNode.getTextContent() === '') {\n          firstNode.setFormat(format);\n          firstNode.setStyle(style);\n        } else {\n          const textNode = $createTextNode(text);\n          textNode.setFormat(format);\n          textNode.setStyle(style);\n          textNode.select();\n          if (startOffset === 0) {\n            firstNode.insertBefore(textNode, false);\n          } else {\n            const [targetNode] = firstNode.splitText(startOffset);\n            targetNode.insertAfter(textNode, false);\n          }\n          // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n          if (textNode.isComposing() && this.anchor.type === 'text') {\n            this.anchor.offset -= text.length;\n          }\n          return;\n        }\n      } else if ($isTabNode(firstNode)) {\n        // We don't need to check for delCount because there is only the entire selected node case\n        // that can hit here for content size 1 and with canInsertTextBeforeAfter false\n        const textNode = $createTextNode(text);\n        textNode.setFormat(format);\n        textNode.setStyle(style);\n        textNode.select();\n        firstNode.replace(textNode);\n        return;\n      }\n      const delCount = endOffset - startOffset;\n      firstNode = firstNode.spliceText(startOffset, delCount, text, true);\n      if (firstNode.getTextContent() === '') {\n        firstNode.remove();\n      } else if (this.anchor.type === 'text') {\n        if (firstNode.isComposing()) {\n          // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n          this.anchor.offset -= text.length;\n        } else {\n          this.format = firstNodeFormat;\n          this.style = firstNodeStyle;\n        }\n      }\n    } else {\n      const markedNodeKeysForKeep = new Set([...firstNode.getParentKeys(), ...lastNode.getParentKeys()]);\n\n      // We have to get the parent elements before the next section,\n      // as in that section we might mutate the lastNode.\n      const firstElement = $isElementNode(firstNode) ? firstNode : firstNode.getParentOrThrow();\n      let lastElement = $isElementNode(lastNode) ? lastNode : lastNode.getParentOrThrow();\n      let lastElementChild = lastNode;\n\n      // If the last element is inline, we should instead look at getting\n      // the nodes of its parent, rather than itself. This behavior will\n      // then better match how text node insertions work. We will need to\n      // also update the last element's child accordingly as we do this.\n      if (!firstElement.is(lastElement) && lastElement.isInline()) {\n        // Keep traversing till we have a non-inline element parent.\n        do {\n          lastElementChild = lastElement;\n          lastElement = lastElement.getParentOrThrow();\n        } while (lastElement.isInline());\n      }\n\n      // Handle mutations to the last node.\n      if (endPoint.type === 'text' && (endOffset !== 0 || lastNode.getTextContent() === '') || endPoint.type === 'element' && lastNode.getIndexWithinParent() < endOffset) {\n        if ($isTextNode(lastNode) && !lastNode.isToken() && endOffset !== lastNode.getTextContentSize()) {\n          if (lastNode.isSegmented()) {\n            const textNode = $createTextNode(lastNode.getTextContent());\n            lastNode.replace(textNode);\n            lastNode = textNode;\n          }\n          // root node selections only select whole nodes, so no text splice is necessary\n          if (!$isRootNode(endPoint.getNode()) && endPoint.type === 'text') {\n            lastNode = lastNode.spliceText(0, endOffset, '');\n          }\n          markedNodeKeysForKeep.add(lastNode.__key);\n        } else {\n          const lastNodeParent = lastNode.getParentOrThrow();\n          if (!lastNodeParent.canBeEmpty() && lastNodeParent.getChildrenSize() === 1) {\n            lastNodeParent.remove();\n          } else {\n            lastNode.remove();\n          }\n        }\n      } else {\n        markedNodeKeysForKeep.add(lastNode.__key);\n      }\n\n      // Either move the remaining nodes of the last parent to after\n      // the first child, or remove them entirely. If the last parent\n      // is the same as the first parent, this logic also works.\n      const lastNodeChildren = lastElement.getChildren();\n      const selectedNodesSet = new Set(selectedNodes);\n      const firstAndLastElementsAreEqual = firstElement.is(lastElement);\n\n      // We choose a target to insert all nodes after. In the case of having\n      // and inline starting parent element with a starting node that has no\n      // siblings, we should insert after the starting parent element, otherwise\n      // we will incorrectly merge into the starting parent element.\n      // TODO: should we keep on traversing parents if we're inside another\n      // nested inline element?\n      const insertionTarget = firstElement.isInline() && firstNode.getNextSibling() === null ? firstElement : firstNode;\n      for (let i = lastNodeChildren.length - 1; i >= 0; i--) {\n        const lastNodeChild = lastNodeChildren[i];\n        if (lastNodeChild.is(firstNode) || $isElementNode(lastNodeChild) && lastNodeChild.isParentOf(firstNode)) {\n          break;\n        }\n        if (lastNodeChild.isAttached()) {\n          if (!selectedNodesSet.has(lastNodeChild) || lastNodeChild.is(lastElementChild)) {\n            if (!firstAndLastElementsAreEqual) {\n              insertionTarget.insertAfter(lastNodeChild, false);\n            }\n          } else {\n            lastNodeChild.remove();\n          }\n        }\n      }\n      if (!firstAndLastElementsAreEqual) {\n        // Check if we have already moved out all the nodes of the\n        // last parent, and if so, traverse the parent tree and mark\n        // them all as being able to deleted too.\n        let parent = lastElement;\n        let lastRemovedParent = null;\n        while (parent !== null) {\n          const children = parent.getChildren();\n          const childrenLength = children.length;\n          if (childrenLength === 0 || children[childrenLength - 1].is(lastRemovedParent)) {\n            markedNodeKeysForKeep.delete(parent.__key);\n            lastRemovedParent = parent;\n          }\n          parent = parent.getParent();\n        }\n      }\n\n      // Ensure we do splicing after moving of nodes, as splicing\n      // can have side-effects (in the case of hashtags).\n      if (!firstNode.isToken()) {\n        firstNode = firstNode.spliceText(startOffset, firstNodeTextLength - startOffset, text, true);\n        if (firstNode.getTextContent() === '') {\n          firstNode.remove();\n        } else if (firstNode.isComposing() && this.anchor.type === 'text') {\n          // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n          this.anchor.offset -= text.length;\n        }\n      } else if (startOffset === firstNodeTextLength) {\n        firstNode.select();\n      } else {\n        const textNode = $createTextNode(text);\n        textNode.select();\n        firstNode.replace(textNode);\n      }\n\n      // Remove all selected nodes that haven't already been removed.\n      for (let i = 1; i < selectedNodesLength; i++) {\n        const selectedNode = selectedNodes[i];\n        const key = selectedNode.__key;\n        if (!markedNodeKeysForKeep.has(key)) {\n          selectedNode.remove();\n        }\n      }\n    }\n  }\n\n  /**\n   * Removes the text in the Selection, adjusting the EditorState accordingly.\n   */\n  removeText() {\n    if (this.isCollapsed()) {\n      return;\n    }\n    const {\n      anchor,\n      focus\n    } = this;\n    const selectedNodes = this.getNodes();\n    const firstPoint = this.isBackward() ? focus : anchor;\n    const lastPoint = this.isBackward() ? anchor : focus;\n    let firstNode = firstPoint.getNode();\n    let lastNode = lastPoint.getNode();\n    const firstBlock = $getAncestor(firstNode, INTERNAL_$isBlock);\n    const lastBlock = $getAncestor(lastNode, INTERNAL_$isBlock);\n    // If a token is partially selected then move the selection to cover the whole selection\n    if ($isTextNode(firstNode) && firstNode.isToken() && firstPoint.offset < firstNode.getTextContentSize()) {\n      firstPoint.offset = 0;\n    }\n    if (lastPoint.offset > 0 && $isTextNode(lastNode) && lastNode.isToken()) {\n      lastPoint.offset = lastNode.getTextContentSize();\n    }\n    for (const node of selectedNodes) {\n      if (!$hasAncestor(firstNode, node) && !$hasAncestor(lastNode, node) && node.getKey() !== firstNode.getKey() && node.getKey() !== lastNode.getKey()) {\n        node.remove();\n      }\n    }\n    const fixText = (node, del) => {\n      if (node.getTextContent() === '') {\n        node.remove();\n      } else if (del !== 0 && $isTokenOrSegmented(node)) {\n        const textNode = $createTextNode(node.getTextContent());\n        textNode.setFormat(node.getFormat());\n        textNode.setStyle(node.getStyle());\n        return node.replace(textNode);\n      }\n    };\n    if (firstNode === lastNode && $isTextNode(firstNode)) {\n      const del = Math.abs(focus.offset - anchor.offset);\n      firstNode.spliceText(firstPoint.offset, del, '', true);\n      fixText(firstNode, del);\n      return;\n    }\n    if ($isTextNode(firstNode)) {\n      const del = firstNode.getTextContentSize() - firstPoint.offset;\n      firstNode.spliceText(firstPoint.offset, del, '');\n      firstNode = fixText(firstNode, del) || firstNode;\n    }\n    if ($isTextNode(lastNode)) {\n      lastNode.spliceText(0, lastPoint.offset, '');\n      lastNode = fixText(lastNode, lastPoint.offset) || lastNode;\n    }\n    if (firstNode.isAttached() && $isTextNode(firstNode)) {\n      firstNode.selectEnd();\n    } else if (lastNode.isAttached() && $isTextNode(lastNode)) {\n      lastNode.selectStart();\n    }\n\n    // Merge blocks\n    const bothElem = $isElementNode(firstBlock) && $isElementNode(lastBlock);\n    if (bothElem && firstBlock !== lastBlock) {\n      firstBlock.append(...lastBlock.getChildren());\n      lastBlock.remove();\n      lastPoint.set(firstPoint.key, firstPoint.offset, firstPoint.type);\n    }\n  }\n\n  // TO-DO: Migrate this method to the new utility function $forEachSelectedTextNode (share similar logic)\n  /**\n   * Applies the provided format to the TextNodes in the Selection, splitting or\n   * merging nodes as necessary.\n   *\n   * @param formatType the format type to apply to the nodes in the Selection.\n   * @param alignWithFormat a 32-bit integer representing formatting flags to align with.\n   */\n  formatText(formatType, alignWithFormat = null) {\n    if (this.isCollapsed()) {\n      this.toggleFormat(formatType);\n      // When changing format, we should stop composition\n      $setCompositionKey(null);\n      return;\n    }\n    const selectedNodes = this.getNodes();\n    const selectedTextNodes = [];\n    for (const selectedNode of selectedNodes) {\n      if ($isTextNode(selectedNode)) {\n        selectedTextNodes.push(selectedNode);\n      }\n    }\n    const applyFormatToElements = alignWith => {\n      selectedNodes.forEach(node => {\n        if ($isElementNode(node)) {\n          const newFormat = node.getFormatFlags(formatType, alignWith);\n          node.setTextFormat(newFormat);\n        }\n      });\n    };\n    const selectedTextNodesLength = selectedTextNodes.length;\n    if (selectedTextNodesLength === 0) {\n      this.toggleFormat(formatType);\n      // When changing format, we should stop composition\n      $setCompositionKey(null);\n      applyFormatToElements(alignWithFormat);\n      return;\n    }\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBackward = this.isBackward();\n    const startPoint = isBackward ? focus : anchor;\n    const endPoint = isBackward ? anchor : focus;\n    let firstIndex = 0;\n    let firstNode = selectedTextNodes[0];\n    let startOffset = startPoint.type === 'element' ? 0 : startPoint.offset;\n\n    // In case selection started at the end of text node use next text node\n    if (startPoint.type === 'text' && startOffset === firstNode.getTextContentSize()) {\n      firstIndex = 1;\n      firstNode = selectedTextNodes[1];\n      startOffset = 0;\n    }\n    if (firstNode == null) {\n      return;\n    }\n    const firstNextFormat = firstNode.getFormatFlags(formatType, alignWithFormat);\n    applyFormatToElements(firstNextFormat);\n    const lastIndex = selectedTextNodesLength - 1;\n    let lastNode = selectedTextNodes[lastIndex];\n    const endOffset = endPoint.type === 'text' ? endPoint.offset : lastNode.getTextContentSize();\n\n    // Single node selected\n    if (firstNode.is(lastNode)) {\n      // No actual text is selected, so do nothing.\n      if (startOffset === endOffset) {\n        return;\n      }\n      // The entire node is selected or it is token, so just format it\n      if ($isTokenOrSegmented(firstNode) || startOffset === 0 && endOffset === firstNode.getTextContentSize()) {\n        firstNode.setFormat(firstNextFormat);\n      } else {\n        // Node is partially selected, so split it into two nodes\n        // add style the selected one.\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        replacement.setFormat(firstNextFormat);\n\n        // Update selection only if starts/ends on text node\n        if (startPoint.type === 'text') {\n          startPoint.set(replacement.__key, 0, 'text');\n        }\n        if (endPoint.type === 'text') {\n          endPoint.set(replacement.__key, endOffset - startOffset, 'text');\n        }\n      }\n      this.format = firstNextFormat;\n      return;\n    }\n    // Multiple nodes selected\n    // The entire first node isn't selected, so split it\n    if (startOffset !== 0 && !$isTokenOrSegmented(firstNode)) {\n      [, firstNode] = firstNode.splitText(startOffset);\n      startOffset = 0;\n    }\n    firstNode.setFormat(firstNextFormat);\n    const lastNextFormat = lastNode.getFormatFlags(formatType, firstNextFormat);\n    // If the offset is 0, it means no actual characters are selected,\n    // so we skip formatting the last node altogether.\n    if (endOffset > 0) {\n      if (endOffset !== lastNode.getTextContentSize() && !$isTokenOrSegmented(lastNode)) {\n        [lastNode] = lastNode.splitText(endOffset);\n      }\n      lastNode.setFormat(lastNextFormat);\n    }\n\n    // Process all text nodes in between\n    for (let i = firstIndex + 1; i < lastIndex; i++) {\n      const textNode = selectedTextNodes[i];\n      const nextFormat = textNode.getFormatFlags(formatType, lastNextFormat);\n      textNode.setFormat(nextFormat);\n    }\n\n    // Update selection only if starts/ends on text node\n    if (startPoint.type === 'text') {\n      startPoint.set(firstNode.__key, startOffset, 'text');\n    }\n    if (endPoint.type === 'text') {\n      endPoint.set(lastNode.__key, endOffset, 'text');\n    }\n    this.format = firstNextFormat | lastNextFormat;\n  }\n\n  /**\n   * Attempts to \"intelligently\" insert an arbitrary list of Lexical nodes into the EditorState at the\n   * current Selection according to a set of heuristics that determine how surrounding nodes\n   * should be changed, replaced, or moved to accommodate the incoming ones.\n   *\n   * @param nodes - the nodes to insert\n   */\n  insertNodes(nodes) {\n    if (nodes.length === 0) {\n      return;\n    }\n    if (this.anchor.key === 'root') {\n      this.insertParagraph();\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection)) {\n        throw Error(`Expected RangeSelection after insertParagraph`);\n      }\n      return selection.insertNodes(nodes);\n    }\n    const firstPoint = this.isBackward() ? this.focus : this.anchor;\n    const firstNode = firstPoint.getNode();\n    const firstBlock = $getAncestor(firstNode, INTERNAL_$isBlock);\n    const last = nodes[nodes.length - 1];\n\n    // CASE 1: insert inside a code block\n    if ($isElementNode(firstBlock) && '__language' in firstBlock) {\n      if ('__language' in nodes[0]) {\n        this.insertText(nodes[0].getTextContent());\n      } else {\n        const index = $removeTextAndSplitBlock(this);\n        firstBlock.splice(index, 0, nodes);\n        last.selectEnd();\n      }\n      return;\n    }\n\n    // CASE 2: All elements of the array are inline\n    const notInline = node => ($isElementNode(node) || $isDecoratorNode(node)) && !node.isInline();\n    if (!nodes.some(notInline)) {\n      if (!$isElementNode(firstBlock)) {\n        throw Error(`Expected node ${firstNode.constructor.name} of type ${firstNode.getType()} to have a block ElementNode ancestor`);\n      }\n      const index = $removeTextAndSplitBlock(this);\n      firstBlock.splice(index, 0, nodes);\n      last.selectEnd();\n      return;\n    }\n\n    // CASE 3: At least 1 element of the array is not inline\n    const blocksParent = $wrapInlineNodes(nodes);\n    const nodeToSelect = blocksParent.getLastDescendant();\n    const blocks = blocksParent.getChildren();\n    const isMergeable = node => $isElementNode(node) && INTERNAL_$isBlock(node) && !node.isEmpty() && $isElementNode(firstBlock) && (!firstBlock.isEmpty() || firstBlock.canMergeWhenEmpty());\n    const shouldInsert = !$isElementNode(firstBlock) || !firstBlock.isEmpty();\n    const insertedParagraph = shouldInsert ? this.insertParagraph() : null;\n    const lastToInsert = blocks[blocks.length - 1];\n    let firstToInsert = blocks[0];\n    if (isMergeable(firstToInsert)) {\n      if (!$isElementNode(firstBlock)) {\n        throw Error(`Expected node ${firstNode.constructor.name} of type ${firstNode.getType()} to have a block ElementNode ancestor`);\n      }\n      firstBlock.append(...firstToInsert.getChildren());\n      firstToInsert = blocks[1];\n    }\n    if (firstToInsert) {\n      if (!(firstBlock !== null)) {\n        throw Error(`Expected node ${firstNode.constructor.name} of type ${firstNode.getType()} to have a block ancestor`);\n      }\n      insertRangeAfter(firstBlock, firstToInsert);\n    }\n    const lastInsertedBlock = $getAncestor(nodeToSelect, INTERNAL_$isBlock);\n    if (insertedParagraph && $isElementNode(lastInsertedBlock) && (insertedParagraph.canMergeWhenEmpty() || INTERNAL_$isBlock(lastToInsert))) {\n      lastInsertedBlock.append(...insertedParagraph.getChildren());\n      insertedParagraph.remove();\n    }\n    if ($isElementNode(firstBlock) && firstBlock.isEmpty()) {\n      firstBlock.remove();\n    }\n    nodeToSelect.selectEnd();\n\n    // To understand this take a look at the test \"can wrap post-linebreak nodes into new element\"\n    const lastChild = $isElementNode(firstBlock) ? firstBlock.getLastChild() : null;\n    if ($isLineBreakNode(lastChild) && lastInsertedBlock !== firstBlock) {\n      lastChild.remove();\n    }\n  }\n\n  /**\n   * Inserts a new ParagraphNode into the EditorState at the current Selection\n   *\n   * @returns the newly inserted node.\n   */\n  insertParagraph() {\n    if (this.anchor.key === 'root') {\n      const paragraph = $createParagraphNode();\n      $getRoot().splice(this.anchor.offset, 0, [paragraph]);\n      paragraph.select();\n      return paragraph;\n    }\n    const index = $removeTextAndSplitBlock(this);\n    const block = $getAncestor(this.anchor.getNode(), INTERNAL_$isBlock);\n    if (!$isElementNode(block)) {\n      throw Error(`Expected ancestor to be a block ElementNode`);\n    }\n    const firstToAppend = block.getChildAtIndex(index);\n    const nodesToInsert = firstToAppend ? [firstToAppend, ...firstToAppend.getNextSiblings()] : [];\n    const newBlock = block.insertNewAfter(this, false);\n    if (newBlock) {\n      newBlock.append(...nodesToInsert);\n      newBlock.selectStart();\n      return newBlock;\n    }\n    // if newBlock is null, it means that block is of type CodeNode.\n    return null;\n  }\n\n  /**\n   * Inserts a logical linebreak, which may be a new LineBreakNode or a new ParagraphNode, into the EditorState at the\n   * current Selection.\n   */\n  insertLineBreak(selectStart) {\n    const lineBreak = $createLineBreakNode();\n    this.insertNodes([lineBreak]);\n    // this is used in MacOS with the command 'ctrl-O' (openLineBreak)\n    if (selectStart) {\n      const parent = lineBreak.getParentOrThrow();\n      const index = lineBreak.getIndexWithinParent();\n      parent.select(index, index);\n    }\n  }\n\n  /**\n   * Extracts the nodes in the Selection, splitting nodes where necessary\n   * to get offset-level precision.\n   *\n   * @returns The nodes in the Selection\n   */\n  extract() {\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    const lastIndex = selectedNodesLength - 1;\n    const anchor = this.anchor;\n    const focus = this.focus;\n    let firstNode = selectedNodes[0];\n    let lastNode = selectedNodes[lastIndex];\n    const [anchorOffset, focusOffset] = $getCharacterOffsets(this);\n    if (selectedNodesLength === 0) {\n      return [];\n    } else if (selectedNodesLength === 1) {\n      if ($isTextNode(firstNode) && !this.isCollapsed()) {\n        const startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\n        const endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const node = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        return node != null ? [node] : [];\n      }\n      return [firstNode];\n    }\n    const isBefore = anchor.isBefore(focus);\n    if ($isTextNode(firstNode)) {\n      const startOffset = isBefore ? anchorOffset : focusOffset;\n      if (startOffset === firstNode.getTextContentSize()) {\n        selectedNodes.shift();\n      } else if (startOffset !== 0) {\n        [, firstNode] = firstNode.splitText(startOffset);\n        selectedNodes[0] = firstNode;\n      }\n    }\n    if ($isTextNode(lastNode)) {\n      const lastNodeText = lastNode.getTextContent();\n      const lastNodeTextLength = lastNodeText.length;\n      const endOffset = isBefore ? focusOffset : anchorOffset;\n      if (endOffset === 0) {\n        selectedNodes.pop();\n      } else if (endOffset !== lastNodeTextLength) {\n        [lastNode] = lastNode.splitText(endOffset);\n        selectedNodes[lastIndex] = lastNode;\n      }\n    }\n    return selectedNodes;\n  }\n\n  /**\n   * Modifies the Selection according to the parameters and a set of heuristics that account for\n   * various node types. Can be used to safely move or extend selection by one logical \"unit\" without\n   * dealing explicitly with all the possible node types.\n   *\n   * @param alter the type of modification to perform\n   * @param isBackward whether or not selection is backwards\n   * @param granularity the granularity at which to apply the modification\n   */\n  modify(alter, isBackward, granularity) {\n    const focus = this.focus;\n    const anchor = this.anchor;\n    const collapse = alter === 'move';\n\n    // Handle the selection movement around decorators.\n    const possibleNode = $getAdjacentNode(focus, isBackward);\n    if ($isDecoratorNode(possibleNode) && !possibleNode.isIsolated()) {\n      // Make it possible to move selection from range selection to\n      // node selection on the node.\n      if (collapse && possibleNode.isKeyboardSelectable()) {\n        const nodeSelection = $createNodeSelection();\n        nodeSelection.add(possibleNode.__key);\n        $setSelection(nodeSelection);\n        return;\n      }\n      const sibling = isBackward ? possibleNode.getPreviousSibling() : possibleNode.getNextSibling();\n      if (!$isTextNode(sibling)) {\n        const parent = possibleNode.getParentOrThrow();\n        let offset;\n        let elementKey;\n        if ($isElementNode(sibling)) {\n          elementKey = sibling.__key;\n          offset = isBackward ? sibling.getChildrenSize() : 0;\n        } else {\n          offset = possibleNode.getIndexWithinParent();\n          elementKey = parent.__key;\n          if (!isBackward) {\n            offset++;\n          }\n        }\n        focus.set(elementKey, offset, 'element');\n        if (collapse) {\n          anchor.set(elementKey, offset, 'element');\n        }\n        return;\n      } else {\n        const siblingKey = sibling.__key;\n        const offset = isBackward ? sibling.getTextContent().length : 0;\n        focus.set(siblingKey, offset, 'text');\n        if (collapse) {\n          anchor.set(siblingKey, offset, 'text');\n        }\n        return;\n      }\n    }\n    const editor = getActiveEditor();\n    const domSelection = getDOMSelection(editor._window);\n    if (!domSelection) {\n      return;\n    }\n    const blockCursorElement = editor._blockCursorElement;\n    const rootElement = editor._rootElement;\n    // Remove the block cursor element if it exists. This will ensure selection\n    // works as intended. If we leave it in the DOM all sorts of strange bugs\n    // occur. :/\n    if (rootElement !== null && blockCursorElement !== null && $isElementNode(possibleNode) && !possibleNode.isInline() && !possibleNode.canBeEmpty()) {\n      removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\n    }\n    // We use the DOM selection.modify API here to \"tell\" us what the selection\n    // will be. We then use it to update the Lexical selection accordingly. This\n    // is much more reliable than waiting for a beforeinput and using the ranges\n    // from getTargetRanges(), and is also better than trying to do it ourselves\n    // using Intl.Segmenter or other workarounds that struggle with word segments\n    // and line segments (especially with word wrapping and non-Roman languages).\n    moveNativeSelection(domSelection, alter, isBackward ? 'backward' : 'forward', granularity);\n    // Guard against no ranges\n    if (domSelection.rangeCount > 0) {\n      const range = domSelection.getRangeAt(0);\n      // Apply the DOM selection to our Lexical selection.\n      const anchorNode = this.anchor.getNode();\n      const root = $isRootNode(anchorNode) ? anchorNode : $getNearestRootOrShadowRoot(anchorNode);\n      this.applyDOMRange(range);\n      this.dirty = true;\n      if (!collapse) {\n        // Validate selection; make sure that the new extended selection respects shadow roots\n        const nodes = this.getNodes();\n        const validNodes = [];\n        let shrinkSelection = false;\n        for (let i = 0; i < nodes.length; i++) {\n          const nextNode = nodes[i];\n          if ($hasAncestor(nextNode, root)) {\n            validNodes.push(nextNode);\n          } else {\n            shrinkSelection = true;\n          }\n        }\n        if (shrinkSelection && validNodes.length > 0) {\n          // validNodes length check is a safeguard against an invalid selection; as getNodes()\n          // will return an empty array in this case\n          if (isBackward) {\n            const firstValidNode = validNodes[0];\n            if ($isElementNode(firstValidNode)) {\n              firstValidNode.selectStart();\n            } else {\n              firstValidNode.getParentOrThrow().selectStart();\n            }\n          } else {\n            const lastValidNode = validNodes[validNodes.length - 1];\n            if ($isElementNode(lastValidNode)) {\n              lastValidNode.selectEnd();\n            } else {\n              lastValidNode.getParentOrThrow().selectEnd();\n            }\n          }\n        }\n\n        // Because a range works on start and end, we might need to flip\n        // the anchor and focus points to match what the DOM has, not what\n        // the range has specifically.\n        if (domSelection.anchorNode !== range.startContainer || domSelection.anchorOffset !== range.startOffset) {\n          $swapPoints(this);\n        }\n      }\n    }\n  }\n  /**\n   * Helper for handling forward character and word deletion that prevents element nodes\n   * like a table, columns layout being destroyed\n   *\n   * @param anchor the anchor\n   * @param anchorNode the anchor node in the selection\n   * @param isBackward whether or not selection is backwards\n   */\n  forwardDeletion(anchor, anchorNode, isBackward) {\n    if (!isBackward && (\n    // Delete forward handle case\n    anchor.type === 'element' && $isElementNode(anchorNode) && anchor.offset === anchorNode.getChildrenSize() || anchor.type === 'text' && anchor.offset === anchorNode.getTextContentSize())) {\n      const parent = anchorNode.getParent();\n      const nextSibling = anchorNode.getNextSibling() || (parent === null ? null : parent.getNextSibling());\n      if ($isElementNode(nextSibling) && nextSibling.isShadowRoot()) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Performs one logical character deletion operation on the EditorState based on the current Selection.\n   * Handles different node types.\n   *\n   * @param isBackward whether or not the selection is backwards.\n   */\n  deleteCharacter(isBackward) {\n    const wasCollapsed = this.isCollapsed();\n    if (this.isCollapsed()) {\n      const anchor = this.anchor;\n      let anchorNode = anchor.getNode();\n      if (this.forwardDeletion(anchor, anchorNode, isBackward)) {\n        return;\n      }\n\n      // Handle the deletion around decorators.\n      const focus = this.focus;\n      const possibleNode = $getAdjacentNode(focus, isBackward);\n      if ($isDecoratorNode(possibleNode) && !possibleNode.isIsolated()) {\n        // Make it possible to move selection from range selection to\n        // node selection on the node.\n        if (possibleNode.isKeyboardSelectable() && $isElementNode(anchorNode) && anchorNode.getChildrenSize() === 0) {\n          anchorNode.remove();\n          const nodeSelection = $createNodeSelection();\n          nodeSelection.add(possibleNode.__key);\n          $setSelection(nodeSelection);\n        } else {\n          possibleNode.remove();\n          const editor = getActiveEditor();\n          editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n        }\n        return;\n      } else if (!isBackward && $isElementNode(possibleNode) && $isElementNode(anchorNode) && anchorNode.isEmpty()) {\n        anchorNode.remove();\n        possibleNode.selectStart();\n        return;\n      }\n      this.modify('extend', isBackward, 'character');\n      if (!this.isCollapsed()) {\n        const focusNode = focus.type === 'text' ? focus.getNode() : null;\n        anchorNode = anchor.type === 'text' ? anchor.getNode() : null;\n        if (focusNode !== null && focusNode.isSegmented()) {\n          const offset = focus.offset;\n          const textContentSize = focusNode.getTextContentSize();\n          if (focusNode.is(anchorNode) || isBackward && offset !== textContentSize || !isBackward && offset !== 0) {\n            $removeSegment(focusNode, isBackward, offset);\n            return;\n          }\n        } else if (anchorNode !== null && anchorNode.isSegmented()) {\n          const offset = anchor.offset;\n          const textContentSize = anchorNode.getTextContentSize();\n          if (anchorNode.is(focusNode) || isBackward && offset !== 0 || !isBackward && offset !== textContentSize) {\n            $removeSegment(anchorNode, isBackward, offset);\n            return;\n          }\n        }\n        $updateCaretSelectionForUnicodeCharacter(this, isBackward);\n      } else if (isBackward && anchor.offset === 0) {\n        // Special handling around rich text nodes\n        const element = anchor.type === 'element' ? anchor.getNode() : anchor.getNode().getParentOrThrow();\n        if (element.collapseAtStart(this)) {\n          return;\n        }\n      }\n    }\n    this.removeText();\n    if (isBackward && !wasCollapsed && this.isCollapsed() && this.anchor.type === 'element' && this.anchor.offset === 0) {\n      const anchorNode = this.anchor.getNode();\n      if (anchorNode.isEmpty() && $isRootNode(anchorNode.getParent()) && anchorNode.getIndexWithinParent() === 0) {\n        anchorNode.collapseAtStart(this);\n      }\n    }\n  }\n\n  /**\n   * Performs one logical line deletion operation on the EditorState based on the current Selection.\n   * Handles different node types.\n   *\n   * @param isBackward whether or not the selection is backwards.\n   */\n  deleteLine(isBackward) {\n    if (this.isCollapsed()) {\n      // Since `domSelection.modify('extend', ..., 'lineboundary')` works well for text selections\n      // but doesn't properly handle selections which end on elements, a space character is added\n      // for such selections transforming their anchor's type to 'text'\n      const anchorIsElement = this.anchor.type === 'element';\n      if (anchorIsElement) {\n        this.insertText(' ');\n      }\n      this.modify('extend', isBackward, 'lineboundary');\n\n      // If the selection starts at the beginning of a text node (offset 0),\n      // extend the selection by one character in the specified direction.\n      // This ensures that the parent element is deleted along with its content.\n      // Otherwise, only the text content will be deleted, leaving an empty parent node.\n      if (this.isCollapsed() && this.anchor.offset === 0) {\n        this.modify('extend', isBackward, 'character');\n      }\n\n      // Adjusts selection to include an extra character added for element anchors to remove it\n      if (anchorIsElement) {\n        const startPoint = isBackward ? this.anchor : this.focus;\n        startPoint.set(startPoint.key, startPoint.offset + 1, startPoint.type);\n      }\n    }\n    this.removeText();\n  }\n\n  /**\n   * Performs one logical word deletion operation on the EditorState based on the current Selection.\n   * Handles different node types.\n   *\n   * @param isBackward whether or not the selection is backwards.\n   */\n  deleteWord(isBackward) {\n    if (this.isCollapsed()) {\n      const anchor = this.anchor;\n      const anchorNode = anchor.getNode();\n      if (this.forwardDeletion(anchor, anchorNode, isBackward)) {\n        return;\n      }\n      this.modify('extend', isBackward, 'word');\n    }\n    this.removeText();\n  }\n\n  /**\n   * Returns whether the Selection is \"backwards\", meaning the focus\n   * logically precedes the anchor in the EditorState.\n   * @returns true if the Selection is backwards, false otherwise.\n   */\n  isBackward() {\n    return this.focus.isBefore(this.anchor);\n  }\n  getStartEndPoints() {\n    return [this.anchor, this.focus];\n  }\n}\nfunction $isNodeSelection(x) {\n  return x instanceof NodeSelection;\n}\nfunction getCharacterOffset(point) {\n  const offset = point.offset;\n  if (point.type === 'text') {\n    return offset;\n  }\n  const parent = point.getNode();\n  return offset === parent.getChildrenSize() ? parent.getTextContent().length : 0;\n}\nfunction $getCharacterOffsets(selection) {\n  const anchorAndFocus = selection.getStartEndPoints();\n  if (anchorAndFocus === null) {\n    return [0, 0];\n  }\n  const [anchor, focus] = anchorAndFocus;\n  if (anchor.type === 'element' && focus.type === 'element' && anchor.key === focus.key && anchor.offset === focus.offset) {\n    return [0, 0];\n  }\n  return [getCharacterOffset(anchor), getCharacterOffset(focus)];\n}\nfunction $swapPoints(selection) {\n  const focus = selection.focus;\n  const anchor = selection.anchor;\n  const anchorKey = anchor.key;\n  const anchorOffset = anchor.offset;\n  const anchorType = anchor.type;\n  $setPointValues(anchor, focus.key, focus.offset, focus.type);\n  $setPointValues(focus, anchorKey, anchorOffset, anchorType);\n  selection._cachedNodes = null;\n}\nfunction moveNativeSelection(domSelection, alter, direction, granularity) {\n  // Selection.modify() method applies a change to the current selection or cursor position,\n  // but is still non-standard in some browsers.\n  domSelection.modify(alter, direction, granularity);\n}\nfunction $updateCaretSelectionForUnicodeCharacter(selection, isBackward) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if (anchorNode === focusNode && anchor.type === 'text' && focus.type === 'text') {\n    // Handling of multibyte characters\n    const anchorOffset = anchor.offset;\n    const focusOffset = focus.offset;\n    const isBefore = anchorOffset < focusOffset;\n    const startOffset = isBefore ? anchorOffset : focusOffset;\n    const endOffset = isBefore ? focusOffset : anchorOffset;\n    const characterOffset = endOffset - 1;\n    if (startOffset !== characterOffset) {\n      const text = anchorNode.getTextContent().slice(startOffset, endOffset);\n      if (!doesContainGrapheme(text)) {\n        if (isBackward) {\n          focus.offset = characterOffset;\n        } else {\n          anchor.offset = characterOffset;\n        }\n      }\n    }\n  }\n}\nfunction $removeSegment(node, isBackward, offset) {\n  const textNode = node;\n  const textContent = textNode.getTextContent();\n  const split = textContent.split(/(?=\\s)/g);\n  const splitLength = split.length;\n  let segmentOffset = 0;\n  let restoreOffset = 0;\n  for (let i = 0; i < splitLength; i++) {\n    const text = split[i];\n    const isLast = i === splitLength - 1;\n    restoreOffset = segmentOffset;\n    segmentOffset += text.length;\n    if (isBackward && segmentOffset === offset || segmentOffset > offset || isLast) {\n      split.splice(i, 1);\n      if (isLast) {\n        restoreOffset = undefined;\n      }\n      break;\n    }\n  }\n  const nextTextContent = split.join('').trim();\n  if (nextTextContent === '') {\n    textNode.remove();\n  } else {\n    textNode.setTextContent(nextTextContent);\n    textNode.select(restoreOffset, restoreOffset);\n  }\n}\nfunction shouldResolveAncestor(resolvedElement, resolvedOffset, lastPoint) {\n  const parent = resolvedElement.getParent();\n  return lastPoint === null || parent === null || !parent.canBeEmpty() || parent !== lastPoint.getNode();\n}\nfunction $internalResolveSelectionPoint(dom, offset, lastPoint, editor) {\n  let resolvedOffset = offset;\n  let resolvedNode;\n  // If we have selection on an element, we will\n  // need to figure out (using the offset) what text\n  // node should be selected.\n\n  if (isHTMLElement(dom)) {\n    // Resolve element to a ElementNode, or TextNode, or null\n    let moveSelectionToEnd = false;\n    // Given we're moving selection to another node, selection is\n    // definitely dirty.\n    // We use the anchor to find which child node to select\n    const childNodes = dom.childNodes;\n    const childNodesLength = childNodes.length;\n    const blockCursorElement = editor._blockCursorElement;\n    // If the anchor is the same as length, then this means we\n    // need to select the very last text node.\n    if (resolvedOffset === childNodesLength) {\n      moveSelectionToEnd = true;\n      resolvedOffset = childNodesLength - 1;\n    }\n    let childDOM = childNodes[resolvedOffset];\n    let hasBlockCursor = false;\n    if (childDOM === blockCursorElement) {\n      childDOM = childNodes[resolvedOffset + 1];\n      hasBlockCursor = true;\n    } else if (blockCursorElement !== null) {\n      const blockCursorElementParent = blockCursorElement.parentNode;\n      if (dom === blockCursorElementParent) {\n        const blockCursorOffset = Array.prototype.indexOf.call(blockCursorElementParent.children, blockCursorElement);\n        if (offset > blockCursorOffset) {\n          resolvedOffset--;\n        }\n      }\n    }\n    resolvedNode = $getNodeFromDOM(childDOM);\n    if ($isTextNode(resolvedNode)) {\n      resolvedOffset = getTextNodeOffset(resolvedNode, moveSelectionToEnd);\n    } else {\n      let resolvedElement = $getNodeFromDOM(dom);\n      // Ensure resolvedElement is actually a element.\n      if (resolvedElement === null) {\n        return null;\n      }\n      if ($isElementNode(resolvedElement)) {\n        const elementDOM = editor.getElementByKey(resolvedElement.getKey());\n        if (!(elementDOM !== null)) {\n          throw Error(`$internalResolveSelectionPoint: node in DOM but not keyToDOMMap`);\n        }\n        const slot = resolvedElement.getDOMSlot(elementDOM);\n        [resolvedElement, resolvedOffset] = slot.resolveChildIndex(resolvedElement, elementDOM, dom, offset);\n        // This is just a typescript workaround, it is true but lost due to mutability\n        if (!$isElementNode(resolvedElement)) {\n          throw Error(`$internalResolveSelectionPoint: resolvedElement is not an ElementNode`);\n        }\n        if (moveSelectionToEnd && resolvedOffset >= resolvedElement.getChildrenSize()) {\n          resolvedOffset = Math.max(0, resolvedElement.getChildrenSize() - 1);\n        }\n        let child = resolvedElement.getChildAtIndex(resolvedOffset);\n        if ($isElementNode(child) && shouldResolveAncestor(child, resolvedOffset, lastPoint)) {\n          const descendant = moveSelectionToEnd ? child.getLastDescendant() : child.getFirstDescendant();\n          if (descendant === null) {\n            resolvedElement = child;\n          } else {\n            child = descendant;\n            resolvedElement = $isElementNode(child) ? child : child.getParentOrThrow();\n          }\n          resolvedOffset = 0;\n        }\n        if ($isTextNode(child)) {\n          resolvedNode = child;\n          resolvedElement = null;\n          resolvedOffset = getTextNodeOffset(child, moveSelectionToEnd);\n        } else if (child !== resolvedElement && moveSelectionToEnd && !hasBlockCursor) {\n          if (!$isElementNode(resolvedElement)) {\n            throw Error(`invariant`);\n          }\n          resolvedOffset = Math.min(resolvedElement.getChildrenSize(), resolvedOffset + 1);\n        }\n      } else {\n        const index = resolvedElement.getIndexWithinParent();\n        // When selecting decorators, there can be some selection issues when using resolvedOffset,\n        // and instead we should be checking if we're using the offset\n        if (offset === 0 && $isDecoratorNode(resolvedElement) && $getNodeFromDOM(dom) === resolvedElement) {\n          resolvedOffset = index;\n        } else {\n          resolvedOffset = index + 1;\n        }\n        resolvedElement = resolvedElement.getParentOrThrow();\n      }\n      if ($isElementNode(resolvedElement)) {\n        return $createPoint(resolvedElement.__key, resolvedOffset, 'element');\n      }\n    }\n  } else {\n    // TextNode or null\n    resolvedNode = $getNodeFromDOM(dom);\n  }\n  if (!$isTextNode(resolvedNode)) {\n    return null;\n  }\n  return $createPoint(resolvedNode.__key, resolvedOffset, 'text');\n}\nfunction resolveSelectionPointOnBoundary(point, isBackward, isCollapsed) {\n  const offset = point.offset;\n  const node = point.getNode();\n  if (offset === 0) {\n    const prevSibling = node.getPreviousSibling();\n    const parent = node.getParent();\n    if (!isBackward) {\n      if ($isElementNode(prevSibling) && !isCollapsed && prevSibling.isInline()) {\n        point.key = prevSibling.__key;\n        point.offset = prevSibling.getChildrenSize();\n        // @ts-expect-error: intentional\n        point.type = 'element';\n      } else if ($isTextNode(prevSibling)) {\n        point.key = prevSibling.__key;\n        point.offset = prevSibling.getTextContent().length;\n      }\n    } else if ((isCollapsed || !isBackward) && prevSibling === null && $isElementNode(parent) && parent.isInline()) {\n      const parentSibling = parent.getPreviousSibling();\n      if ($isTextNode(parentSibling)) {\n        point.key = parentSibling.__key;\n        point.offset = parentSibling.getTextContent().length;\n      }\n    }\n  } else if (offset === node.getTextContent().length) {\n    const nextSibling = node.getNextSibling();\n    const parent = node.getParent();\n    if (isBackward && $isElementNode(nextSibling) && nextSibling.isInline()) {\n      point.key = nextSibling.__key;\n      point.offset = 0;\n      // @ts-expect-error: intentional\n      point.type = 'element';\n    } else if ((isCollapsed || isBackward) && nextSibling === null && $isElementNode(parent) && parent.isInline() && !parent.canInsertTextAfter()) {\n      const parentSibling = parent.getNextSibling();\n      if ($isTextNode(parentSibling)) {\n        point.key = parentSibling.__key;\n        point.offset = 0;\n      }\n    }\n  }\n}\nfunction $normalizeSelectionPointsForBoundaries(anchor, focus, lastSelection) {\n  if (anchor.type === 'text' && focus.type === 'text') {\n    const isBackward = anchor.isBefore(focus);\n    const isCollapsed = anchor.is(focus);\n\n    // Attempt to normalize the offset to the previous sibling if we're at the\n    // start of a text node and the sibling is a text node or inline element.\n    resolveSelectionPointOnBoundary(anchor, isBackward, isCollapsed);\n    resolveSelectionPointOnBoundary(focus, !isBackward, isCollapsed);\n    if (isCollapsed) {\n      focus.key = anchor.key;\n      focus.offset = anchor.offset;\n      focus.type = anchor.type;\n    }\n    const editor = getActiveEditor();\n    if (editor.isComposing() && editor._compositionKey !== anchor.key && $isRangeSelection(lastSelection)) {\n      const lastAnchor = lastSelection.anchor;\n      const lastFocus = lastSelection.focus;\n      $setPointValues(anchor, lastAnchor.key, lastAnchor.offset, lastAnchor.type);\n      $setPointValues(focus, lastFocus.key, lastFocus.offset, lastFocus.type);\n    }\n  }\n}\nfunction $internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection) {\n  if (anchorDOM === null || focusDOM === null || !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n    return null;\n  }\n  const resolvedAnchorPoint = $internalResolveSelectionPoint(anchorDOM, anchorOffset, $isRangeSelection(lastSelection) ? lastSelection.anchor : null, editor);\n  if (resolvedAnchorPoint === null) {\n    return null;\n  }\n  {\n    $validatePoint(editor, 'anchor', resolvedAnchorPoint);\n  }\n  const resolvedFocusPoint = $internalResolveSelectionPoint(focusDOM, focusOffset, $isRangeSelection(lastSelection) ? lastSelection.focus : null, editor);\n  if (resolvedFocusPoint === null) {\n    return null;\n  }\n  {\n    $validatePoint(editor, 'focus', resolvedAnchorPoint);\n  }\n  if (resolvedAnchorPoint.type === 'element' && resolvedFocusPoint.type === 'element') {\n    const anchorNode = $getNodeFromDOM(anchorDOM);\n    const focusNode = $getNodeFromDOM(focusDOM);\n    // Ensure if we're selecting the content of a decorator that we\n    // return null for this point, as it's not in the controlled scope\n    // of Lexical.\n    if ($isDecoratorNode(anchorNode) && $isDecoratorNode(focusNode)) {\n      return null;\n    }\n  }\n\n  // Handle normalization of selection when it is at the boundaries.\n  $normalizeSelectionPointsForBoundaries(resolvedAnchorPoint, resolvedFocusPoint, lastSelection);\n  return [resolvedAnchorPoint, resolvedFocusPoint];\n}\nfunction $isBlockElementNode(node) {\n  return $isElementNode(node) && !node.isInline();\n}\n\n// This is used to make a selection when the existing\n// selection is null, i.e. forcing selection on the editor\n// when it current exists outside the editor.\n\nfunction $internalMakeRangeSelection(anchorKey, anchorOffset, focusKey, focusOffset, anchorType, focusType) {\n  const editorState = getActiveEditorState();\n  const selection = new RangeSelection($createPoint(anchorKey, anchorOffset, anchorType), $createPoint(focusKey, focusOffset, focusType), 0, '');\n  selection.dirty = true;\n  editorState._selection = selection;\n  return selection;\n}\nfunction $createRangeSelection() {\n  const anchor = $createPoint('root', 0, 'element');\n  const focus = $createPoint('root', 0, 'element');\n  return new RangeSelection(anchor, focus, 0, '');\n}\nfunction $createNodeSelection() {\n  return new NodeSelection(new Set());\n}\nfunction $internalCreateSelection(editor) {\n  const currentEditorState = editor.getEditorState();\n  const lastSelection = currentEditorState._selection;\n  const domSelection = getDOMSelection(editor._window);\n  if ($isRangeSelection(lastSelection) || lastSelection == null) {\n    return $internalCreateRangeSelection(lastSelection, domSelection, editor, null);\n  }\n  return lastSelection.clone();\n}\nfunction $createRangeSelectionFromDom(domSelection, editor) {\n  return $internalCreateRangeSelection(null, domSelection, editor, null);\n}\nfunction $internalCreateRangeSelection(lastSelection, domSelection, editor, event) {\n  const windowObj = editor._window;\n  if (windowObj === null) {\n    return null;\n  }\n  // When we create a selection, we try to use the previous\n  // selection where possible, unless an actual user selection\n  // change has occurred. When we do need to create a new selection\n  // we validate we can have text nodes for both anchor and focus\n  // nodes. If that holds true, we then return that selection\n  // as a mutable object that we use for the editor state for this\n  // update cycle. If a selection gets changed, and requires a\n  // update to native DOM selection, it gets marked as \"dirty\".\n  // If the selection changes, but matches with the existing\n  // DOM selection, then we only need to sync it. Otherwise,\n  // we generally bail out of doing an update to selection during\n  // reconciliation unless there are dirty nodes that need\n  // reconciling.\n\n  const windowEvent = event || windowObj.event;\n  const eventType = windowEvent ? windowEvent.type : undefined;\n  const isSelectionChange = eventType === 'selectionchange';\n  const useDOMSelection = !getIsProcessingMutations() && (isSelectionChange || eventType === 'beforeinput' || eventType === 'compositionstart' || eventType === 'compositionend' || eventType === 'click' && windowEvent && windowEvent.detail === 3 || eventType === 'drop' || eventType === undefined);\n  let anchorDOM, focusDOM, anchorOffset, focusOffset;\n  if (!$isRangeSelection(lastSelection) || useDOMSelection) {\n    if (domSelection === null) {\n      return null;\n    }\n    anchorDOM = domSelection.anchorNode;\n    focusDOM = domSelection.focusNode;\n    anchorOffset = domSelection.anchorOffset;\n    focusOffset = domSelection.focusOffset;\n    if (isSelectionChange && $isRangeSelection(lastSelection) && !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n      return lastSelection.clone();\n    }\n  } else {\n    return lastSelection.clone();\n  }\n  // Let's resolve the text nodes from the offsets and DOM nodes we have from\n  // native selection.\n  const resolvedSelectionPoints = $internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection);\n  if (resolvedSelectionPoints === null) {\n    return null;\n  }\n  const [resolvedAnchorPoint, resolvedFocusPoint] = resolvedSelectionPoints;\n  return new RangeSelection(resolvedAnchorPoint, resolvedFocusPoint, !$isRangeSelection(lastSelection) ? 0 : lastSelection.format, !$isRangeSelection(lastSelection) ? '' : lastSelection.style);\n}\nfunction $validatePoint(editor, name, point) {\n  const node = $getNodeByKey(point.key);\n  if (!(node !== undefined)) {\n    throw Error(`$validatePoint: ${name} key ${point.key} not found in current editorState`);\n  }\n  if (point.type === 'text') {\n    if (!$isTextNode(node)) {\n      throw Error(`$validatePoint: ${name} key ${point.key} is not a TextNode`);\n    }\n    const size = node.getTextContentSize();\n    if (!(point.offset <= size)) {\n      throw Error(`$validatePoint: ${name} point.offset > node.getTextContentSize() (${String(point.offset)} > ${String(size)})`);\n    }\n  } else {\n    if (!$isElementNode(node)) {\n      throw Error(`$validatePoint: ${name} key ${point.key} is not an ElementNode`);\n    }\n    const size = node.getChildrenSize();\n    if (!(point.offset <= size)) {\n      throw Error(`$validatePoint: ${name} point.offset > node.getChildrenSize() (${String(point.offset)} > ${String(size)})`);\n    }\n  }\n}\nfunction $getSelection() {\n  const editorState = getActiveEditorState();\n  return editorState._selection;\n}\nfunction $getPreviousSelection() {\n  const editor = getActiveEditor();\n  return editor._editorState._selection;\n}\nfunction $updateElementSelectionOnCreateDeleteNode(selection, parentNode, nodeOffset, times = 1) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if (!parentNode.is(anchorNode) && !parentNode.is(focusNode)) {\n    return;\n  }\n  const parentKey = parentNode.__key;\n  // Single node. We shift selection but never redimension it\n  if (selection.isCollapsed()) {\n    const selectionOffset = anchor.offset;\n    if (nodeOffset <= selectionOffset && times > 0 || nodeOffset < selectionOffset && times < 0) {\n      const newSelectionOffset = Math.max(0, selectionOffset + times);\n      anchor.set(parentKey, newSelectionOffset, 'element');\n      focus.set(parentKey, newSelectionOffset, 'element');\n      // The new selection might point to text nodes, try to resolve them\n      $updateSelectionResolveTextNodes(selection);\n    }\n  } else {\n    // Multiple nodes selected. We shift or redimension selection\n    const isBackward = selection.isBackward();\n    const firstPoint = isBackward ? focus : anchor;\n    const firstPointNode = firstPoint.getNode();\n    const lastPoint = isBackward ? anchor : focus;\n    const lastPointNode = lastPoint.getNode();\n    if (parentNode.is(firstPointNode)) {\n      const firstPointOffset = firstPoint.offset;\n      if (nodeOffset <= firstPointOffset && times > 0 || nodeOffset < firstPointOffset && times < 0) {\n        firstPoint.set(parentKey, Math.max(0, firstPointOffset + times), 'element');\n      }\n    }\n    if (parentNode.is(lastPointNode)) {\n      const lastPointOffset = lastPoint.offset;\n      if (nodeOffset <= lastPointOffset && times > 0 || nodeOffset < lastPointOffset && times < 0) {\n        lastPoint.set(parentKey, Math.max(0, lastPointOffset + times), 'element');\n      }\n    }\n  }\n  // The new selection might point to text nodes, try to resolve them\n  $updateSelectionResolveTextNodes(selection);\n}\nfunction $updateSelectionResolveTextNodes(selection) {\n  const anchor = selection.anchor;\n  const anchorOffset = anchor.offset;\n  const focus = selection.focus;\n  const focusOffset = focus.offset;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if (selection.isCollapsed()) {\n    if (!$isElementNode(anchorNode)) {\n      return;\n    }\n    const childSize = anchorNode.getChildrenSize();\n    const anchorOffsetAtEnd = anchorOffset >= childSize;\n    const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n      if (anchorOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n      anchor.set(child.__key, newOffset, 'text');\n      focus.set(child.__key, newOffset, 'text');\n    }\n    return;\n  }\n  if ($isElementNode(anchorNode)) {\n    const childSize = anchorNode.getChildrenSize();\n    const anchorOffsetAtEnd = anchorOffset >= childSize;\n    const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n      if (anchorOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n      anchor.set(child.__key, newOffset, 'text');\n    }\n  }\n  if ($isElementNode(focusNode)) {\n    const childSize = focusNode.getChildrenSize();\n    const focusOffsetAtEnd = focusOffset >= childSize;\n    const child = focusOffsetAtEnd ? focusNode.getChildAtIndex(childSize - 1) : focusNode.getChildAtIndex(focusOffset);\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n      if (focusOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n      focus.set(child.__key, newOffset, 'text');\n    }\n  }\n}\nfunction applySelectionTransforms(nextEditorState, editor) {\n  const prevEditorState = editor.getEditorState();\n  const prevSelection = prevEditorState._selection;\n  const nextSelection = nextEditorState._selection;\n  if ($isRangeSelection(nextSelection)) {\n    const anchor = nextSelection.anchor;\n    const focus = nextSelection.focus;\n    let anchorNode;\n    if (anchor.type === 'text') {\n      anchorNode = anchor.getNode();\n      anchorNode.selectionTransform(prevSelection, nextSelection);\n    }\n    if (focus.type === 'text') {\n      const focusNode = focus.getNode();\n      if (anchorNode !== focusNode) {\n        focusNode.selectionTransform(prevSelection, nextSelection);\n      }\n    }\n  }\n}\nfunction moveSelectionPointToSibling(point, node, parent, prevSibling, nextSibling) {\n  let siblingKey = null;\n  let offset = 0;\n  let type = null;\n  if (prevSibling !== null) {\n    siblingKey = prevSibling.__key;\n    if ($isTextNode(prevSibling)) {\n      offset = prevSibling.getTextContentSize();\n      type = 'text';\n    } else if ($isElementNode(prevSibling)) {\n      offset = prevSibling.getChildrenSize();\n      type = 'element';\n    }\n  } else {\n    if (nextSibling !== null) {\n      siblingKey = nextSibling.__key;\n      if ($isTextNode(nextSibling)) {\n        type = 'text';\n      } else if ($isElementNode(nextSibling)) {\n        type = 'element';\n      }\n    }\n  }\n  if (siblingKey !== null && type !== null) {\n    point.set(siblingKey, offset, type);\n  } else {\n    offset = node.getIndexWithinParent();\n    if (offset === -1) {\n      // Move selection to end of parent\n      offset = parent.getChildrenSize();\n    }\n    point.set(parent.__key, offset, 'element');\n  }\n}\nfunction adjustPointOffsetForMergedSibling(point, isBefore, key, target, textLength) {\n  if (point.type === 'text') {\n    point.key = key;\n    if (!isBefore) {\n      point.offset += textLength;\n    }\n  } else if (point.offset > target.getIndexWithinParent()) {\n    point.offset -= 1;\n  }\n}\nfunction updateDOMSelection(prevSelection, nextSelection, editor, domSelection, tags, rootElement, nodeCount) {\n  const anchorDOMNode = domSelection.anchorNode;\n  const focusDOMNode = domSelection.focusNode;\n  const anchorOffset = domSelection.anchorOffset;\n  const focusOffset = domSelection.focusOffset;\n  const activeElement = document.activeElement;\n\n  // TODO: make this not hard-coded, and add another config option\n  // that makes this configurable.\n  if (tags.has('collaboration') && activeElement !== rootElement || activeElement !== null && isSelectionCapturedInDecoratorInput(activeElement)) {\n    return;\n  }\n  if (!$isRangeSelection(nextSelection)) {\n    // We don't remove selection if the prevSelection is null because\n    // of editor.setRootElement(). If this occurs on init when the\n    // editor is already focused, then this can cause the editor to\n    // lose focus.\n    if (prevSelection !== null && isSelectionWithinEditor(editor, anchorDOMNode, focusDOMNode)) {\n      domSelection.removeAllRanges();\n    }\n    return;\n  }\n  const anchor = nextSelection.anchor;\n  const focus = nextSelection.focus;\n  const anchorKey = anchor.key;\n  const focusKey = focus.key;\n  const anchorDOM = getElementByKeyOrThrow(editor, anchorKey);\n  const focusDOM = getElementByKeyOrThrow(editor, focusKey);\n  const nextAnchorOffset = anchor.offset;\n  const nextFocusOffset = focus.offset;\n  const nextFormat = nextSelection.format;\n  const nextStyle = nextSelection.style;\n  const isCollapsed = nextSelection.isCollapsed();\n  let nextAnchorNode = anchorDOM;\n  let nextFocusNode = focusDOM;\n  let anchorFormatOrStyleChanged = false;\n  if (anchor.type === 'text') {\n    nextAnchorNode = getDOMTextNode(anchorDOM);\n    const anchorNode = anchor.getNode();\n    anchorFormatOrStyleChanged = anchorNode.getFormat() !== nextFormat || anchorNode.getStyle() !== nextStyle;\n  } else if ($isRangeSelection(prevSelection) && prevSelection.anchor.type === 'text') {\n    anchorFormatOrStyleChanged = true;\n  }\n  if (focus.type === 'text') {\n    nextFocusNode = getDOMTextNode(focusDOM);\n  }\n\n  // If we can't get an underlying text node for selection, then\n  // we should avoid setting selection to something incorrect.\n  if (nextAnchorNode === null || nextFocusNode === null) {\n    return;\n  }\n  if (isCollapsed && (prevSelection === null || anchorFormatOrStyleChanged || $isRangeSelection(prevSelection) && (prevSelection.format !== nextFormat || prevSelection.style !== nextStyle))) {\n    markCollapsedSelectionFormat(nextFormat, nextStyle, nextAnchorOffset, anchorKey, performance.now());\n  }\n\n  // Diff against the native DOM selection to ensure we don't do\n  // an unnecessary selection update. We also skip this check if\n  // we're moving selection to within an element, as this can\n  // sometimes be problematic around scrolling.\n  if (anchorOffset === nextAnchorOffset && focusOffset === nextFocusOffset && anchorDOMNode === nextAnchorNode && focusDOMNode === nextFocusNode &&\n  // Badly interpreted range selection when collapsed - #1482\n  !(domSelection.type === 'Range' && isCollapsed)) {\n    // If the root element does not have focus, ensure it has focus\n    if (activeElement === null || !rootElement.contains(activeElement)) {\n      rootElement.focus({\n        preventScroll: true\n      });\n    }\n    if (anchor.type !== 'element') {\n      return;\n    }\n  }\n\n  // Apply the updated selection to the DOM. Note: this will trigger\n  // a \"selectionchange\" event, although it will be asynchronous.\n  try {\n    domSelection.setBaseAndExtent(nextAnchorNode, nextAnchorOffset, nextFocusNode, nextFocusOffset);\n  } catch (error) {\n    // If we encounter an error, continue. This can sometimes\n    // occur with FF and there's no good reason as to why it\n    // should happen.\n    {\n      console.warn(error);\n    }\n  }\n  if (!tags.has('skip-scroll-into-view') && nextSelection.isCollapsed() && rootElement !== null && rootElement === document.activeElement) {\n    const selectionTarget = $isRangeSelection(nextSelection) && nextSelection.anchor.type === 'element' ? nextAnchorNode.childNodes[nextAnchorOffset] || null : domSelection.rangeCount > 0 ? domSelection.getRangeAt(0) : null;\n    if (selectionTarget !== null) {\n      let selectionRect;\n      if (selectionTarget instanceof Text) {\n        const range = document.createRange();\n        range.selectNode(selectionTarget);\n        selectionRect = range.getBoundingClientRect();\n      } else {\n        selectionRect = selectionTarget.getBoundingClientRect();\n      }\n      scrollIntoViewIfNeeded(editor, selectionRect, rootElement);\n    }\n  }\n  markSelectionChangeFromDOMUpdate();\n}\nfunction $insertNodes(nodes) {\n  let selection = $getSelection() || $getPreviousSelection();\n  if (selection === null) {\n    selection = $getRoot().selectEnd();\n  }\n  selection.insertNodes(nodes);\n}\nfunction $getTextContent() {\n  const selection = $getSelection();\n  if (selection === null) {\n    return '';\n  }\n  return selection.getTextContent();\n}\nfunction $removeTextAndSplitBlock(selection) {\n  let selection_ = selection;\n  if (!selection.isCollapsed()) {\n    selection_.removeText();\n  }\n  // A new selection can originate as a result of node replacement, in which case is registered via\n  // $setSelection\n  const newSelection = $getSelection();\n  if ($isRangeSelection(newSelection)) {\n    selection_ = newSelection;\n  }\n  if (!$isRangeSelection(selection_)) {\n    throw Error(`Unexpected dirty selection to be null`);\n  }\n  const anchor = selection_.anchor;\n  let node = anchor.getNode();\n  let offset = anchor.offset;\n  while (!INTERNAL_$isBlock(node)) {\n    [node, offset] = $splitNodeAtPoint(node, offset);\n  }\n  return offset;\n}\nfunction $splitNodeAtPoint(node, offset) {\n  const parent = node.getParent();\n  if (!parent) {\n    const paragraph = $createParagraphNode();\n    $getRoot().append(paragraph);\n    paragraph.select();\n    return [$getRoot(), 0];\n  }\n  if ($isTextNode(node)) {\n    const split = node.splitText(offset);\n    if (split.length === 0) {\n      return [parent, node.getIndexWithinParent()];\n    }\n    const x = offset === 0 ? 0 : 1;\n    const index = split[0].getIndexWithinParent() + x;\n    return [parent, index];\n  }\n  if (!$isElementNode(node) || offset === 0) {\n    return [parent, node.getIndexWithinParent()];\n  }\n  const firstToAppend = node.getChildAtIndex(offset);\n  if (firstToAppend) {\n    const insertPoint = new RangeSelection($createPoint(node.__key, offset, 'element'), $createPoint(node.__key, offset, 'element'), 0, '');\n    const newElement = node.insertNewAfter(insertPoint);\n    if (newElement) {\n      newElement.append(firstToAppend, ...firstToAppend.getNextSiblings());\n    }\n  }\n  return [parent, node.getIndexWithinParent() + 1];\n}\nfunction $wrapInlineNodes(nodes) {\n  // We temporarily insert the topLevelNodes into an arbitrary ElementNode,\n  // since insertAfter does not work on nodes that have no parent (TO-DO: fix that).\n  const virtualRoot = $createParagraphNode();\n  let currentBlock = null;\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    const isLineBreakNode = $isLineBreakNode(node);\n    if (isLineBreakNode || $isDecoratorNode(node) && node.isInline() || $isElementNode(node) && node.isInline() || $isTextNode(node) || node.isParentRequired()) {\n      if (currentBlock === null) {\n        currentBlock = node.createParentElementNode();\n        virtualRoot.append(currentBlock);\n        // In the case of LineBreakNode, we just need to\n        // add an empty ParagraphNode to the topLevelBlocks.\n        if (isLineBreakNode) {\n          continue;\n        }\n      }\n      if (currentBlock !== null) {\n        currentBlock.append(node);\n      }\n    } else {\n      virtualRoot.append(node);\n      currentBlock = null;\n    }\n  }\n  return virtualRoot;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nlet activeEditorState = null;\nlet activeEditor = null;\nlet isReadOnlyMode = false;\nlet isAttemptingToRecoverFromReconcilerError = false;\nlet infiniteTransformCount = 0;\nconst observerOptions = {\n  characterData: true,\n  childList: true,\n  subtree: true\n};\nfunction isCurrentlyReadOnlyMode() {\n  return isReadOnlyMode || activeEditorState !== null && activeEditorState._readOnly;\n}\nfunction errorOnReadOnly() {\n  if (isReadOnlyMode) {\n    {\n      throw Error(`Cannot use method in read-only mode.`);\n    }\n  }\n}\nfunction errorOnInfiniteTransforms() {\n  if (infiniteTransformCount > 99) {\n    {\n      throw Error(`One or more transforms are endlessly triggering additional transforms. May have encountered infinite recursion caused by transforms that have their preconditions too lose and/or conflict with each other.`);\n    }\n  }\n}\nfunction getActiveEditorState() {\n  if (activeEditorState === null) {\n    {\n      throw Error(`Unable to find an active editor state. State helpers or node methods can only be used synchronously during the callback of editor.update(), editor.read(), or editorState.read().${collectBuildInformation()}`);\n    }\n  }\n  return activeEditorState;\n}\nfunction getActiveEditor() {\n  if (activeEditor === null) {\n    {\n      throw Error(`Unable to find an active editor. This method can only be used synchronously during the callback of editor.update() or editor.read().${collectBuildInformation()}`);\n    }\n  }\n  return activeEditor;\n}\nfunction collectBuildInformation() {\n  let compatibleEditors = 0;\n  const incompatibleEditors = new Set();\n  const thisVersion = LexicalEditor.version;\n  if (typeof window !== 'undefined') {\n    for (const node of document.querySelectorAll('[contenteditable]')) {\n      const editor = getEditorPropertyFromDOMNode(node);\n      if (isLexicalEditor(editor)) {\n        compatibleEditors++;\n      } else if (editor) {\n        let version = String(editor.constructor.version || '<0.17.1');\n        if (version === thisVersion) {\n          version += ' (separately built, likely a bundler configuration issue)';\n        }\n        incompatibleEditors.add(version);\n      }\n    }\n  }\n  let output = ` Detected on the page: ${compatibleEditors} compatible editor(s) with version ${thisVersion}`;\n  if (incompatibleEditors.size) {\n    output += ` and incompatible editors with versions ${Array.from(incompatibleEditors).join(', ')}`;\n  }\n  return output;\n}\nfunction internalGetActiveEditor() {\n  return activeEditor;\n}\nfunction internalGetActiveEditorState() {\n  return activeEditorState;\n}\nfunction $applyTransforms(editor, node, transformsCache) {\n  const type = node.__type;\n  const registeredNode = getRegisteredNodeOrThrow(editor, type);\n  let transformsArr = transformsCache.get(type);\n  if (transformsArr === undefined) {\n    transformsArr = Array.from(registeredNode.transforms);\n    transformsCache.set(type, transformsArr);\n  }\n  const transformsArrLength = transformsArr.length;\n  for (let i = 0; i < transformsArrLength; i++) {\n    transformsArr[i](node);\n    if (!node.isAttached()) {\n      break;\n    }\n  }\n}\nfunction $isNodeValidForTransform(node, compositionKey) {\n  return node !== undefined &&\n  // We don't want to transform nodes being composed\n  node.__key !== compositionKey && node.isAttached();\n}\nfunction $normalizeAllDirtyTextNodes(editorState, editor) {\n  const dirtyLeaves = editor._dirtyLeaves;\n  const nodeMap = editorState._nodeMap;\n  for (const nodeKey of dirtyLeaves) {\n    const node = nodeMap.get(nodeKey);\n    if ($isTextNode(node) && node.isAttached() && node.isSimpleText() && !node.isUnmergeable()) {\n      $normalizeTextNode(node);\n    }\n  }\n}\nfunction addTags(editor, tags) {\n  if (!tags) {\n    return;\n  }\n  const updateTags = editor._updateTags;\n  let tags_ = tags;\n  if (!Array.isArray(tags)) {\n    tags_ = [tags];\n  }\n  for (const tag of tags_) {\n    updateTags.add(tag);\n  }\n}\n\n/**\n * Transform heuristic:\n * 1. We transform leaves first. If transforms generate additional dirty nodes we repeat step 1.\n * The reasoning behind this is that marking a leaf as dirty marks all its parent elements as dirty too.\n * 2. We transform elements. If element transforms generate additional dirty nodes we repeat step 1.\n * If element transforms only generate additional dirty elements we only repeat step 2.\n *\n * Note that to keep track of newly dirty nodes and subtrees we leverage the editor._dirtyNodes and\n * editor._subtrees which we reset in every loop.\n */\nfunction $applyAllTransforms(editorState, editor) {\n  const dirtyLeaves = editor._dirtyLeaves;\n  const dirtyElements = editor._dirtyElements;\n  const nodeMap = editorState._nodeMap;\n  const compositionKey = $getCompositionKey();\n  const transformsCache = new Map();\n  let untransformedDirtyLeaves = dirtyLeaves;\n  let untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\n  let untransformedDirtyElements = dirtyElements;\n  let untransformedDirtyElementsLength = untransformedDirtyElements.size;\n  while (untransformedDirtyLeavesLength > 0 || untransformedDirtyElementsLength > 0) {\n    if (untransformedDirtyLeavesLength > 0) {\n      // We leverage editor._dirtyLeaves to track the new dirty leaves after the transforms\n      editor._dirtyLeaves = new Set();\n      for (const nodeKey of untransformedDirtyLeaves) {\n        const node = nodeMap.get(nodeKey);\n        if ($isTextNode(node) && node.isAttached() && node.isSimpleText() && !node.isUnmergeable()) {\n          $normalizeTextNode(node);\n        }\n        if (node !== undefined && $isNodeValidForTransform(node, compositionKey)) {\n          $applyTransforms(editor, node, transformsCache);\n        }\n        dirtyLeaves.add(nodeKey);\n      }\n      untransformedDirtyLeaves = editor._dirtyLeaves;\n      untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\n\n      // We want to prioritize node transforms over element transforms\n      if (untransformedDirtyLeavesLength > 0) {\n        infiniteTransformCount++;\n        continue;\n      }\n    }\n\n    // All dirty leaves have been processed. Let's do elements!\n    // We have previously processed dirty leaves, so let's restart the editor leaves Set to track\n    // new ones caused by element transforms\n    editor._dirtyLeaves = new Set();\n    editor._dirtyElements = new Map();\n    for (const currentUntransformedDirtyElement of untransformedDirtyElements) {\n      const nodeKey = currentUntransformedDirtyElement[0];\n      const intentionallyMarkedAsDirty = currentUntransformedDirtyElement[1];\n      if (nodeKey !== 'root' && !intentionallyMarkedAsDirty) {\n        continue;\n      }\n      const node = nodeMap.get(nodeKey);\n      if (node !== undefined && $isNodeValidForTransform(node, compositionKey)) {\n        $applyTransforms(editor, node, transformsCache);\n      }\n      dirtyElements.set(nodeKey, intentionallyMarkedAsDirty);\n    }\n    untransformedDirtyLeaves = editor._dirtyLeaves;\n    untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\n    untransformedDirtyElements = editor._dirtyElements;\n    untransformedDirtyElementsLength = untransformedDirtyElements.size;\n    infiniteTransformCount++;\n  }\n  editor._dirtyLeaves = dirtyLeaves;\n  editor._dirtyElements = dirtyElements;\n}\nfunction $parseSerializedNode(serializedNode) {\n  const internalSerializedNode = serializedNode;\n  return $parseSerializedNodeImpl(internalSerializedNode, getActiveEditor()._nodes);\n}\nfunction $parseSerializedNodeImpl(serializedNode, registeredNodes) {\n  const type = serializedNode.type;\n  const registeredNode = registeredNodes.get(type);\n  if (registeredNode === undefined) {\n    {\n      throw Error(`parseEditorState: type \"${type}\" + not found`);\n    }\n  }\n  const nodeClass = registeredNode.klass;\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .importJSON().`);\n    }\n  }\n  const node = nodeClass.importJSON(serializedNode);\n  const children = serializedNode.children;\n  if ($isElementNode(node) && Array.isArray(children)) {\n    for (let i = 0; i < children.length; i++) {\n      const serializedJSONChildNode = children[i];\n      const childNode = $parseSerializedNodeImpl(serializedJSONChildNode, registeredNodes);\n      node.append(childNode);\n    }\n  }\n  return node;\n}\nfunction parseEditorState(serializedEditorState, editor, updateFn) {\n  const editorState = createEmptyEditorState();\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previousDirtyElements = editor._dirtyElements;\n  const previousDirtyLeaves = editor._dirtyLeaves;\n  const previousCloneNotNeeded = editor._cloneNotNeeded;\n  const previousDirtyType = editor._dirtyType;\n  editor._dirtyElements = new Map();\n  editor._dirtyLeaves = new Set();\n  editor._cloneNotNeeded = new Set();\n  editor._dirtyType = 0;\n  activeEditorState = editorState;\n  isReadOnlyMode = false;\n  activeEditor = editor;\n  try {\n    const registeredNodes = editor._nodes;\n    const serializedNode = serializedEditorState.root;\n    $parseSerializedNodeImpl(serializedNode, registeredNodes);\n    if (updateFn) {\n      updateFn();\n    }\n\n    // Make the editorState immutable\n    editorState._readOnly = true;\n    {\n      handleDEVOnlyPendingUpdateGuarantees(editorState);\n    }\n  } catch (error) {\n    if (error instanceof Error) {\n      editor._onError(error);\n    }\n  } finally {\n    editor._dirtyElements = previousDirtyElements;\n    editor._dirtyLeaves = previousDirtyLeaves;\n    editor._cloneNotNeeded = previousCloneNotNeeded;\n    editor._dirtyType = previousDirtyType;\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n  }\n  return editorState;\n}\n\n// This technically isn't an update but given we need\n// exposure to the module's active bindings, we have this\n// function here\n\nfunction readEditorState(editor, editorState, callbackFn) {\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  activeEditorState = editorState;\n  isReadOnlyMode = true;\n  activeEditor = editor;\n  try {\n    return callbackFn();\n  } finally {\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n  }\n}\nfunction handleDEVOnlyPendingUpdateGuarantees(pendingEditorState) {\n  // Given we can't Object.freeze the nodeMap as it's a Map,\n  // we instead replace its set, clear and delete methods.\n  const nodeMap = pendingEditorState._nodeMap;\n  nodeMap.set = () => {\n    throw new Error('Cannot call set() on a frozen Lexical node map');\n  };\n  nodeMap.clear = () => {\n    throw new Error('Cannot call clear() on a frozen Lexical node map');\n  };\n  nodeMap.delete = () => {\n    throw new Error('Cannot call delete() on a frozen Lexical node map');\n  };\n}\nfunction $commitPendingUpdates(editor, recoveryEditorState) {\n  const pendingEditorState = editor._pendingEditorState;\n  const rootElement = editor._rootElement;\n  const shouldSkipDOM = editor._headless || rootElement === null;\n  if (pendingEditorState === null) {\n    return;\n  }\n\n  // ======\n  // Reconciliation has started.\n  // ======\n\n  const currentEditorState = editor._editorState;\n  const currentSelection = currentEditorState._selection;\n  const pendingSelection = pendingEditorState._selection;\n  const needsUpdate = editor._dirtyType !== NO_DIRTY_NODES;\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previouslyUpdating = editor._updating;\n  const observer = editor._observer;\n  let mutatedNodes = null;\n  editor._pendingEditorState = null;\n  editor._editorState = pendingEditorState;\n  if (!shouldSkipDOM && needsUpdate && observer !== null) {\n    activeEditor = editor;\n    activeEditorState = pendingEditorState;\n    isReadOnlyMode = false;\n    // We don't want updates to sync block the reconciliation.\n    editor._updating = true;\n    try {\n      const dirtyType = editor._dirtyType;\n      const dirtyElements = editor._dirtyElements;\n      const dirtyLeaves = editor._dirtyLeaves;\n      observer.disconnect();\n      mutatedNodes = $reconcileRoot(currentEditorState, pendingEditorState, editor, dirtyType, dirtyElements, dirtyLeaves);\n    } catch (error) {\n      // Report errors\n      if (error instanceof Error) {\n        editor._onError(error);\n      }\n\n      // Reset editor and restore incoming editor state to the DOM\n      if (!isAttemptingToRecoverFromReconcilerError) {\n        resetEditor(editor, null, rootElement, pendingEditorState);\n        initMutationObserver(editor);\n        editor._dirtyType = FULL_RECONCILE;\n        isAttemptingToRecoverFromReconcilerError = true;\n        $commitPendingUpdates(editor, currentEditorState);\n        isAttemptingToRecoverFromReconcilerError = false;\n      } else {\n        // To avoid a possible situation of infinite loops, lets throw\n        throw error;\n      }\n      return;\n    } finally {\n      observer.observe(rootElement, observerOptions);\n      editor._updating = previouslyUpdating;\n      activeEditorState = previousActiveEditorState;\n      isReadOnlyMode = previousReadOnlyMode;\n      activeEditor = previousActiveEditor;\n    }\n  }\n  if (!pendingEditorState._readOnly) {\n    pendingEditorState._readOnly = true;\n    {\n      handleDEVOnlyPendingUpdateGuarantees(pendingEditorState);\n      if ($isRangeSelection(pendingSelection)) {\n        Object.freeze(pendingSelection.anchor);\n        Object.freeze(pendingSelection.focus);\n      }\n      Object.freeze(pendingSelection);\n    }\n  }\n  const dirtyLeaves = editor._dirtyLeaves;\n  const dirtyElements = editor._dirtyElements;\n  const normalizedNodes = editor._normalizedNodes;\n  const tags = editor._updateTags;\n  const deferred = editor._deferred;\n  if (needsUpdate) {\n    editor._dirtyType = NO_DIRTY_NODES;\n    editor._cloneNotNeeded.clear();\n    editor._dirtyLeaves = new Set();\n    editor._dirtyElements = new Map();\n    editor._normalizedNodes = new Set();\n    editor._updateTags = new Set();\n  }\n  $garbageCollectDetachedDecorators(editor, pendingEditorState);\n\n  // ======\n  // Reconciliation has finished. Now update selection and trigger listeners.\n  // ======\n\n  const domSelection = shouldSkipDOM ? null : getDOMSelection(editor._window);\n\n  // Attempt to update the DOM selection, including focusing of the root element,\n  // and scroll into view if needed.\n  if (editor._editable &&\n  // domSelection will be null in headless\n  domSelection !== null && (needsUpdate || pendingSelection === null || pendingSelection.dirty) && rootElement !== null && !tags.has('skip-dom-selection')) {\n    activeEditor = editor;\n    activeEditorState = pendingEditorState;\n    try {\n      if (observer !== null) {\n        observer.disconnect();\n      }\n      if (needsUpdate || pendingSelection === null || pendingSelection.dirty) {\n        const blockCursorElement = editor._blockCursorElement;\n        if (blockCursorElement !== null) {\n          removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\n        }\n        updateDOMSelection(currentSelection, pendingSelection, editor, domSelection, tags, rootElement);\n      }\n      updateDOMBlockCursorElement(editor, rootElement, pendingSelection);\n      if (observer !== null) {\n        observer.observe(rootElement, observerOptions);\n      }\n    } finally {\n      activeEditor = previousActiveEditor;\n      activeEditorState = previousActiveEditorState;\n    }\n  }\n  if (mutatedNodes !== null) {\n    triggerMutationListeners(editor, mutatedNodes, tags, dirtyLeaves, currentEditorState);\n  }\n  if (!$isRangeSelection(pendingSelection) && pendingSelection !== null && (currentSelection === null || !currentSelection.is(pendingSelection))) {\n    editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n  }\n  /**\n   * Capture pendingDecorators after garbage collecting detached decorators\n   */\n  const pendingDecorators = editor._pendingDecorators;\n  if (pendingDecorators !== null) {\n    editor._decorators = pendingDecorators;\n    editor._pendingDecorators = null;\n    triggerListeners('decorator', editor, true, pendingDecorators);\n  }\n\n  // If reconciler fails, we reset whole editor (so current editor state becomes empty)\n  // and attempt to re-render pendingEditorState. If that goes through we trigger\n  // listeners, but instead use recoverEditorState which is current editor state before reset\n  // This specifically important for collab that relies on prevEditorState from update\n  // listener to calculate delta of changed nodes/properties\n  triggerTextContentListeners(editor, recoveryEditorState || currentEditorState, pendingEditorState);\n  triggerListeners('update', editor, true, {\n    dirtyElements,\n    dirtyLeaves,\n    editorState: pendingEditorState,\n    normalizedNodes,\n    prevEditorState: recoveryEditorState || currentEditorState,\n    tags\n  });\n  triggerDeferredUpdateCallbacks(editor, deferred);\n  $triggerEnqueuedUpdates(editor);\n}\nfunction triggerTextContentListeners(editor, currentEditorState, pendingEditorState) {\n  const currentTextContent = getEditorStateTextContent(currentEditorState);\n  const latestTextContent = getEditorStateTextContent(pendingEditorState);\n  if (currentTextContent !== latestTextContent) {\n    triggerListeners('textcontent', editor, true, latestTextContent);\n  }\n}\nfunction triggerMutationListeners(editor, mutatedNodes, updateTags, dirtyLeaves, prevEditorState) {\n  const listeners = Array.from(editor._listeners.mutation);\n  const listenersLength = listeners.length;\n  for (let i = 0; i < listenersLength; i++) {\n    const [listener, klass] = listeners[i];\n    const mutatedNodesByType = mutatedNodes.get(klass);\n    if (mutatedNodesByType !== undefined) {\n      listener(mutatedNodesByType, {\n        dirtyLeaves,\n        prevEditorState,\n        updateTags\n      });\n    }\n  }\n}\nfunction triggerListeners(type, editor, isCurrentlyEnqueuingUpdates, ...payload) {\n  const previouslyUpdating = editor._updating;\n  editor._updating = isCurrentlyEnqueuingUpdates;\n  try {\n    const listeners = Array.from(editor._listeners[type]);\n    for (let i = 0; i < listeners.length; i++) {\n      // @ts-ignore\n      listeners[i].apply(null, payload);\n    }\n  } finally {\n    editor._updating = previouslyUpdating;\n  }\n}\nfunction triggerCommandListeners(editor, type, payload) {\n  if (editor._updating === false || activeEditor !== editor) {\n    let returnVal = false;\n    editor.update(() => {\n      returnVal = triggerCommandListeners(editor, type, payload);\n    });\n    return returnVal;\n  }\n  const editors = getEditorsToPropagate(editor);\n  for (let i = 4; i >= 0; i--) {\n    for (let e = 0; e < editors.length; e++) {\n      const currentEditor = editors[e];\n      const commandListeners = currentEditor._commands;\n      const listenerInPriorityOrder = commandListeners.get(type);\n      if (listenerInPriorityOrder !== undefined) {\n        const listenersSet = listenerInPriorityOrder[i];\n        if (listenersSet !== undefined) {\n          const listeners = Array.from(listenersSet);\n          const listenersLength = listeners.length;\n          for (let j = 0; j < listenersLength; j++) {\n            if (listeners[j](payload, editor) === true) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n  }\n  return false;\n}\nfunction $triggerEnqueuedUpdates(editor) {\n  const queuedUpdates = editor._updates;\n  if (queuedUpdates.length !== 0) {\n    const queuedUpdate = queuedUpdates.shift();\n    if (queuedUpdate) {\n      const [updateFn, options] = queuedUpdate;\n      $beginUpdate(editor, updateFn, options);\n    }\n  }\n}\nfunction triggerDeferredUpdateCallbacks(editor, deferred) {\n  editor._deferred = [];\n  if (deferred.length !== 0) {\n    const previouslyUpdating = editor._updating;\n    editor._updating = true;\n    try {\n      for (let i = 0; i < deferred.length; i++) {\n        deferred[i]();\n      }\n    } finally {\n      editor._updating = previouslyUpdating;\n    }\n  }\n}\nfunction processNestedUpdates(editor, initialSkipTransforms) {\n  const queuedUpdates = editor._updates;\n  let skipTransforms = initialSkipTransforms || false;\n\n  // Updates might grow as we process them, we so we'll need\n  // to handle each update as we go until the updates array is\n  // empty.\n  while (queuedUpdates.length !== 0) {\n    const queuedUpdate = queuedUpdates.shift();\n    if (queuedUpdate) {\n      const [nextUpdateFn, options] = queuedUpdate;\n      let onUpdate;\n      if (options !== undefined) {\n        onUpdate = options.onUpdate;\n        if (options.skipTransforms) {\n          skipTransforms = true;\n        }\n        if (options.discrete) {\n          const pendingEditorState = editor._pendingEditorState;\n          if (!(pendingEditorState !== null)) {\n            throw Error(`Unexpected empty pending editor state on discrete nested update`);\n          }\n          pendingEditorState._flushSync = true;\n        }\n        if (onUpdate) {\n          editor._deferred.push(onUpdate);\n        }\n        addTags(editor, options.tag);\n      }\n      nextUpdateFn();\n    }\n  }\n  return skipTransforms;\n}\nfunction $beginUpdate(editor, updateFn, options) {\n  const updateTags = editor._updateTags;\n  let onUpdate;\n  let skipTransforms = false;\n  let discrete = false;\n  if (options !== undefined) {\n    onUpdate = options.onUpdate;\n    addTags(editor, options.tag);\n    skipTransforms = options.skipTransforms || false;\n    discrete = options.discrete || false;\n  }\n  if (onUpdate) {\n    editor._deferred.push(onUpdate);\n  }\n  const currentEditorState = editor._editorState;\n  let pendingEditorState = editor._pendingEditorState;\n  let editorStateWasCloned = false;\n  if (pendingEditorState === null || pendingEditorState._readOnly) {\n    pendingEditorState = editor._pendingEditorState = cloneEditorState(pendingEditorState || currentEditorState);\n    editorStateWasCloned = true;\n  }\n  pendingEditorState._flushSync = discrete;\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previouslyUpdating = editor._updating;\n  activeEditorState = pendingEditorState;\n  isReadOnlyMode = false;\n  editor._updating = true;\n  activeEditor = editor;\n  try {\n    if (editorStateWasCloned) {\n      if (editor._headless) {\n        if (currentEditorState._selection !== null) {\n          pendingEditorState._selection = currentEditorState._selection.clone();\n        }\n      } else {\n        pendingEditorState._selection = $internalCreateSelection(editor);\n      }\n    }\n    const startingCompositionKey = editor._compositionKey;\n    updateFn();\n    skipTransforms = processNestedUpdates(editor, skipTransforms);\n    applySelectionTransforms(pendingEditorState, editor);\n    if (editor._dirtyType !== NO_DIRTY_NODES) {\n      if (skipTransforms) {\n        $normalizeAllDirtyTextNodes(pendingEditorState, editor);\n      } else {\n        $applyAllTransforms(pendingEditorState, editor);\n      }\n      processNestedUpdates(editor);\n      $garbageCollectDetachedNodes(currentEditorState, pendingEditorState, editor._dirtyLeaves, editor._dirtyElements);\n    }\n    const endingCompositionKey = editor._compositionKey;\n    if (startingCompositionKey !== endingCompositionKey) {\n      pendingEditorState._flushSync = true;\n    }\n    const pendingSelection = pendingEditorState._selection;\n    if ($isRangeSelection(pendingSelection)) {\n      const pendingNodeMap = pendingEditorState._nodeMap;\n      const anchorKey = pendingSelection.anchor.key;\n      const focusKey = pendingSelection.focus.key;\n      if (pendingNodeMap.get(anchorKey) === undefined || pendingNodeMap.get(focusKey) === undefined) {\n        {\n          throw Error(`updateEditor: selection has been lost because the previously selected nodes have been removed and selection wasn't moved to another node. Ensure selection changes after removing/replacing a selected node.`);\n        }\n      }\n    } else if ($isNodeSelection(pendingSelection)) {\n      // TODO: we should also validate node selection?\n      if (pendingSelection._nodes.size === 0) {\n        pendingEditorState._selection = null;\n      }\n    }\n  } catch (error) {\n    // Report errors\n    if (error instanceof Error) {\n      editor._onError(error);\n    }\n\n    // Restore existing editor state to the DOM\n    editor._pendingEditorState = currentEditorState;\n    editor._dirtyType = FULL_RECONCILE;\n    editor._cloneNotNeeded.clear();\n    editor._dirtyLeaves = new Set();\n    editor._dirtyElements.clear();\n    $commitPendingUpdates(editor);\n    return;\n  } finally {\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n    editor._updating = previouslyUpdating;\n    infiniteTransformCount = 0;\n  }\n  const shouldUpdate = editor._dirtyType !== NO_DIRTY_NODES || editor._deferred.length > 0 || editorStateHasDirtySelection(pendingEditorState, editor);\n  if (shouldUpdate) {\n    if (pendingEditorState._flushSync) {\n      pendingEditorState._flushSync = false;\n      $commitPendingUpdates(editor);\n    } else if (editorStateWasCloned) {\n      scheduleMicroTask(() => {\n        $commitPendingUpdates(editor);\n      });\n    }\n  } else {\n    pendingEditorState._flushSync = false;\n    if (editorStateWasCloned) {\n      updateTags.clear();\n      editor._deferred = [];\n      editor._pendingEditorState = null;\n    }\n  }\n}\nfunction updateEditor(editor, updateFn, options) {\n  if (editor._updating) {\n    editor._updates.push([updateFn, options]);\n  } else {\n    $beginUpdate(editor, updateFn, options);\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\n\n/**\n * A utility class for managing the DOM children of an ElementNode\n */\nclass ElementDOMSlot {\n  constructor(/** The element returned by createDOM */\n  element, /** All managed children will be inserted before this node, if defined */\n  before, /** All managed children will be inserted after this node, if defined */\n  after) {\n    this.element = element;\n    this.before = before || null;\n    this.after = after || null;\n  }\n  /**\n   * Return a new ElementDOMSlot where all managed children will be inserted before this node\n   */\n  withBefore(before) {\n    return new ElementDOMSlot(this.element, before, this.after);\n  }\n  /**\n   * Return a new ElementDOMSlot where all managed children will be inserted after this node\n   */\n  withAfter(after) {\n    return new ElementDOMSlot(this.element, this.before, after);\n  }\n  /**\n   * Return a new ElementDOMSlot with an updated root element\n   */\n  withElement(element) {\n    return new ElementDOMSlot(element, this.before, this.after);\n  }\n  /**\n   * Insert the given child before this.before and any reconciler managed line break node,\n   * or append it if this.before is not defined\n   */\n  insertChild(dom) {\n    const before = this.before || this.getManagedLineBreak();\n    if (!(before === null || before.parentElement === this.element)) {\n      throw Error(`ElementDOMSlot.insertChild: before is not in element`);\n    }\n    this.element.insertBefore(dom, before);\n    return this;\n  }\n  /**\n   * Remove the managed child from this container, will throw if it was not already there\n   */\n  removeChild(dom) {\n    if (!(dom.parentElement === this.element)) {\n      throw Error(`ElementDOMSlot.removeChild: dom is not in element`);\n    }\n    this.element.removeChild(dom);\n    return this;\n  }\n  /**\n   * Replace managed child prevDom with dom. Will throw if prevDom is not a child\n   *\n   * @param dom The new node to replace prevDom\n   * @param prevDom the node that will be replaced\n   */\n  replaceChild(dom, prevDom) {\n    if (!(prevDom.parentElement === this.element)) {\n      throw Error(`ElementDOMSlot.replaceChild: prevDom is not in element`);\n    }\n    this.element.replaceChild(dom, prevDom);\n    return this;\n  }\n  /**\n   * Returns the first managed child of this node,\n   * which will either be this.after.nextSibling or this.element.firstChild,\n   * and will never be this.before if it is defined.\n   */\n  getFirstChild() {\n    const firstChild = this.after ? this.after.nextSibling : this.element.firstChild;\n    return firstChild === this.before || firstChild === this.getManagedLineBreak() ? null : firstChild;\n  }\n  /**\n   * @internal\n   */\n  getManagedLineBreak() {\n    const element = this.element;\n    return element.__lexicalLineBreak || null;\n  }\n  /** @internal */\n  setManagedLineBreak(lineBreakType) {\n    if (lineBreakType === null) {\n      this.removeManagedLineBreak();\n    } else {\n      const webkitHack = lineBreakType === 'decorator' && (IS_IOS || IS_SAFARI);\n      this.insertManagedLineBreak(webkitHack);\n    }\n  }\n\n  /** @internal */\n  removeManagedLineBreak() {\n    const br = this.getManagedLineBreak();\n    if (br) {\n      const element = this.element;\n      const sibling = br.nodeName === 'IMG' ? br.nextSibling : null;\n      if (sibling) {\n        element.removeChild(sibling);\n      }\n      element.removeChild(br);\n      element.__lexicalLineBreak = undefined;\n    }\n  }\n  /** @internal */\n  insertManagedLineBreak(webkitHack) {\n    const prevBreak = this.getManagedLineBreak();\n    if (prevBreak) {\n      if (webkitHack === (prevBreak.nodeName === 'IMG')) {\n        return;\n      }\n      this.removeManagedLineBreak();\n    }\n    const element = this.element;\n    const before = this.before;\n    const br = document.createElement('br');\n    element.insertBefore(br, before);\n    if (webkitHack) {\n      const img = document.createElement('img');\n      img.setAttribute('data-lexical-linebreak', 'true');\n      img.style.cssText = 'display: inline !important; border: 0px !important; margin: 0px !important;';\n      img.alt = '';\n      element.insertBefore(img, br);\n      element.__lexicalLineBreak = img;\n    } else {\n      element.__lexicalLineBreak = br;\n    }\n  }\n\n  /**\n   * @internal\n   *\n   * Returns the offset of the first child\n   */\n  getFirstChildOffset() {\n    let i = 0;\n    for (let node = this.after; node !== null; node = node.previousSibling) {\n      i++;\n    }\n    return i;\n  }\n\n  /**\n   * @internal\n   */\n  resolveChildIndex(element, elementDOM, initialDOM, initialOffset) {\n    if (initialDOM === this.element) {\n      const firstChildOffset = this.getFirstChildOffset();\n      return [element, Math.min(firstChildOffset + element.getChildrenSize(), Math.max(firstChildOffset, initialOffset))];\n    }\n    // The resolved offset must be before or after the children\n    const initialPath = indexPath(elementDOM, initialDOM);\n    initialPath.push(initialOffset);\n    const elementPath = indexPath(elementDOM, this.element);\n    let offset = element.getIndexWithinParent();\n    for (let i = 0; i < elementPath.length; i++) {\n      const target = initialPath[i];\n      const source = elementPath[i];\n      if (target === undefined || target < source) {\n        break;\n      } else if (target > source) {\n        offset += 1;\n        break;\n      }\n    }\n    return [element.getParentOrThrow(), offset];\n  }\n}\nfunction indexPath(root, child) {\n  const path = [];\n  let node = child;\n  for (; node !== root && node !== null; node = child.parentNode) {\n    let i = 0;\n    for (let sibling = node.previousSibling; sibling !== null; sibling = node.previousSibling) {\n      i++;\n    }\n    path.push(i);\n  }\n  if (!(node === root)) {\n    throw Error(`indexPath: root is not a parent of child`);\n  }\n  return path.reverse();\n}\n\n/** @noInheritDoc */\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nclass ElementNode extends LexicalNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  constructor(key) {\n    super(key);\n    this.__first = null;\n    this.__last = null;\n    this.__size = 0;\n    this.__format = 0;\n    this.__style = '';\n    this.__indent = 0;\n    this.__dir = null;\n    this.__textFormat = 0;\n    this.__textStyle = '';\n  }\n  afterCloneFrom(prevNode) {\n    super.afterCloneFrom(prevNode);\n    this.__first = prevNode.__first;\n    this.__last = prevNode.__last;\n    this.__size = prevNode.__size;\n    this.__indent = prevNode.__indent;\n    this.__format = prevNode.__format;\n    this.__style = prevNode.__style;\n    this.__dir = prevNode.__dir;\n    this.__textFormat = prevNode.__textFormat;\n    this.__textStyle = prevNode.__textStyle;\n  }\n  getFormat() {\n    const self = this.getLatest();\n    return self.__format;\n  }\n  getFormatType() {\n    const format = this.getFormat();\n    return ELEMENT_FORMAT_TO_TYPE[format] || '';\n  }\n  getStyle() {\n    const self = this.getLatest();\n    return self.__style;\n  }\n  getIndent() {\n    const self = this.getLatest();\n    return self.__indent;\n  }\n  getChildren() {\n    const children = [];\n    let child = this.getFirstChild();\n    while (child !== null) {\n      children.push(child);\n      child = child.getNextSibling();\n    }\n    return children;\n  }\n  getChildrenKeys() {\n    const children = [];\n    let child = this.getFirstChild();\n    while (child !== null) {\n      children.push(child.__key);\n      child = child.getNextSibling();\n    }\n    return children;\n  }\n  getChildrenSize() {\n    const self = this.getLatest();\n    return self.__size;\n  }\n  isEmpty() {\n    return this.getChildrenSize() === 0;\n  }\n  isDirty() {\n    const editor = getActiveEditor();\n    const dirtyElements = editor._dirtyElements;\n    return dirtyElements !== null && dirtyElements.has(this.__key);\n  }\n  isLastChild() {\n    const self = this.getLatest();\n    const parentLastChild = this.getParentOrThrow().getLastChild();\n    return parentLastChild !== null && parentLastChild.is(self);\n  }\n  getAllTextNodes() {\n    const textNodes = [];\n    let child = this.getFirstChild();\n    while (child !== null) {\n      if ($isTextNode(child)) {\n        textNodes.push(child);\n      }\n      if ($isElementNode(child)) {\n        const subChildrenNodes = child.getAllTextNodes();\n        textNodes.push(...subChildrenNodes);\n      }\n      child = child.getNextSibling();\n    }\n    return textNodes;\n  }\n  getFirstDescendant() {\n    let node = this.getFirstChild();\n    while ($isElementNode(node)) {\n      const child = node.getFirstChild();\n      if (child === null) {\n        break;\n      }\n      node = child;\n    }\n    return node;\n  }\n  getLastDescendant() {\n    let node = this.getLastChild();\n    while ($isElementNode(node)) {\n      const child = node.getLastChild();\n      if (child === null) {\n        break;\n      }\n      node = child;\n    }\n    return node;\n  }\n  getDescendantByIndex(index) {\n    const children = this.getChildren();\n    const childrenLength = children.length;\n    // For non-empty element nodes, we resolve its descendant\n    // (either a leaf node or the bottom-most element)\n    if (index >= childrenLength) {\n      const resolvedNode = children[childrenLength - 1];\n      return $isElementNode(resolvedNode) && resolvedNode.getLastDescendant() || resolvedNode || null;\n    }\n    const resolvedNode = children[index];\n    return $isElementNode(resolvedNode) && resolvedNode.getFirstDescendant() || resolvedNode || null;\n  }\n  getFirstChild() {\n    const self = this.getLatest();\n    const firstKey = self.__first;\n    return firstKey === null ? null : $getNodeByKey(firstKey);\n  }\n  getFirstChildOrThrow() {\n    const firstChild = this.getFirstChild();\n    if (firstChild === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a first child.`);\n      }\n    }\n    return firstChild;\n  }\n  getLastChild() {\n    const self = this.getLatest();\n    const lastKey = self.__last;\n    return lastKey === null ? null : $getNodeByKey(lastKey);\n  }\n  getLastChildOrThrow() {\n    const lastChild = this.getLastChild();\n    if (lastChild === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a last child.`);\n      }\n    }\n    return lastChild;\n  }\n  getChildAtIndex(index) {\n    const size = this.getChildrenSize();\n    let node;\n    let i;\n    if (index < size / 2) {\n      node = this.getFirstChild();\n      i = 0;\n      while (node !== null && i <= index) {\n        if (i === index) {\n          return node;\n        }\n        node = node.getNextSibling();\n        i++;\n      }\n      return null;\n    }\n    node = this.getLastChild();\n    i = size - 1;\n    while (node !== null && i >= index) {\n      if (i === index) {\n        return node;\n      }\n      node = node.getPreviousSibling();\n      i--;\n    }\n    return null;\n  }\n  getTextContent() {\n    let textContent = '';\n    const children = this.getChildren();\n    const childrenLength = children.length;\n    for (let i = 0; i < childrenLength; i++) {\n      const child = children[i];\n      textContent += child.getTextContent();\n      if ($isElementNode(child) && i !== childrenLength - 1 && !child.isInline()) {\n        textContent += DOUBLE_LINE_BREAK;\n      }\n    }\n    return textContent;\n  }\n  getTextContentSize() {\n    let textContentSize = 0;\n    const children = this.getChildren();\n    const childrenLength = children.length;\n    for (let i = 0; i < childrenLength; i++) {\n      const child = children[i];\n      textContentSize += child.getTextContentSize();\n      if ($isElementNode(child) && i !== childrenLength - 1 && !child.isInline()) {\n        textContentSize += DOUBLE_LINE_BREAK.length;\n      }\n    }\n    return textContentSize;\n  }\n  getDirection() {\n    const self = this.getLatest();\n    return self.__dir;\n  }\n  getTextFormat() {\n    const self = this.getLatest();\n    return self.__textFormat;\n  }\n  hasFormat(type) {\n    if (type !== '') {\n      const formatFlag = ELEMENT_TYPE_TO_FORMAT[type];\n      return (this.getFormat() & formatFlag) !== 0;\n    }\n    return false;\n  }\n  hasTextFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return (this.getTextFormat() & formatFlag) !== 0;\n  }\n  /**\n   * Returns the format flags applied to the node as a 32-bit integer.\n   *\n   * @returns a number representing the TextFormatTypes applied to the node.\n   */\n  getFormatFlags(type, alignWithFormat) {\n    const self = this.getLatest();\n    const format = self.__textFormat;\n    return toggleTextFormatType(format, type, alignWithFormat);\n  }\n  getTextStyle() {\n    const self = this.getLatest();\n    return self.__textStyle;\n  }\n\n  // Mutators\n\n  select(_anchorOffset, _focusOffset) {\n    errorOnReadOnly();\n    const selection = $getSelection();\n    let anchorOffset = _anchorOffset;\n    let focusOffset = _focusOffset;\n    const childrenCount = this.getChildrenSize();\n    if (!this.canBeEmpty()) {\n      if (_anchorOffset === 0 && _focusOffset === 0) {\n        const firstChild = this.getFirstChild();\n        if ($isTextNode(firstChild) || $isElementNode(firstChild)) {\n          return firstChild.select(0, 0);\n        }\n      } else if ((_anchorOffset === undefined || _anchorOffset === childrenCount) && (_focusOffset === undefined || _focusOffset === childrenCount)) {\n        const lastChild = this.getLastChild();\n        if ($isTextNode(lastChild) || $isElementNode(lastChild)) {\n          return lastChild.select();\n        }\n      }\n    }\n    if (anchorOffset === undefined) {\n      anchorOffset = childrenCount;\n    }\n    if (focusOffset === undefined) {\n      focusOffset = childrenCount;\n    }\n    const key = this.__key;\n    if (!$isRangeSelection(selection)) {\n      return $internalMakeRangeSelection(key, anchorOffset, key, focusOffset, 'element', 'element');\n    } else {\n      selection.anchor.set(key, anchorOffset, 'element');\n      selection.focus.set(key, focusOffset, 'element');\n      selection.dirty = true;\n    }\n    return selection;\n  }\n  selectStart() {\n    const firstNode = this.getFirstDescendant();\n    return firstNode ? firstNode.selectStart() : this.select();\n  }\n  selectEnd() {\n    const lastNode = this.getLastDescendant();\n    return lastNode ? lastNode.selectEnd() : this.select();\n  }\n  clear() {\n    const writableSelf = this.getWritable();\n    const children = this.getChildren();\n    children.forEach(child => child.remove());\n    return writableSelf;\n  }\n  append(...nodesToAppend) {\n    return this.splice(this.getChildrenSize(), 0, nodesToAppend);\n  }\n  setDirection(direction) {\n    const self = this.getWritable();\n    self.__dir = direction;\n    return self;\n  }\n  setFormat(type) {\n    const self = this.getWritable();\n    self.__format = type !== '' ? ELEMENT_TYPE_TO_FORMAT[type] : 0;\n    return this;\n  }\n  setStyle(style) {\n    const self = this.getWritable();\n    self.__style = style || '';\n    return this;\n  }\n  setTextFormat(type) {\n    const self = this.getWritable();\n    self.__textFormat = type;\n    return self;\n  }\n  setTextStyle(style) {\n    const self = this.getWritable();\n    self.__textStyle = style;\n    return self;\n  }\n  setIndent(indentLevel) {\n    const self = this.getWritable();\n    self.__indent = indentLevel;\n    return this;\n  }\n  splice(start, deleteCount, nodesToInsert) {\n    const nodesToInsertLength = nodesToInsert.length;\n    const oldSize = this.getChildrenSize();\n    const writableSelf = this.getWritable();\n    if (!(start + deleteCount <= oldSize)) {\n      throw Error(`ElementNode.splice: start + deleteCount > oldSize (${String(start)} + ${String(deleteCount)} > ${String(oldSize)})`);\n    }\n    const writableSelfKey = writableSelf.__key;\n    const nodesToInsertKeys = [];\n    const nodesToRemoveKeys = [];\n    const nodeAfterRange = this.getChildAtIndex(start + deleteCount);\n    let nodeBeforeRange = null;\n    let newSize = oldSize - deleteCount + nodesToInsertLength;\n    if (start !== 0) {\n      if (start === oldSize) {\n        nodeBeforeRange = this.getLastChild();\n      } else {\n        const node = this.getChildAtIndex(start);\n        if (node !== null) {\n          nodeBeforeRange = node.getPreviousSibling();\n        }\n      }\n    }\n    if (deleteCount > 0) {\n      let nodeToDelete = nodeBeforeRange === null ? this.getFirstChild() : nodeBeforeRange.getNextSibling();\n      for (let i = 0; i < deleteCount; i++) {\n        if (nodeToDelete === null) {\n          {\n            throw Error(`splice: sibling not found`);\n          }\n        }\n        const nextSibling = nodeToDelete.getNextSibling();\n        const nodeKeyToDelete = nodeToDelete.__key;\n        const writableNodeToDelete = nodeToDelete.getWritable();\n        removeFromParent(writableNodeToDelete);\n        nodesToRemoveKeys.push(nodeKeyToDelete);\n        nodeToDelete = nextSibling;\n      }\n    }\n    let prevNode = nodeBeforeRange;\n    for (let i = 0; i < nodesToInsertLength; i++) {\n      const nodeToInsert = nodesToInsert[i];\n      if (prevNode !== null && nodeToInsert.is(prevNode)) {\n        nodeBeforeRange = prevNode = prevNode.getPreviousSibling();\n      }\n      const writableNodeToInsert = nodeToInsert.getWritable();\n      if (writableNodeToInsert.__parent === writableSelfKey) {\n        newSize--;\n      }\n      removeFromParent(writableNodeToInsert);\n      const nodeKeyToInsert = nodeToInsert.__key;\n      if (prevNode === null) {\n        writableSelf.__first = nodeKeyToInsert;\n        writableNodeToInsert.__prev = null;\n      } else {\n        const writablePrevNode = prevNode.getWritable();\n        writablePrevNode.__next = nodeKeyToInsert;\n        writableNodeToInsert.__prev = writablePrevNode.__key;\n      }\n      if (nodeToInsert.__key === writableSelfKey) {\n        {\n          throw Error(`append: attempting to append self`);\n        }\n      }\n      // Set child parent to self\n      writableNodeToInsert.__parent = writableSelfKey;\n      nodesToInsertKeys.push(nodeKeyToInsert);\n      prevNode = nodeToInsert;\n    }\n    if (start + deleteCount === oldSize) {\n      if (prevNode !== null) {\n        const writablePrevNode = prevNode.getWritable();\n        writablePrevNode.__next = null;\n        writableSelf.__last = prevNode.__key;\n      }\n    } else if (nodeAfterRange !== null) {\n      const writableNodeAfterRange = nodeAfterRange.getWritable();\n      if (prevNode !== null) {\n        const writablePrevNode = prevNode.getWritable();\n        writableNodeAfterRange.__prev = prevNode.__key;\n        writablePrevNode.__next = nodeAfterRange.__key;\n      } else {\n        writableNodeAfterRange.__prev = null;\n      }\n    }\n    writableSelf.__size = newSize;\n\n    // In case of deletion we need to adjust selection, unlink removed nodes\n    // and clean up node itself if it becomes empty. None of these needed\n    // for insertion-only cases\n    if (nodesToRemoveKeys.length) {\n      // Adjusting selection, in case node that was anchor/focus will be deleted\n      const selection = $getSelection();\n      if ($isRangeSelection(selection)) {\n        const nodesToRemoveKeySet = new Set(nodesToRemoveKeys);\n        const nodesToInsertKeySet = new Set(nodesToInsertKeys);\n        const {\n          anchor,\n          focus\n        } = selection;\n        if (isPointRemoved(anchor, nodesToRemoveKeySet, nodesToInsertKeySet)) {\n          moveSelectionPointToSibling(anchor, anchor.getNode(), this, nodeBeforeRange, nodeAfterRange);\n        }\n        if (isPointRemoved(focus, nodesToRemoveKeySet, nodesToInsertKeySet)) {\n          moveSelectionPointToSibling(focus, focus.getNode(), this, nodeBeforeRange, nodeAfterRange);\n        }\n        // Cleanup if node can't be empty\n        if (newSize === 0 && !this.canBeEmpty() && !$isRootOrShadowRoot(this)) {\n          this.remove();\n        }\n      }\n    }\n    return writableSelf;\n  }\n  /**\n   * @internal\n   *\n   * An experimental API that an ElementNode can override to control where its\n   * children are inserted into the DOM, this is useful to add a wrapping node\n   * or accessory nodes before or after the children. The root of the node returned\n   * by createDOM must still be exactly one HTMLElement.\n   */\n  getDOMSlot(element) {\n    return new ElementDOMSlot(element);\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (isHTMLElement(element)) {\n      const indent = this.getIndent();\n      if (indent > 0) {\n        // padding-inline-start is not widely supported in email HTML\n        // (see https://www.caniemail.com/features/css-padding-inline-start-end/),\n        // If you want to use HTML output for email, consider overriding the serialization\n        // to use `padding-right` in RTL languages, `padding-left` in `LTR` languages, or\n        // `text-indent` if you are ok with first-line indents.\n        // We recommend keeping multiples of 40px to maintain consistency with list-items\n        // (see https://github.com/facebook/lexical/pull/4025)\n        element.style.paddingInlineStart = `${indent * 40}px`;\n      }\n    }\n    return {\n      element\n    };\n  }\n  // JSON serialization\n  exportJSON() {\n    const json = {\n      children: [],\n      direction: this.getDirection(),\n      format: this.getFormatType(),\n      indent: this.getIndent(),\n      // As an exception here we invoke super at the end for historical reasons.\n      // Namely, to preserve the order of the properties and not to break the tests\n      // that use the serialized string representation.\n      ...super.exportJSON()\n    };\n    const textFormat = this.getTextFormat();\n    const textStyle = this.getTextStyle();\n    if (textFormat !== 0) {\n      json.textFormat = textFormat;\n    }\n    if (textStyle !== '') {\n      json.textStyle = textStyle;\n    }\n    return json;\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setFormat(serializedNode.format).setIndent(serializedNode.indent).setDirection(serializedNode.direction).setTextFormat(serializedNode.textFormat || 0).setTextStyle(serializedNode.textStyle || '');\n  }\n  // These are intended to be extends for specific element heuristics.\n  insertNewAfter(selection, restoreSelection) {\n    return null;\n  }\n  canIndent() {\n    return true;\n  }\n  /*\n   * This method controls the behavior of a the node during backwards\n   * deletion (i.e., backspace) when selection is at the beginning of\n   * the node (offset 0)\n   */\n  collapseAtStart(selection) {\n    return false;\n  }\n  excludeFromCopy(destination) {\n    return false;\n  }\n  /** @deprecated @internal */\n  canReplaceWith(replacement) {\n    return true;\n  }\n  /** @deprecated @internal */\n  canInsertAfter(node) {\n    return true;\n  }\n  canBeEmpty() {\n    return true;\n  }\n  canInsertTextBefore() {\n    return true;\n  }\n  canInsertTextAfter() {\n    return true;\n  }\n  isInline() {\n    return false;\n  }\n  // A shadow root is a Node that behaves like RootNode. The shadow root (and RootNode) mark the\n  // end of the hiercharchy, most implementations should treat it as there's nothing (upwards)\n  // beyond this point. For example, node.getTopLevelElement(), when performed inside a TableCellNode\n  // will return the immediate first child underneath TableCellNode instead of RootNode.\n  isShadowRoot() {\n    return false;\n  }\n  /** @deprecated @internal */\n  canMergeWith(node) {\n    return false;\n  }\n  extractWithChild(child, selection, destination) {\n    return false;\n  }\n\n  /**\n   * Determines whether this node, when empty, can merge with a first block\n   * of nodes being inserted.\n   *\n   * This method is specifically called in {@link RangeSelection.insertNodes}\n   * to determine merging behavior during nodes insertion.\n   *\n   * @example\n   * // In a ListItemNode or QuoteNode implementation:\n   * canMergeWhenEmpty(): true {\n   *  return true;\n   * }\n   */\n  canMergeWhenEmpty() {\n    return false;\n  }\n\n  /** @internal */\n  reconcileObservedMutation(dom, editor) {\n    const slot = this.getDOMSlot(dom);\n    let currentDOM = slot.getFirstChild();\n    for (let currentNode = this.getFirstChild(); currentNode; currentNode = currentNode.getNextSibling()) {\n      const correctDOM = editor.getElementByKey(currentNode.getKey());\n      if (correctDOM === null) {\n        continue;\n      }\n      if (currentDOM == null) {\n        slot.insertChild(correctDOM);\n        currentDOM = correctDOM;\n      } else if (currentDOM !== correctDOM) {\n        slot.replaceChild(correctDOM, currentDOM);\n      }\n      currentDOM = currentDOM.nextSibling;\n    }\n  }\n}\nfunction $isElementNode(node) {\n  return node instanceof ElementNode;\n}\nfunction isPointRemoved(point, nodesToRemoveKeySet, nodesToInsertKeySet) {\n  let node = point.getNode();\n  while (node) {\n    const nodeKey = node.__key;\n    if (nodesToRemoveKeySet.has(nodeKey) && !nodesToInsertKeySet.has(nodeKey)) {\n      return true;\n    }\n    node = node.getParent();\n  }\n  return false;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n/** @noInheritDoc */\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nclass DecoratorNode extends LexicalNode {\n  /**\n   * The returned value is added to the LexicalEditor._decorators\n   */\n  decorate(editor, config) {\n    {\n      throw Error(`decorate: base method not extended`);\n    }\n  }\n  isIsolated() {\n    return false;\n  }\n  isInline() {\n    return true;\n  }\n  isKeyboardSelectable() {\n    return true;\n  }\n}\nfunction $isDecoratorNode(node) {\n  return node instanceof DecoratorNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass RootNode extends ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'root';\n  }\n  static clone() {\n    return new RootNode();\n  }\n  constructor() {\n    super('root');\n    this.__cachedText = null;\n  }\n  getTopLevelElementOrThrow() {\n    {\n      throw Error(`getTopLevelElementOrThrow: root nodes are not top level elements`);\n    }\n  }\n  getTextContent() {\n    const cachedText = this.__cachedText;\n    if (isCurrentlyReadOnlyMode() || getActiveEditor()._dirtyType === NO_DIRTY_NODES) {\n      if (cachedText !== null) {\n        return cachedText;\n      }\n    }\n    return super.getTextContent();\n  }\n  remove() {\n    {\n      throw Error(`remove: cannot be called on root nodes`);\n    }\n  }\n  replace(node) {\n    {\n      throw Error(`replace: cannot be called on root nodes`);\n    }\n  }\n  insertBefore(nodeToInsert) {\n    {\n      throw Error(`insertBefore: cannot be called on root nodes`);\n    }\n  }\n  insertAfter(nodeToInsert) {\n    {\n      throw Error(`insertAfter: cannot be called on root nodes`);\n    }\n  }\n\n  // View\n\n  updateDOM(prevNode, dom) {\n    return false;\n  }\n\n  // Mutate\n\n  append(...nodesToAppend) {\n    for (let i = 0; i < nodesToAppend.length; i++) {\n      const node = nodesToAppend[i];\n      if (!$isElementNode(node) && !$isDecoratorNode(node)) {\n        {\n          throw Error(`rootNode.append: Only element or decorator nodes can be appended to the root node`);\n        }\n      }\n    }\n    return super.append(...nodesToAppend);\n  }\n  static importJSON(serializedNode) {\n    // We don't create a root, and instead use the existing root.\n    return $getRoot().updateFromJSON(serializedNode);\n  }\n  collapseAtStart() {\n    return true;\n  }\n}\nfunction $createRootNode() {\n  return new RootNode();\n}\nfunction $isRootNode(node) {\n  return node instanceof RootNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction editorStateHasDirtySelection(editorState, editor) {\n  const currentSelection = editor.getEditorState()._selection;\n  const pendingSelection = editorState._selection;\n\n  // Check if we need to update because of changes in selection\n  if (pendingSelection !== null) {\n    if (pendingSelection.dirty || !pendingSelection.is(currentSelection)) {\n      return true;\n    }\n  } else if (currentSelection !== null) {\n    return true;\n  }\n  return false;\n}\nfunction cloneEditorState(current) {\n  return new EditorState(new Map(current._nodeMap));\n}\nfunction createEmptyEditorState() {\n  return new EditorState(new Map([['root', $createRootNode()]]));\n}\nfunction exportNodeToJSON(node) {\n  const serializedNode = node.exportJSON();\n  const nodeClass = node.constructor;\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not match the serialized type. Check if .exportJSON() is implemented and it is returning the correct type.`);\n    }\n  }\n  if ($isElementNode(node)) {\n    const serializedChildren = serializedNode.children;\n    if (!Array.isArray(serializedChildren)) {\n      {\n        throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);\n      }\n    }\n    const children = node.getChildren();\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      const serializedChildNode = exportNodeToJSON(child);\n      serializedChildren.push(serializedChildNode);\n    }\n  }\n\n  // @ts-expect-error\n  return serializedNode;\n}\nclass EditorState {\n  constructor(nodeMap, selection) {\n    this._nodeMap = nodeMap;\n    this._selection = selection || null;\n    this._flushSync = false;\n    this._readOnly = false;\n  }\n  isEmpty() {\n    return this._nodeMap.size === 1 && this._selection === null;\n  }\n  read(callbackFn, options) {\n    return readEditorState(options && options.editor || null, this, callbackFn);\n  }\n  clone(selection) {\n    const editorState = new EditorState(this._nodeMap, selection === undefined ? this._selection : selection);\n    editorState._readOnly = true;\n    return editorState;\n  }\n  toJSON() {\n    return readEditorState(null, this, () => ({\n      root: exportNodeToJSON($getRoot())\n    }));\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// TODO: Cleanup ArtificialNode__DO_NOT_USE #5966\nclass ArtificialNode__DO_NOT_USE extends ElementNode {\n  static getType() {\n    return 'artificial';\n  }\n  createDOM(config) {\n    // this isnt supposed to be used and is not used anywhere but defining it to appease the API\n    const dom = document.createElement('div');\n    return dom;\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ParagraphNode extends ElementNode {\n  static getType() {\n    return 'paragraph';\n  }\n  static clone(node) {\n    return new ParagraphNode(node.__key);\n  }\n\n  // View\n\n  createDOM(config) {\n    const dom = document.createElement('p');\n    const classNames = getCachedClassNameArray(config.theme, 'paragraph');\n    if (classNames !== undefined) {\n      const domClassList = dom.classList;\n      domClassList.add(...classNames);\n    }\n    return dom;\n  }\n  updateDOM(prevNode, dom, config) {\n    return false;\n  }\n  static importDOM() {\n    return {\n      p: node => ({\n        conversion: $convertParagraphElement,\n        priority: 0\n      })\n    };\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (isHTMLElement(element)) {\n      if (this.isEmpty()) {\n        element.append(document.createElement('br'));\n      }\n      const formatType = this.getFormatType();\n      element.style.textAlign = formatType;\n      const direction = this.getDirection();\n      if (direction) {\n        element.dir = direction;\n      }\n    }\n    return {\n      element\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createParagraphNode().updateFromJSON(serializedNode);\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      // These are included explicitly for backwards compatibility\n      textFormat: this.getTextFormat(),\n      textStyle: this.getTextStyle()\n    };\n  }\n\n  // Mutation\n\n  insertNewAfter(rangeSelection, restoreSelection) {\n    const newElement = $createParagraphNode();\n    newElement.setTextFormat(rangeSelection.format);\n    newElement.setTextStyle(rangeSelection.style);\n    const direction = this.getDirection();\n    newElement.setDirection(direction);\n    newElement.setFormat(this.getFormatType());\n    newElement.setStyle(this.getTextStyle());\n    this.insertAfter(newElement, restoreSelection);\n    return newElement;\n  }\n  collapseAtStart() {\n    const children = this.getChildren();\n    // If we have an empty (trimmed) first paragraph and try and remove it,\n    // delete the paragraph as long as we have another sibling to go to\n    if (children.length === 0 || $isTextNode(children[0]) && children[0].getTextContent().trim() === '') {\n      const nextSibling = this.getNextSibling();\n      if (nextSibling !== null) {\n        this.selectNext();\n        this.remove();\n        return true;\n      }\n      const prevSibling = this.getPreviousSibling();\n      if (prevSibling !== null) {\n        this.selectPrevious();\n        this.remove();\n        return true;\n      }\n    }\n    return false;\n  }\n}\nfunction $convertParagraphElement(element) {\n  const node = $createParagraphNode();\n  if (element.style) {\n    node.setFormat(element.style.textAlign);\n    setNodeIndentFromDOM(element, node);\n  }\n  return {\n    node\n  };\n}\nfunction $createParagraphNode() {\n  return $applyNodeReplacement(new ParagraphNode());\n}\nfunction $isParagraphNode(node) {\n  return node instanceof ParagraphNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// https://github.com/microsoft/TypeScript/issues/3841\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\nconst DEFAULT_SKIP_INITIALIZATION = false;\nconst COMMAND_PRIORITY_EDITOR = 0;\nconst COMMAND_PRIORITY_LOW = 1;\nconst COMMAND_PRIORITY_NORMAL = 2;\nconst COMMAND_PRIORITY_HIGH = 3;\nconst COMMAND_PRIORITY_CRITICAL = 4;\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n/**\n * Type helper for extracting the payload type from a command.\n *\n * @example\n * ```ts\n * const MY_COMMAND = createCommand<SomeType>();\n *\n * // ...\n *\n * editor.registerCommand(MY_COMMAND, payload => {\n *   // Type of `payload` is inferred here. But lets say we want to extract a function to delegate to\n *   $handleMyCommand(editor, payload);\n *   return true;\n * });\n *\n * function $handleMyCommand(editor: LexicalEditor, payload: CommandPayloadType<typeof MY_COMMAND>) {\n *   // `payload` is of type `SomeType`, extracted from the command.\n * }\n * ```\n */\n\nfunction resetEditor(editor, prevRootElement, nextRootElement, pendingEditorState) {\n  const keyNodeMap = editor._keyToDOMMap;\n  keyNodeMap.clear();\n  editor._editorState = createEmptyEditorState();\n  editor._pendingEditorState = pendingEditorState;\n  editor._compositionKey = null;\n  editor._dirtyType = NO_DIRTY_NODES;\n  editor._cloneNotNeeded.clear();\n  editor._dirtyLeaves = new Set();\n  editor._dirtyElements.clear();\n  editor._normalizedNodes = new Set();\n  editor._updateTags = new Set();\n  editor._updates = [];\n  editor._blockCursorElement = null;\n  const observer = editor._observer;\n  if (observer !== null) {\n    observer.disconnect();\n    editor._observer = null;\n  }\n\n  // Remove all the DOM nodes from the root element\n  if (prevRootElement !== null) {\n    prevRootElement.textContent = '';\n  }\n  if (nextRootElement !== null) {\n    nextRootElement.textContent = '';\n    keyNodeMap.set('root', nextRootElement);\n  }\n}\nfunction initializeConversionCache(nodes, additionalConversions) {\n  const conversionCache = new Map();\n  const handledConversions = new Set();\n  const addConversionsToCache = map => {\n    Object.keys(map).forEach(key => {\n      let currentCache = conversionCache.get(key);\n      if (currentCache === undefined) {\n        currentCache = [];\n        conversionCache.set(key, currentCache);\n      }\n      currentCache.push(map[key]);\n    });\n  };\n  nodes.forEach(node => {\n    const importDOM = node.klass.importDOM;\n    if (importDOM == null || handledConversions.has(importDOM)) {\n      return;\n    }\n    handledConversions.add(importDOM);\n    const map = importDOM.call(node.klass);\n    if (map !== null) {\n      addConversionsToCache(map);\n    }\n  });\n  if (additionalConversions) {\n    addConversionsToCache(additionalConversions);\n  }\n  return conversionCache;\n}\n\n/**\n * Creates a new LexicalEditor attached to a single contentEditable (provided in the config). This is\n * the lowest-level initialization API for a LexicalEditor. If you're using React or another framework,\n * consider using the appropriate abstractions, such as LexicalComposer\n * @param editorConfig - the editor configuration.\n * @returns a LexicalEditor instance\n */\nfunction createEditor(editorConfig) {\n  const config = editorConfig || {};\n  const activeEditor = internalGetActiveEditor();\n  const theme = config.theme || {};\n  const parentEditor = editorConfig === undefined ? activeEditor : config.parentEditor || null;\n  const disableEvents = config.disableEvents || false;\n  const editorState = createEmptyEditorState();\n  const namespace = config.namespace || (parentEditor !== null ? parentEditor._config.namespace : createUID());\n  const initialEditorState = config.editorState;\n  const nodes = [RootNode, TextNode, LineBreakNode, TabNode, ParagraphNode, ArtificialNode__DO_NOT_USE, ...(config.nodes || [])];\n  const {\n    onError,\n    html\n  } = config;\n  const isEditable = config.editable !== undefined ? config.editable : true;\n  let registeredNodes;\n  if (editorConfig === undefined && activeEditor !== null) {\n    registeredNodes = activeEditor._nodes;\n  } else {\n    registeredNodes = new Map();\n    for (let i = 0; i < nodes.length; i++) {\n      let klass = nodes[i];\n      let replace = null;\n      let replaceWithKlass = null;\n      if (typeof klass !== 'function') {\n        const options = klass;\n        klass = options.replace;\n        replace = options.with;\n        replaceWithKlass = options.withKlass || null;\n      }\n      // Ensure custom nodes implement required methods and replaceWithKlass is instance of base klass.\n      {\n        // ArtificialNode__DO_NOT_USE can get renamed, so we use the type\n        const nodeType = Object.prototype.hasOwnProperty.call(klass, 'getType') && klass.getType();\n        const name = klass.name;\n        if (replaceWithKlass) {\n          if (!(replaceWithKlass.prototype instanceof klass)) {\n            throw Error(`${replaceWithKlass.name} doesn't extend the ${name}`);\n          }\n        }\n        if (name !== 'RootNode' && nodeType !== 'root' && nodeType !== 'artificial') {\n          const proto = klass.prototype;\n          ['getType', 'clone'].forEach(method => {\n            // eslint-disable-next-line no-prototype-builtins\n            if (!klass.hasOwnProperty(method)) {\n              console.warn(`${name} must implement static \"${method}\" method`);\n            }\n          });\n          if (\n          // eslint-disable-next-line no-prototype-builtins\n          !klass.hasOwnProperty('importDOM') &&\n          // eslint-disable-next-line no-prototype-builtins\n          klass.hasOwnProperty('exportDOM')) {\n            console.warn(`${name} should implement \"importDOM\" if using a custom \"exportDOM\" method to ensure HTML serialization (important for copy & paste) works as expected`);\n          }\n          if ($isDecoratorNode(proto)) {\n            // eslint-disable-next-line no-prototype-builtins\n            if (!proto.hasOwnProperty('decorate')) {\n              console.warn(`${proto.constructor.name} must implement \"decorate\" method`);\n            }\n          }\n          if (\n          // eslint-disable-next-line no-prototype-builtins\n          !klass.hasOwnProperty('importJSON')) {\n            console.warn(`${name} should implement \"importJSON\" method to ensure JSON and default HTML serialization works as expected`);\n          }\n        }\n      }\n      const type = klass.getType();\n      const transform = klass.transform();\n      const transforms = new Set();\n      if (transform !== null) {\n        transforms.add(transform);\n      }\n      registeredNodes.set(type, {\n        exportDOM: html && html.export ? html.export.get(klass) : undefined,\n        klass,\n        replace,\n        replaceWithKlass,\n        transforms\n      });\n    }\n  }\n  const editor = new LexicalEditor(editorState, parentEditor, registeredNodes, {\n    disableEvents,\n    namespace,\n    theme\n  }, onError ? onError : console.error, initializeConversionCache(registeredNodes, html ? html.import : undefined), isEditable);\n  if (initialEditorState !== undefined) {\n    editor._pendingEditorState = initialEditorState;\n    editor._dirtyType = FULL_RECONCILE;\n  }\n  return editor;\n}\nclass LexicalEditor {\n  /** The version with build identifiers for this editor (since 0.17.1) */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n  constructor(editorState, parentEditor, nodes, config, onError, htmlConversions, editable) {\n    this._parentEditor = parentEditor;\n    // The root element associated with this editor\n    this._rootElement = null;\n    // The current editor state\n    this._editorState = editorState;\n    // Handling of drafts and updates\n    this._pendingEditorState = null;\n    // Used to help co-ordinate selection and events\n    this._compositionKey = null;\n    this._deferred = [];\n    // Used during reconciliation\n    this._keyToDOMMap = new Map();\n    this._updates = [];\n    this._updating = false;\n    // Listeners\n    this._listeners = {\n      decorator: new Set(),\n      editable: new Set(),\n      mutation: new Map(),\n      root: new Set(),\n      textcontent: new Set(),\n      update: new Set()\n    };\n    // Commands\n    this._commands = new Map();\n    // Editor configuration for theme/context.\n    this._config = config;\n    // Mapping of types to their nodes\n    this._nodes = nodes;\n    // React node decorators for portals\n    this._decorators = {};\n    this._pendingDecorators = null;\n    // Used to optimize reconciliation\n    this._dirtyType = NO_DIRTY_NODES;\n    this._cloneNotNeeded = new Set();\n    this._dirtyLeaves = new Set();\n    this._dirtyElements = new Map();\n    this._normalizedNodes = new Set();\n    this._updateTags = new Set();\n    // Handling of DOM mutations\n    this._observer = null;\n    // Used for identifying owning editors\n    this._key = createUID();\n    this._onError = onError;\n    this._htmlConversions = htmlConversions;\n    this._editable = editable;\n    this._headless = parentEditor !== null && parentEditor._headless;\n    this._window = null;\n    this._blockCursorElement = null;\n  }\n\n  /**\n   *\n   * @returns true if the editor is currently in \"composition\" mode due to receiving input\n   * through an IME, or 3P extension, for example. Returns false otherwise.\n   */\n  isComposing() {\n    return this._compositionKey != null;\n  }\n  /**\n   * Registers a listener for Editor update event. Will trigger the provided callback\n   * each time the editor goes through an update (via {@link LexicalEditor.update}) until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerUpdateListener(listener) {\n    const listenerSetOrMap = this._listeners.update;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for for when the editor changes between editable and non-editable states.\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerEditableListener(listener) {\n    const listenerSetOrMap = this._listeners.editable;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for when the editor's decorator object changes. The decorator object contains\n   * all DecoratorNode keys -> their decorated value. This is primarily used with external UI frameworks.\n   *\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerDecoratorListener(listener) {\n    const listenerSetOrMap = this._listeners.decorator;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for when Lexical commits an update to the DOM and the text content of\n   * the editor changes from the previous state of the editor. If the text content is the\n   * same between updates, no notifications to the listeners will happen.\n   *\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerTextContentListener(listener) {\n    const listenerSetOrMap = this._listeners.textcontent;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for when the editor's root DOM element (the content editable\n   * Lexical attaches to) changes. This is primarily used to attach event listeners to the root\n   *  element. The root listener function is executed directly upon registration and then on\n   * any subsequent update.\n   *\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerRootListener(listener) {\n    const listenerSetOrMap = this._listeners.root;\n    listener(this._rootElement, null);\n    listenerSetOrMap.add(listener);\n    return () => {\n      listener(null, this._rootElement);\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener that will trigger anytime the provided command\n   * is dispatched with {@link LexicalEditor.dispatch}, subject to priority.\n   * Listeners that run at a higher priority can \"intercept\" commands and\n   * prevent them from propagating to other handlers by returning true.\n   *\n   * Listeners are always invoked in an {@link LexicalEditor.update} and can\n   * call dollar functions.\n   *\n   * Listeners registered at the same priority level will run\n   * deterministically in the order of registration.\n   *\n   * @param command - the command that will trigger the callback.\n   * @param listener - the function that will execute when the command is dispatched.\n   * @param priority - the relative priority of the listener. 0 | 1 | 2 | 3 | 4\n   *   (or {@link COMMAND_PRIORITY_EDITOR} |\n   *     {@link COMMAND_PRIORITY_LOW} |\n   *     {@link COMMAND_PRIORITY_NORMAL} |\n   *     {@link COMMAND_PRIORITY_HIGH} |\n   *     {@link COMMAND_PRIORITY_CRITICAL})\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerCommand(command, listener, priority) {\n    if (priority === undefined) {\n      {\n        throw Error(`Listener for type \"command\" requires a \"priority\".`);\n      }\n    }\n    const commandsMap = this._commands;\n    if (!commandsMap.has(command)) {\n      commandsMap.set(command, [new Set(), new Set(), new Set(), new Set(), new Set()]);\n    }\n    const listenersInPriorityOrder = commandsMap.get(command);\n    if (listenersInPriorityOrder === undefined) {\n      {\n        throw Error(`registerCommand: Command ${String(command)} not found in command map`);\n      }\n    }\n    const listeners = listenersInPriorityOrder[priority];\n    listeners.add(listener);\n    return () => {\n      listeners.delete(listener);\n      if (listenersInPriorityOrder.every(listenersSet => listenersSet.size === 0)) {\n        commandsMap.delete(command);\n      }\n    };\n  }\n\n  /**\n   * Registers a listener that will run when a Lexical node of the provided class is\n   * mutated. The listener will receive a list of nodes along with the type of mutation\n   * that was performed on each: created, destroyed, or updated.\n   *\n   * One common use case for this is to attach DOM event listeners to the underlying DOM nodes as Lexical nodes are created.\n   * {@link LexicalEditor.getElementByKey} can be used for this.\n   *\n   * If any existing nodes are in the DOM, and skipInitialization is not true, the listener\n   * will be called immediately with an updateTag of 'registerMutationListener' where all\n   * nodes have the 'created' NodeMutation. This can be controlled with the skipInitialization option\n   * (whose default was previously true for backwards compatibility with &lt;=0.16.1 but has been changed to false as of 0.21.0).\n   *\n   * @param klass - The class of the node that you want to listen to mutations on.\n   * @param listener - The logic you want to run when the node is mutated.\n   * @param options - see {@link MutationListenerOptions}\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerMutationListener(klass, listener, options) {\n    const klassToMutate = this.resolveRegisteredNodeAfterReplacements(this.getRegisteredNode(klass)).klass;\n    const mutations = this._listeners.mutation;\n    mutations.set(listener, klassToMutate);\n    const skipInitialization = options && options.skipInitialization;\n    if (!(skipInitialization === undefined ? DEFAULT_SKIP_INITIALIZATION : skipInitialization)) {\n      this.initializeMutationListener(listener, klassToMutate);\n    }\n    return () => {\n      mutations.delete(listener);\n    };\n  }\n\n  /** @internal */\n  getRegisteredNode(klass) {\n    const registeredNode = this._nodes.get(klass.getType());\n    if (registeredNode === undefined) {\n      {\n        throw Error(`Node ${klass.name} has not been registered. Ensure node has been passed to createEditor.`);\n      }\n    }\n    return registeredNode;\n  }\n\n  /** @internal */\n  resolveRegisteredNodeAfterReplacements(registeredNode) {\n    while (registeredNode.replaceWithKlass) {\n      registeredNode = this.getRegisteredNode(registeredNode.replaceWithKlass);\n    }\n    return registeredNode;\n  }\n\n  /** @internal */\n  initializeMutationListener(listener, klass) {\n    const prevEditorState = this._editorState;\n    const nodeMap = getCachedTypeToNodeMap(prevEditorState).get(klass.getType());\n    if (!nodeMap) {\n      return;\n    }\n    const nodeMutationMap = new Map();\n    for (const k of nodeMap.keys()) {\n      nodeMutationMap.set(k, 'created');\n    }\n    if (nodeMutationMap.size > 0) {\n      listener(nodeMutationMap, {\n        dirtyLeaves: new Set(),\n        prevEditorState,\n        updateTags: new Set(['registerMutationListener'])\n      });\n    }\n  }\n\n  /** @internal */\n  registerNodeTransformToKlass(klass, listener) {\n    const registeredNode = this.getRegisteredNode(klass);\n    registeredNode.transforms.add(listener);\n    return registeredNode;\n  }\n\n  /**\n   * Registers a listener that will run when a Lexical node of the provided class is\n   * marked dirty during an update. The listener will continue to run as long as the node\n   * is marked dirty. There are no guarantees around the order of transform execution!\n   *\n   * Watch out for infinite loops. See [Node Transforms](https://lexical.dev/docs/concepts/transforms)\n   * @param klass - The class of the node that you want to run transforms on.\n   * @param listener - The logic you want to run when the node is updated.\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerNodeTransform(klass, listener) {\n    const registeredNode = this.registerNodeTransformToKlass(klass, listener);\n    const registeredNodes = [registeredNode];\n    const replaceWithKlass = registeredNode.replaceWithKlass;\n    if (replaceWithKlass != null) {\n      const registeredReplaceWithNode = this.registerNodeTransformToKlass(replaceWithKlass, listener);\n      registeredNodes.push(registeredReplaceWithNode);\n    }\n    markNodesWithTypesAsDirty(this, registeredNodes.map(node => node.klass.getType()));\n    return () => {\n      registeredNodes.forEach(node => node.transforms.delete(listener));\n    };\n  }\n\n  /**\n   * Used to assert that a certain node is registered, usually by plugins to ensure nodes that they\n   * depend on have been registered.\n   * @returns True if the editor has registered the provided node type, false otherwise.\n   */\n  hasNode(node) {\n    return this._nodes.has(node.getType());\n  }\n\n  /**\n   * Used to assert that certain nodes are registered, usually by plugins to ensure nodes that they\n   * depend on have been registered.\n   * @returns True if the editor has registered all of the provided node types, false otherwise.\n   */\n  hasNodes(nodes) {\n    return nodes.every(this.hasNode.bind(this));\n  }\n\n  /**\n   * Dispatches a command of the specified type with the specified payload.\n   * This triggers all command listeners (set by {@link LexicalEditor.registerCommand})\n   * for this type, passing them the provided payload. The command listeners\n   * will be triggered in an implicit {@link LexicalEditor.update}, unless\n   * this was invoked from inside an update in which case that update context\n   * will be re-used (as if this was a dollar function itself).\n   * @param type - the type of command listeners to trigger.\n   * @param payload - the data to pass as an argument to the command listeners.\n   */\n  dispatchCommand(type, payload) {\n    return dispatchCommand(this, type, payload);\n  }\n\n  /**\n   * Gets a map of all decorators in the editor.\n   * @returns A mapping of call decorator keys to their decorated content\n   */\n  getDecorators() {\n    return this._decorators;\n  }\n\n  /**\n   *\n   * @returns the current root element of the editor. If you want to register\n   * an event listener, do it via {@link LexicalEditor.registerRootListener}, since\n   * this reference may not be stable.\n   */\n  getRootElement() {\n    return this._rootElement;\n  }\n\n  /**\n   * Gets the key of the editor\n   * @returns The editor key\n   */\n  getKey() {\n    return this._key;\n  }\n\n  /**\n   * Imperatively set the root contenteditable element that Lexical listens\n   * for events on.\n   */\n  setRootElement(nextRootElement) {\n    const prevRootElement = this._rootElement;\n    if (nextRootElement !== prevRootElement) {\n      const classNames = getCachedClassNameArray(this._config.theme, 'root');\n      const pendingEditorState = this._pendingEditorState || this._editorState;\n      this._rootElement = nextRootElement;\n      resetEditor(this, prevRootElement, nextRootElement, pendingEditorState);\n      if (prevRootElement !== null) {\n        // TODO: remove this flag once we no longer use UEv2 internally\n        if (!this._config.disableEvents) {\n          removeRootElementEvents(prevRootElement);\n        }\n        if (classNames != null) {\n          prevRootElement.classList.remove(...classNames);\n        }\n      }\n      if (nextRootElement !== null) {\n        const windowObj = getDefaultView(nextRootElement);\n        const style = nextRootElement.style;\n        style.userSelect = 'text';\n        style.whiteSpace = 'pre-wrap';\n        style.wordBreak = 'break-word';\n        nextRootElement.setAttribute('data-lexical-editor', 'true');\n        this._window = windowObj;\n        this._dirtyType = FULL_RECONCILE;\n        initMutationObserver(this);\n        this._updateTags.add('history-merge');\n        $commitPendingUpdates(this);\n\n        // TODO: remove this flag once we no longer use UEv2 internally\n        if (!this._config.disableEvents) {\n          addRootElementEvents(nextRootElement, this);\n        }\n        if (classNames != null) {\n          nextRootElement.classList.add(...classNames);\n        }\n        {\n          const nextRootElementParent = nextRootElement.parentElement;\n          if (nextRootElementParent != null && ['flex', 'inline-flex'].includes(getComputedStyle(nextRootElementParent).display)) {\n            console.warn(`When using \"display: flex\" or \"display: inline-flex\" on an element containing content editable, Chrome may have unwanted focusing behavior when clicking outside of it. Consider wrapping the content editable within a non-flex element.`);\n          }\n        }\n      } else {\n        // When the content editable is unmounted we will still trigger a\n        // reconciliation so that any pending updates are flushed,\n        // to match the previous state change when\n        // `_editorState = pendingEditorState` was used, but by\n        // using a commit we preserve the readOnly invariant\n        // for editor.getEditorState().\n        this._window = null;\n        this._updateTags.add('history-merge');\n        $commitPendingUpdates(this);\n      }\n      triggerListeners('root', this, false, nextRootElement, prevRootElement);\n    }\n  }\n\n  /**\n   * Gets the underlying HTMLElement associated with the LexicalNode for the given key.\n   * @returns the HTMLElement rendered by the LexicalNode associated with the key.\n   * @param key - the key of the LexicalNode.\n   */\n  getElementByKey(key) {\n    return this._keyToDOMMap.get(key) || null;\n  }\n\n  /**\n   * Gets the active editor state.\n   * @returns The editor state\n   */\n  getEditorState() {\n    return this._editorState;\n  }\n\n  /**\n   * Imperatively set the EditorState. Triggers reconciliation like an update.\n   * @param editorState - the state to set the editor\n   * @param options - options for the update.\n   */\n  setEditorState(editorState, options) {\n    if (editorState.isEmpty()) {\n      {\n        throw Error(`setEditorState: the editor state is empty. Ensure the editor state's root node never becomes empty.`);\n      }\n    }\n\n    // Ensure that we have a writable EditorState so that transforms can run\n    // during a historic operation\n    let writableEditorState = editorState;\n    if (writableEditorState._readOnly) {\n      writableEditorState = cloneEditorState(editorState);\n      writableEditorState._selection = editorState._selection ? editorState._selection.clone() : null;\n    }\n    $flushRootMutations(this);\n    const pendingEditorState = this._pendingEditorState;\n    const tags = this._updateTags;\n    const tag = options !== undefined ? options.tag : null;\n    if (pendingEditorState !== null && !pendingEditorState.isEmpty()) {\n      if (tag != null) {\n        tags.add(tag);\n      }\n      $commitPendingUpdates(this);\n    }\n    this._pendingEditorState = writableEditorState;\n    this._dirtyType = FULL_RECONCILE;\n    this._dirtyElements.set('root', false);\n    this._compositionKey = null;\n    if (tag != null) {\n      tags.add(tag);\n    }\n\n    // Only commit pending updates if not already in an editor.update\n    // (e.g. dispatchCommand) otherwise this will cause a second commit\n    // with an already read-only state and selection\n    if (!this._updating) {\n      $commitPendingUpdates(this);\n    }\n  }\n\n  /**\n   * Parses a SerializedEditorState (usually produced by {@link EditorState.toJSON}) and returns\n   * and EditorState object that can be, for example, passed to {@link LexicalEditor.setEditorState}. Typically,\n   * deserialization from JSON stored in a database uses this method.\n   * @param maybeStringifiedEditorState\n   * @param updateFn\n   * @returns\n   */\n  parseEditorState(maybeStringifiedEditorState, updateFn) {\n    const serializedEditorState = typeof maybeStringifiedEditorState === 'string' ? JSON.parse(maybeStringifiedEditorState) : maybeStringifiedEditorState;\n    return parseEditorState(serializedEditorState, this, updateFn);\n  }\n\n  /**\n   * Executes a read of the editor's state, with the\n   * editor context available (useful for exporting and read-only DOM\n   * operations). Much like update, but prevents any mutation of the\n   * editor's state. Any pending updates will be flushed immediately before\n   * the read.\n   * @param callbackFn - A function that has access to read-only editor state.\n   */\n  read(callbackFn) {\n    $commitPendingUpdates(this);\n    return this.getEditorState().read(callbackFn, {\n      editor: this\n    });\n  }\n\n  /**\n   * Executes an update to the editor state. The updateFn callback is the ONLY place\n   * where Lexical editor state can be safely mutated.\n   * @param updateFn - A function that has access to writable editor state.\n   * @param options - A bag of options to control the behavior of the update.\n   * @param options.onUpdate - A function to run once the update is complete.\n   * Useful for synchronizing updates in some cases.\n   * @param options.skipTransforms - Setting this to true will suppress all node\n   * transforms for this update cycle.\n   * @param options.tag - A tag to identify this update, in an update listener, for instance.\n   * Some tags are reserved by the core and control update behavior in different ways.\n   * @param options.discrete - If true, prevents this update from being batched, forcing it to\n   * run synchronously.\n   */\n  update(updateFn, options) {\n    updateEditor(this, updateFn, options);\n  }\n\n  /**\n   * Focuses the editor\n   * @param callbackFn - A function to run after the editor is focused.\n   * @param options - A bag of options\n   * @param options.defaultSelection - Where to move selection when the editor is\n   * focused. Can be rootStart, rootEnd, or undefined. Defaults to rootEnd.\n   */\n  focus(callbackFn, options = {}) {\n    const rootElement = this._rootElement;\n    if (rootElement !== null) {\n      // This ensures that iOS does not trigger caps lock upon focus\n      rootElement.setAttribute('autocapitalize', 'off');\n      updateEditor(this, () => {\n        const selection = $getSelection();\n        const root = $getRoot();\n        if (selection !== null) {\n          // Marking the selection dirty will force the selection back to it\n          selection.dirty = true;\n        } else if (root.getChildrenSize() !== 0) {\n          if (options.defaultSelection === 'rootStart') {\n            root.selectStart();\n          } else {\n            root.selectEnd();\n          }\n        }\n      }, {\n        onUpdate: () => {\n          rootElement.removeAttribute('autocapitalize');\n          if (callbackFn) {\n            callbackFn();\n          }\n        },\n        tag: 'focus'\n      });\n      // In the case where onUpdate doesn't fire (due to the focus update not\n      // occuring).\n      if (this._pendingEditorState === null) {\n        rootElement.removeAttribute('autocapitalize');\n      }\n    }\n  }\n\n  /**\n   * Removes focus from the editor.\n   */\n  blur() {\n    const rootElement = this._rootElement;\n    if (rootElement !== null) {\n      rootElement.blur();\n    }\n    const domSelection = getDOMSelection(this._window);\n    if (domSelection !== null) {\n      domSelection.removeAllRanges();\n    }\n  }\n  /**\n   * Returns true if the editor is editable, false otherwise.\n   * @returns True if the editor is editable, false otherwise.\n   */\n  isEditable() {\n    return this._editable;\n  }\n  /**\n   * Sets the editable property of the editor. When false, the\n   * editor will not listen for user events on the underling contenteditable.\n   * @param editable - the value to set the editable mode to.\n   */\n  setEditable(editable) {\n    if (this._editable !== editable) {\n      this._editable = editable;\n      triggerListeners('editable', this, true, editable);\n    }\n  }\n  /**\n   * Returns a JSON-serializable javascript object NOT a JSON string.\n   * You still must call JSON.stringify (or something else) to turn the\n   * state into a string you can transfer over the wire and store in a database.\n   *\n   * See {@link LexicalNode.exportJSON}\n   *\n   * @returns A JSON-serializable javascript object\n   */\n  toJSON() {\n    return {\n      editorState: this._editorState.toJSON()\n    };\n  }\n}\nLexicalEditor.version = \"0.23.1+dev.esm\";\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sZXhpY2FsL0xleGljYWwuZGV2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw2QkFBNkI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsc0JBQXNCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsdUJBQXVCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1QkFBdUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFVBQVU7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELHVCQUF1Qiw0RUFBNEUsOEJBQThCO0FBQ3RMO0FBQ0EsTUFBTTtBQUNOO0FBQ0EscURBQXFELHVCQUF1QjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsWUFBWTtBQUMzQztBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsWUFBWTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFVBQVU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsOENBQThDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxJQUFJO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1QkFBdUIsWUFBWSxVQUFVO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvR0FBb0csdUJBQXVCLFlBQVksNEJBQTRCLGVBQWUsMkJBQTJCLFlBQVksZ0NBQWdDLHFCQUFxQix1QkFBdUIsWUFBWSxTQUFTO0FBQzFUO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsNkVBQTZFLDJCQUEyQixZQUFZLGdDQUFnQyxxQ0FBcUMsdUJBQXVCLFlBQVksU0FBUztBQUNyTztBQUNBO0FBQ0E7QUFDQSxrSUFBa0ksdUJBQXVCLFlBQVksVUFBVSxVQUFVLDJCQUEyQixZQUFZLCtCQUErQjtBQUMvUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLEtBQUs7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLCtCQUErQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxpQkFBaUIsMkJBQTJCLHNCQUFzQjtBQUM3RztBQUNBO0FBQ0EsMkNBQTJDLGlCQUFpQiwyQkFBMkIsc0JBQXNCO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsd0JBQXdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLFFBQVEsSUFBSSxxQkFBcUI7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsd0JBQXdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLHlCQUF5QixrQkFBa0IsVUFBVSxZQUFZLGNBQWMsT0FBTyx3QkFBd0IsT0FBTyxtQkFBbUIsY0FBYyxPQUFPLGdCQUFnQixTQUFTLG1CQUFtQjtBQUN6TTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsSUFBSTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDhCQUE4QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDBCQUEwQjtBQUM1QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxXQUFXO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxXQUFXO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDRCQUE0QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx1QkFBdUI7QUFDOUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOENBQThDLDhCQUE4QjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxZQUFZO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsWUFBWTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBLE1BQU0sNEJBQTRCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsMkNBQTJDO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsV0FBVztBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDJDQUEyQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJFQUEyRSx3QkFBd0I7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxZQUFZO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsTUFBTSxVQUFVLFlBQVksaUNBQWlDLGtCQUFrQjtBQUN0SDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxRQUFRO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQix5QkFBeUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDRCQUE0QixVQUFVLHFCQUFxQjtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyw0QkFBNEIsVUFBVSxxQkFBcUI7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDRCQUE0QixVQUFVLHFCQUFxQjtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0Y7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE1BQU0sTUFBTSxXQUFXO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxNQUFNLE1BQU0sV0FBVztBQUM1RDtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsTUFBTSw0Q0FBNEMsc0JBQXNCLElBQUksYUFBYTtBQUM5SDtBQUNBLElBQUk7QUFDSjtBQUNBLHFDQUFxQyxNQUFNLE1BQU0sV0FBVztBQUM1RDtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsTUFBTSx5Q0FBeUMsc0JBQXNCLElBQUksYUFBYTtBQUMzSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNNQUFzTSwwQkFBMEI7QUFDaE87QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5SkFBeUosMEJBQTBCO0FBQ25MO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsbUJBQW1CLG9DQUFvQyxZQUFZO0FBQzVHO0FBQ0EseURBQXlELDJDQUEyQztBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IseUJBQXlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxLQUFLO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsZ0JBQWdCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQixvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIscUJBQXFCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscUJBQXFCO0FBQzNDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsd0JBQXdCLHVCQUF1QjtBQUN0RztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGVBQWU7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxnQ0FBZ0M7QUFDekM7QUFDQSw2Q0FBNkMsa0JBQWtCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxZQUFZO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFlBQVk7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsZUFBZSxJQUFJLHFCQUFxQixJQUFJLGdCQUFnQjtBQUNwSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFlBQVk7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGFBQWE7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsZ0JBQWdCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxnQkFBZ0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsdUJBQXVCLHFCQUFxQixLQUFLO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLE1BQU0seUJBQXlCLE9BQU87QUFDcEU7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixNQUFNO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHdCQUF3QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE1BQU07QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELDJCQUEyQjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDZCQUE2QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsNEJBQTRCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtCQUErQjtBQUMzQyxVQUFVLDRCQUE0QjtBQUN0QyxVQUFVLCtCQUErQjtBQUN6QyxVQUFVLDZCQUE2QjtBQUN2QyxVQUFVLGdDQUFnQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsaUJBQWlCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxxQ0FBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixZQUFZO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrREFBa0Qsb0NBQW9DO0FBQ3RGO0FBQ0EsdUNBQXVDLDJCQUEyQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx5Q0FBeUM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwREFBMEQseUJBQXlCO0FBQ25GLGlFQUFpRSxtQ0FBbUM7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU4b0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9sZWkvaG9tZS91bmRlcmcvdGhlYXRyZS95My9zZWdwL21pbGt1cC9ub2RlX21vZHVsZXMvbGV4aWNhbC9MZXhpY2FsLmRldi5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1hbmQodHlwZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGVcbiAgfSA7XG59XG5jb25zdCBTRUxFQ1RJT05fQ0hBTkdFX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdTRUxFQ1RJT05fQ0hBTkdFX0NPTU1BTkQnKTtcbmNvbnN0IFNFTEVDVElPTl9JTlNFUlRfQ0xJUEJPQVJEX05PREVTX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdTRUxFQ1RJT05fSU5TRVJUX0NMSVBCT0FSRF9OT0RFU19DT01NQU5EJyk7XG5jb25zdCBDTElDS19DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnQ0xJQ0tfQ09NTUFORCcpO1xuY29uc3QgREVMRVRFX0NIQVJBQ1RFUl9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnREVMRVRFX0NIQVJBQ1RFUl9DT01NQU5EJyk7XG5jb25zdCBJTlNFUlRfTElORV9CUkVBS19DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnSU5TRVJUX0xJTkVfQlJFQUtfQ09NTUFORCcpO1xuY29uc3QgSU5TRVJUX1BBUkFHUkFQSF9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnSU5TRVJUX1BBUkFHUkFQSF9DT01NQU5EJyk7XG5jb25zdCBDT05UUk9MTEVEX1RFWFRfSU5TRVJUSU9OX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdDT05UUk9MTEVEX1RFWFRfSU5TRVJUSU9OX0NPTU1BTkQnKTtcbmNvbnN0IFBBU1RFX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdQQVNURV9DT01NQU5EJyk7XG5jb25zdCBSRU1PVkVfVEVYVF9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnUkVNT1ZFX1RFWFRfQ09NTUFORCcpO1xuY29uc3QgREVMRVRFX1dPUkRfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0RFTEVURV9XT1JEX0NPTU1BTkQnKTtcbmNvbnN0IERFTEVURV9MSU5FX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdERUxFVEVfTElORV9DT01NQU5EJyk7XG5jb25zdCBGT1JNQVRfVEVYVF9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnRk9STUFUX1RFWFRfQ09NTUFORCcpO1xuY29uc3QgVU5ET19DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnVU5ET19DT01NQU5EJyk7XG5jb25zdCBSRURPX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdSRURPX0NPTU1BTkQnKTtcbmNvbnN0IEtFWV9ET1dOX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdLRVlET1dOX0NPTU1BTkQnKTtcbmNvbnN0IEtFWV9BUlJPV19SSUdIVF9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnS0VZX0FSUk9XX1JJR0hUX0NPTU1BTkQnKTtcbmNvbnN0IE1PVkVfVE9fRU5EID0gY3JlYXRlQ29tbWFuZCgnTU9WRV9UT19FTkQnKTtcbmNvbnN0IEtFWV9BUlJPV19MRUZUX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdLRVlfQVJST1dfTEVGVF9DT01NQU5EJyk7XG5jb25zdCBNT1ZFX1RPX1NUQVJUID0gY3JlYXRlQ29tbWFuZCgnTU9WRV9UT19TVEFSVCcpO1xuY29uc3QgS0VZX0FSUk9XX1VQX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdLRVlfQVJST1dfVVBfQ09NTUFORCcpO1xuY29uc3QgS0VZX0FSUk9XX0RPV05fQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0tFWV9BUlJPV19ET1dOX0NPTU1BTkQnKTtcbmNvbnN0IEtFWV9FTlRFUl9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnS0VZX0VOVEVSX0NPTU1BTkQnKTtcbmNvbnN0IEtFWV9TUEFDRV9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnS0VZX1NQQUNFX0NPTU1BTkQnKTtcbmNvbnN0IEtFWV9CQUNLU1BBQ0VfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0tFWV9CQUNLU1BBQ0VfQ09NTUFORCcpO1xuY29uc3QgS0VZX0VTQ0FQRV9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnS0VZX0VTQ0FQRV9DT01NQU5EJyk7XG5jb25zdCBLRVlfREVMRVRFX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdLRVlfREVMRVRFX0NPTU1BTkQnKTtcbmNvbnN0IEtFWV9UQUJfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0tFWV9UQUJfQ09NTUFORCcpO1xuY29uc3QgSU5TRVJUX1RBQl9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnSU5TRVJUX1RBQl9DT01NQU5EJyk7XG5jb25zdCBJTkRFTlRfQ09OVEVOVF9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnSU5ERU5UX0NPTlRFTlRfQ09NTUFORCcpO1xuY29uc3QgT1VUREVOVF9DT05URU5UX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdPVVRERU5UX0NPTlRFTlRfQ09NTUFORCcpO1xuY29uc3QgRFJPUF9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnRFJPUF9DT01NQU5EJyk7XG5jb25zdCBGT1JNQVRfRUxFTUVOVF9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnRk9STUFUX0VMRU1FTlRfQ09NTUFORCcpO1xuY29uc3QgRFJBR1NUQVJUX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdEUkFHU1RBUlRfQ09NTUFORCcpO1xuY29uc3QgRFJBR09WRVJfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0RSQUdPVkVSX0NPTU1BTkQnKTtcbmNvbnN0IERSQUdFTkRfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0RSQUdFTkRfQ09NTUFORCcpO1xuY29uc3QgQ09QWV9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnQ09QWV9DT01NQU5EJyk7XG5jb25zdCBDVVRfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0NVVF9DT01NQU5EJyk7XG5jb25zdCBTRUxFQ1RfQUxMX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdTRUxFQ1RfQUxMX0NPTU1BTkQnKTtcbmNvbnN0IENMRUFSX0VESVRPUl9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnQ0xFQVJfRURJVE9SX0NPTU1BTkQnKTtcbmNvbnN0IENMRUFSX0hJU1RPUllfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0NMRUFSX0hJU1RPUllfQ09NTUFORCcpO1xuY29uc3QgQ0FOX1JFRE9fQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0NBTl9SRURPX0NPTU1BTkQnKTtcbmNvbnN0IENBTl9VTkRPX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdDQU5fVU5ET19DT01NQU5EJyk7XG5jb25zdCBGT0NVU19DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnRk9DVVNfQ09NTUFORCcpO1xuY29uc3QgQkxVUl9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnQkxVUl9DT01NQU5EJyk7XG5jb25zdCBLRVlfTU9ESUZJRVJfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0tFWV9NT0RJRklFUl9DT01NQU5EJyk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuY29uc3QgQ0FOX1VTRV9ET00gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT09ICd1bmRlZmluZWQnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IGRvY3VtZW50TW9kZSA9IENBTl9VU0VfRE9NICYmICdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50ID8gZG9jdW1lbnQuZG9jdW1lbnRNb2RlIDogbnVsbDtcbmNvbnN0IElTX0FQUExFID0gQ0FOX1VTRV9ET00gJiYgL01hY3xpUG9kfGlQaG9uZXxpUGFkLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSk7XG5jb25zdCBJU19GSVJFRk9YID0gQ0FOX1VTRV9ET00gJiYgL14oPyEuKlNlYW1vbmtleSkoPz0uKkZpcmVmb3gpLiovaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuY29uc3QgQ0FOX1VTRV9CRUZPUkVfSU5QVVQgPSBDQU5fVVNFX0RPTSAmJiAnSW5wdXRFdmVudCcgaW4gd2luZG93ICYmICFkb2N1bWVudE1vZGUgPyAnZ2V0VGFyZ2V0UmFuZ2VzJyBpbiBuZXcgd2luZG93LklucHV0RXZlbnQoJ2lucHV0JykgOiBmYWxzZTtcbmNvbnN0IElTX1NBRkFSSSA9IENBTl9VU0VfRE9NICYmIC9WZXJzaW9uXFwvW1xcZC5dKy4qU2FmYXJpLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuY29uc3QgSVNfSU9TID0gQ0FOX1VTRV9ET00gJiYgL2lQYWR8aVBob25lfGlQb2QvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgIXdpbmRvdy5NU1N0cmVhbTtcbmNvbnN0IElTX0FORFJPSUQgPSBDQU5fVVNFX0RPTSAmJiAvQW5kcm9pZC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuLy8gS2VlcCB0aGVzZSBpbiBjYXNlIHdlIG5lZWQgdG8gdXNlIHRoZW0gaW4gdGhlIGZ1dHVyZS5cbi8vIGV4cG9ydCBjb25zdCBJU19XSU5ET1dTOiBib29sZWFuID0gQ0FOX1VTRV9ET00gJiYgL1dpbi8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pO1xuY29uc3QgSVNfQ0hST01FID0gQ0FOX1VTRV9ET00gJiYgL14oPz0uKkNocm9tZSkuKi9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4vLyBleHBvcnQgY29uc3QgY2FuVXNlVGV4dElucHV0RXZlbnQ6IGJvb2xlYW4gPSBDQU5fVVNFX0RPTSAmJiAnVGV4dEV2ZW50JyBpbiB3aW5kb3cgJiYgIWRvY3VtZW50TW9kZTtcblxuY29uc3QgSVNfQU5EUk9JRF9DSFJPTUUgPSBDQU5fVVNFX0RPTSAmJiBJU19BTkRST0lEICYmIElTX0NIUk9NRTtcbmNvbnN0IElTX0FQUExFX1dFQktJVCA9IENBTl9VU0VfRE9NICYmIC9BcHBsZVdlYktpdFxcL1tcXGQuXSsvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgIUlTX0NIUk9NRTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5cbi8vIERPTVxuY29uc3QgRE9NX0VMRU1FTlRfVFlQRSA9IDE7XG5jb25zdCBET01fVEVYVF9UWVBFID0gMztcbmNvbnN0IERPTV9ET0NVTUVOVF9UWVBFID0gOTtcbmNvbnN0IERPTV9ET0NVTUVOVF9GUkFHTUVOVF9UWVBFID0gMTE7XG5cbi8vIFJlY29uY2lsaW5nXG5jb25zdCBOT19ESVJUWV9OT0RFUyA9IDA7XG5jb25zdCBIQVNfRElSVFlfTk9ERVMgPSAxO1xuY29uc3QgRlVMTF9SRUNPTkNJTEUgPSAyO1xuXG4vLyBUZXh0IG5vZGUgbW9kZXNcbmNvbnN0IElTX05PUk1BTCA9IDA7XG5jb25zdCBJU19UT0tFTiA9IDE7XG5jb25zdCBJU19TRUdNRU5URUQgPSAyO1xuLy8gSVNfSU5FUlQgPSAzXG5cbi8vIFRleHQgbm9kZSBmb3JtYXR0aW5nXG5jb25zdCBJU19CT0xEID0gMTtcbmNvbnN0IElTX0lUQUxJQyA9IDEgPDwgMTtcbmNvbnN0IElTX1NUUklLRVRIUk9VR0ggPSAxIDw8IDI7XG5jb25zdCBJU19VTkRFUkxJTkUgPSAxIDw8IDM7XG5jb25zdCBJU19DT0RFID0gMSA8PCA0O1xuY29uc3QgSVNfU1VCU0NSSVBUID0gMSA8PCA1O1xuY29uc3QgSVNfU1VQRVJTQ1JJUFQgPSAxIDw8IDY7XG5jb25zdCBJU19ISUdITElHSFQgPSAxIDw8IDc7XG5jb25zdCBJU19MT1dFUkNBU0UgPSAxIDw8IDg7XG5jb25zdCBJU19VUFBFUkNBU0UgPSAxIDw8IDk7XG5jb25zdCBJU19DQVBJVEFMSVpFID0gMSA8PCAxMDtcbmNvbnN0IElTX0FMTF9GT1JNQVRUSU5HID0gSVNfQk9MRCB8IElTX0lUQUxJQyB8IElTX1NUUklLRVRIUk9VR0ggfCBJU19VTkRFUkxJTkUgfCBJU19DT0RFIHwgSVNfU1VCU0NSSVBUIHwgSVNfU1VQRVJTQ1JJUFQgfCBJU19ISUdITElHSFQgfCBJU19MT1dFUkNBU0UgfCBJU19VUFBFUkNBU0UgfCBJU19DQVBJVEFMSVpFO1xuXG4vLyBUZXh0IG5vZGUgZGV0YWlsc1xuY29uc3QgSVNfRElSRUNUSU9OTEVTUyA9IDE7XG5jb25zdCBJU19VTk1FUkdFQUJMRSA9IDEgPDwgMTtcblxuLy8gRWxlbWVudCBub2RlIGZvcm1hdHRpbmdcbmNvbnN0IElTX0FMSUdOX0xFRlQgPSAxO1xuY29uc3QgSVNfQUxJR05fQ0VOVEVSID0gMjtcbmNvbnN0IElTX0FMSUdOX1JJR0hUID0gMztcbmNvbnN0IElTX0FMSUdOX0pVU1RJRlkgPSA0O1xuY29uc3QgSVNfQUxJR05fU1RBUlQgPSA1O1xuY29uc3QgSVNfQUxJR05fRU5EID0gNjtcblxuLy8gUmVjb25jaWxpYXRpb25cbmNvbnN0IE5PTl9CUkVBS0lOR19TUEFDRSA9ICdcXHUwMEEwJztcbmNvbnN0IFpFUk9fV0lEVEhfU1BBQ0UgPSAnXFx1MjAwYic7XG5cbi8vIEZvciBpT1MvU2FmYXJpIHdlIHVzZSBhIG5vbiBicmVha2luZyBzcGFjZSwgb3RoZXJ3aXNlIHRoZSBjdXJzb3IgYXBwZWFyc1xuLy8gb3ZlcmxhcHBpbmcgdGhlIGNvbXBvc2VkIHRleHQuXG5jb25zdCBDT01QT1NJVElPTl9TVUZGSVggPSBJU19TQUZBUkkgfHwgSVNfSU9TIHx8IElTX0FQUExFX1dFQktJVCA/IE5PTl9CUkVBS0lOR19TUEFDRSA6IFpFUk9fV0lEVEhfU1BBQ0U7XG5jb25zdCBET1VCTEVfTElORV9CUkVBSyA9ICdcXG5cXG4nO1xuXG4vLyBGb3IgRkYsIHdlIG5lZWQgdG8gdXNlIGEgbm9uLWJyZWFraW5nIHNwYWNlLCBvciBpdCBnZXRzIGNvbXBvc2l0aW9uXG4vLyBpbiBhIHN0dWNrIHN0YXRlLlxuY29uc3QgQ09NUE9TSVRJT05fU1RBUlRfQ0hBUiA9IElTX0ZJUkVGT1ggPyBOT05fQlJFQUtJTkdfU1BBQ0UgOiBDT01QT1NJVElPTl9TVUZGSVg7XG5jb25zdCBSVEwgPSAnXFx1MDU5MS1cXHUwN0ZGXFx1RkIxRC1cXHVGREZEXFx1RkU3MC1cXHVGRUZDJztcbmNvbnN0IExUUiA9ICdBLVphLXpcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjYnICsgJ1xcdTAwRjgtXFx1MDJCOFxcdTAzMDAtXFx1MDU5MFxcdTA4MDAtXFx1MUZGRlxcdTIwMEVcXHUyQzAwLVxcdUZCMUMnICsgJ1xcdUZFMDAtXFx1RkU2RlxcdUZFRkQtXFx1RkZGRic7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1taXNsZWFkaW5nLWNoYXJhY3Rlci1jbGFzc1xuY29uc3QgUlRMX1JFR0VYID0gbmV3IFJlZ0V4cCgnXlteJyArIExUUiArICddKlsnICsgUlRMICsgJ10nKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1taXNsZWFkaW5nLWNoYXJhY3Rlci1jbGFzc1xuY29uc3QgTFRSX1JFR0VYID0gbmV3IFJlZ0V4cCgnXlteJyArIFJUTCArICddKlsnICsgTFRSICsgJ10nKTtcbmNvbnN0IFRFWFRfVFlQRV9UT19GT1JNQVQgPSB7XG4gIGJvbGQ6IElTX0JPTEQsXG4gIGNhcGl0YWxpemU6IElTX0NBUElUQUxJWkUsXG4gIGNvZGU6IElTX0NPREUsXG4gIGhpZ2hsaWdodDogSVNfSElHSExJR0hULFxuICBpdGFsaWM6IElTX0lUQUxJQyxcbiAgbG93ZXJjYXNlOiBJU19MT1dFUkNBU0UsXG4gIHN0cmlrZXRocm91Z2g6IElTX1NUUklLRVRIUk9VR0gsXG4gIHN1YnNjcmlwdDogSVNfU1VCU0NSSVBULFxuICBzdXBlcnNjcmlwdDogSVNfU1VQRVJTQ1JJUFQsXG4gIHVuZGVybGluZTogSVNfVU5ERVJMSU5FLFxuICB1cHBlcmNhc2U6IElTX1VQUEVSQ0FTRVxufTtcbmNvbnN0IERFVEFJTF9UWVBFX1RPX0RFVEFJTCA9IHtcbiAgZGlyZWN0aW9ubGVzczogSVNfRElSRUNUSU9OTEVTUyxcbiAgdW5tZXJnZWFibGU6IElTX1VOTUVSR0VBQkxFXG59O1xuY29uc3QgRUxFTUVOVF9UWVBFX1RPX0ZPUk1BVCA9IHtcbiAgY2VudGVyOiBJU19BTElHTl9DRU5URVIsXG4gIGVuZDogSVNfQUxJR05fRU5ELFxuICBqdXN0aWZ5OiBJU19BTElHTl9KVVNUSUZZLFxuICBsZWZ0OiBJU19BTElHTl9MRUZULFxuICByaWdodDogSVNfQUxJR05fUklHSFQsXG4gIHN0YXJ0OiBJU19BTElHTl9TVEFSVFxufTtcbmNvbnN0IEVMRU1FTlRfRk9STUFUX1RPX1RZUEUgPSB7XG4gIFtJU19BTElHTl9DRU5URVJdOiAnY2VudGVyJyxcbiAgW0lTX0FMSUdOX0VORF06ICdlbmQnLFxuICBbSVNfQUxJR05fSlVTVElGWV06ICdqdXN0aWZ5JyxcbiAgW0lTX0FMSUdOX0xFRlRdOiAnbGVmdCcsXG4gIFtJU19BTElHTl9SSUdIVF06ICdyaWdodCcsXG4gIFtJU19BTElHTl9TVEFSVF06ICdzdGFydCdcbn07XG5jb25zdCBURVhUX01PREVfVE9fVFlQRSA9IHtcbiAgbm9ybWFsOiBJU19OT1JNQUwsXG4gIHNlZ21lbnRlZDogSVNfU0VHTUVOVEVELFxuICB0b2tlbjogSVNfVE9LRU5cbn07XG5jb25zdCBURVhUX1RZUEVfVE9fTU9ERSA9IHtcbiAgW0lTX05PUk1BTF06ICdub3JtYWwnLFxuICBbSVNfU0VHTUVOVEVEXTogJ3NlZ21lbnRlZCcsXG4gIFtJU19UT0tFTl06ICd0b2tlbidcbn07XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gbm9ybWFsaXplQ2xhc3NOYW1lcyguLi5jbGFzc05hbWVzKSB7XG4gIGNvbnN0IHJ2YWwgPSBbXTtcbiAgZm9yIChjb25zdCBjbGFzc05hbWUgb2YgY2xhc3NOYW1lcykge1xuICAgIGlmIChjbGFzc05hbWUgJiYgdHlwZW9mIGNsYXNzTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGZvciAoY29uc3QgW3NdIG9mIGNsYXNzTmFtZS5tYXRjaEFsbCgvXFxTKy9nKSkge1xuICAgICAgICBydmFsLnB1c2gocyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBydmFsO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8vIFRoZSB0aW1lIGJldHdlZW4gYSB0ZXh0IGVudHJ5IGV2ZW50IGFuZCB0aGUgbXV0YXRpb24gb2JzZXJ2ZXIgZmlyaW5nLlxuY29uc3QgVEVYVF9NVVRBVElPTl9WQVJJQU5DRSA9IDEwMDtcbmxldCBpc1Byb2Nlc3NpbmdNdXRhdGlvbnMgPSBmYWxzZTtcbmxldCBsYXN0VGV4dEVudHJ5VGltZVN0YW1wID0gMDtcbmZ1bmN0aW9uIGdldElzUHJvY2Vzc2luZ011dGF0aW9ucygpIHtcbiAgcmV0dXJuIGlzUHJvY2Vzc2luZ011dGF0aW9ucztcbn1cbmZ1bmN0aW9uIHVwZGF0ZVRpbWVTdGFtcChldmVudCkge1xuICBsYXN0VGV4dEVudHJ5VGltZVN0YW1wID0gZXZlbnQudGltZVN0YW1wO1xufVxuZnVuY3Rpb24gaW5pdFRleHRFbnRyeUxpc3RlbmVyKGVkaXRvcikge1xuICBpZiAobGFzdFRleHRFbnRyeVRpbWVTdGFtcCA9PT0gMCkge1xuICAgIGdldFdpbmRvdyhlZGl0b3IpLmFkZEV2ZW50TGlzdGVuZXIoJ3RleHRJbnB1dCcsIHVwZGF0ZVRpbWVTdGFtcCwgdHJ1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzTWFuYWdlZExpbmVCcmVhayhkb20sIHRhcmdldCwgZWRpdG9yKSB7XG4gIGNvbnN0IGlzQlIgPSBkb20ubm9kZU5hbWUgPT09ICdCUic7XG4gIGNvbnN0IGxleGljYWxMaW5lQnJlYWsgPSB0YXJnZXQuX19sZXhpY2FsTGluZUJyZWFrO1xuICByZXR1cm4gbGV4aWNhbExpbmVCcmVhayAmJiAoZG9tID09PSBsZXhpY2FsTGluZUJyZWFrIHx8IGlzQlIgJiYgZG9tLnByZXZpb3VzU2libGluZyA9PT0gbGV4aWNhbExpbmVCcmVhaykgfHwgaXNCUiAmJiBnZXROb2RlS2V5RnJvbURPTU5vZGUoZG9tLCBlZGl0b3IpICE9PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBnZXRMYXN0U2VsZWN0aW9uKGVkaXRvcikge1xuICByZXR1cm4gZWRpdG9yLmdldEVkaXRvclN0YXRlKCkucmVhZCgoKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIHJldHVybiBzZWxlY3Rpb24gIT09IG51bGwgPyBzZWxlY3Rpb24uY2xvbmUoKSA6IG51bGw7XG4gIH0pO1xufVxuZnVuY3Rpb24gJGhhbmRsZVRleHRNdXRhdGlvbih0YXJnZXQsIG5vZGUsIGVkaXRvcikge1xuICBjb25zdCBkb21TZWxlY3Rpb24gPSBnZXRET01TZWxlY3Rpb24oZWRpdG9yLl93aW5kb3cpO1xuICBsZXQgYW5jaG9yT2Zmc2V0ID0gbnVsbDtcbiAgbGV0IGZvY3VzT2Zmc2V0ID0gbnVsbDtcbiAgaWYgKGRvbVNlbGVjdGlvbiAhPT0gbnVsbCAmJiBkb21TZWxlY3Rpb24uYW5jaG9yTm9kZSA9PT0gdGFyZ2V0KSB7XG4gICAgYW5jaG9yT2Zmc2V0ID0gZG9tU2VsZWN0aW9uLmFuY2hvck9mZnNldDtcbiAgICBmb2N1c09mZnNldCA9IGRvbVNlbGVjdGlvbi5mb2N1c09mZnNldDtcbiAgfVxuICBjb25zdCB0ZXh0ID0gdGFyZ2V0Lm5vZGVWYWx1ZTtcbiAgaWYgKHRleHQgIT09IG51bGwpIHtcbiAgICAkdXBkYXRlVGV4dE5vZGVGcm9tRE9NQ29udGVudChub2RlLCB0ZXh0LCBhbmNob3JPZmZzZXQsIGZvY3VzT2Zmc2V0LCBmYWxzZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNob3VsZFVwZGF0ZVRleHROb2RlRnJvbU11dGF0aW9uKHNlbGVjdGlvbiwgdGFyZ2V0RE9NLCB0YXJnZXROb2RlKSB7XG4gIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgY29uc3QgYW5jaG9yTm9kZSA9IHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpO1xuICAgIGlmIChhbmNob3JOb2RlLmlzKHRhcmdldE5vZGUpICYmIHNlbGVjdGlvbi5mb3JtYXQgIT09IGFuY2hvck5vZGUuZ2V0Rm9ybWF0KCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGlzRE9NVGV4dE5vZGUodGFyZ2V0RE9NKSAmJiB0YXJnZXROb2RlLmlzQXR0YWNoZWQoKTtcbn1cbmZ1bmN0aW9uICRnZXROZWFyZXN0TWFuYWdlZE5vZGVQYWlyRnJvbURPTU5vZGUoc3RhcnRpbmdET00sIGVkaXRvciwgZWRpdG9yU3RhdGUsIHJvb3RFbGVtZW50KSB7XG4gIGZvciAobGV0IGRvbSA9IHN0YXJ0aW5nRE9NOyBkb20gJiYgIWlzRE9NVW5tYW5hZ2VkKGRvbSk7IGRvbSA9IGdldFBhcmVudEVsZW1lbnQoZG9tKSkge1xuICAgIGNvbnN0IGtleSA9IGdldE5vZGVLZXlGcm9tRE9NTm9kZShkb20sIGVkaXRvcik7XG4gICAgaWYgKGtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBub2RlID0gJGdldE5vZGVCeUtleShrZXksIGVkaXRvclN0YXRlKTtcbiAgICAgIGlmIChub2RlKSB7XG4gICAgICAgIC8vIEFsbCBkZWNvcmF0b3Igbm9kZXMgYXJlIHVubWFuYWdlZFxuICAgICAgICByZXR1cm4gJGlzRGVjb3JhdG9yTm9kZShub2RlKSB8fCAhaXNIVE1MRWxlbWVudChkb20pID8gdW5kZWZpbmVkIDogW2RvbSwgbm9kZV07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkb20gPT09IHJvb3RFbGVtZW50KSB7XG4gICAgICByZXR1cm4gW3Jvb3RFbGVtZW50LCBpbnRlcm5hbEdldFJvb3QoZWRpdG9yU3RhdGUpXTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uICRmbHVzaE11dGF0aW9ucyQxKGVkaXRvciwgbXV0YXRpb25zLCBvYnNlcnZlcikge1xuICBpc1Byb2Nlc3NpbmdNdXRhdGlvbnMgPSB0cnVlO1xuICBjb25zdCBzaG91bGRGbHVzaFRleHRNdXRhdGlvbnMgPSBwZXJmb3JtYW5jZS5ub3coKSAtIGxhc3RUZXh0RW50cnlUaW1lU3RhbXAgPiBURVhUX01VVEFUSU9OX1ZBUklBTkNFO1xuICB0cnkge1xuICAgIHVwZGF0ZUVkaXRvcihlZGl0b3IsICgpID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKSB8fCBnZXRMYXN0U2VsZWN0aW9uKGVkaXRvcik7XG4gICAgICBjb25zdCBiYWRET01UYXJnZXRzID0gbmV3IE1hcCgpO1xuICAgICAgY29uc3Qgcm9vdEVsZW1lbnQgPSBlZGl0b3IuZ2V0Um9vdEVsZW1lbnQoKTtcbiAgICAgIC8vIFdlIHVzZSB0aGUgY3VycmVudCBlZGl0b3Igc3RhdGUsIGFzIHRoYXQgcmVmbGVjdHMgd2hhdCBpc1xuICAgICAgLy8gYWN0dWFsbHkgXCJvbiBzY3JlZW5cIi5cbiAgICAgIGNvbnN0IGN1cnJlbnRFZGl0b3JTdGF0ZSA9IGVkaXRvci5fZWRpdG9yU3RhdGU7XG4gICAgICBjb25zdCBibG9ja0N1cnNvckVsZW1lbnQgPSBlZGl0b3IuX2Jsb2NrQ3Vyc29yRWxlbWVudDtcbiAgICAgIGxldCBzaG91bGRSZXZlcnRTZWxlY3Rpb24gPSBmYWxzZTtcbiAgICAgIGxldCBwb3NzaWJsZVRleHRGb3JGaXJlZm94UGFzdGUgPSAnJztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0YXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG11dGF0aW9uID0gbXV0YXRpb25zW2ldO1xuICAgICAgICBjb25zdCB0eXBlID0gbXV0YXRpb24udHlwZTtcbiAgICAgICAgY29uc3QgdGFyZ2V0RE9NID0gbXV0YXRpb24udGFyZ2V0O1xuICAgICAgICBjb25zdCBwYWlyID0gJGdldE5lYXJlc3RNYW5hZ2VkTm9kZVBhaXJGcm9tRE9NTm9kZSh0YXJnZXRET00sIGVkaXRvciwgY3VycmVudEVkaXRvclN0YXRlLCByb290RWxlbWVudCk7XG4gICAgICAgIGlmICghcGFpcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFtub2RlRE9NLCB0YXJnZXROb2RlXSA9IHBhaXI7XG4gICAgICAgIGlmICh0eXBlID09PSAnY2hhcmFjdGVyRGF0YScpIHtcbiAgICAgICAgICAvLyBUZXh0IG11dGF0aW9ucyBhcmUgZGVmZXJyZWQgYW5kIHBhc3NlZCB0byBtdXRhdGlvbiBsaXN0ZW5lcnMgdG8gYmVcbiAgICAgICAgICAvLyBwcm9jZXNzZWQgb3V0c2lkZSBvZiB0aGUgTGV4aWNhbCBlbmdpbmUuXG4gICAgICAgICAgaWYgKHNob3VsZEZsdXNoVGV4dE11dGF0aW9ucyAmJiAkaXNUZXh0Tm9kZSh0YXJnZXROb2RlKSAmJiBpc0RPTVRleHROb2RlKHRhcmdldERPTSkgJiYgc2hvdWxkVXBkYXRlVGV4dE5vZGVGcm9tTXV0YXRpb24oc2VsZWN0aW9uLCB0YXJnZXRET00sIHRhcmdldE5vZGUpKSB7XG4gICAgICAgICAgICAkaGFuZGxlVGV4dE11dGF0aW9uKHRhcmdldERPTSwgdGFyZ2V0Tm9kZSwgZWRpdG9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2NoaWxkTGlzdCcpIHtcbiAgICAgICAgICBzaG91bGRSZXZlcnRTZWxlY3Rpb24gPSB0cnVlO1xuICAgICAgICAgIC8vIFdlIGF0dGVtcHQgdG8gXCJ1bmRvXCIgYW55IGNoYW5nZXMgdGhhdCBoYXZlIG9jY3VycmVkIG91dHNpZGVcbiAgICAgICAgICAvLyBvZiBMZXhpY2FsLiBXZSB3YW50IExleGljYWwncyBlZGl0b3Igc3RhdGUgdG8gYmUgc291cmNlIG9mIHRydXRoLlxuICAgICAgICAgIC8vIFRvIHRoZSB1c2VyLCB0aGVzZSB3aWxsIGxvb2sgbGlrZSBuby1vcHMuXG4gICAgICAgICAgY29uc3QgYWRkZWRET01zID0gbXV0YXRpb24uYWRkZWROb2RlcztcbiAgICAgICAgICBmb3IgKGxldCBzID0gMDsgcyA8IGFkZGVkRE9Ncy5sZW5ndGg7IHMrKykge1xuICAgICAgICAgICAgY29uc3QgYWRkZWRET00gPSBhZGRlZERPTXNbc107XG4gICAgICAgICAgICBjb25zdCBub2RlID0gJGdldE5vZGVGcm9tRE9NTm9kZShhZGRlZERPTSk7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRET00gPSBhZGRlZERPTS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgaWYgKHBhcmVudERPTSAhPSBudWxsICYmIGFkZGVkRE9NICE9PSBibG9ja0N1cnNvckVsZW1lbnQgJiYgbm9kZSA9PT0gbnVsbCAmJiAhaXNNYW5hZ2VkTGluZUJyZWFrKGFkZGVkRE9NLCBwYXJlbnRET00sIGVkaXRvcikpIHtcbiAgICAgICAgICAgICAgaWYgKElTX0ZJUkVGT1gpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwb3NzaWJsZVRleHQgPSAoaXNIVE1MRWxlbWVudChhZGRlZERPTSkgPyBhZGRlZERPTS5pbm5lclRleHQgOiBudWxsKSB8fCBhZGRlZERPTS5ub2RlVmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHBvc3NpYmxlVGV4dCkge1xuICAgICAgICAgICAgICAgICAgcG9zc2libGVUZXh0Rm9yRmlyZWZveFBhc3RlICs9IHBvc3NpYmxlVGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcGFyZW50RE9NLnJlbW92ZUNoaWxkKGFkZGVkRE9NKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgcmVtb3ZlZERPTXMgPSBtdXRhdGlvbi5yZW1vdmVkTm9kZXM7XG4gICAgICAgICAgY29uc3QgcmVtb3ZlZERPTXNMZW5ndGggPSByZW1vdmVkRE9Ncy5sZW5ndGg7XG4gICAgICAgICAgaWYgKHJlbW92ZWRET01zTGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbGV0IHVucmVtb3ZlZEJScyA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBzID0gMDsgcyA8IHJlbW92ZWRET01zTGVuZ3RoOyBzKyspIHtcbiAgICAgICAgICAgICAgY29uc3QgcmVtb3ZlZERPTSA9IHJlbW92ZWRET01zW3NdO1xuICAgICAgICAgICAgICBpZiAoaXNNYW5hZ2VkTGluZUJyZWFrKHJlbW92ZWRET00sIHRhcmdldERPTSwgZWRpdG9yKSB8fCBibG9ja0N1cnNvckVsZW1lbnQgPT09IHJlbW92ZWRET00pIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRET00uYXBwZW5kQ2hpbGQocmVtb3ZlZERPTSk7XG4gICAgICAgICAgICAgICAgdW5yZW1vdmVkQlJzKys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZW1vdmVkRE9Nc0xlbmd0aCAhPT0gdW5yZW1vdmVkQlJzKSB7XG4gICAgICAgICAgICAgIGJhZERPTVRhcmdldHMuc2V0KG5vZGVET00sIHRhcmdldE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBOb3cgd2UgcHJvY2VzcyBlYWNoIG9mIHRoZSB1bmlxdWUgdGFyZ2V0IG5vZGVzLCBhdHRlbXB0aW5nXG4gICAgICAvLyB0byByZXN0b3JlIHRoZWlyIGNvbnRlbnRzIGJhY2sgdG8gdGhlIHNvdXJjZSBvZiB0cnV0aCwgd2hpY2hcbiAgICAgIC8vIGlzIExleGljYWwncyBcImN1cnJlbnRcIiBlZGl0b3Igc3RhdGUuIFRoaXMgaXMgYmFzaWNhbGx5IGxpa2VcbiAgICAgIC8vIGFuIGludGVybmFsIHJldmVydCBvbiB0aGUgRE9NLlxuICAgICAgaWYgKGJhZERPTVRhcmdldHMuc2l6ZSA+IDApIHtcbiAgICAgICAgZm9yIChjb25zdCBbbm9kZURPTSwgdGFyZ2V0Tm9kZV0gb2YgYmFkRE9NVGFyZ2V0cykge1xuICAgICAgICAgIHRhcmdldE5vZGUucmVjb25jaWxlT2JzZXJ2ZWRNdXRhdGlvbihub2RlRE9NLCBlZGl0b3IpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIENhcHR1cmUgYWxsIHRoZSBtdXRhdGlvbnMgbWFkZSBkdXJpbmcgdGhpcyBmdW5jdGlvbi4gVGhpc1xuICAgICAgLy8gYWxzbyBwcmV2ZW50cyB1cyBoYXZpbmcgdG8gcHJvY2VzcyB0aGVtIG9uIHRoZSBuZXh0IGN5Y2xlXG4gICAgICAvLyBvZiBvbk11dGF0aW9uLCBhcyB0aGVzZSBtdXRhdGlvbnMgd2VyZSBtYWRlIGJ5IHVzLlxuICAgICAgY29uc3QgcmVjb3JkcyA9IG9ic2VydmVyLnRha2VSZWNvcmRzKCk7XG5cbiAgICAgIC8vIENoZWNrIGZvciBhbnkgcmFuZG9tIGF1dG8tYWRkZWQgPGJyPiBlbGVtZW50cywgYW5kIHJlbW92ZSB0aGVtLlxuICAgICAgLy8gVGhlc2UgZ2V0IGFkZGVkIGJ5IHRoZSBicm93c2VyIHdoZW4gd2UgdW5kbyB0aGUgYWJvdmUgbXV0YXRpb25zXG4gICAgICAvLyBhbmQgdGhpcyBjYW4gbGVhZCB0byBhIGJyb2tlbiBVSS5cbiAgICAgIGlmIChyZWNvcmRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWNvcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgcmVjb3JkID0gcmVjb3Jkc1tpXTtcbiAgICAgICAgICBjb25zdCBhZGRlZE5vZGVzID0gcmVjb3JkLmFkZGVkTm9kZXM7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0ID0gcmVjb3JkLnRhcmdldDtcbiAgICAgICAgICBmb3IgKGxldCBzID0gMDsgcyA8IGFkZGVkTm9kZXMubGVuZ3RoOyBzKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGFkZGVkRE9NID0gYWRkZWROb2Rlc1tzXTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudERPTSA9IGFkZGVkRE9NLnBhcmVudE5vZGU7XG4gICAgICAgICAgICBpZiAocGFyZW50RE9NICE9IG51bGwgJiYgYWRkZWRET00ubm9kZU5hbWUgPT09ICdCUicgJiYgIWlzTWFuYWdlZExpbmVCcmVhayhhZGRlZERPTSwgdGFyZ2V0LCBlZGl0b3IpKSB7XG4gICAgICAgICAgICAgIHBhcmVudERPTS5yZW1vdmVDaGlsZChhZGRlZERPTSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2xlYXIgYW55IG9mIHRob3NlIHJlbW92YWwgbXV0YXRpb25zXG4gICAgICAgIG9ic2VydmVyLnRha2VSZWNvcmRzKCk7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZWN0aW9uICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChzaG91bGRSZXZlcnRTZWxlY3Rpb24pIHtcbiAgICAgICAgICBzZWxlY3Rpb24uZGlydHkgPSB0cnVlO1xuICAgICAgICAgICRzZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSVNfRklSRUZPWCAmJiBpc0ZpcmVmb3hDbGlwYm9hcmRFdmVudHMoZWRpdG9yKSkge1xuICAgICAgICAgIHNlbGVjdGlvbi5pbnNlcnRSYXdUZXh0KHBvc3NpYmxlVGV4dEZvckZpcmVmb3hQYXN0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSBmaW5hbGx5IHtcbiAgICBpc1Byb2Nlc3NpbmdNdXRhdGlvbnMgPSBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gJGZsdXNoUm9vdE11dGF0aW9ucyhlZGl0b3IpIHtcbiAgY29uc3Qgb2JzZXJ2ZXIgPSBlZGl0b3IuX29ic2VydmVyO1xuICBpZiAob2JzZXJ2ZXIgIT09IG51bGwpIHtcbiAgICBjb25zdCBtdXRhdGlvbnMgPSBvYnNlcnZlci50YWtlUmVjb3JkcygpO1xuICAgICRmbHVzaE11dGF0aW9ucyQxKGVkaXRvciwgbXV0YXRpb25zLCBvYnNlcnZlcik7XG4gIH1cbn1cbmZ1bmN0aW9uIGluaXRNdXRhdGlvbk9ic2VydmVyKGVkaXRvcikge1xuICBpbml0VGV4dEVudHJ5TGlzdGVuZXIoZWRpdG9yKTtcbiAgZWRpdG9yLl9vYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKChtdXRhdGlvbnMsIG9ic2VydmVyKSA9PiB7XG4gICAgJGZsdXNoTXV0YXRpb25zJDEoZWRpdG9yLCBtdXRhdGlvbnMsIG9ic2VydmVyKTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gJGNhblNpbXBsZVRleHROb2Rlc0JlTWVyZ2VkKG5vZGUxLCBub2RlMikge1xuICBjb25zdCBub2RlMU1vZGUgPSBub2RlMS5fX21vZGU7XG4gIGNvbnN0IG5vZGUxRm9ybWF0ID0gbm9kZTEuX19mb3JtYXQ7XG4gIGNvbnN0IG5vZGUxU3R5bGUgPSBub2RlMS5fX3N0eWxlO1xuICBjb25zdCBub2RlMk1vZGUgPSBub2RlMi5fX21vZGU7XG4gIGNvbnN0IG5vZGUyRm9ybWF0ID0gbm9kZTIuX19mb3JtYXQ7XG4gIGNvbnN0IG5vZGUyU3R5bGUgPSBub2RlMi5fX3N0eWxlO1xuICByZXR1cm4gKG5vZGUxTW9kZSA9PT0gbnVsbCB8fCBub2RlMU1vZGUgPT09IG5vZGUyTW9kZSkgJiYgKG5vZGUxRm9ybWF0ID09PSBudWxsIHx8IG5vZGUxRm9ybWF0ID09PSBub2RlMkZvcm1hdCkgJiYgKG5vZGUxU3R5bGUgPT09IG51bGwgfHwgbm9kZTFTdHlsZSA9PT0gbm9kZTJTdHlsZSk7XG59XG5mdW5jdGlvbiAkbWVyZ2VUZXh0Tm9kZXMobm9kZTEsIG5vZGUyKSB7XG4gIGNvbnN0IHdyaXRhYmxlTm9kZTEgPSBub2RlMS5tZXJnZVdpdGhTaWJsaW5nKG5vZGUyKTtcbiAgY29uc3Qgbm9ybWFsaXplZE5vZGVzID0gZ2V0QWN0aXZlRWRpdG9yKCkuX25vcm1hbGl6ZWROb2RlcztcbiAgbm9ybWFsaXplZE5vZGVzLmFkZChub2RlMS5fX2tleSk7XG4gIG5vcm1hbGl6ZWROb2Rlcy5hZGQobm9kZTIuX19rZXkpO1xuICByZXR1cm4gd3JpdGFibGVOb2RlMTtcbn1cbmZ1bmN0aW9uICRub3JtYWxpemVUZXh0Tm9kZSh0ZXh0Tm9kZSkge1xuICBsZXQgbm9kZSA9IHRleHROb2RlO1xuICBpZiAobm9kZS5fX3RleHQgPT09ICcnICYmIG5vZGUuaXNTaW1wbGVUZXh0KCkgJiYgIW5vZGUuaXNVbm1lcmdlYWJsZSgpKSB7XG4gICAgbm9kZS5yZW1vdmUoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBCYWNrd2FyZFxuICBsZXQgcHJldmlvdXNOb2RlO1xuICB3aGlsZSAoKHByZXZpb3VzTm9kZSA9IG5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCkpICE9PSBudWxsICYmICRpc1RleHROb2RlKHByZXZpb3VzTm9kZSkgJiYgcHJldmlvdXNOb2RlLmlzU2ltcGxlVGV4dCgpICYmICFwcmV2aW91c05vZGUuaXNVbm1lcmdlYWJsZSgpKSB7XG4gICAgaWYgKHByZXZpb3VzTm9kZS5fX3RleHQgPT09ICcnKSB7XG4gICAgICBwcmV2aW91c05vZGUucmVtb3ZlKCk7XG4gICAgfSBlbHNlIGlmICgkY2FuU2ltcGxlVGV4dE5vZGVzQmVNZXJnZWQocHJldmlvdXNOb2RlLCBub2RlKSkge1xuICAgICAgbm9kZSA9ICRtZXJnZVRleHROb2RlcyhwcmV2aW91c05vZGUsIG5vZGUpO1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8vIEZvcndhcmRcbiAgbGV0IG5leHROb2RlO1xuICB3aGlsZSAoKG5leHROb2RlID0gbm9kZS5nZXROZXh0U2libGluZygpKSAhPT0gbnVsbCAmJiAkaXNUZXh0Tm9kZShuZXh0Tm9kZSkgJiYgbmV4dE5vZGUuaXNTaW1wbGVUZXh0KCkgJiYgIW5leHROb2RlLmlzVW5tZXJnZWFibGUoKSkge1xuICAgIGlmIChuZXh0Tm9kZS5fX3RleHQgPT09ICcnKSB7XG4gICAgICBuZXh0Tm9kZS5yZW1vdmUoKTtcbiAgICB9IGVsc2UgaWYgKCRjYW5TaW1wbGVUZXh0Tm9kZXNCZU1lcmdlZChub2RlLCBuZXh0Tm9kZSkpIHtcbiAgICAgIG5vZGUgPSAkbWVyZ2VUZXh0Tm9kZXMobm9kZSwgbmV4dE5vZGUpO1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gJG5vcm1hbGl6ZVNlbGVjdGlvbihzZWxlY3Rpb24pIHtcbiAgJG5vcm1hbGl6ZVBvaW50KHNlbGVjdGlvbi5hbmNob3IpO1xuICAkbm9ybWFsaXplUG9pbnQoc2VsZWN0aW9uLmZvY3VzKTtcbiAgcmV0dXJuIHNlbGVjdGlvbjtcbn1cbmZ1bmN0aW9uICRub3JtYWxpemVQb2ludChwb2ludCkge1xuICB3aGlsZSAocG9pbnQudHlwZSA9PT0gJ2VsZW1lbnQnKSB7XG4gICAgY29uc3Qgbm9kZSA9IHBvaW50LmdldE5vZGUoKTtcbiAgICBjb25zdCBvZmZzZXQgPSBwb2ludC5vZmZzZXQ7XG4gICAgbGV0IG5leHROb2RlO1xuICAgIGxldCBuZXh0T2Zmc2V0QXRFbmQ7XG4gICAgaWYgKG9mZnNldCA9PT0gbm9kZS5nZXRDaGlsZHJlblNpemUoKSkge1xuICAgICAgbmV4dE5vZGUgPSBub2RlLmdldENoaWxkQXRJbmRleChvZmZzZXQgLSAxKTtcbiAgICAgIG5leHRPZmZzZXRBdEVuZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHROb2RlID0gbm9kZS5nZXRDaGlsZEF0SW5kZXgob2Zmc2V0KTtcbiAgICAgIG5leHRPZmZzZXRBdEVuZCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoJGlzVGV4dE5vZGUobmV4dE5vZGUpKSB7XG4gICAgICBwb2ludC5zZXQobmV4dE5vZGUuX19rZXksIG5leHRPZmZzZXRBdEVuZCA/IG5leHROb2RlLmdldFRleHRDb250ZW50U2l6ZSgpIDogMCwgJ3RleHQnKTtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSBpZiAoISRpc0VsZW1lbnROb2RlKG5leHROb2RlKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHBvaW50LnNldChuZXh0Tm9kZS5fX2tleSwgbmV4dE9mZnNldEF0RW5kID8gbmV4dE5vZGUuZ2V0Q2hpbGRyZW5TaXplKCkgOiAwLCAnZWxlbWVudCcpO1xuICB9XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxubGV0IGtleUNvdW50ZXIgPSAxO1xuZnVuY3Rpb24gcmVzZXRSYW5kb21LZXkoKSB7XG4gIGtleUNvdW50ZXIgPSAxO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVSYW5kb21LZXkoKSB7XG4gIHJldHVybiAnJyArIGtleUNvdW50ZXIrKztcbn1cbmZ1bmN0aW9uIGdldFJlZ2lzdGVyZWROb2RlT3JUaHJvdyhlZGl0b3IsIG5vZGVUeXBlKSB7XG4gIGNvbnN0IHJlZ2lzdGVyZWROb2RlID0gZWRpdG9yLl9ub2Rlcy5nZXQobm9kZVR5cGUpO1xuICBpZiAocmVnaXN0ZXJlZE5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGByZWdpc3RlcmVkTm9kZTogVHlwZSAke25vZGVUeXBlfSBub3QgZm91bmRgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlZ2lzdGVyZWROb2RlO1xufVxuY29uc3Qgc2NoZWR1bGVNaWNyb1Rhc2sgPSB0eXBlb2YgcXVldWVNaWNyb3Rhc2sgPT09ICdmdW5jdGlvbicgPyBxdWV1ZU1pY3JvdGFzayA6IGZuID0+IHtcbiAgLy8gTm8gd2luZG93IHByZWZpeCBpbnRlbmRlZCAoIzE0MDApXG4gIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZm4pO1xufTtcbmZ1bmN0aW9uICRpc1NlbGVjdGlvbkNhcHR1cmVkSW5EZWNvcmF0b3Iobm9kZSkge1xuICByZXR1cm4gJGlzRGVjb3JhdG9yTm9kZSgkZ2V0TmVhcmVzdE5vZGVGcm9tRE9NTm9kZShub2RlKSk7XG59XG5mdW5jdGlvbiBpc1NlbGVjdGlvbkNhcHR1cmVkSW5EZWNvcmF0b3JJbnB1dChhbmNob3JET00pIHtcbiAgY29uc3QgYWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gIGlmICghaXNIVE1MRWxlbWVudChhY3RpdmVFbGVtZW50KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBub2RlTmFtZSA9IGFjdGl2ZUVsZW1lbnQubm9kZU5hbWU7XG4gIHJldHVybiAkaXNEZWNvcmF0b3JOb2RlKCRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlKGFuY2hvckRPTSkpICYmIChub2RlTmFtZSA9PT0gJ0lOUFVUJyB8fCBub2RlTmFtZSA9PT0gJ1RFWFRBUkVBJyB8fCBhY3RpdmVFbGVtZW50LmNvbnRlbnRFZGl0YWJsZSA9PT0gJ3RydWUnICYmIGdldEVkaXRvclByb3BlcnR5RnJvbURPTU5vZGUoYWN0aXZlRWxlbWVudCkgPT0gbnVsbCk7XG59XG5mdW5jdGlvbiBpc1NlbGVjdGlvbldpdGhpbkVkaXRvcihlZGl0b3IsIGFuY2hvckRPTSwgZm9jdXNET00pIHtcbiAgY29uc3Qgcm9vdEVsZW1lbnQgPSBlZGl0b3IuZ2V0Um9vdEVsZW1lbnQoKTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gcm9vdEVsZW1lbnQgIT09IG51bGwgJiYgcm9vdEVsZW1lbnQuY29udGFpbnMoYW5jaG9yRE9NKSAmJiByb290RWxlbWVudC5jb250YWlucyhmb2N1c0RPTSkgJiZcbiAgICAvLyBJZ25vcmUgaWYgc2VsZWN0aW9uIGlzIHdpdGhpbiBuZXN0ZWQgZWRpdG9yXG4gICAgYW5jaG9yRE9NICE9PSBudWxsICYmICFpc1NlbGVjdGlvbkNhcHR1cmVkSW5EZWNvcmF0b3JJbnB1dChhbmNob3JET00pICYmIGdldE5lYXJlc3RFZGl0b3JGcm9tRE9NTm9kZShhbmNob3JET00pID09PSBlZGl0b3I7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gYXJndW1lbnQgaXMgYSBMZXhpY2FsRWRpdG9yIGluc3RhbmNlIGZyb20gdGhpcyBidWlsZCBvZiBMZXhpY2FsXG4gKi9cbmZ1bmN0aW9uIGlzTGV4aWNhbEVkaXRvcihlZGl0b3IpIHtcbiAgLy8gQ2hlY2sgaW5zdGFuY2VvZiB0byBwcmV2ZW50IGlzc3VlcyB3aXRoIG11bHRpcGxlIGVtYmVkZGVkIExleGljYWwgaW5zdGFsbGF0aW9uc1xuICByZXR1cm4gZWRpdG9yIGluc3RhbmNlb2YgTGV4aWNhbEVkaXRvcjtcbn1cbmZ1bmN0aW9uIGdldE5lYXJlc3RFZGl0b3JGcm9tRE9NTm9kZShub2RlKSB7XG4gIGxldCBjdXJyZW50Tm9kZSA9IG5vZGU7XG4gIHdoaWxlIChjdXJyZW50Tm9kZSAhPSBudWxsKSB7XG4gICAgY29uc3QgZWRpdG9yID0gZ2V0RWRpdG9yUHJvcGVydHlGcm9tRE9NTm9kZShjdXJyZW50Tm9kZSk7XG4gICAgaWYgKGlzTGV4aWNhbEVkaXRvcihlZGl0b3IpKSB7XG4gICAgICByZXR1cm4gZWRpdG9yO1xuICAgIH1cbiAgICBjdXJyZW50Tm9kZSA9IGdldFBhcmVudEVsZW1lbnQoY3VycmVudE5vZGUpO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKiogQGludGVybmFsICovXG5mdW5jdGlvbiBnZXRFZGl0b3JQcm9wZXJ0eUZyb21ET01Ob2RlKG5vZGUpIHtcbiAgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW50ZXJuYWwgZmllbGRcbiAgcmV0dXJuIG5vZGUgPyBub2RlLl9fbGV4aWNhbEVkaXRvciA6IG51bGw7XG59XG5mdW5jdGlvbiBnZXRUZXh0RGlyZWN0aW9uKHRleHQpIHtcbiAgaWYgKFJUTF9SRUdFWC50ZXN0KHRleHQpKSB7XG4gICAgcmV0dXJuICdydGwnO1xuICB9XG4gIGlmIChMVFJfUkVHRVgudGVzdCh0ZXh0KSkge1xuICAgIHJldHVybiAnbHRyJztcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uICRpc1Rva2VuT3JTZWdtZW50ZWQobm9kZSkge1xuICByZXR1cm4gbm9kZS5pc1Rva2VuKCkgfHwgbm9kZS5pc1NlZ21lbnRlZCgpO1xufVxuXG4vKipcbiAqIEBwYXJhbSBub2RlIC0gVGhlIGVsZW1lbnQgYmVpbmcgdGVzdGVkXG4gKiBAcmV0dXJucyBSZXR1cm5zIHRydWUgaWYgbm9kZSBpcyBhbiBET00gVGV4dCBub2RlLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzRE9NVGV4dE5vZGUobm9kZSkge1xuICByZXR1cm4gaXNET01Ob2RlKG5vZGUpICYmIG5vZGUubm9kZVR5cGUgPT09IERPTV9URVhUX1RZUEU7XG59XG5cbi8qKlxuICogQHBhcmFtIG5vZGUgLSBUaGUgZWxlbWVudCBiZWluZyB0ZXN0ZWRcbiAqIEByZXR1cm5zIFJldHVybnMgdHJ1ZSBpZiBub2RlIGlzIGFuIERPTSBEb2N1bWVudCBub2RlLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzRE9NRG9jdW1lbnROb2RlKG5vZGUpIHtcbiAgcmV0dXJuIGlzRE9NTm9kZShub2RlKSAmJiBub2RlLm5vZGVUeXBlID09PSBET01fRE9DVU1FTlRfVFlQRTtcbn1cbmZ1bmN0aW9uIGdldERPTVRleHROb2RlKGVsZW1lbnQpIHtcbiAgbGV0IG5vZGUgPSBlbGVtZW50O1xuICB3aGlsZSAobm9kZSAhPSBudWxsKSB7XG4gICAgaWYgKGlzRE9NVGV4dE5vZGUobm9kZSkpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBub2RlID0gbm9kZS5maXJzdENoaWxkO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gdG9nZ2xlVGV4dEZvcm1hdFR5cGUoZm9ybWF0LCB0eXBlLCBhbGlnbldpdGhGb3JtYXQpIHtcbiAgY29uc3QgYWN0aXZlRm9ybWF0ID0gVEVYVF9UWVBFX1RPX0ZPUk1BVFt0eXBlXTtcbiAgaWYgKGFsaWduV2l0aEZvcm1hdCAhPT0gbnVsbCAmJiAoZm9ybWF0ICYgYWN0aXZlRm9ybWF0KSA9PT0gKGFsaWduV2l0aEZvcm1hdCAmIGFjdGl2ZUZvcm1hdCkpIHtcbiAgICByZXR1cm4gZm9ybWF0O1xuICB9XG4gIGxldCBuZXdGb3JtYXQgPSBmb3JtYXQgXiBhY3RpdmVGb3JtYXQ7XG4gIGlmICh0eXBlID09PSAnc3Vic2NyaXB0Jykge1xuICAgIG5ld0Zvcm1hdCAmPSB+VEVYVF9UWVBFX1RPX0ZPUk1BVC5zdXBlcnNjcmlwdDtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnc3VwZXJzY3JpcHQnKSB7XG4gICAgbmV3Rm9ybWF0ICY9IH5URVhUX1RZUEVfVE9fRk9STUFULnN1YnNjcmlwdDtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbG93ZXJjYXNlJykge1xuICAgIG5ld0Zvcm1hdCAmPSB+VEVYVF9UWVBFX1RPX0ZPUk1BVC51cHBlcmNhc2U7XG4gICAgbmV3Rm9ybWF0ICY9IH5URVhUX1RZUEVfVE9fRk9STUFULmNhcGl0YWxpemU7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3VwcGVyY2FzZScpIHtcbiAgICBuZXdGb3JtYXQgJj0gflRFWFRfVFlQRV9UT19GT1JNQVQubG93ZXJjYXNlO1xuICAgIG5ld0Zvcm1hdCAmPSB+VEVYVF9UWVBFX1RPX0ZPUk1BVC5jYXBpdGFsaXplO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdjYXBpdGFsaXplJykge1xuICAgIG5ld0Zvcm1hdCAmPSB+VEVYVF9UWVBFX1RPX0ZPUk1BVC5sb3dlcmNhc2U7XG4gICAgbmV3Rm9ybWF0ICY9IH5URVhUX1RZUEVfVE9fRk9STUFULnVwcGVyY2FzZTtcbiAgfVxuICByZXR1cm4gbmV3Rm9ybWF0O1xufVxuZnVuY3Rpb24gJGlzTGVhZk5vZGUobm9kZSkge1xuICByZXR1cm4gJGlzVGV4dE5vZGUobm9kZSkgfHwgJGlzTGluZUJyZWFrTm9kZShub2RlKSB8fCAkaXNEZWNvcmF0b3JOb2RlKG5vZGUpO1xufVxuZnVuY3Rpb24gJHNldE5vZGVLZXkobm9kZSwgZXhpc3RpbmdLZXkpIHtcbiAgaWYgKGV4aXN0aW5nS2V5ICE9IG51bGwpIHtcbiAgICB7XG4gICAgICBlcnJvck9uTm9kZUtleUNvbnN0cnVjdG9yTWlzbWF0Y2gobm9kZSwgZXhpc3RpbmdLZXkpO1xuICAgIH1cbiAgICBub2RlLl9fa2V5ID0gZXhpc3RpbmdLZXk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGVycm9yT25SZWFkT25seSgpO1xuICBlcnJvck9uSW5maW5pdGVUcmFuc2Zvcm1zKCk7XG4gIGNvbnN0IGVkaXRvciA9IGdldEFjdGl2ZUVkaXRvcigpO1xuICBjb25zdCBlZGl0b3JTdGF0ZSA9IGdldEFjdGl2ZUVkaXRvclN0YXRlKCk7XG4gIGNvbnN0IGtleSA9IGdlbmVyYXRlUmFuZG9tS2V5KCk7XG4gIGVkaXRvclN0YXRlLl9ub2RlTWFwLnNldChrZXksIG5vZGUpO1xuICAvLyBUT0RPIFNwbGl0IHRoaXMgZnVuY3Rpb24gaW50byBsZWFmL2VsZW1lbnRcbiAgaWYgKCRpc0VsZW1lbnROb2RlKG5vZGUpKSB7XG4gICAgZWRpdG9yLl9kaXJ0eUVsZW1lbnRzLnNldChrZXksIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIGVkaXRvci5fZGlydHlMZWF2ZXMuYWRkKGtleSk7XG4gIH1cbiAgZWRpdG9yLl9jbG9uZU5vdE5lZWRlZC5hZGQoa2V5KTtcbiAgZWRpdG9yLl9kaXJ0eVR5cGUgPSBIQVNfRElSVFlfTk9ERVM7XG4gIG5vZGUuX19rZXkgPSBrZXk7XG59XG5mdW5jdGlvbiBlcnJvck9uTm9kZUtleUNvbnN0cnVjdG9yTWlzbWF0Y2gobm9kZSwgZXhpc3RpbmdLZXkpIHtcbiAgY29uc3QgZWRpdG9yU3RhdGUgPSBpbnRlcm5hbEdldEFjdGl2ZUVkaXRvclN0YXRlKCk7XG4gIGlmICghZWRpdG9yU3RhdGUpIHtcbiAgICAvLyB0ZXN0cyBleHBlY3QgdG8gYmUgYWJsZSB0byBkbyB0aGlzIGtpbmQgb2YgY2xvbmUgd2l0aG91dCBhbiBhY3RpdmUgZWRpdG9yIHN0YXRlXG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGV4aXN0aW5nTm9kZSA9IGVkaXRvclN0YXRlLl9ub2RlTWFwLmdldChleGlzdGluZ0tleSk7XG4gIGlmIChleGlzdGluZ05vZGUgJiYgZXhpc3RpbmdOb2RlLmNvbnN0cnVjdG9yICE9PSBub2RlLmNvbnN0cnVjdG9yKSB7XG4gICAgLy8gTGlmdGVkIGNvbmRpdGlvbiB0byBpZiBzdGF0ZW1lbnQgYmVjYXVzZSB0aGUgaW52ZXJ0ZWQgbG9naWMgaXMgYSBiaXQgY29uZnVzaW5nXG4gICAgaWYgKG5vZGUuY29uc3RydWN0b3IubmFtZSAhPT0gZXhpc3RpbmdOb2RlLmNvbnN0cnVjdG9yLm5hbWUpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYExleGljYWwgbm9kZSB3aXRoIGNvbnN0cnVjdG9yICR7bm9kZS5jb25zdHJ1Y3Rvci5uYW1lfSBhdHRlbXB0ZWQgdG8gcmUtdXNlIGtleSBmcm9tIG5vZGUgaW4gYWN0aXZlIGVkaXRvciBzdGF0ZSB3aXRoIGNvbnN0cnVjdG9yICR7ZXhpc3RpbmdOb2RlLmNvbnN0cnVjdG9yLm5hbWV9LiBLZXlzIG11c3Qgbm90IGJlIHJlLXVzZWQgd2hlbiB0aGUgdHlwZSBpcyBjaGFuZ2VkLmApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKGBMZXhpY2FsIG5vZGUgd2l0aCBjb25zdHJ1Y3RvciAke25vZGUuY29uc3RydWN0b3IubmFtZX0gYXR0ZW1wdGVkIHRvIHJlLXVzZSBrZXkgZnJvbSBub2RlIGluIGFjdGl2ZSBlZGl0b3Igc3RhdGUgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3Igd2l0aCB0aGUgc2FtZSBuYW1lIChwb3NzaWJseSBkdWUgdG8gaW52YWxpZCBIb3QgTW9kdWxlIFJlcGxhY2VtZW50KS4gS2V5cyBtdXN0IG5vdCBiZSByZS11c2VkIHdoZW4gdGhlIHR5cGUgaXMgY2hhbmdlZC5gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGludGVybmFsTWFya1BhcmVudEVsZW1lbnRzQXNEaXJ0eShwYXJlbnRLZXksIG5vZGVNYXAsIGRpcnR5RWxlbWVudHMpIHtcbiAgbGV0IG5leHRQYXJlbnRLZXkgPSBwYXJlbnRLZXk7XG4gIHdoaWxlIChuZXh0UGFyZW50S2V5ICE9PSBudWxsKSB7XG4gICAgaWYgKGRpcnR5RWxlbWVudHMuaGFzKG5leHRQYXJlbnRLZXkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5vZGUgPSBub2RlTWFwLmdldChuZXh0UGFyZW50S2V5KTtcbiAgICBpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZGlydHlFbGVtZW50cy5zZXQobmV4dFBhcmVudEtleSwgZmFsc2UpO1xuICAgIG5leHRQYXJlbnRLZXkgPSBub2RlLl9fcGFyZW50O1xuICB9XG59XG5cbi8vIFRPRE8gIzYwMzEgdGhpcyBmdW5jdGlvbiBvciB0aGVpciBjYWxsZXJzIGhhdmUgdG8gYWRqdXN0IHNlbGVjdGlvbiAoaS5lLiBpbnNlcnRCZWZvcmUpXG5mdW5jdGlvbiByZW1vdmVGcm9tUGFyZW50KG5vZGUpIHtcbiAgY29uc3Qgb2xkUGFyZW50ID0gbm9kZS5nZXRQYXJlbnQoKTtcbiAgaWYgKG9sZFBhcmVudCAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHdyaXRhYmxlTm9kZSA9IG5vZGUuZ2V0V3JpdGFibGUoKTtcbiAgICBjb25zdCB3cml0YWJsZVBhcmVudCA9IG9sZFBhcmVudC5nZXRXcml0YWJsZSgpO1xuICAgIGNvbnN0IHByZXZTaWJsaW5nID0gbm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICBjb25zdCBuZXh0U2libGluZyA9IG5vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICAvLyBUT0RPOiB0aGlzIGZ1bmN0aW9uIGR1cGxpY2F0ZXMgYSBidW5jaCBvZiBvcGVyYXRpb25zLCBjYW4gYmUgc2ltcGxpZmllZC5cbiAgICBpZiAocHJldlNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgIGlmIChuZXh0U2libGluZyAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCB3cml0YWJsZU5leHRTaWJsaW5nID0gbmV4dFNpYmxpbmcuZ2V0V3JpdGFibGUoKTtcbiAgICAgICAgd3JpdGFibGVQYXJlbnQuX19maXJzdCA9IG5leHRTaWJsaW5nLl9fa2V5O1xuICAgICAgICB3cml0YWJsZU5leHRTaWJsaW5nLl9fcHJldiA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3cml0YWJsZVBhcmVudC5fX2ZpcnN0ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgd3JpdGFibGVQcmV2U2libGluZyA9IHByZXZTaWJsaW5nLmdldFdyaXRhYmxlKCk7XG4gICAgICBpZiAobmV4dFNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3Qgd3JpdGFibGVOZXh0U2libGluZyA9IG5leHRTaWJsaW5nLmdldFdyaXRhYmxlKCk7XG4gICAgICAgIHdyaXRhYmxlTmV4dFNpYmxpbmcuX19wcmV2ID0gd3JpdGFibGVQcmV2U2libGluZy5fX2tleTtcbiAgICAgICAgd3JpdGFibGVQcmV2U2libGluZy5fX25leHQgPSB3cml0YWJsZU5leHRTaWJsaW5nLl9fa2V5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JpdGFibGVQcmV2U2libGluZy5fX25leHQgPSBudWxsO1xuICAgICAgfVxuICAgICAgd3JpdGFibGVOb2RlLl9fcHJldiA9IG51bGw7XG4gICAgfVxuICAgIGlmIChuZXh0U2libGluZyA9PT0gbnVsbCkge1xuICAgICAgaWYgKHByZXZTaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHdyaXRhYmxlUHJldlNpYmxpbmcgPSBwcmV2U2libGluZy5nZXRXcml0YWJsZSgpO1xuICAgICAgICB3cml0YWJsZVBhcmVudC5fX2xhc3QgPSBwcmV2U2libGluZy5fX2tleTtcbiAgICAgICAgd3JpdGFibGVQcmV2U2libGluZy5fX25leHQgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JpdGFibGVQYXJlbnQuX19sYXN0ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgd3JpdGFibGVOZXh0U2libGluZyA9IG5leHRTaWJsaW5nLmdldFdyaXRhYmxlKCk7XG4gICAgICBpZiAocHJldlNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3Qgd3JpdGFibGVQcmV2U2libGluZyA9IHByZXZTaWJsaW5nLmdldFdyaXRhYmxlKCk7XG4gICAgICAgIHdyaXRhYmxlUHJldlNpYmxpbmcuX19uZXh0ID0gd3JpdGFibGVOZXh0U2libGluZy5fX2tleTtcbiAgICAgICAgd3JpdGFibGVOZXh0U2libGluZy5fX3ByZXYgPSB3cml0YWJsZVByZXZTaWJsaW5nLl9fa2V5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JpdGFibGVOZXh0U2libGluZy5fX3ByZXYgPSBudWxsO1xuICAgICAgfVxuICAgICAgd3JpdGFibGVOb2RlLl9fbmV4dCA9IG51bGw7XG4gICAgfVxuICAgIHdyaXRhYmxlUGFyZW50Ll9fc2l6ZS0tO1xuICAgIHdyaXRhYmxlTm9kZS5fX3BhcmVudCA9IG51bGw7XG4gIH1cbn1cblxuLy8gTmV2ZXIgdXNlIHRoaXMgZnVuY3Rpb24gZGlyZWN0bHkhIEl0IHdpbGwgYnJlYWtcbi8vIHRoZSBjbG9uaW5nIGhldXJpc3RpYy4gSW5zdGVhZCB1c2Ugbm9kZS5nZXRXcml0YWJsZSgpLlxuZnVuY3Rpb24gaW50ZXJuYWxNYXJrTm9kZUFzRGlydHkobm9kZSkge1xuICBlcnJvck9uSW5maW5pdGVUcmFuc2Zvcm1zKCk7XG4gIGNvbnN0IGxhdGVzdCA9IG5vZGUuZ2V0TGF0ZXN0KCk7XG4gIGNvbnN0IHBhcmVudCA9IGxhdGVzdC5fX3BhcmVudDtcbiAgY29uc3QgZWRpdG9yU3RhdGUgPSBnZXRBY3RpdmVFZGl0b3JTdGF0ZSgpO1xuICBjb25zdCBlZGl0b3IgPSBnZXRBY3RpdmVFZGl0b3IoKTtcbiAgY29uc3Qgbm9kZU1hcCA9IGVkaXRvclN0YXRlLl9ub2RlTWFwO1xuICBjb25zdCBkaXJ0eUVsZW1lbnRzID0gZWRpdG9yLl9kaXJ0eUVsZW1lbnRzO1xuICBpZiAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgaW50ZXJuYWxNYXJrUGFyZW50RWxlbWVudHNBc0RpcnR5KHBhcmVudCwgbm9kZU1hcCwgZGlydHlFbGVtZW50cyk7XG4gIH1cbiAgY29uc3Qga2V5ID0gbGF0ZXN0Ll9fa2V5O1xuICBlZGl0b3IuX2RpcnR5VHlwZSA9IEhBU19ESVJUWV9OT0RFUztcbiAgaWYgKCRpc0VsZW1lbnROb2RlKG5vZGUpKSB7XG4gICAgZGlydHlFbGVtZW50cy5zZXQoa2V5LCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBUT0RPIHNwbGl0IGludGVybmFsbHkgTWFya05vZGVBc0RpcnR5IGludG8gdHdvIGRlZGljYXRlZCBFbGVtZW50L2xlYXZlIGZ1bmN0aW9uc1xuICAgIGVkaXRvci5fZGlydHlMZWF2ZXMuYWRkKGtleSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGludGVybmFsTWFya1NpYmxpbmdzQXNEaXJ0eShub2RlKSB7XG4gIGNvbnN0IHByZXZpb3VzTm9kZSA9IG5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gIGNvbnN0IG5leHROb2RlID0gbm9kZS5nZXROZXh0U2libGluZygpO1xuICBpZiAocHJldmlvdXNOb2RlICE9PSBudWxsKSB7XG4gICAgaW50ZXJuYWxNYXJrTm9kZUFzRGlydHkocHJldmlvdXNOb2RlKTtcbiAgfVxuICBpZiAobmV4dE5vZGUgIT09IG51bGwpIHtcbiAgICBpbnRlcm5hbE1hcmtOb2RlQXNEaXJ0eShuZXh0Tm9kZSk7XG4gIH1cbn1cbmZ1bmN0aW9uICRzZXRDb21wb3NpdGlvbktleShjb21wb3NpdGlvbktleSkge1xuICBlcnJvck9uUmVhZE9ubHkoKTtcbiAgY29uc3QgZWRpdG9yID0gZ2V0QWN0aXZlRWRpdG9yKCk7XG4gIGNvbnN0IHByZXZpb3VzQ29tcG9zaXRpb25LZXkgPSBlZGl0b3IuX2NvbXBvc2l0aW9uS2V5O1xuICBpZiAoY29tcG9zaXRpb25LZXkgIT09IHByZXZpb3VzQ29tcG9zaXRpb25LZXkpIHtcbiAgICBlZGl0b3IuX2NvbXBvc2l0aW9uS2V5ID0gY29tcG9zaXRpb25LZXk7XG4gICAgaWYgKHByZXZpb3VzQ29tcG9zaXRpb25LZXkgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSAkZ2V0Tm9kZUJ5S2V5KHByZXZpb3VzQ29tcG9zaXRpb25LZXkpO1xuICAgICAgaWYgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZS5nZXRXcml0YWJsZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29tcG9zaXRpb25LZXkgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSAkZ2V0Tm9kZUJ5S2V5KGNvbXBvc2l0aW9uS2V5KTtcbiAgICAgIGlmIChub2RlICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuZ2V0V3JpdGFibGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uICRnZXRDb21wb3NpdGlvbktleSgpIHtcbiAgaWYgKGlzQ3VycmVudGx5UmVhZE9ubHlNb2RlKCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBlZGl0b3IgPSBnZXRBY3RpdmVFZGl0b3IoKTtcbiAgcmV0dXJuIGVkaXRvci5fY29tcG9zaXRpb25LZXk7XG59XG5mdW5jdGlvbiAkZ2V0Tm9kZUJ5S2V5KGtleSwgX2VkaXRvclN0YXRlKSB7XG4gIGNvbnN0IGVkaXRvclN0YXRlID0gX2VkaXRvclN0YXRlIHx8IGdldEFjdGl2ZUVkaXRvclN0YXRlKCk7XG4gIGNvbnN0IG5vZGUgPSBlZGl0b3JTdGF0ZS5fbm9kZU1hcC5nZXQoa2V5KTtcbiAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gJGdldE5vZGVGcm9tRE9NTm9kZShkb20sIGVkaXRvclN0YXRlKSB7XG4gIGNvbnN0IGVkaXRvciA9IGdldEFjdGl2ZUVkaXRvcigpO1xuICBjb25zdCBrZXkgPSBnZXROb2RlS2V5RnJvbURPTU5vZGUoZG9tLCBlZGl0b3IpO1xuICBpZiAoa2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gJGdldE5vZGVCeUtleShrZXksIGVkaXRvclN0YXRlKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHNldE5vZGVLZXlPbkRPTU5vZGUoZG9tLCBlZGl0b3IsIGtleSkge1xuICBjb25zdCBwcm9wID0gYF9fbGV4aWNhbEtleV8ke2VkaXRvci5fa2V5fWA7XG4gIGRvbVtwcm9wXSA9IGtleTtcbn1cbmZ1bmN0aW9uIGdldE5vZGVLZXlGcm9tRE9NTm9kZShkb20sIGVkaXRvcikge1xuICBjb25zdCBwcm9wID0gYF9fbGV4aWNhbEtleV8ke2VkaXRvci5fa2V5fWA7XG4gIHJldHVybiBkb21bcHJvcF07XG59XG5mdW5jdGlvbiAkZ2V0TmVhcmVzdE5vZGVGcm9tRE9NTm9kZShzdGFydGluZ0RPTSwgZWRpdG9yU3RhdGUpIHtcbiAgbGV0IGRvbSA9IHN0YXJ0aW5nRE9NO1xuICB3aGlsZSAoZG9tICE9IG51bGwpIHtcbiAgICBjb25zdCBub2RlID0gJGdldE5vZGVGcm9tRE9NTm9kZShkb20sIGVkaXRvclN0YXRlKTtcbiAgICBpZiAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIGRvbSA9IGdldFBhcmVudEVsZW1lbnQoZG9tKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGNsb25lRGVjb3JhdG9ycyhlZGl0b3IpIHtcbiAgY29uc3QgY3VycmVudERlY29yYXRvcnMgPSBlZGl0b3IuX2RlY29yYXRvcnM7XG4gIGNvbnN0IHBlbmRpbmdEZWNvcmF0b3JzID0gT2JqZWN0LmFzc2lnbih7fSwgY3VycmVudERlY29yYXRvcnMpO1xuICBlZGl0b3IuX3BlbmRpbmdEZWNvcmF0b3JzID0gcGVuZGluZ0RlY29yYXRvcnM7XG4gIHJldHVybiBwZW5kaW5nRGVjb3JhdG9ycztcbn1cbmZ1bmN0aW9uIGdldEVkaXRvclN0YXRlVGV4dENvbnRlbnQoZWRpdG9yU3RhdGUpIHtcbiAgcmV0dXJuIGVkaXRvclN0YXRlLnJlYWQoKCkgPT4gJGdldFJvb3QoKS5nZXRUZXh0Q29udGVudCgpKTtcbn1cbmZ1bmN0aW9uIG1hcmtOb2Rlc1dpdGhUeXBlc0FzRGlydHkoZWRpdG9yLCB0eXBlcykge1xuICAvLyBXZSBvbmx5IG5lZWQgdG8gbWFyayBub2RlcyBkaXJ0eSBpZiB0aGV5IHdlcmUgaW4gdGhlIHByZXZpb3VzIHN0YXRlLlxuICAvLyBJZiB0aGV5IGFyZW4ndCwgdGhlbiB0aGV5IGFyZSBieSBkZWZpbml0aW9uIGRpcnR5IGFscmVhZHkuXG4gIGNvbnN0IGNhY2hlZE1hcCA9IGdldENhY2hlZFR5cGVUb05vZGVNYXAoZWRpdG9yLmdldEVkaXRvclN0YXRlKCkpO1xuICBjb25zdCBkaXJ0eU5vZGVNYXBzID0gW107XG4gIGZvciAoY29uc3QgdHlwZSBvZiB0eXBlcykge1xuICAgIGNvbnN0IG5vZGVNYXAgPSBjYWNoZWRNYXAuZ2V0KHR5cGUpO1xuICAgIGlmIChub2RlTWFwKSB7XG4gICAgICAvLyBCeSBjb25zdHJ1Y3Rpb24gdGhlc2UgYXJlIG5vbi1lbXB0eVxuICAgICAgZGlydHlOb2RlTWFwcy5wdXNoKG5vZGVNYXApO1xuICAgIH1cbiAgfVxuICAvLyBOb3RoaW5nIHRvIG1hcmsgZGlydHksIG5vIHVwZGF0ZSBuZWNlc3NhcnlcbiAgaWYgKGRpcnR5Tm9kZU1hcHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgIGZvciAoY29uc3Qgbm9kZU1hcCBvZiBkaXJ0eU5vZGVNYXBzKSB7XG4gICAgICBmb3IgKGNvbnN0IG5vZGVLZXkgb2Ygbm9kZU1hcC5rZXlzKCkpIHtcbiAgICAgICAgLy8gV2UgYXJlIG9ubHkgY29uY2VybmVkIHdpdGggbm9kZXMgdGhhdCBhcmUgc3RpbGwgaW4gdGhlIGxhdGVzdCBOb2RlTWFwLFxuICAgICAgICAvLyBpZiB0aGV5IG5vIGxvbmdlciBleGlzdCB0aGVuIG1hcmtEaXJ0eSB3b3VsZCByYWlzZSBhbiBleGNlcHRpb25cbiAgICAgICAgY29uc3QgbGF0ZXN0ID0gJGdldE5vZGVCeUtleShub2RlS2V5KTtcbiAgICAgICAgaWYgKGxhdGVzdCkge1xuICAgICAgICAgIGxhdGVzdC5tYXJrRGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwgZWRpdG9yLl9wZW5kaW5nRWRpdG9yU3RhdGUgPT09IG51bGwgPyB7XG4gICAgdGFnOiAnaGlzdG9yeS1tZXJnZSdcbiAgfSA6IHVuZGVmaW5lZCk7XG59XG5mdW5jdGlvbiAkZ2V0Um9vdCgpIHtcbiAgcmV0dXJuIGludGVybmFsR2V0Um9vdChnZXRBY3RpdmVFZGl0b3JTdGF0ZSgpKTtcbn1cbmZ1bmN0aW9uIGludGVybmFsR2V0Um9vdChlZGl0b3JTdGF0ZSkge1xuICByZXR1cm4gZWRpdG9yU3RhdGUuX25vZGVNYXAuZ2V0KCdyb290Jyk7XG59XG5mdW5jdGlvbiAkc2V0U2VsZWN0aW9uKHNlbGVjdGlvbikge1xuICBlcnJvck9uUmVhZE9ubHkoKTtcbiAgY29uc3QgZWRpdG9yU3RhdGUgPSBnZXRBY3RpdmVFZGl0b3JTdGF0ZSgpO1xuICBpZiAoc2VsZWN0aW9uICE9PSBudWxsKSB7XG4gICAge1xuICAgICAgaWYgKE9iamVjdC5pc0Zyb3plbihzZWxlY3Rpb24pKSB7XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihgJHNldFNlbGVjdGlvbiBjYWxsZWQgb24gZnJvemVuIHNlbGVjdGlvbiBvYmplY3QuIEVuc3VyZSBzZWxlY3Rpb24gaXMgY2xvbmVkIGJlZm9yZSBwYXNzaW5nIGluLmApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHNlbGVjdGlvbi5kaXJ0eSA9IHRydWU7XG4gICAgc2VsZWN0aW9uLnNldENhY2hlZE5vZGVzKG51bGwpO1xuICB9XG4gIGVkaXRvclN0YXRlLl9zZWxlY3Rpb24gPSBzZWxlY3Rpb247XG59XG5mdW5jdGlvbiAkZmx1c2hNdXRhdGlvbnMoKSB7XG4gIGVycm9yT25SZWFkT25seSgpO1xuICBjb25zdCBlZGl0b3IgPSBnZXRBY3RpdmVFZGl0b3IoKTtcbiAgJGZsdXNoUm9vdE11dGF0aW9ucyhlZGl0b3IpO1xufVxuZnVuY3Rpb24gJGdldE5vZGVGcm9tRE9NKGRvbSkge1xuICBjb25zdCBlZGl0b3IgPSBnZXRBY3RpdmVFZGl0b3IoKTtcbiAgY29uc3Qgbm9kZUtleSA9IGdldE5vZGVLZXlGcm9tRE9NVHJlZShkb20sIGVkaXRvcik7XG4gIGlmIChub2RlS2V5ID09PSBudWxsKSB7XG4gICAgY29uc3Qgcm9vdEVsZW1lbnQgPSBlZGl0b3IuZ2V0Um9vdEVsZW1lbnQoKTtcbiAgICBpZiAoZG9tID09PSByb290RWxlbWVudCkge1xuICAgICAgcmV0dXJuICRnZXROb2RlQnlLZXkoJ3Jvb3QnKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuICRnZXROb2RlQnlLZXkobm9kZUtleSk7XG59XG5mdW5jdGlvbiBnZXRUZXh0Tm9kZU9mZnNldChub2RlLCBtb3ZlU2VsZWN0aW9uVG9FbmQpIHtcbiAgcmV0dXJuIG1vdmVTZWxlY3Rpb25Ub0VuZCA/IG5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCkgOiAwO1xufVxuZnVuY3Rpb24gZ2V0Tm9kZUtleUZyb21ET01UcmVlKFxuLy8gTm90ZSB0aGF0IG5vZGUgaGVyZSByZWZlcnMgdG8gYSBET00gTm9kZSwgbm90IGFuIExleGljYWwgTm9kZVxuZG9tLCBlZGl0b3IpIHtcbiAgbGV0IG5vZGUgPSBkb207XG4gIHdoaWxlIChub2RlICE9IG51bGwpIHtcbiAgICBjb25zdCBrZXkgPSBnZXROb2RlS2V5RnJvbURPTU5vZGUobm9kZSwgZWRpdG9yKTtcbiAgICBpZiAoa2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuICAgIG5vZGUgPSBnZXRQYXJlbnRFbGVtZW50KG5vZGUpO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZG9lc0NvbnRhaW5HcmFwaGVtZShzdHIpIHtcbiAgcmV0dXJuIC9bXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdL2cudGVzdChzdHIpO1xufVxuZnVuY3Rpb24gZ2V0RWRpdG9yc1RvUHJvcGFnYXRlKGVkaXRvcikge1xuICBjb25zdCBlZGl0b3JzVG9Qcm9wYWdhdGUgPSBbXTtcbiAgbGV0IGN1cnJlbnRFZGl0b3IgPSBlZGl0b3I7XG4gIHdoaWxlIChjdXJyZW50RWRpdG9yICE9PSBudWxsKSB7XG4gICAgZWRpdG9yc1RvUHJvcGFnYXRlLnB1c2goY3VycmVudEVkaXRvcik7XG4gICAgY3VycmVudEVkaXRvciA9IGN1cnJlbnRFZGl0b3IuX3BhcmVudEVkaXRvcjtcbiAgfVxuICByZXR1cm4gZWRpdG9yc1RvUHJvcGFnYXRlO1xufVxuZnVuY3Rpb24gY3JlYXRlVUlEKCkge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikucmVwbGFjZSgvW15hLXpdKy9nLCAnJykuc3Vic3RyKDAsIDUpO1xufVxuZnVuY3Rpb24gZ2V0QW5jaG9yVGV4dEZyb21ET00oYW5jaG9yTm9kZSkge1xuICByZXR1cm4gaXNET01UZXh0Tm9kZShhbmNob3JOb2RlKSA/IGFuY2hvck5vZGUubm9kZVZhbHVlIDogbnVsbDtcbn1cbmZ1bmN0aW9uICR1cGRhdGVTZWxlY3RlZFRleHRGcm9tRE9NKGlzQ29tcG9zaXRpb25FbmQsIGVkaXRvciwgZGF0YSkge1xuICAvLyBVcGRhdGUgdGhlIHRleHQgY29udGVudCB3aXRoIHRoZSBsYXRlc3QgY29tcG9zaXRpb24gdGV4dFxuICBjb25zdCBkb21TZWxlY3Rpb24gPSBnZXRET01TZWxlY3Rpb24oZWRpdG9yLl93aW5kb3cpO1xuICBpZiAoZG9tU2VsZWN0aW9uID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGFuY2hvck5vZGUgPSBkb21TZWxlY3Rpb24uYW5jaG9yTm9kZTtcbiAgbGV0IHtcbiAgICBhbmNob3JPZmZzZXQsXG4gICAgZm9jdXNPZmZzZXRcbiAgfSA9IGRvbVNlbGVjdGlvbjtcbiAgaWYgKGFuY2hvck5vZGUgIT09IG51bGwpIHtcbiAgICBsZXQgdGV4dENvbnRlbnQgPSBnZXRBbmNob3JUZXh0RnJvbURPTShhbmNob3JOb2RlKTtcbiAgICBjb25zdCBub2RlID0gJGdldE5lYXJlc3ROb2RlRnJvbURPTU5vZGUoYW5jaG9yTm9kZSk7XG4gICAgaWYgKHRleHRDb250ZW50ICE9PSBudWxsICYmICRpc1RleHROb2RlKG5vZGUpKSB7XG4gICAgICAvLyBEYXRhIGlzIGludGVudGlvbmFsbHkgdHJ1dGh5LCBhcyB3ZSBjaGVjayBmb3IgYm9vbGVhbiwgbnVsbCBhbmQgZW1wdHkgc3RyaW5nLlxuICAgICAgaWYgKHRleHRDb250ZW50ID09PSBDT01QT1NJVElPTl9TVUZGSVggJiYgZGF0YSkge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgdGV4dENvbnRlbnQgPSBkYXRhO1xuICAgICAgICBhbmNob3JPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIGZvY3VzT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgfVxuICAgICAgaWYgKHRleHRDb250ZW50ICE9PSBudWxsKSB7XG4gICAgICAgICR1cGRhdGVUZXh0Tm9kZUZyb21ET01Db250ZW50KG5vZGUsIHRleHRDb250ZW50LCBhbmNob3JPZmZzZXQsIGZvY3VzT2Zmc2V0LCBpc0NvbXBvc2l0aW9uRW5kKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uICR1cGRhdGVUZXh0Tm9kZUZyb21ET01Db250ZW50KHRleHROb2RlLCB0ZXh0Q29udGVudCwgYW5jaG9yT2Zmc2V0LCBmb2N1c09mZnNldCwgY29tcG9zaXRpb25FbmQpIHtcbiAgbGV0IG5vZGUgPSB0ZXh0Tm9kZTtcbiAgaWYgKG5vZGUuaXNBdHRhY2hlZCgpICYmIChjb21wb3NpdGlvbkVuZCB8fCAhbm9kZS5pc0RpcnR5KCkpKSB7XG4gICAgY29uc3QgaXNDb21wb3NpbmcgPSBub2RlLmlzQ29tcG9zaW5nKCk7XG4gICAgbGV0IG5vcm1hbGl6ZWRUZXh0Q29udGVudCA9IHRleHRDb250ZW50O1xuICAgIGlmICgoaXNDb21wb3NpbmcgfHwgY29tcG9zaXRpb25FbmQpICYmIHRleHRDb250ZW50W3RleHRDb250ZW50Lmxlbmd0aCAtIDFdID09PSBDT01QT1NJVElPTl9TVUZGSVgpIHtcbiAgICAgIG5vcm1hbGl6ZWRUZXh0Q29udGVudCA9IHRleHRDb250ZW50LnNsaWNlKDAsIC0xKTtcbiAgICB9XG4gICAgY29uc3QgcHJldlRleHRDb250ZW50ID0gbm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICAgIGlmIChjb21wb3NpdGlvbkVuZCB8fCBub3JtYWxpemVkVGV4dENvbnRlbnQgIT09IHByZXZUZXh0Q29udGVudCkge1xuICAgICAgaWYgKG5vcm1hbGl6ZWRUZXh0Q29udGVudCA9PT0gJycpIHtcbiAgICAgICAgJHNldENvbXBvc2l0aW9uS2V5KG51bGwpO1xuICAgICAgICBpZiAoIUlTX1NBRkFSSSAmJiAhSVNfSU9TICYmICFJU19BUFBMRV9XRUJLSVQpIHtcbiAgICAgICAgICAvLyBGb3IgY29tcG9zaXRpb24gKG1haW5seSBBbmRyb2lkKSwgd2UgaGF2ZSB0byByZW1vdmUgdGhlIG5vZGUgb24gYSBsYXRlciB1cGRhdGVcbiAgICAgICAgICBjb25zdCBlZGl0b3IgPSBnZXRBY3RpdmVFZGl0b3IoKTtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAobm9kZS5pc0F0dGFjaGVkKCkpIHtcbiAgICAgICAgICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LCAyMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBwYXJlbnQgPSBub2RlLmdldFBhcmVudCgpO1xuICAgICAgY29uc3QgcHJldlNlbGVjdGlvbiA9ICRnZXRQcmV2aW91c1NlbGVjdGlvbigpO1xuICAgICAgY29uc3QgcHJldlRleHRDb250ZW50U2l6ZSA9IG5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCk7XG4gICAgICBjb25zdCBjb21wb3NpdGlvbktleSA9ICRnZXRDb21wb3NpdGlvbktleSgpO1xuICAgICAgY29uc3Qgbm9kZUtleSA9IG5vZGUuZ2V0S2V5KCk7XG4gICAgICBpZiAobm9kZS5pc1Rva2VuKCkgfHwgY29tcG9zaXRpb25LZXkgIT09IG51bGwgJiYgbm9kZUtleSA9PT0gY29tcG9zaXRpb25LZXkgJiYgIWlzQ29tcG9zaW5nIHx8XG4gICAgICAvLyBDaGVjayBpZiBjaGFyYWN0ZXIgd2FzIGFkZGVkIGF0IHRoZSBzdGFydCBvciBib3VuZGFyaWVzIHdoZW4gbm90IGluc2VydGFibGUsIGFuZCB3ZSBuZWVkXG4gICAgICAvLyB0byBjbGVhciB0aGlzIGlucHV0IGZyb20gb2NjdXJyaW5nIGFzIHRoYXQgYWN0aW9uIHdhc24ndCBwZXJtaXR0ZWQuXG4gICAgICAkaXNSYW5nZVNlbGVjdGlvbihwcmV2U2VsZWN0aW9uKSAmJiAocGFyZW50ICE9PSBudWxsICYmICFwYXJlbnQuY2FuSW5zZXJ0VGV4dEJlZm9yZSgpICYmIHByZXZTZWxlY3Rpb24uYW5jaG9yLm9mZnNldCA9PT0gMCB8fCBwcmV2U2VsZWN0aW9uLmFuY2hvci5rZXkgPT09IHRleHROb2RlLl9fa2V5ICYmIHByZXZTZWxlY3Rpb24uYW5jaG9yLm9mZnNldCA9PT0gMCAmJiAhbm9kZS5jYW5JbnNlcnRUZXh0QmVmb3JlKCkgJiYgIWlzQ29tcG9zaW5nIHx8IHByZXZTZWxlY3Rpb24uZm9jdXMua2V5ID09PSB0ZXh0Tm9kZS5fX2tleSAmJiBwcmV2U2VsZWN0aW9uLmZvY3VzLm9mZnNldCA9PT0gcHJldlRleHRDb250ZW50U2l6ZSAmJiAhbm9kZS5jYW5JbnNlcnRUZXh0QWZ0ZXIoKSAmJiAhaXNDb21wb3NpbmcpKSB7XG4gICAgICAgIG5vZGUubWFya0RpcnR5KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICAgIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSB8fCBhbmNob3JPZmZzZXQgPT09IG51bGwgfHwgZm9jdXNPZmZzZXQgPT09IG51bGwpIHtcbiAgICAgICAgbm9kZS5zZXRUZXh0Q29udGVudChub3JtYWxpemVkVGV4dENvbnRlbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZWxlY3Rpb24uc2V0VGV4dE5vZGVSYW5nZShub2RlLCBhbmNob3JPZmZzZXQsIG5vZGUsIGZvY3VzT2Zmc2V0KTtcbiAgICAgIGlmIChub2RlLmlzU2VnbWVudGVkKCkpIHtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxUZXh0Q29udGVudCA9IG5vZGUuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICAgICAgY29uc3QgcmVwbGFjZW1lbnQgPSAkY3JlYXRlVGV4dE5vZGUob3JpZ2luYWxUZXh0Q29udGVudCk7XG4gICAgICAgIG5vZGUucmVwbGFjZShyZXBsYWNlbWVudCk7XG4gICAgICAgIG5vZGUgPSByZXBsYWNlbWVudDtcbiAgICAgIH1cbiAgICAgIG5vZGUuc2V0VGV4dENvbnRlbnQobm9ybWFsaXplZFRleHRDb250ZW50KTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uICRwcmV2aW91c1NpYmxpbmdEb2VzTm90QWNjZXB0VGV4dChub2RlKSB7XG4gIGNvbnN0IHByZXZpb3VzU2libGluZyA9IG5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gIHJldHVybiAoJGlzVGV4dE5vZGUocHJldmlvdXNTaWJsaW5nKSB8fCAkaXNFbGVtZW50Tm9kZShwcmV2aW91c1NpYmxpbmcpICYmIHByZXZpb3VzU2libGluZy5pc0lubGluZSgpKSAmJiAhcHJldmlvdXNTaWJsaW5nLmNhbkluc2VydFRleHRBZnRlcigpO1xufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGNvbm5lY3RlZCB0byAkc2hvdWxkUHJldmVudERlZmF1bHRBbmRJbnNlcnRUZXh0IGFuZCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlXG4vLyBUZXh0Tm9kZSBib3VuZGFyaWVzIGFyZSB3cml0YWJsZSBvciB3ZSBzaG91bGQgdXNlIHRoZSBwcmV2aW91cy9uZXh0IHNpYmxpbmcgaW5zdGVhZC4gRm9yIGV4YW1wbGUsXG4vLyBpbiB0aGUgY2FzZSBvZiBhIExpbmtOb2RlLCBib3VuZGFyaWVzIGFyZSBub3Qgd3JpdGFibGUuXG5mdW5jdGlvbiAkc2hvdWxkSW5zZXJ0VGV4dEFmdGVyT3JCZWZvcmVUZXh0Tm9kZShzZWxlY3Rpb24sIG5vZGUpIHtcbiAgaWYgKG5vZGUuaXNTZWdtZW50ZWQoKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICghc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3Qgb2Zmc2V0ID0gc2VsZWN0aW9uLmFuY2hvci5vZmZzZXQ7XG4gIGNvbnN0IHBhcmVudCA9IG5vZGUuZ2V0UGFyZW50T3JUaHJvdygpO1xuICBjb25zdCBpc1Rva2VuID0gbm9kZS5pc1Rva2VuKCk7XG4gIGlmIChvZmZzZXQgPT09IDApIHtcbiAgICByZXR1cm4gIW5vZGUuY2FuSW5zZXJ0VGV4dEJlZm9yZSgpIHx8ICFwYXJlbnQuY2FuSW5zZXJ0VGV4dEJlZm9yZSgpICYmICFub2RlLmlzQ29tcG9zaW5nKCkgfHwgaXNUb2tlbiB8fCAkcHJldmlvdXNTaWJsaW5nRG9lc05vdEFjY2VwdFRleHQobm9kZSk7XG4gIH0gZWxzZSBpZiAob2Zmc2V0ID09PSBub2RlLmdldFRleHRDb250ZW50U2l6ZSgpKSB7XG4gICAgcmV0dXJuICFub2RlLmNhbkluc2VydFRleHRBZnRlcigpIHx8ICFwYXJlbnQuY2FuSW5zZXJ0VGV4dEFmdGVyKCkgJiYgIW5vZGUuaXNDb21wb3NpbmcoKSB8fCBpc1Rva2VuO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gaXNUYWIoa2V5LCBhbHRLZXksIGN0cmxLZXksIG1ldGFLZXkpIHtcbiAgcmV0dXJuIGtleSA9PT0gJ1RhYicgJiYgIWFsdEtleSAmJiAhY3RybEtleSAmJiAhbWV0YUtleTtcbn1cbmZ1bmN0aW9uIGlzQm9sZChrZXksIGFsdEtleSwgbWV0YUtleSwgY3RybEtleSkge1xuICByZXR1cm4ga2V5LnRvTG93ZXJDYXNlKCkgPT09ICdiJyAmJiAhYWx0S2V5ICYmIGNvbnRyb2xPck1ldGEobWV0YUtleSwgY3RybEtleSk7XG59XG5mdW5jdGlvbiBpc0l0YWxpYyhrZXksIGFsdEtleSwgbWV0YUtleSwgY3RybEtleSkge1xuICByZXR1cm4ga2V5LnRvTG93ZXJDYXNlKCkgPT09ICdpJyAmJiAhYWx0S2V5ICYmIGNvbnRyb2xPck1ldGEobWV0YUtleSwgY3RybEtleSk7XG59XG5mdW5jdGlvbiBpc1VuZGVybGluZShrZXksIGFsdEtleSwgbWV0YUtleSwgY3RybEtleSkge1xuICByZXR1cm4ga2V5LnRvTG93ZXJDYXNlKCkgPT09ICd1JyAmJiAhYWx0S2V5ICYmIGNvbnRyb2xPck1ldGEobWV0YUtleSwgY3RybEtleSk7XG59XG5mdW5jdGlvbiBpc1BhcmFncmFwaChrZXksIHNoaWZ0S2V5KSB7XG4gIHJldHVybiBpc1JldHVybihrZXkpICYmICFzaGlmdEtleTtcbn1cbmZ1bmN0aW9uIGlzTGluZUJyZWFrKGtleSwgc2hpZnRLZXkpIHtcbiAgcmV0dXJuIGlzUmV0dXJuKGtleSkgJiYgc2hpZnRLZXk7XG59XG5cbi8vIEluc2VydHMgYSBuZXcgbGluZSBhZnRlciB0aGUgc2VsZWN0aW9uXG5cbmZ1bmN0aW9uIGlzT3BlbkxpbmVCcmVhayhrZXksIGN0cmxLZXkpIHtcbiAgLy8gNzkgPSBLZXlPXG4gIHJldHVybiBJU19BUFBMRSAmJiBjdHJsS2V5ICYmIGtleS50b0xvd2VyQ2FzZSgpID09PSAnbyc7XG59XG5mdW5jdGlvbiBpc0RlbGV0ZVdvcmRCYWNrd2FyZChrZXksIGFsdEtleSwgY3RybEtleSkge1xuICByZXR1cm4gaXNCYWNrc3BhY2Uoa2V5KSAmJiAoSVNfQVBQTEUgPyBhbHRLZXkgOiBjdHJsS2V5KTtcbn1cbmZ1bmN0aW9uIGlzRGVsZXRlV29yZEZvcndhcmQoa2V5LCBhbHRLZXksIGN0cmxLZXkpIHtcbiAgcmV0dXJuIGlzRGVsZXRlKGtleSkgJiYgKElTX0FQUExFID8gYWx0S2V5IDogY3RybEtleSk7XG59XG5mdW5jdGlvbiBpc0RlbGV0ZUxpbmVCYWNrd2FyZChrZXksIG1ldGFLZXkpIHtcbiAgcmV0dXJuIElTX0FQUExFICYmIG1ldGFLZXkgJiYgaXNCYWNrc3BhY2Uoa2V5KTtcbn1cbmZ1bmN0aW9uIGlzRGVsZXRlTGluZUZvcndhcmQoa2V5LCBtZXRhS2V5KSB7XG4gIHJldHVybiBJU19BUFBMRSAmJiBtZXRhS2V5ICYmIGlzRGVsZXRlKGtleSk7XG59XG5mdW5jdGlvbiBpc0RlbGV0ZUJhY2t3YXJkKGtleSwgYWx0S2V5LCBtZXRhS2V5LCBjdHJsS2V5KSB7XG4gIGlmIChJU19BUFBMRSkge1xuICAgIGlmIChhbHRLZXkgfHwgbWV0YUtleSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gaXNCYWNrc3BhY2Uoa2V5KSB8fCBrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2gnICYmIGN0cmxLZXk7XG4gIH1cbiAgaWYgKGN0cmxLZXkgfHwgYWx0S2V5IHx8IG1ldGFLZXkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzQmFja3NwYWNlKGtleSk7XG59XG5mdW5jdGlvbiBpc0RlbGV0ZUZvcndhcmQoa2V5LCBjdHJsS2V5LCBzaGlmdEtleSwgYWx0S2V5LCBtZXRhS2V5KSB7XG4gIGlmIChJU19BUFBMRSkge1xuICAgIGlmIChzaGlmdEtleSB8fCBhbHRLZXkgfHwgbWV0YUtleSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gaXNEZWxldGUoa2V5KSB8fCBrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2QnICYmIGN0cmxLZXk7XG4gIH1cbiAgaWYgKGN0cmxLZXkgfHwgYWx0S2V5IHx8IG1ldGFLZXkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzRGVsZXRlKGtleSk7XG59XG5mdW5jdGlvbiBpc1VuZG8oa2V5LCBzaGlmdEtleSwgbWV0YUtleSwgY3RybEtleSkge1xuICByZXR1cm4ga2V5LnRvTG93ZXJDYXNlKCkgPT09ICd6JyAmJiAhc2hpZnRLZXkgJiYgY29udHJvbE9yTWV0YShtZXRhS2V5LCBjdHJsS2V5KTtcbn1cbmZ1bmN0aW9uIGlzUmVkbyhrZXksIHNoaWZ0S2V5LCBtZXRhS2V5LCBjdHJsS2V5KSB7XG4gIGlmIChJU19BUFBMRSkge1xuICAgIHJldHVybiBrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ3onICYmIG1ldGFLZXkgJiYgc2hpZnRLZXk7XG4gIH1cbiAgcmV0dXJuIGtleS50b0xvd2VyQ2FzZSgpID09PSAneScgJiYgY3RybEtleSB8fCBrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ3onICYmIGN0cmxLZXkgJiYgc2hpZnRLZXk7XG59XG5mdW5jdGlvbiBpc0NvcHkoa2V5LCBzaGlmdEtleSwgbWV0YUtleSwgY3RybEtleSkge1xuICBpZiAoc2hpZnRLZXkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGtleS50b0xvd2VyQ2FzZSgpID09PSAnYycpIHtcbiAgICByZXR1cm4gSVNfQVBQTEUgPyBtZXRhS2V5IDogY3RybEtleTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc0N1dChrZXksIHNoaWZ0S2V5LCBtZXRhS2V5LCBjdHJsS2V5KSB7XG4gIGlmIChzaGlmdEtleSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoa2V5LnRvTG93ZXJDYXNlKCkgPT09ICd4Jykge1xuICAgIHJldHVybiBJU19BUFBMRSA/IG1ldGFLZXkgOiBjdHJsS2V5O1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzQXJyb3dMZWZ0KGtleSkge1xuICByZXR1cm4ga2V5ID09PSAnQXJyb3dMZWZ0Jztcbn1cbmZ1bmN0aW9uIGlzQXJyb3dSaWdodChrZXkpIHtcbiAgcmV0dXJuIGtleSA9PT0gJ0Fycm93UmlnaHQnO1xufVxuZnVuY3Rpb24gaXNBcnJvd1VwKGtleSkge1xuICByZXR1cm4ga2V5ID09PSAnQXJyb3dVcCc7XG59XG5mdW5jdGlvbiBpc0Fycm93RG93bihrZXkpIHtcbiAgcmV0dXJuIGtleSA9PT0gJ0Fycm93RG93bic7XG59XG5mdW5jdGlvbiBpc01vdmVCYWNrd2FyZChrZXksIGN0cmxLZXksIGFsdEtleSwgbWV0YUtleSkge1xuICByZXR1cm4gaXNBcnJvd0xlZnQoa2V5KSAmJiAhY3RybEtleSAmJiAhbWV0YUtleSAmJiAhYWx0S2V5O1xufVxuZnVuY3Rpb24gaXNNb3ZlVG9TdGFydChrZXksIGN0cmxLZXksIHNoaWZ0S2V5LCBhbHRLZXksIG1ldGFLZXkpIHtcbiAgcmV0dXJuIGlzQXJyb3dMZWZ0KGtleSkgJiYgIWFsdEtleSAmJiAhc2hpZnRLZXkgJiYgKGN0cmxLZXkgfHwgbWV0YUtleSk7XG59XG5mdW5jdGlvbiBpc01vdmVGb3J3YXJkKGtleSwgY3RybEtleSwgYWx0S2V5LCBtZXRhS2V5KSB7XG4gIHJldHVybiBpc0Fycm93UmlnaHQoa2V5KSAmJiAhY3RybEtleSAmJiAhbWV0YUtleSAmJiAhYWx0S2V5O1xufVxuZnVuY3Rpb24gaXNNb3ZlVG9FbmQoa2V5LCBjdHJsS2V5LCBzaGlmdEtleSwgYWx0S2V5LCBtZXRhS2V5KSB7XG4gIHJldHVybiBpc0Fycm93UmlnaHQoa2V5KSAmJiAhYWx0S2V5ICYmICFzaGlmdEtleSAmJiAoY3RybEtleSB8fCBtZXRhS2V5KTtcbn1cbmZ1bmN0aW9uIGlzTW92ZVVwKGtleSwgY3RybEtleSwgbWV0YUtleSkge1xuICByZXR1cm4gaXNBcnJvd1VwKGtleSkgJiYgIWN0cmxLZXkgJiYgIW1ldGFLZXk7XG59XG5mdW5jdGlvbiBpc01vdmVEb3duKGtleSwgY3RybEtleSwgbWV0YUtleSkge1xuICByZXR1cm4gaXNBcnJvd0Rvd24oa2V5KSAmJiAhY3RybEtleSAmJiAhbWV0YUtleTtcbn1cbmZ1bmN0aW9uIGlzTW9kaWZpZXIoY3RybEtleSwgc2hpZnRLZXksIGFsdEtleSwgbWV0YUtleSkge1xuICByZXR1cm4gY3RybEtleSB8fCBzaGlmdEtleSB8fCBhbHRLZXkgfHwgbWV0YUtleTtcbn1cbmZ1bmN0aW9uIGlzU3BhY2Uoa2V5KSB7XG4gIHJldHVybiBrZXkgPT09ICcgJztcbn1cbmZ1bmN0aW9uIGNvbnRyb2xPck1ldGEobWV0YUtleSwgY3RybEtleSkge1xuICBpZiAoSVNfQVBQTEUpIHtcbiAgICByZXR1cm4gbWV0YUtleTtcbiAgfVxuICByZXR1cm4gY3RybEtleTtcbn1cbmZ1bmN0aW9uIGlzUmV0dXJuKGtleSkge1xuICByZXR1cm4ga2V5ID09PSAnRW50ZXInO1xufVxuZnVuY3Rpb24gaXNCYWNrc3BhY2Uoa2V5KSB7XG4gIHJldHVybiBrZXkgPT09ICdCYWNrc3BhY2UnO1xufVxuZnVuY3Rpb24gaXNFc2NhcGUoa2V5KSB7XG4gIHJldHVybiBrZXkgPT09ICdFc2NhcGUnO1xufVxuZnVuY3Rpb24gaXNEZWxldGUoa2V5KSB7XG4gIHJldHVybiBrZXkgPT09ICdEZWxldGUnO1xufVxuZnVuY3Rpb24gaXNTZWxlY3RBbGwoa2V5LCBtZXRhS2V5LCBjdHJsS2V5KSB7XG4gIHJldHVybiBrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2EnICYmIGNvbnRyb2xPck1ldGEobWV0YUtleSwgY3RybEtleSk7XG59XG5mdW5jdGlvbiAkc2VsZWN0QWxsKHNlbGVjdGlvbikge1xuICBjb25zdCByb290ID0gJGdldFJvb3QoKTtcbiAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICAgIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICAgIGNvbnN0IGFuY2hvck5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICAgIGNvbnN0IHRvcFBhcmVudCA9IGFuY2hvck5vZGUuZ2V0VG9wTGV2ZWxFbGVtZW50T3JUaHJvdygpO1xuICAgIGNvbnN0IHJvb3ROb2RlID0gdG9wUGFyZW50LmdldFBhcmVudE9yVGhyb3coKTtcbiAgICBhbmNob3Iuc2V0KHJvb3ROb2RlLmdldEtleSgpLCAwLCAnZWxlbWVudCcpO1xuICAgIGZvY3VzLnNldChyb290Tm9kZS5nZXRLZXkoKSwgcm9vdE5vZGUuZ2V0Q2hpbGRyZW5TaXplKCksICdlbGVtZW50Jyk7XG4gICAgJG5vcm1hbGl6ZVNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgIHJldHVybiBzZWxlY3Rpb247XG4gIH0gZWxzZSB7XG4gICAgLy8gQ3JlYXRlIGEgbmV3IFJhbmdlU2VsZWN0aW9uXG4gICAgY29uc3QgbmV3U2VsZWN0aW9uID0gcm9vdC5zZWxlY3QoMCwgcm9vdC5nZXRDaGlsZHJlblNpemUoKSk7XG4gICAgJHNldFNlbGVjdGlvbigkbm9ybWFsaXplU2VsZWN0aW9uKG5ld1NlbGVjdGlvbikpO1xuICAgIHJldHVybiBuZXdTZWxlY3Rpb247XG4gIH1cbn1cbmZ1bmN0aW9uIGdldENhY2hlZENsYXNzTmFtZUFycmF5KGNsYXNzTmFtZXNUaGVtZSwgY2xhc3NOYW1lVGhlbWVUeXBlKSB7XG4gIGlmIChjbGFzc05hbWVzVGhlbWUuX19sZXhpY2FsQ2xhc3NOYW1lQ2FjaGUgPT09IHVuZGVmaW5lZCkge1xuICAgIGNsYXNzTmFtZXNUaGVtZS5fX2xleGljYWxDbGFzc05hbWVDYWNoZSA9IHt9O1xuICB9XG4gIGNvbnN0IGNsYXNzTmFtZXNDYWNoZSA9IGNsYXNzTmFtZXNUaGVtZS5fX2xleGljYWxDbGFzc05hbWVDYWNoZTtcbiAgY29uc3QgY2FjaGVkQ2xhc3NOYW1lcyA9IGNsYXNzTmFtZXNDYWNoZVtjbGFzc05hbWVUaGVtZVR5cGVdO1xuICBpZiAoY2FjaGVkQ2xhc3NOYW1lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGNhY2hlZENsYXNzTmFtZXM7XG4gIH1cbiAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzTmFtZXNUaGVtZVtjbGFzc05hbWVUaGVtZVR5cGVdO1xuICAvLyBBcyB3ZSdyZSB1c2luZyBjbGFzc0xpc3QsIHdlIG5lZWRcbiAgLy8gdG8gaGFuZGxlIGNsYXNzTmFtZSB0b2tlbnMgdGhhdCBoYXZlIHNwYWNlcy5cbiAgLy8gVGhlIGVhc2llc3Qgd2F5IHRvIGRvIHRoaXMgdG8gY29udmVydCB0aGVcbiAgLy8gY2xhc3NOYW1lIHRva2VucyB0byBhbiBhcnJheSB0aGF0IGNhbiBiZVxuICAvLyBhcHBsaWVkIHRvIGNsYXNzTGlzdC5hZGQoKS9yZW1vdmUoKS5cbiAgaWYgKHR5cGVvZiBjbGFzc05hbWVzID09PSAnc3RyaW5nJykge1xuICAgIGNvbnN0IGNsYXNzTmFtZXNBcnIgPSBub3JtYWxpemVDbGFzc05hbWVzKGNsYXNzTmFtZXMpO1xuICAgIGNsYXNzTmFtZXNDYWNoZVtjbGFzc05hbWVUaGVtZVR5cGVdID0gY2xhc3NOYW1lc0FycjtcbiAgICByZXR1cm4gY2xhc3NOYW1lc0FycjtcbiAgfVxuICByZXR1cm4gY2xhc3NOYW1lcztcbn1cbmZ1bmN0aW9uIHNldE11dGF0ZWROb2RlKG11dGF0ZWROb2RlcywgcmVnaXN0ZXJlZE5vZGVzLCBtdXRhdGlvbkxpc3RlbmVycywgbm9kZSwgbXV0YXRpb24pIHtcbiAgaWYgKG11dGF0aW9uTGlzdGVuZXJzLnNpemUgPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLl9fdHlwZTtcbiAgY29uc3Qgbm9kZUtleSA9IG5vZGUuX19rZXk7XG4gIGNvbnN0IHJlZ2lzdGVyZWROb2RlID0gcmVnaXN0ZXJlZE5vZGVzLmdldChub2RlVHlwZSk7XG4gIGlmIChyZWdpc3RlcmVkTm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYFR5cGUgJHtub2RlVHlwZX0gbm90IGluIHJlZ2lzdGVyZWROb2Rlc2ApO1xuICAgIH1cbiAgfVxuICBjb25zdCBrbGFzcyA9IHJlZ2lzdGVyZWROb2RlLmtsYXNzO1xuICBsZXQgbXV0YXRlZE5vZGVzQnlUeXBlID0gbXV0YXRlZE5vZGVzLmdldChrbGFzcyk7XG4gIGlmIChtdXRhdGVkTm9kZXNCeVR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgIG11dGF0ZWROb2Rlc0J5VHlwZSA9IG5ldyBNYXAoKTtcbiAgICBtdXRhdGVkTm9kZXMuc2V0KGtsYXNzLCBtdXRhdGVkTm9kZXNCeVR5cGUpO1xuICB9XG4gIGNvbnN0IHByZXZNdXRhdGlvbiA9IG11dGF0ZWROb2Rlc0J5VHlwZS5nZXQobm9kZUtleSk7XG4gIC8vIElmIHRoZSBub2RlIGhhcyBhbHJlYWR5IGJlZW4gXCJkZXN0cm95ZWRcIiwgeWV0IHdlIGFyZVxuICAvLyByZS1tYWtpbmcgaXQsIHRoZW4gdGhpcyBtZWFucyBhIG1vdmUgbGlrZWx5IGhhcHBlbmVkLlxuICAvLyBXZSBzaG91bGQgY2hhbmdlIHRoZSBtdXRhdGlvbiB0byBiZSB0aGF0IG9mIFwidXBkYXRlZFwiXG4gIC8vIGluc3RlYWQuXG4gIGNvbnN0IGlzTW92ZSA9IHByZXZNdXRhdGlvbiA9PT0gJ2Rlc3Ryb3llZCcgJiYgbXV0YXRpb24gPT09ICdjcmVhdGVkJztcbiAgaWYgKHByZXZNdXRhdGlvbiA9PT0gdW5kZWZpbmVkIHx8IGlzTW92ZSkge1xuICAgIG11dGF0ZWROb2Rlc0J5VHlwZS5zZXQobm9kZUtleSwgaXNNb3ZlID8gJ3VwZGF0ZWQnIDogbXV0YXRpb24pO1xuICB9XG59XG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgTGV4aWNhbEVkaXRvci5yZWdpc3Rlck11dGF0aW9uTGlzdGVuZXJ9IHdpdGggYHNraXBJbml0aWFsaXphdGlvbjogZmFsc2VgIGluc3RlYWQuXG4gKi9cbmZ1bmN0aW9uICRub2Rlc09mVHlwZShrbGFzcykge1xuICBjb25zdCBrbGFzc1R5cGUgPSBrbGFzcy5nZXRUeXBlKCk7XG4gIGNvbnN0IGVkaXRvclN0YXRlID0gZ2V0QWN0aXZlRWRpdG9yU3RhdGUoKTtcbiAgaWYgKGVkaXRvclN0YXRlLl9yZWFkT25seSkge1xuICAgIGNvbnN0IG5vZGVzID0gZ2V0Q2FjaGVkVHlwZVRvTm9kZU1hcChlZGl0b3JTdGF0ZSkuZ2V0KGtsYXNzVHlwZSk7XG4gICAgcmV0dXJuIG5vZGVzID8gQXJyYXkuZnJvbShub2Rlcy52YWx1ZXMoKSkgOiBbXTtcbiAgfVxuICBjb25zdCBub2RlcyA9IGVkaXRvclN0YXRlLl9ub2RlTWFwO1xuICBjb25zdCBub2Rlc09mVHlwZSA9IFtdO1xuICBmb3IgKGNvbnN0IFssIG5vZGVdIG9mIG5vZGVzKSB7XG4gICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBrbGFzcyAmJiBub2RlLl9fdHlwZSA9PT0ga2xhc3NUeXBlICYmIG5vZGUuaXNBdHRhY2hlZCgpKSB7XG4gICAgICBub2Rlc09mVHlwZS5wdXNoKG5vZGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbm9kZXNPZlR5cGU7XG59XG5mdW5jdGlvbiByZXNvbHZlRWxlbWVudChlbGVtZW50LCBpc0JhY2t3YXJkLCBmb2N1c09mZnNldCkge1xuICBjb25zdCBwYXJlbnQgPSBlbGVtZW50LmdldFBhcmVudCgpO1xuICBsZXQgb2Zmc2V0ID0gZm9jdXNPZmZzZXQ7XG4gIGxldCBibG9jayA9IGVsZW1lbnQ7XG4gIGlmIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICBpZiAoaXNCYWNrd2FyZCAmJiBmb2N1c09mZnNldCA9PT0gMCkge1xuICAgICAgb2Zmc2V0ID0gYmxvY2suZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKTtcbiAgICAgIGJsb2NrID0gcGFyZW50O1xuICAgIH0gZWxzZSBpZiAoIWlzQmFja3dhcmQgJiYgZm9jdXNPZmZzZXQgPT09IGJsb2NrLmdldENoaWxkcmVuU2l6ZSgpKSB7XG4gICAgICBvZmZzZXQgPSBibG9jay5nZXRJbmRleFdpdGhpblBhcmVudCgpICsgMTtcbiAgICAgIGJsb2NrID0gcGFyZW50O1xuICAgIH1cbiAgfVxuICByZXR1cm4gYmxvY2suZ2V0Q2hpbGRBdEluZGV4KGlzQmFja3dhcmQgPyBvZmZzZXQgLSAxIDogb2Zmc2V0KTtcbn1cbmZ1bmN0aW9uICRnZXRBZGphY2VudE5vZGUoZm9jdXMsIGlzQmFja3dhcmQpIHtcbiAgY29uc3QgZm9jdXNPZmZzZXQgPSBmb2N1cy5vZmZzZXQ7XG4gIGlmIChmb2N1cy50eXBlID09PSAnZWxlbWVudCcpIHtcbiAgICBjb25zdCBibG9jayA9IGZvY3VzLmdldE5vZGUoKTtcbiAgICByZXR1cm4gcmVzb2x2ZUVsZW1lbnQoYmxvY2ssIGlzQmFja3dhcmQsIGZvY3VzT2Zmc2V0KTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBmb2N1c05vZGUgPSBmb2N1cy5nZXROb2RlKCk7XG4gICAgaWYgKGlzQmFja3dhcmQgJiYgZm9jdXNPZmZzZXQgPT09IDAgfHwgIWlzQmFja3dhcmQgJiYgZm9jdXNPZmZzZXQgPT09IGZvY3VzTm9kZS5nZXRUZXh0Q29udGVudFNpemUoKSkge1xuICAgICAgY29uc3QgcG9zc2libGVOb2RlID0gaXNCYWNrd2FyZCA/IGZvY3VzTm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKSA6IGZvY3VzTm9kZS5nZXROZXh0U2libGluZygpO1xuICAgICAgaWYgKHBvc3NpYmxlTm9kZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZUVsZW1lbnQoZm9jdXNOb2RlLmdldFBhcmVudE9yVGhyb3coKSwgaXNCYWNrd2FyZCwgZm9jdXNOb2RlLmdldEluZGV4V2l0aGluUGFyZW50KCkgKyAoaXNCYWNrd2FyZCA/IDAgOiAxKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcG9zc2libGVOb2RlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzRmlyZWZveENsaXBib2FyZEV2ZW50cyhlZGl0b3IpIHtcbiAgY29uc3QgZXZlbnQgPSBnZXRXaW5kb3coZWRpdG9yKS5ldmVudDtcbiAgY29uc3QgaW5wdXRUeXBlID0gZXZlbnQgJiYgZXZlbnQuaW5wdXRUeXBlO1xuICByZXR1cm4gaW5wdXRUeXBlID09PSAnaW5zZXJ0RnJvbVBhc3RlJyB8fCBpbnB1dFR5cGUgPT09ICdpbnNlcnRGcm9tUGFzdGVBc1F1b3RhdGlvbic7XG59XG5mdW5jdGlvbiBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBjb21tYW5kLCBwYXlsb2FkKSB7XG4gIHJldHVybiB0cmlnZ2VyQ29tbWFuZExpc3RlbmVycyhlZGl0b3IsIGNvbW1hbmQsIHBheWxvYWQpO1xufVxuZnVuY3Rpb24gJHRleHRDb250ZW50UmVxdWlyZXNEb3VibGVMaW5lYnJlYWtBdEVuZChub2RlKSB7XG4gIHJldHVybiAhJGlzUm9vdE5vZGUobm9kZSkgJiYgIW5vZGUuaXNMYXN0Q2hpbGQoKSAmJiAhbm9kZS5pc0lubGluZSgpO1xufVxuZnVuY3Rpb24gZ2V0RWxlbWVudEJ5S2V5T3JUaHJvdyhlZGl0b3IsIGtleSkge1xuICBjb25zdCBlbGVtZW50ID0gZWRpdG9yLl9rZXlUb0RPTU1hcC5nZXQoa2V5KTtcbiAgaWYgKGVsZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGBSZWNvbmNpbGlhdGlvbjogY291bGQgbm90IGZpbmQgRE9NIGVsZW1lbnQgZm9yIG5vZGUga2V5ICR7a2V5fWApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZWxlbWVudDtcbn1cbmZ1bmN0aW9uIGdldFBhcmVudEVsZW1lbnQobm9kZSkge1xuICBjb25zdCBwYXJlbnRFbGVtZW50ID0gbm9kZS5hc3NpZ25lZFNsb3QgfHwgbm9kZS5wYXJlbnRFbGVtZW50O1xuICByZXR1cm4gaXNEb2N1bWVudEZyYWdtZW50KHBhcmVudEVsZW1lbnQpID8gcGFyZW50RWxlbWVudC5ob3N0IDogcGFyZW50RWxlbWVudDtcbn1cbmZ1bmN0aW9uIGdldERPTU93bmVyRG9jdW1lbnQodGFyZ2V0KSB7XG4gIHJldHVybiBpc0RPTURvY3VtZW50Tm9kZSh0YXJnZXQpID8gdGFyZ2V0IDogaXNIVE1MRWxlbWVudCh0YXJnZXQpID8gdGFyZ2V0Lm93bmVyRG9jdW1lbnQgOiBudWxsO1xufVxuZnVuY3Rpb24gc2Nyb2xsSW50b1ZpZXdJZk5lZWRlZChlZGl0b3IsIHNlbGVjdGlvblJlY3QsIHJvb3RFbGVtZW50KSB7XG4gIGNvbnN0IGRvYyA9IGdldERPTU93bmVyRG9jdW1lbnQocm9vdEVsZW1lbnQpO1xuICBjb25zdCBkZWZhdWx0VmlldyA9IGdldERlZmF1bHRWaWV3KGRvYyk7XG4gIGlmIChkb2MgPT09IG51bGwgfHwgZGVmYXVsdFZpZXcgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IHtcbiAgICB0b3A6IGN1cnJlbnRUb3AsXG4gICAgYm90dG9tOiBjdXJyZW50Qm90dG9tXG4gIH0gPSBzZWxlY3Rpb25SZWN0O1xuICBsZXQgdGFyZ2V0VG9wID0gMDtcbiAgbGV0IHRhcmdldEJvdHRvbSA9IDA7XG4gIGxldCBlbGVtZW50ID0gcm9vdEVsZW1lbnQ7XG4gIHdoaWxlIChlbGVtZW50ICE9PSBudWxsKSB7XG4gICAgY29uc3QgaXNCb2R5RWxlbWVudCA9IGVsZW1lbnQgPT09IGRvYy5ib2R5O1xuICAgIGlmIChpc0JvZHlFbGVtZW50KSB7XG4gICAgICB0YXJnZXRUb3AgPSAwO1xuICAgICAgdGFyZ2V0Qm90dG9tID0gZ2V0V2luZG93KGVkaXRvcikuaW5uZXJIZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHRhcmdldFJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdGFyZ2V0VG9wID0gdGFyZ2V0UmVjdC50b3A7XG4gICAgICB0YXJnZXRCb3R0b20gPSB0YXJnZXRSZWN0LmJvdHRvbTtcbiAgICB9XG4gICAgbGV0IGRpZmYgPSAwO1xuICAgIGlmIChjdXJyZW50VG9wIDwgdGFyZ2V0VG9wKSB7XG4gICAgICBkaWZmID0gLSh0YXJnZXRUb3AgLSBjdXJyZW50VG9wKTtcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnRCb3R0b20gPiB0YXJnZXRCb3R0b20pIHtcbiAgICAgIGRpZmYgPSBjdXJyZW50Qm90dG9tIC0gdGFyZ2V0Qm90dG9tO1xuICAgIH1cbiAgICBpZiAoZGlmZiAhPT0gMCkge1xuICAgICAgaWYgKGlzQm9keUVsZW1lbnQpIHtcbiAgICAgICAgLy8gT25seSBoYW5kbGVzIHNjcm9sbGluZyBvZiBZIGF4aXNcbiAgICAgICAgZGVmYXVsdFZpZXcuc2Nyb2xsQnkoMCwgZGlmZik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBzY3JvbGxUb3AgPSBlbGVtZW50LnNjcm9sbFRvcDtcbiAgICAgICAgZWxlbWVudC5zY3JvbGxUb3AgKz0gZGlmZjtcbiAgICAgICAgY29uc3QgeU9mZnNldCA9IGVsZW1lbnQuc2Nyb2xsVG9wIC0gc2Nyb2xsVG9wO1xuICAgICAgICBjdXJyZW50VG9wIC09IHlPZmZzZXQ7XG4gICAgICAgIGN1cnJlbnRCb3R0b20gLT0geU9mZnNldDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzQm9keUVsZW1lbnQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBlbGVtZW50ID0gZ2V0UGFyZW50RWxlbWVudChlbGVtZW50KTtcbiAgfVxufVxuZnVuY3Rpb24gJGhhc1VwZGF0ZVRhZyh0YWcpIHtcbiAgY29uc3QgZWRpdG9yID0gZ2V0QWN0aXZlRWRpdG9yKCk7XG4gIHJldHVybiBlZGl0b3IuX3VwZGF0ZVRhZ3MuaGFzKHRhZyk7XG59XG5mdW5jdGlvbiAkYWRkVXBkYXRlVGFnKHRhZykge1xuICBlcnJvck9uUmVhZE9ubHkoKTtcbiAgY29uc3QgZWRpdG9yID0gZ2V0QWN0aXZlRWRpdG9yKCk7XG4gIGVkaXRvci5fdXBkYXRlVGFncy5hZGQodGFnKTtcbn1cblxuLyoqXG4gKiBBZGQgYSBmdW5jdGlvbiB0byBydW4gYWZ0ZXIgdGhlIGN1cnJlbnQgdXBkYXRlLiBUaGlzIHdpbGwgcnVuIGFmdGVyIGFueVxuICogYG9uVXBkYXRlYCBmdW5jdGlvbiBhbHJlYWR5IHN1cHBsaWVkIHRvIGBlZGl0b3IudXBkYXRlKClgLCBhcyB3ZWxsIGFzIGFueVxuICogZnVuY3Rpb25zIGFkZGVkIHdpdGggcHJldmlvdXMgY2FsbHMgdG8gYCRvblVwZGF0ZWAuXG4gKlxuICogQHBhcmFtIHVwZGF0ZUZuIFRoZSBmdW5jdGlvbiB0byBydW4gYWZ0ZXIgdGhlIGN1cnJlbnQgdXBkYXRlLlxuICovXG5mdW5jdGlvbiAkb25VcGRhdGUodXBkYXRlRm4pIHtcbiAgZXJyb3JPblJlYWRPbmx5KCk7XG4gIGNvbnN0IGVkaXRvciA9IGdldEFjdGl2ZUVkaXRvcigpO1xuICBlZGl0b3IuX2RlZmVycmVkLnB1c2godXBkYXRlRm4pO1xufVxuZnVuY3Rpb24gJG1heWJlTW92ZUNoaWxkcmVuU2VsZWN0aW9uVG9QYXJlbnQocGFyZW50Tm9kZSkge1xuICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSB8fCAhJGlzRWxlbWVudE5vZGUocGFyZW50Tm9kZSkpIHtcbiAgICByZXR1cm4gc2VsZWN0aW9uO1xuICB9XG4gIGNvbnN0IHtcbiAgICBhbmNob3IsXG4gICAgZm9jdXNcbiAgfSA9IHNlbGVjdGlvbjtcbiAgY29uc3QgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gIGNvbnN0IGZvY3VzTm9kZSA9IGZvY3VzLmdldE5vZGUoKTtcbiAgaWYgKCRoYXNBbmNlc3RvcihhbmNob3JOb2RlLCBwYXJlbnROb2RlKSkge1xuICAgIGFuY2hvci5zZXQocGFyZW50Tm9kZS5fX2tleSwgMCwgJ2VsZW1lbnQnKTtcbiAgfVxuICBpZiAoJGhhc0FuY2VzdG9yKGZvY3VzTm9kZSwgcGFyZW50Tm9kZSkpIHtcbiAgICBmb2N1cy5zZXQocGFyZW50Tm9kZS5fX2tleSwgMCwgJ2VsZW1lbnQnKTtcbiAgfVxuICByZXR1cm4gc2VsZWN0aW9uO1xufVxuZnVuY3Rpb24gJGhhc0FuY2VzdG9yKGNoaWxkLCB0YXJnZXROb2RlKSB7XG4gIGxldCBwYXJlbnQgPSBjaGlsZC5nZXRQYXJlbnQoKTtcbiAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgIGlmIChwYXJlbnQuaXModGFyZ2V0Tm9kZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBwYXJlbnQgPSBwYXJlbnQuZ2V0UGFyZW50KCk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0RGVmYXVsdFZpZXcoZG9tRWxlbSkge1xuICBjb25zdCBvd25lckRvYyA9IGdldERPTU93bmVyRG9jdW1lbnQoZG9tRWxlbSk7XG4gIHJldHVybiBvd25lckRvYyA/IG93bmVyRG9jLmRlZmF1bHRWaWV3IDogbnVsbDtcbn1cbmZ1bmN0aW9uIGdldFdpbmRvdyhlZGl0b3IpIHtcbiAgY29uc3Qgd2luZG93T2JqID0gZWRpdG9yLl93aW5kb3c7XG4gIGlmICh3aW5kb3dPYmogPT09IG51bGwpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgd2luZG93IG9iamVjdCBub3QgZm91bmRgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHdpbmRvd09iajtcbn1cbmZ1bmN0aW9uICRpc0lubGluZUVsZW1lbnRPckRlY29yYXRvck5vZGUobm9kZSkge1xuICByZXR1cm4gJGlzRWxlbWVudE5vZGUobm9kZSkgJiYgbm9kZS5pc0lubGluZSgpIHx8ICRpc0RlY29yYXRvck5vZGUobm9kZSkgJiYgbm9kZS5pc0lubGluZSgpO1xufVxuZnVuY3Rpb24gJGdldE5lYXJlc3RSb290T3JTaGFkb3dSb290KG5vZGUpIHtcbiAgbGV0IHBhcmVudCA9IG5vZGUuZ2V0UGFyZW50T3JUaHJvdygpO1xuICB3aGlsZSAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgaWYgKCRpc1Jvb3RPclNoYWRvd1Jvb3QocGFyZW50KSkge1xuICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICB9XG4gICAgcGFyZW50ID0gcGFyZW50LmdldFBhcmVudE9yVGhyb3coKTtcbiAgfVxuICByZXR1cm4gcGFyZW50O1xufVxuZnVuY3Rpb24gJGlzUm9vdE9yU2hhZG93Um9vdChub2RlKSB7XG4gIHJldHVybiAkaXNSb290Tm9kZShub2RlKSB8fCAkaXNFbGVtZW50Tm9kZShub2RlKSAmJiBub2RlLmlzU2hhZG93Um9vdCgpO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBzaGFsbG93IGNsb25lIG9mIG5vZGUgd2l0aCBhIG5ldyBrZXlcbiAqXG4gKiBAcGFyYW0gbm9kZSAtIFRoZSBub2RlIHRvIGJlIGNvcGllZC5cbiAqIEByZXR1cm5zIFRoZSBjb3B5IG9mIHRoZSBub2RlLlxuICovXG5mdW5jdGlvbiAkY29weU5vZGUobm9kZSkge1xuICBjb25zdCBjb3B5ID0gbm9kZS5jb25zdHJ1Y3Rvci5jbG9uZShub2RlKTtcbiAgJHNldE5vZGVLZXkoY29weSwgbnVsbCk7XG4gIHJldHVybiBjb3B5O1xufVxuZnVuY3Rpb24gJGFwcGx5Tm9kZVJlcGxhY2VtZW50KG5vZGUpIHtcbiAgY29uc3QgZWRpdG9yID0gZ2V0QWN0aXZlRWRpdG9yKCk7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS5jb25zdHJ1Y3Rvci5nZXRUeXBlKCk7XG4gIGNvbnN0IHJlZ2lzdGVyZWROb2RlID0gZWRpdG9yLl9ub2Rlcy5nZXQobm9kZVR5cGUpO1xuICBpZiAoIShyZWdpc3RlcmVkTm9kZSAhPT0gdW5kZWZpbmVkKSkge1xuICAgIHRocm93IEVycm9yKGAkYXBwbHlOb2RlUmVwbGFjZW1lbnQgbm9kZSAke25vZGUuY29uc3RydWN0b3IubmFtZX0gd2l0aCB0eXBlICR7bm9kZVR5cGV9IG11c3QgYmUgcmVnaXN0ZXJlZCB0byB0aGUgZWRpdG9yLiBZb3UgY2FuIGRvIHRoaXMgYnkgcGFzc2luZyB0aGUgbm9kZSBjbGFzcyB2aWEgdGhlIFwibm9kZXNcIiBhcnJheSBpbiB0aGUgZWRpdG9yIGNvbmZpZy5gKTtcbiAgfVxuICBjb25zdCB7XG4gICAgcmVwbGFjZSxcbiAgICByZXBsYWNlV2l0aEtsYXNzXG4gIH0gPSByZWdpc3RlcmVkTm9kZTtcbiAgaWYgKHJlcGxhY2UgIT09IG51bGwpIHtcbiAgICBjb25zdCByZXBsYWNlbWVudE5vZGUgPSByZXBsYWNlKG5vZGUpO1xuICAgIGNvbnN0IHJlcGxhY2VtZW50Tm9kZUtsYXNzID0gcmVwbGFjZW1lbnROb2RlLmNvbnN0cnVjdG9yO1xuICAgIGlmIChyZXBsYWNlV2l0aEtsYXNzICE9PSBudWxsKSB7XG4gICAgICBpZiAoIShyZXBsYWNlbWVudE5vZGUgaW5zdGFuY2VvZiByZXBsYWNlV2l0aEtsYXNzKSkge1xuICAgICAgICB0aHJvdyBFcnJvcihgJGFwcGx5Tm9kZVJlcGxhY2VtZW50IGZhaWxlZC4gRXhwZWN0ZWQgcmVwbGFjZW1lbnQgbm9kZSB0byBiZSBhbiBpbnN0YW5jZSBvZiAke3JlcGxhY2VXaXRoS2xhc3MubmFtZX0gd2l0aCB0eXBlICR7cmVwbGFjZVdpdGhLbGFzcy5nZXRUeXBlKCl9IGJ1dCByZXR1cm5lZCAke3JlcGxhY2VtZW50Tm9kZUtsYXNzLm5hbWV9IHdpdGggdHlwZSAke3JlcGxhY2VtZW50Tm9kZUtsYXNzLmdldFR5cGUoKX0gZnJvbSBvcmlnaW5hbCBub2RlICR7bm9kZS5jb25zdHJ1Y3Rvci5uYW1lfSB3aXRoIHR5cGUgJHtub2RlVHlwZX1gKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCEocmVwbGFjZW1lbnROb2RlIGluc3RhbmNlb2Ygbm9kZS5jb25zdHJ1Y3RvciAmJiByZXBsYWNlbWVudE5vZGVLbGFzcyAhPT0gbm9kZS5jb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYCRhcHBseU5vZGVSZXBsYWNlbWVudCBmYWlsZWQuIEVuc3VyZSByZXBsYWNlbWVudCBub2RlICR7cmVwbGFjZW1lbnROb2RlS2xhc3MubmFtZX0gd2l0aCB0eXBlICR7cmVwbGFjZW1lbnROb2RlS2xhc3MuZ2V0VHlwZSgpfSBpcyBhIHN1YmNsYXNzIG9mIHRoZSBvcmlnaW5hbCBub2RlICR7bm9kZS5jb25zdHJ1Y3Rvci5uYW1lfSB3aXRoIHR5cGUgJHtub2RlVHlwZX0uYCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghKHJlcGxhY2VtZW50Tm9kZS5fX2tleSAhPT0gbm9kZS5fX2tleSkpIHtcbiAgICAgIHRocm93IEVycm9yKGAkYXBwbHlOb2RlUmVwbGFjZW1lbnQgZmFpbGVkLiBFbnN1cmUgdGhhdCB0aGUga2V5IGFyZ3VtZW50IGlzICpub3QqIHVzZWQgaW4geW91ciByZXBsYWNlIGZ1bmN0aW9uIChmcm9tIG5vZGUgJHtub2RlLmNvbnN0cnVjdG9yLm5hbWV9IHdpdGggdHlwZSAke25vZGVUeXBlfSB0byBub2RlICR7cmVwbGFjZW1lbnROb2RlS2xhc3MubmFtZX0gd2l0aCB0eXBlICR7cmVwbGFjZW1lbnROb2RlS2xhc3MuZ2V0VHlwZSgpfSksIE5vZGUga2V5cyBtdXN0IG5ldmVyIGJlIHJlLXVzZWQgZXhjZXB0IGJ5IHRoZSBzdGF0aWMgY2xvbmUgbWV0aG9kLmApO1xuICAgIH1cbiAgICByZXR1cm4gcmVwbGFjZW1lbnROb2RlO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gZXJyb3JPbkluc2VydFRleHROb2RlT25Sb290KG5vZGUsIGluc2VydE5vZGUpIHtcbiAgY29uc3QgcGFyZW50Tm9kZSA9IG5vZGUuZ2V0UGFyZW50KCk7XG4gIGlmICgkaXNSb290Tm9kZShwYXJlbnROb2RlKSAmJiAhJGlzRWxlbWVudE5vZGUoaW5zZXJ0Tm9kZSkgJiYgISRpc0RlY29yYXRvck5vZGUoaW5zZXJ0Tm9kZSkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgT25seSBlbGVtZW50IG9yIGRlY29yYXRvciBub2RlcyBjYW4gYmUgaW5zZXJ0ZWQgaW4gdG8gdGhlIHJvb3Qgbm9kZWApO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gJGdldE5vZGVCeUtleU9yVGhyb3coa2V5KSB7XG4gIGNvbnN0IG5vZGUgPSAkZ2V0Tm9kZUJ5S2V5KGtleSk7XG4gIGlmIChub2RlID09PSBudWxsKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIG5vZGUgd2l0aCBrZXkgJHtrZXl9IHRvIGV4aXN0IGJ1dCBpdCdzIG5vdCBpbiB0aGUgbm9kZU1hcC5gKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBjcmVhdGVCbG9ja0N1cnNvckVsZW1lbnQoZWRpdG9yQ29uZmlnKSB7XG4gIGNvbnN0IHRoZW1lID0gZWRpdG9yQ29uZmlnLnRoZW1lO1xuICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGVsZW1lbnQuY29udGVudEVkaXRhYmxlID0gJ2ZhbHNlJztcbiAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtbGV4aWNhbC1jdXJzb3InLCAndHJ1ZScpO1xuICBsZXQgYmxvY2tDdXJzb3JUaGVtZSA9IHRoZW1lLmJsb2NrQ3Vyc29yO1xuICBpZiAoYmxvY2tDdXJzb3JUaGVtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBibG9ja0N1cnNvclRoZW1lID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgY2xhc3NOYW1lc0FyciA9IG5vcm1hbGl6ZUNsYXNzTmFtZXMoYmxvY2tDdXJzb3JUaGVtZSk7XG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbnRlbnRpb25hbFxuICAgICAgYmxvY2tDdXJzb3JUaGVtZSA9IHRoZW1lLmJsb2NrQ3Vyc29yID0gY2xhc3NOYW1lc0FycjtcbiAgICB9XG4gICAgaWYgKGJsb2NrQ3Vyc29yVGhlbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKC4uLmJsb2NrQ3Vyc29yVGhlbWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZWxlbWVudDtcbn1cbmZ1bmN0aW9uIG5lZWRzQmxvY2tDdXJzb3Iobm9kZSkge1xuICByZXR1cm4gKCRpc0RlY29yYXRvck5vZGUobm9kZSkgfHwgJGlzRWxlbWVudE5vZGUobm9kZSkgJiYgIW5vZGUuY2FuQmVFbXB0eSgpKSAmJiAhbm9kZS5pc0lubGluZSgpO1xufVxuZnVuY3Rpb24gcmVtb3ZlRE9NQmxvY2tDdXJzb3JFbGVtZW50KGJsb2NrQ3Vyc29yRWxlbWVudCwgZWRpdG9yLCByb290RWxlbWVudCkge1xuICByb290RWxlbWVudC5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgnY2FyZXQtY29sb3InKTtcbiAgZWRpdG9yLl9ibG9ja0N1cnNvckVsZW1lbnQgPSBudWxsO1xuICBjb25zdCBwYXJlbnRFbGVtZW50ID0gYmxvY2tDdXJzb3JFbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gIGlmIChwYXJlbnRFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgcGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZChibG9ja0N1cnNvckVsZW1lbnQpO1xuICB9XG59XG5mdW5jdGlvbiB1cGRhdGVET01CbG9ja0N1cnNvckVsZW1lbnQoZWRpdG9yLCByb290RWxlbWVudCwgbmV4dFNlbGVjdGlvbikge1xuICBsZXQgYmxvY2tDdXJzb3JFbGVtZW50ID0gZWRpdG9yLl9ibG9ja0N1cnNvckVsZW1lbnQ7XG4gIGlmICgkaXNSYW5nZVNlbGVjdGlvbihuZXh0U2VsZWN0aW9uKSAmJiBuZXh0U2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgJiYgbmV4dFNlbGVjdGlvbi5hbmNob3IudHlwZSA9PT0gJ2VsZW1lbnQnICYmIHJvb3RFbGVtZW50LmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgY29uc3QgYW5jaG9yID0gbmV4dFNlbGVjdGlvbi5hbmNob3I7XG4gICAgY29uc3QgZWxlbWVudE5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICAgIGNvbnN0IG9mZnNldCA9IGFuY2hvci5vZmZzZXQ7XG4gICAgY29uc3QgZWxlbWVudE5vZGVTaXplID0gZWxlbWVudE5vZGUuZ2V0Q2hpbGRyZW5TaXplKCk7XG4gICAgbGV0IGlzQmxvY2tDdXJzb3IgPSBmYWxzZTtcbiAgICBsZXQgaW5zZXJ0QmVmb3JlRWxlbWVudCA9IG51bGw7XG4gICAgaWYgKG9mZnNldCA9PT0gZWxlbWVudE5vZGVTaXplKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IGVsZW1lbnROb2RlLmdldENoaWxkQXRJbmRleChvZmZzZXQgLSAxKTtcbiAgICAgIGlmIChuZWVkc0Jsb2NrQ3Vyc29yKGNoaWxkKSkge1xuICAgICAgICBpc0Jsb2NrQ3Vyc29yID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY2hpbGQgPSBlbGVtZW50Tm9kZS5nZXRDaGlsZEF0SW5kZXgob2Zmc2V0KTtcbiAgICAgIGlmIChjaGlsZCAhPT0gbnVsbCAmJiBuZWVkc0Jsb2NrQ3Vyc29yKGNoaWxkKSkge1xuICAgICAgICBjb25zdCBzaWJsaW5nID0gY2hpbGQuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgICAgIGlmIChzaWJsaW5nID09PSBudWxsIHx8IG5lZWRzQmxvY2tDdXJzb3Ioc2libGluZykpIHtcbiAgICAgICAgICBpc0Jsb2NrQ3Vyc29yID0gdHJ1ZTtcbiAgICAgICAgICBpbnNlcnRCZWZvcmVFbGVtZW50ID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleShjaGlsZC5fX2tleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzQmxvY2tDdXJzb3IpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnRET00gPSBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KGVsZW1lbnROb2RlLl9fa2V5KTtcbiAgICAgIGlmIChibG9ja0N1cnNvckVsZW1lbnQgPT09IG51bGwpIHtcbiAgICAgICAgZWRpdG9yLl9ibG9ja0N1cnNvckVsZW1lbnQgPSBibG9ja0N1cnNvckVsZW1lbnQgPSBjcmVhdGVCbG9ja0N1cnNvckVsZW1lbnQoZWRpdG9yLl9jb25maWcpO1xuICAgICAgfVxuICAgICAgcm9vdEVsZW1lbnQuc3R5bGUuY2FyZXRDb2xvciA9ICd0cmFuc3BhcmVudCc7XG4gICAgICBpZiAoaW5zZXJ0QmVmb3JlRWxlbWVudCA9PT0gbnVsbCkge1xuICAgICAgICBlbGVtZW50RE9NLmFwcGVuZENoaWxkKGJsb2NrQ3Vyc29yRWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50RE9NLmluc2VydEJlZm9yZShibG9ja0N1cnNvckVsZW1lbnQsIGluc2VydEJlZm9yZUVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICAvLyBSZW1vdmUgY3Vyc29yXG4gIGlmIChibG9ja0N1cnNvckVsZW1lbnQgIT09IG51bGwpIHtcbiAgICByZW1vdmVET01CbG9ja0N1cnNvckVsZW1lbnQoYmxvY2tDdXJzb3JFbGVtZW50LCBlZGl0b3IsIHJvb3RFbGVtZW50KTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHNlbGVjdGlvbiBmb3IgdGhlIGdpdmVuIHdpbmRvdywgb3IgdGhlIGdsb2JhbCB3aW5kb3cgaWYgbnVsbC5cbiAqIFdpbGwgcmV0dXJuIG51bGwgaWYge0BsaW5rIENBTl9VU0VfRE9NfSBpcyBmYWxzZS5cbiAqXG4gKiBAcGFyYW0gdGFyZ2V0V2luZG93IFRoZSB3aW5kb3cgdG8gZ2V0IHRoZSBzZWxlY3Rpb24gZnJvbVxuICogQHJldHVybnMgYSBTZWxlY3Rpb24gb3IgbnVsbFxuICovXG5mdW5jdGlvbiBnZXRET01TZWxlY3Rpb24odGFyZ2V0V2luZG93KSB7XG4gIHJldHVybiAhQ0FOX1VTRV9ET00gPyBudWxsIDogKHRhcmdldFdpbmRvdyB8fCB3aW5kb3cpLmdldFNlbGVjdGlvbigpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHNlbGVjdGlvbiBmb3IgdGhlIGRlZmF1bHRWaWV3IG9mIHRoZSBvd25lckRvY3VtZW50IG9mIGdpdmVuIEV2ZW50VGFyZ2V0LlxuICpcbiAqIEBwYXJhbSBldmVudFRhcmdldCBUaGUgbm9kZSB0byBnZXQgdGhlIHNlbGVjdGlvbiBmcm9tXG4gKiBAcmV0dXJucyBhIFNlbGVjdGlvbiBvciBudWxsXG4gKi9cbmZ1bmN0aW9uIGdldERPTVNlbGVjdGlvbkZyb21UYXJnZXQoZXZlbnRUYXJnZXQpIHtcbiAgY29uc3QgZGVmYXVsdFZpZXcgPSBnZXREZWZhdWx0VmlldyhldmVudFRhcmdldCk7XG4gIHJldHVybiBkZWZhdWx0VmlldyA/IGRlZmF1bHRWaWV3LmdldFNlbGVjdGlvbigpIDogbnVsbDtcbn1cbmZ1bmN0aW9uICRzcGxpdE5vZGUobm9kZSwgb2Zmc2V0KSB7XG4gIGxldCBzdGFydE5vZGUgPSBub2RlLmdldENoaWxkQXRJbmRleChvZmZzZXQpO1xuICBpZiAoc3RhcnROb2RlID09IG51bGwpIHtcbiAgICBzdGFydE5vZGUgPSBub2RlO1xuICB9XG4gIGlmICghISRpc1Jvb3RPclNoYWRvd1Jvb3Qobm9kZSkpIHtcbiAgICB0aHJvdyBFcnJvcihgQ2FuIG5vdCBjYWxsICRzcGxpdE5vZGUoKSBvbiByb290IGVsZW1lbnRgKTtcbiAgfVxuICBjb25zdCByZWN1cnNlID0gY3VycmVudE5vZGUgPT4ge1xuICAgIGNvbnN0IHBhcmVudCA9IGN1cnJlbnROb2RlLmdldFBhcmVudE9yVGhyb3coKTtcbiAgICBjb25zdCBpc1BhcmVudFJvb3QgPSAkaXNSb290T3JTaGFkb3dSb290KHBhcmVudCk7XG4gICAgLy8gVGhlIG5vZGUgd2Ugc3RhcnQgc3BsaXQgZnJvbSAobGVhZikgaXMgbW92ZWQsIGJ1dCBpdHMgcmVjdXJzaXZlXG4gICAgLy8gcGFyZW50cyBhcmUgY29waWVkIHRvIGNyZWF0ZSBzZXBhcmF0ZSB0cmVlXG4gICAgY29uc3Qgbm9kZVRvTW92ZSA9IGN1cnJlbnROb2RlID09PSBzdGFydE5vZGUgJiYgIWlzUGFyZW50Um9vdCA/IGN1cnJlbnROb2RlIDogJGNvcHlOb2RlKGN1cnJlbnROb2RlKTtcbiAgICBpZiAoaXNQYXJlbnRSb290KSB7XG4gICAgICBpZiAoISgkaXNFbGVtZW50Tm9kZShjdXJyZW50Tm9kZSkgJiYgJGlzRWxlbWVudE5vZGUobm9kZVRvTW92ZSkpKSB7XG4gICAgICAgIHRocm93IEVycm9yKGBDaGlsZHJlbiBvZiBhIHJvb3QgbXVzdCBiZSBFbGVtZW50Tm9kZWApO1xuICAgICAgfVxuICAgICAgY3VycmVudE5vZGUuaW5zZXJ0QWZ0ZXIobm9kZVRvTW92ZSk7XG4gICAgICByZXR1cm4gW2N1cnJlbnROb2RlLCBub2RlVG9Nb3ZlLCBub2RlVG9Nb3ZlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgW2xlZnRUcmVlLCByaWdodFRyZWUsIG5ld1BhcmVudF0gPSByZWN1cnNlKHBhcmVudCk7XG4gICAgICBjb25zdCBuZXh0U2libGluZ3MgPSBjdXJyZW50Tm9kZS5nZXROZXh0U2libGluZ3MoKTtcbiAgICAgIG5ld1BhcmVudC5hcHBlbmQobm9kZVRvTW92ZSwgLi4ubmV4dFNpYmxpbmdzKTtcbiAgICAgIHJldHVybiBbbGVmdFRyZWUsIHJpZ2h0VHJlZSwgbm9kZVRvTW92ZV07XG4gICAgfVxuICB9O1xuICBjb25zdCBbbGVmdFRyZWUsIHJpZ2h0VHJlZV0gPSByZWN1cnNlKHN0YXJ0Tm9kZSk7XG4gIHJldHVybiBbbGVmdFRyZWUsIHJpZ2h0VHJlZV07XG59XG5cbi8qKlxuICogQHBhcmFtIHggLSBUaGUgZWxlbWVudCBiZWluZyB0ZXN0ZWRcbiAqIEByZXR1cm5zIFJldHVybnMgdHJ1ZSBpZiB4IGlzIGFuIEhUTUwgYW5jaG9yIHRhZywgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmZ1bmN0aW9uIGlzSFRNTEFuY2hvckVsZW1lbnQoeCkge1xuICByZXR1cm4gaXNIVE1MRWxlbWVudCh4KSAmJiB4LnRhZ05hbWUgPT09ICdBJztcbn1cblxuLyoqXG4gKiBAcGFyYW0geCAtIFRoZSBlbGVtZW50IGJlaW5nIHRlc3RlZFxuICogQHJldHVybnMgUmV0dXJucyB0cnVlIGlmIHggaXMgYW4gSFRNTCBlbGVtZW50LCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzSFRNTEVsZW1lbnQoeCkge1xuICByZXR1cm4gaXNET01Ob2RlKHgpICYmIHgubm9kZVR5cGUgPT09IERPTV9FTEVNRU5UX1RZUEU7XG59XG5cbi8qKlxuICogQHBhcmFtIHggLSBUaGUgZWxlbWVudCBiZWluZyB0ZXN0ZWRcbiAqIEByZXR1cm5zIFJldHVybnMgdHJ1ZSBpZiB4IGlzIGEgRE9NIE5vZGUsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNET01Ob2RlKHgpIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB4ICE9PSBudWxsICYmICdub2RlVHlwZScgaW4geCAmJiB0eXBlb2YgeC5ub2RlVHlwZSA9PT0gJ251bWJlcic7XG59XG5cbi8qKlxuICogQHBhcmFtIHggLSBUaGUgZWxlbWVudCBiZWluZyB0ZXN0aW5nXG4gKiBAcmV0dXJucyBSZXR1cm5zIHRydWUgaWYgeCBpcyBhIGRvY3VtZW50IGZyYWdtZW50LCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzRG9jdW1lbnRGcmFnbWVudCh4KSB7XG4gIHJldHVybiBpc0RPTU5vZGUoeCkgJiYgeC5ub2RlVHlwZSA9PT0gRE9NX0RPQ1VNRU5UX0ZSQUdNRU5UX1RZUEU7XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBub2RlIC0gdGhlIERvbSBOb2RlIHRvIGNoZWNrXG4gKiBAcmV0dXJucyBpZiB0aGUgRG9tIE5vZGUgaXMgYW4gaW5saW5lIG5vZGVcbiAqL1xuZnVuY3Rpb24gaXNJbmxpbmVEb21Ob2RlKG5vZGUpIHtcbiAgY29uc3QgaW5saW5lTm9kZXMgPSBuZXcgUmVnRXhwKC9eKGF8YWJicnxhY3JvbnltfGJ8Y2l0ZXxjb2RlfGRlbHxlbXxpfGluc3xrYmR8bGFiZWx8b3V0cHV0fHF8cnVieXxzfHNhbXB8c3BhbnxzdHJvbmd8c3VifHN1cHx0aW1lfHV8dHR8dmFyfCN0ZXh0KSQvLCAnaScpO1xuICByZXR1cm4gbm9kZS5ub2RlTmFtZS5tYXRjaChpbmxpbmVOb2RlcykgIT09IG51bGw7XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBub2RlIC0gdGhlIERvbSBOb2RlIHRvIGNoZWNrXG4gKiBAcmV0dXJucyBpZiB0aGUgRG9tIE5vZGUgaXMgYSBibG9jayBub2RlXG4gKi9cbmZ1bmN0aW9uIGlzQmxvY2tEb21Ob2RlKG5vZGUpIHtcbiAgY29uc3QgYmxvY2tOb2RlcyA9IG5ldyBSZWdFeHAoL14oYWRkcmVzc3xhcnRpY2xlfGFzaWRlfGJsb2NrcXVvdGV8Y2FudmFzfGRkfGRpdnxkbHxkdHxmaWVsZHNldHxmaWdjYXB0aW9ufGZpZ3VyZXxmb290ZXJ8Zm9ybXxoMXxoMnxoM3xoNHxoNXxoNnxoZWFkZXJ8aHJ8bGl8bWFpbnxuYXZ8bm9zY3JpcHR8b2x8cHxwcmV8c2VjdGlvbnx0YWJsZXx0ZHx0Zm9vdHx1bHx2aWRlbykkLywgJ2knKTtcbiAgcmV0dXJuIG5vZGUubm9kZU5hbWUubWF0Y2goYmxvY2tOb2RlcykgIT09IG51bGw7XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBmb3IgaW50ZXJuYWwgdXNlIG9mIHRoZSBsaWJyYXJ5LlxuICogUGxlYXNlIGRvIG5vdCB1c2UgaXQgYXMgaXQgbWF5IGNoYW5nZSBpbiB0aGUgZnV0dXJlLlxuICovXG5mdW5jdGlvbiBJTlRFUk5BTF8kaXNCbG9jayhub2RlKSB7XG4gIGlmICgkaXNEZWNvcmF0b3JOb2RlKG5vZGUpICYmICFub2RlLmlzSW5saW5lKCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoISRpc0VsZW1lbnROb2RlKG5vZGUpIHx8ICRpc1Jvb3RPclNoYWRvd1Jvb3Qobm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgZmlyc3RDaGlsZCA9IG5vZGUuZ2V0Rmlyc3RDaGlsZCgpO1xuICBjb25zdCBpc0xlYWZFbGVtZW50ID0gZmlyc3RDaGlsZCA9PT0gbnVsbCB8fCAkaXNMaW5lQnJlYWtOb2RlKGZpcnN0Q2hpbGQpIHx8ICRpc1RleHROb2RlKGZpcnN0Q2hpbGQpIHx8IGZpcnN0Q2hpbGQuaXNJbmxpbmUoKTtcbiAgcmV0dXJuICFub2RlLmlzSW5saW5lKCkgJiYgbm9kZS5jYW5CZUVtcHR5KCkgIT09IGZhbHNlICYmIGlzTGVhZkVsZW1lbnQ7XG59XG5mdW5jdGlvbiAkZ2V0QW5jZXN0b3Iobm9kZSwgcHJlZGljYXRlKSB7XG4gIGxldCBwYXJlbnQgPSBub2RlO1xuICB3aGlsZSAocGFyZW50ICE9PSBudWxsICYmIHBhcmVudC5nZXRQYXJlbnQoKSAhPT0gbnVsbCAmJiAhcHJlZGljYXRlKHBhcmVudCkpIHtcbiAgICBwYXJlbnQgPSBwYXJlbnQuZ2V0UGFyZW50T3JUaHJvdygpO1xuICB9XG4gIHJldHVybiBwcmVkaWNhdGUocGFyZW50KSA/IHBhcmVudCA6IG51bGw7XG59XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgYWNjZXNzaW5nIGN1cnJlbnQgYWN0aXZlIGVkaXRvciBpbnN0YW5jZS5cbiAqIEByZXR1cm5zIEN1cnJlbnQgYWN0aXZlIGVkaXRvclxuICovXG5mdW5jdGlvbiAkZ2V0RWRpdG9yKCkge1xuICByZXR1cm4gZ2V0QWN0aXZlRWRpdG9yKCk7XG59XG5cbi8qKiBAaW50ZXJuYWwgKi9cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIENvbXB1dGUgYSBjYWNoZWQgTWFwIG9mIG5vZGUgdHlwZSB0byBub2RlcyBmb3IgYSBmcm96ZW4gRWRpdG9yU3RhdGVcbiAqL1xuY29uc3QgY2FjaGVkTm9kZU1hcHMgPSBuZXcgV2Vha01hcCgpO1xuY29uc3QgRU1QVFlfVFlQRV9UT19OT0RFX01BUCA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uIGdldENhY2hlZFR5cGVUb05vZGVNYXAoZWRpdG9yU3RhdGUpIHtcbiAgLy8gSWYgdGhpcyBpcyBhIG5ldyBFZGl0b3IgaXQgbWF5IGhhdmUgYSB3cml0YWJsZSB0aGlzLl9lZGl0b3JTdGF0ZVxuICAvLyB3aXRoIG9ubHkgYSAncm9vdCcgZW50cnkuXG4gIGlmICghZWRpdG9yU3RhdGUuX3JlYWRPbmx5ICYmIGVkaXRvclN0YXRlLmlzRW1wdHkoKSkge1xuICAgIHJldHVybiBFTVBUWV9UWVBFX1RPX05PREVfTUFQO1xuICB9XG4gIGlmICghZWRpdG9yU3RhdGUuX3JlYWRPbmx5KSB7XG4gICAgdGhyb3cgRXJyb3IoYGdldENhY2hlZFR5cGVUb05vZGVNYXAgY2FsbGVkIHdpdGggYSB3cml0YWJsZSBFZGl0b3JTdGF0ZWApO1xuICB9XG4gIGxldCB0eXBlVG9Ob2RlTWFwID0gY2FjaGVkTm9kZU1hcHMuZ2V0KGVkaXRvclN0YXRlKTtcbiAgaWYgKCF0eXBlVG9Ob2RlTWFwKSB7XG4gICAgdHlwZVRvTm9kZU1hcCA9IGNvbXB1dGVUeXBlVG9Ob2RlTWFwKGVkaXRvclN0YXRlKTtcbiAgICBjYWNoZWROb2RlTWFwcy5zZXQoZWRpdG9yU3RhdGUsIHR5cGVUb05vZGVNYXApO1xuICB9XG4gIHJldHVybiB0eXBlVG9Ob2RlTWFwO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICogQ29tcHV0ZSBhIE1hcCBvZiBub2RlIHR5cGUgdG8gbm9kZXMgZm9yIGFuIEVkaXRvclN0YXRlXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVUeXBlVG9Ob2RlTWFwKGVkaXRvclN0YXRlKSB7XG4gIGNvbnN0IHR5cGVUb05vZGVNYXAgPSBuZXcgTWFwKCk7XG4gIGZvciAoY29uc3QgW25vZGVLZXksIG5vZGVdIG9mIGVkaXRvclN0YXRlLl9ub2RlTWFwKSB7XG4gICAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLl9fdHlwZTtcbiAgICBsZXQgbm9kZU1hcCA9IHR5cGVUb05vZGVNYXAuZ2V0KG5vZGVUeXBlKTtcbiAgICBpZiAoIW5vZGVNYXApIHtcbiAgICAgIG5vZGVNYXAgPSBuZXcgTWFwKCk7XG4gICAgICB0eXBlVG9Ob2RlTWFwLnNldChub2RlVHlwZSwgbm9kZU1hcCk7XG4gICAgfVxuICAgIG5vZGVNYXAuc2V0KG5vZGVLZXksIG5vZGUpO1xuICB9XG4gIHJldHVybiB0eXBlVG9Ob2RlTWFwO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBjbG9uZSBvZiBhIG5vZGUgdXNpbmcgYG5vZGUuY29uc3RydWN0b3IuY2xvbmUoKWAgZm9sbG93ZWQgYnlcbiAqIGBjbG9uZS5hZnRlckNsb25lRnJvbShub2RlKWAuIFRoZSByZXN1bHRpbmcgY2xvbmUgbXVzdCBoYXZlIHRoZSBzYW1lIGtleSxcbiAqIHBhcmVudC9uZXh0L3ByZXYgcG9pbnRlcnMsIGFuZCBvdGhlciBwcm9wZXJ0aWVzIHRoYXQgYXJlIG5vdCBzZXQgYnlcbiAqIGBub2RlLmNvbnN0cnVjdG9yLmNsb25lYCAoZm9ybWF0LCBzdHlsZSwgZXRjLikuIFRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgYnlcbiAqIHtAbGluayBMZXhpY2FsTm9kZS5nZXRXcml0YWJsZX0gdG8gY3JlYXRlIGEgd3JpdGFibGUgdmVyc2lvbiBvZiBhblxuICogZXhpc3Rpbmcgbm9kZS4gVGhlIGNsb25lIGlzIHRoZSBzYW1lIGxvZ2ljYWwgbm9kZSBhcyB0aGUgb3JpZ2luYWwgbm9kZSxcbiAqIGRvIG5vdCB0cnkgYW5kIHVzZSB0aGlzIGZ1bmN0aW9uIHRvIGR1cGxpY2F0ZSBvciBjb3B5IGFuIGV4aXN0aW5nIG5vZGUuXG4gKlxuICogRG9lcyBub3QgbXV0YXRlIHRoZSBFZGl0b3JTdGF0ZS5cbiAqIEBwYXJhbSBub2RlIC0gVGhlIG5vZGUgdG8gYmUgY2xvbmVkLlxuICogQHJldHVybnMgVGhlIGNsb25lIG9mIHRoZSBub2RlLlxuICovXG5mdW5jdGlvbiAkY2xvbmVXaXRoUHJvcGVydGllcyhsYXRlc3ROb2RlKSB7XG4gIGNvbnN0IGNvbnN0cnVjdG9yID0gbGF0ZXN0Tm9kZS5jb25zdHJ1Y3RvcjtcbiAgY29uc3QgbXV0YWJsZU5vZGUgPSBjb25zdHJ1Y3Rvci5jbG9uZShsYXRlc3ROb2RlKTtcbiAgbXV0YWJsZU5vZGUuYWZ0ZXJDbG9uZUZyb20obGF0ZXN0Tm9kZSk7XG4gIHtcbiAgICBpZiAoIShtdXRhYmxlTm9kZS5fX2tleSA9PT0gbGF0ZXN0Tm9kZS5fX2tleSkpIHtcbiAgICAgIHRocm93IEVycm9yKGAkY2xvbmVXaXRoUHJvcGVydGllczogJHtjb25zdHJ1Y3Rvci5uYW1lfS5jbG9uZShub2RlKSAod2l0aCB0eXBlICcke2NvbnN0cnVjdG9yLmdldFR5cGUoKX0nKSBkaWQgbm90IHJldHVybiBhIG5vZGUgd2l0aCB0aGUgc2FtZSBrZXksIG1ha2Ugc3VyZSB0byBzcGVjaWZ5IG5vZGUuX19rZXkgYXMgdGhlIGxhc3QgYXJndW1lbnQgdG8gdGhlIGNvbnN0cnVjdG9yYCk7XG4gICAgfVxuICAgIGlmICghKG11dGFibGVOb2RlLl9fcGFyZW50ID09PSBsYXRlc3ROb2RlLl9fcGFyZW50ICYmIG11dGFibGVOb2RlLl9fbmV4dCA9PT0gbGF0ZXN0Tm9kZS5fX25leHQgJiYgbXV0YWJsZU5vZGUuX19wcmV2ID09PSBsYXRlc3ROb2RlLl9fcHJldikpIHtcbiAgICAgIHRocm93IEVycm9yKGAkY2xvbmVXaXRoUHJvcGVydGllczogJHtjb25zdHJ1Y3Rvci5uYW1lfS5jbG9uZShub2RlKSAod2l0aCB0eXBlICcke2NvbnN0cnVjdG9yLmdldFR5cGUoKX0nKSBvdmVycmlkZWQgYWZ0ZXJDbG9uZUZyb20gYnV0IGRpZCBub3QgY2FsbCBzdXBlci5hZnRlckNsb25lRnJvbShwcmV2Tm9kZSlgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG11dGFibGVOb2RlO1xufVxuZnVuY3Rpb24gc2V0Tm9kZUluZGVudEZyb21ET00oZWxlbWVudERvbSwgZWxlbWVudE5vZGUpIHtcbiAgY29uc3QgaW5kZW50U2l6ZSA9IHBhcnNlSW50KGVsZW1lbnREb20uc3R5bGUucGFkZGluZ0lubGluZVN0YXJ0LCAxMCkgfHwgMDtcbiAgY29uc3QgaW5kZW50ID0gaW5kZW50U2l6ZSAvIDQwO1xuICBlbGVtZW50Tm9kZS5zZXRJbmRlbnQoaW5kZW50KTtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqXG4gKiBNYXJrIHRoaXMgbm9kZSBhcyB1bm1hbmFnZWQgYnkgbGV4aWNhbCdzIG11dGF0aW9uIG9ic2VydmVyIGxpa2VcbiAqIGRlY29yYXRvciBub2Rlc1xuICovXG5mdW5jdGlvbiBzZXRET01Vbm1hbmFnZWQoZWxlbWVudERvbSkge1xuICBjb25zdCBlbCA9IGVsZW1lbnREb207XG4gIGVsLl9fbGV4aWNhbFVubWFuYWdlZCA9IHRydWU7XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKlxuICogVHJ1ZSBpZiB0aGlzIERPTSBub2RlIHdhcyBtYXJrZWQgd2l0aCB7QGxpbmsgc2V0RE9NVW5tYW5hZ2VkfVxuICovXG5mdW5jdGlvbiBpc0RPTVVubWFuYWdlZChlbGVtZW50RG9tKSB7XG4gIGNvbnN0IGVsID0gZWxlbWVudERvbTtcbiAgcmV0dXJuIGVsLl9fbGV4aWNhbFVubWFuYWdlZCA9PT0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiAkZ2FyYmFnZUNvbGxlY3REZXRhY2hlZERlY29yYXRvcnMoZWRpdG9yLCBwZW5kaW5nRWRpdG9yU3RhdGUpIHtcbiAgY29uc3QgY3VycmVudERlY29yYXRvcnMgPSBlZGl0b3IuX2RlY29yYXRvcnM7XG4gIGNvbnN0IHBlbmRpbmdEZWNvcmF0b3JzID0gZWRpdG9yLl9wZW5kaW5nRGVjb3JhdG9ycztcbiAgbGV0IGRlY29yYXRvcnMgPSBwZW5kaW5nRGVjb3JhdG9ycyB8fCBjdXJyZW50RGVjb3JhdG9ycztcbiAgY29uc3Qgbm9kZU1hcCA9IHBlbmRpbmdFZGl0b3JTdGF0ZS5fbm9kZU1hcDtcbiAgbGV0IGtleTtcbiAgZm9yIChrZXkgaW4gZGVjb3JhdG9ycykge1xuICAgIGlmICghbm9kZU1hcC5oYXMoa2V5KSkge1xuICAgICAgaWYgKGRlY29yYXRvcnMgPT09IGN1cnJlbnREZWNvcmF0b3JzKSB7XG4gICAgICAgIGRlY29yYXRvcnMgPSBjbG9uZURlY29yYXRvcnMoZWRpdG9yKTtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSBkZWNvcmF0b3JzW2tleV07XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiAkZ2FyYmFnZUNvbGxlY3REZXRhY2hlZERlZXBDaGlsZE5vZGVzKG5vZGUsIHBhcmVudEtleSwgcHJldk5vZGVNYXAsIG5vZGVNYXAsIG5vZGVNYXBEZWxldGUsIGRpcnR5Tm9kZXMpIHtcbiAgbGV0IGNoaWxkID0gbm9kZS5nZXRGaXJzdENoaWxkKCk7XG4gIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgIGNvbnN0IGNoaWxkS2V5ID0gY2hpbGQuX19rZXk7XG4gICAgLy8gVE9ETyBSZXZpc2UgY29uZGl0aW9uIGJlbG93LCByZWR1bmRhbnQ/IExleGljYWxOb2RlIGFscmVhZHkgY2xlYW5zIHVwIGNoaWxkcmVuIHdoZW4gbW92aW5nIE5vZGVzXG4gICAgaWYgKGNoaWxkLl9fcGFyZW50ID09PSBwYXJlbnRLZXkpIHtcbiAgICAgIGlmICgkaXNFbGVtZW50Tm9kZShjaGlsZCkpIHtcbiAgICAgICAgJGdhcmJhZ2VDb2xsZWN0RGV0YWNoZWREZWVwQ2hpbGROb2RlcyhjaGlsZCwgY2hpbGRLZXksIHByZXZOb2RlTWFwLCBub2RlTWFwLCBub2RlTWFwRGVsZXRlLCBkaXJ0eU5vZGVzKTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgd2UgaGF2ZSBjcmVhdGVkIGEgbm9kZSBhbmQgaXQgd2FzIGRlcmVmZXJlbmNlZCwgdGhlbiBhbHNvXG4gICAgICAvLyByZW1vdmUgaXQgZnJvbSBvdXQgZGlydHkgbm9kZXMgU2V0LlxuICAgICAgaWYgKCFwcmV2Tm9kZU1hcC5oYXMoY2hpbGRLZXkpKSB7XG4gICAgICAgIGRpcnR5Tm9kZXMuZGVsZXRlKGNoaWxkS2V5KTtcbiAgICAgIH1cbiAgICAgIG5vZGVNYXBEZWxldGUucHVzaChjaGlsZEtleSk7XG4gICAgfVxuICAgIGNoaWxkID0gY2hpbGQuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgfVxufVxuZnVuY3Rpb24gJGdhcmJhZ2VDb2xsZWN0RGV0YWNoZWROb2RlcyhwcmV2RWRpdG9yU3RhdGUsIGVkaXRvclN0YXRlLCBkaXJ0eUxlYXZlcywgZGlydHlFbGVtZW50cykge1xuICBjb25zdCBwcmV2Tm9kZU1hcCA9IHByZXZFZGl0b3JTdGF0ZS5fbm9kZU1hcDtcbiAgY29uc3Qgbm9kZU1hcCA9IGVkaXRvclN0YXRlLl9ub2RlTWFwO1xuICAvLyBTdG9yZSBkaXJ0eUVsZW1lbnRzIGluIGEgcXVldWUgZm9yIGxhdGVyIGRlbGV0aW9uOyBkZWxldGluZyBkaXJ0eSBzdWJ0cmVlcyB0b28gZWFybHkgd2lsbFxuICAvLyBoaW5kZXIgYWNjZXNzaW5nIC5fX25leHQgb24gY2hpbGQgbm9kZXNcbiAgY29uc3Qgbm9kZU1hcERlbGV0ZSA9IFtdO1xuICBmb3IgKGNvbnN0IFtub2RlS2V5XSBvZiBkaXJ0eUVsZW1lbnRzKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVNYXAuZ2V0KG5vZGVLZXkpO1xuICAgIGlmIChub2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEdhcmJhZ2UgY29sbGVjdCBub2RlIGFuZCBpdHMgY2hpbGRyZW4gaWYgdGhleSBleGlzdFxuICAgICAgaWYgKCFub2RlLmlzQXR0YWNoZWQoKSkge1xuICAgICAgICBpZiAoJGlzRWxlbWVudE5vZGUobm9kZSkpIHtcbiAgICAgICAgICAkZ2FyYmFnZUNvbGxlY3REZXRhY2hlZERlZXBDaGlsZE5vZGVzKG5vZGUsIG5vZGVLZXksIHByZXZOb2RlTWFwLCBub2RlTWFwLCBub2RlTWFwRGVsZXRlLCBkaXJ0eUVsZW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBoYXZlIGNyZWF0ZWQgYSBub2RlIGFuZCBpdCB3YXMgZGVyZWZlcmVuY2VkLCB0aGVuIGFsc29cbiAgICAgICAgLy8gcmVtb3ZlIGl0IGZyb20gb3V0IGRpcnR5IG5vZGVzIFNldC5cbiAgICAgICAgaWYgKCFwcmV2Tm9kZU1hcC5oYXMobm9kZUtleSkpIHtcbiAgICAgICAgICBkaXJ0eUVsZW1lbnRzLmRlbGV0ZShub2RlS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBub2RlTWFwRGVsZXRlLnB1c2gobm9kZUtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3Qgbm9kZUtleSBvZiBub2RlTWFwRGVsZXRlKSB7XG4gICAgbm9kZU1hcC5kZWxldGUobm9kZUtleSk7XG4gIH1cbiAgZm9yIChjb25zdCBub2RlS2V5IG9mIGRpcnR5TGVhdmVzKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVNYXAuZ2V0KG5vZGVLZXkpO1xuICAgIGlmIChub2RlICE9PSB1bmRlZmluZWQgJiYgIW5vZGUuaXNBdHRhY2hlZCgpKSB7XG4gICAgICBpZiAoIXByZXZOb2RlTWFwLmhhcyhub2RlS2V5KSkge1xuICAgICAgICBkaXJ0eUxlYXZlcy5kZWxldGUobm9kZUtleSk7XG4gICAgICB9XG4gICAgICBub2RlTWFwLmRlbGV0ZShub2RlS2V5KTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5sZXQgc3ViVHJlZVRleHRDb250ZW50ID0gJyc7XG5sZXQgc3ViVHJlZURpcmVjdGlvbmVkVGV4dENvbnRlbnQgPSAnJztcbmxldCBzdWJUcmVlVGV4dEZvcm1hdCA9IG51bGw7XG5sZXQgc3ViVHJlZVRleHRTdHlsZSA9ICcnO1xubGV0IGVkaXRvclRleHRDb250ZW50ID0gJyc7XG5sZXQgYWN0aXZlRWRpdG9yQ29uZmlnO1xubGV0IGFjdGl2ZUVkaXRvciQxO1xubGV0IGFjdGl2ZUVkaXRvck5vZGVzO1xubGV0IHRyZWF0QWxsTm9kZXNBc0RpcnR5ID0gZmFsc2U7XG5sZXQgYWN0aXZlRWRpdG9yU3RhdGVSZWFkT25seSA9IGZhbHNlO1xubGV0IGFjdGl2ZU11dGF0aW9uTGlzdGVuZXJzO1xubGV0IGFjdGl2ZVRleHREaXJlY3Rpb24gPSBudWxsO1xubGV0IGFjdGl2ZURpcnR5RWxlbWVudHM7XG5sZXQgYWN0aXZlRGlydHlMZWF2ZXM7XG5sZXQgYWN0aXZlUHJldk5vZGVNYXA7XG5sZXQgYWN0aXZlTmV4dE5vZGVNYXA7XG5sZXQgYWN0aXZlUHJldktleVRvRE9NTWFwO1xubGV0IG11dGF0ZWROb2RlcztcbmZ1bmN0aW9uIGRlc3Ryb3lOb2RlKGtleSwgcGFyZW50RE9NKSB7XG4gIGNvbnN0IG5vZGUgPSBhY3RpdmVQcmV2Tm9kZU1hcC5nZXQoa2V5KTtcbiAgaWYgKHBhcmVudERPTSAhPT0gbnVsbCkge1xuICAgIGNvbnN0IGRvbSA9IGdldFByZXZFbGVtZW50QnlLZXlPclRocm93KGtleSk7XG4gICAgaWYgKGRvbS5wYXJlbnROb2RlID09PSBwYXJlbnRET00pIHtcbiAgICAgIHBhcmVudERPTS5yZW1vdmVDaGlsZChkb20pO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRoaXMgbG9naWMgaXMgcmVhbGx5IGltcG9ydGFudCwgb3RoZXJ3aXNlIHdlIHdpbGwgbGVhayBET00gbm9kZXNcbiAgLy8gd2hlbiB0aGVpciBjb3JyZXNwb25kaW5nIExleGljYWxOb2RlcyBhcmUgcmVtb3ZlZCBmcm9tIHRoZSBlZGl0b3Igc3RhdGUuXG4gIGlmICghYWN0aXZlTmV4dE5vZGVNYXAuaGFzKGtleSkpIHtcbiAgICBhY3RpdmVFZGl0b3IkMS5fa2V5VG9ET01NYXAuZGVsZXRlKGtleSk7XG4gIH1cbiAgaWYgKCRpc0VsZW1lbnROb2RlKG5vZGUpKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBjcmVhdGVDaGlsZHJlbkFycmF5KG5vZGUsIGFjdGl2ZVByZXZOb2RlTWFwKTtcbiAgICBkZXN0cm95Q2hpbGRyZW4oY2hpbGRyZW4sIDAsIGNoaWxkcmVuLmxlbmd0aCAtIDEsIG51bGwpO1xuICB9XG4gIGlmIChub2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICBzZXRNdXRhdGVkTm9kZShtdXRhdGVkTm9kZXMsIGFjdGl2ZUVkaXRvck5vZGVzLCBhY3RpdmVNdXRhdGlvbkxpc3RlbmVycywgbm9kZSwgJ2Rlc3Ryb3llZCcpO1xuICB9XG59XG5mdW5jdGlvbiBkZXN0cm95Q2hpbGRyZW4oY2hpbGRyZW4sIF9zdGFydEluZGV4LCBlbmRJbmRleCwgZG9tKSB7XG4gIGxldCBzdGFydEluZGV4ID0gX3N0YXJ0SW5kZXg7XG4gIGZvciAoOyBzdGFydEluZGV4IDw9IGVuZEluZGV4OyArK3N0YXJ0SW5kZXgpIHtcbiAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW3N0YXJ0SW5kZXhdO1xuICAgIGlmIChjaGlsZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBkZXN0cm95Tm9kZShjaGlsZCwgZG9tKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHNldFRleHRBbGlnbihkb21TdHlsZSwgdmFsdWUpIHtcbiAgZG9tU3R5bGUuc2V0UHJvcGVydHkoJ3RleHQtYWxpZ24nLCB2YWx1ZSk7XG59XG5jb25zdCBERUZBVUxUX0lOREVOVF9WQUxVRSA9ICc0MHB4JztcbmZ1bmN0aW9uIHNldEVsZW1lbnRJbmRlbnQoZG9tLCBpbmRlbnQpIHtcbiAgY29uc3QgaW5kZW50Q2xhc3NOYW1lID0gYWN0aXZlRWRpdG9yQ29uZmlnLnRoZW1lLmluZGVudDtcbiAgaWYgKHR5cGVvZiBpbmRlbnRDbGFzc05hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3QgZWxlbWVudEhhc0NsYXNzTmFtZSA9IGRvbS5jbGFzc0xpc3QuY29udGFpbnMoaW5kZW50Q2xhc3NOYW1lKTtcbiAgICBpZiAoaW5kZW50ID4gMCAmJiAhZWxlbWVudEhhc0NsYXNzTmFtZSkge1xuICAgICAgZG9tLmNsYXNzTGlzdC5hZGQoaW5kZW50Q2xhc3NOYW1lKTtcbiAgICB9IGVsc2UgaWYgKGluZGVudCA8IDEgJiYgZWxlbWVudEhhc0NsYXNzTmFtZSkge1xuICAgICAgZG9tLmNsYXNzTGlzdC5yZW1vdmUoaW5kZW50Q2xhc3NOYW1lKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgaW5kZW50YXRpb25CYXNlVmFsdWUgPSBnZXRDb21wdXRlZFN0eWxlKGRvbSkuZ2V0UHJvcGVydHlWYWx1ZSgnLS1sZXhpY2FsLWluZGVudC1iYXNlLXZhbHVlJykgfHwgREVGQVVMVF9JTkRFTlRfVkFMVUU7XG4gIGRvbS5zdHlsZS5zZXRQcm9wZXJ0eSgncGFkZGluZy1pbmxpbmUtc3RhcnQnLCBpbmRlbnQgPT09IDAgPyAnJyA6IGBjYWxjKCR7aW5kZW50fSAqICR7aW5kZW50YXRpb25CYXNlVmFsdWV9KWApO1xufVxuZnVuY3Rpb24gc2V0RWxlbWVudEZvcm1hdChkb20sIGZvcm1hdCkge1xuICBjb25zdCBkb21TdHlsZSA9IGRvbS5zdHlsZTtcbiAgaWYgKGZvcm1hdCA9PT0gMCkge1xuICAgIHNldFRleHRBbGlnbihkb21TdHlsZSwgJycpO1xuICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gSVNfQUxJR05fTEVGVCkge1xuICAgIHNldFRleHRBbGlnbihkb21TdHlsZSwgJ2xlZnQnKTtcbiAgfSBlbHNlIGlmIChmb3JtYXQgPT09IElTX0FMSUdOX0NFTlRFUikge1xuICAgIHNldFRleHRBbGlnbihkb21TdHlsZSwgJ2NlbnRlcicpO1xuICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gSVNfQUxJR05fUklHSFQpIHtcbiAgICBzZXRUZXh0QWxpZ24oZG9tU3R5bGUsICdyaWdodCcpO1xuICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gSVNfQUxJR05fSlVTVElGWSkge1xuICAgIHNldFRleHRBbGlnbihkb21TdHlsZSwgJ2p1c3RpZnknKTtcbiAgfSBlbHNlIGlmIChmb3JtYXQgPT09IElTX0FMSUdOX1NUQVJUKSB7XG4gICAgc2V0VGV4dEFsaWduKGRvbVN0eWxlLCAnc3RhcnQnKTtcbiAgfSBlbHNlIGlmIChmb3JtYXQgPT09IElTX0FMSUdOX0VORCkge1xuICAgIHNldFRleHRBbGlnbihkb21TdHlsZSwgJ2VuZCcpO1xuICB9XG59XG5mdW5jdGlvbiAkY3JlYXRlTm9kZShrZXksIHNsb3QpIHtcbiAgY29uc3Qgbm9kZSA9IGFjdGl2ZU5leHROb2RlTWFwLmdldChrZXkpO1xuICBpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYGNyZWF0ZU5vZGU6IG5vZGUgZG9lcyBub3QgZXhpc3QgaW4gbm9kZU1hcGApO1xuICAgIH1cbiAgfVxuICBjb25zdCBkb20gPSBub2RlLmNyZWF0ZURPTShhY3RpdmVFZGl0b3JDb25maWcsIGFjdGl2ZUVkaXRvciQxKTtcbiAgc3RvcmVET01XaXRoS2V5KGtleSwgZG9tLCBhY3RpdmVFZGl0b3IkMSk7XG5cbiAgLy8gVGhpcyBoZWxwcyBwcmVzZXJ2ZSB0aGUgdGV4dCwgYW5kIHN0b3BzIHNwZWxsIGNoZWNrIHRvb2xzIGZyb21cbiAgLy8gbWVyZ2luZyBvciBicmVhayB0aGUgc3BhbnMgKHdoaWNoIGhhcHBlbnMgaWYgdGhleSBhcmUgbWlzc2luZ1xuICAvLyB0aGlzIGF0dHJpYnV0ZSkuXG4gIGlmICgkaXNUZXh0Tm9kZShub2RlKSkge1xuICAgIGRvbS5zZXRBdHRyaWJ1dGUoJ2RhdGEtbGV4aWNhbC10ZXh0JywgJ3RydWUnKTtcbiAgfSBlbHNlIGlmICgkaXNEZWNvcmF0b3JOb2RlKG5vZGUpKSB7XG4gICAgZG9tLnNldEF0dHJpYnV0ZSgnZGF0YS1sZXhpY2FsLWRlY29yYXRvcicsICd0cnVlJyk7XG4gIH1cbiAgaWYgKCRpc0VsZW1lbnROb2RlKG5vZGUpKSB7XG4gICAgY29uc3QgaW5kZW50ID0gbm9kZS5fX2luZGVudDtcbiAgICBjb25zdCBjaGlsZHJlblNpemUgPSBub2RlLl9fc2l6ZTtcbiAgICBpZiAoaW5kZW50ICE9PSAwKSB7XG4gICAgICBzZXRFbGVtZW50SW5kZW50KGRvbSwgaW5kZW50KTtcbiAgICB9XG4gICAgaWYgKGNoaWxkcmVuU2l6ZSAhPT0gMCkge1xuICAgICAgY29uc3QgZW5kSW5kZXggPSBjaGlsZHJlblNpemUgLSAxO1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSBjcmVhdGVDaGlsZHJlbkFycmF5KG5vZGUsIGFjdGl2ZU5leHROb2RlTWFwKTtcbiAgICAgICRjcmVhdGVDaGlsZHJlbldpdGhEaXJlY3Rpb24oY2hpbGRyZW4sIGVuZEluZGV4LCBub2RlLCBkb20pO1xuICAgIH1cbiAgICBjb25zdCBmb3JtYXQgPSBub2RlLl9fZm9ybWF0O1xuICAgIGlmIChmb3JtYXQgIT09IDApIHtcbiAgICAgIHNldEVsZW1lbnRGb3JtYXQoZG9tLCBmb3JtYXQpO1xuICAgIH1cbiAgICBpZiAoIW5vZGUuaXNJbmxpbmUoKSkge1xuICAgICAgcmVjb25jaWxlRWxlbWVudFRlcm1pbmF0aW5nTGluZUJyZWFrKG51bGwsIG5vZGUsIGRvbSk7XG4gICAgfVxuICAgIGlmICgkdGV4dENvbnRlbnRSZXF1aXJlc0RvdWJsZUxpbmVicmVha0F0RW5kKG5vZGUpKSB7XG4gICAgICBzdWJUcmVlVGV4dENvbnRlbnQgKz0gRE9VQkxFX0xJTkVfQlJFQUs7XG4gICAgICBlZGl0b3JUZXh0Q29udGVudCArPSBET1VCTEVfTElORV9CUkVBSztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgdGV4dCA9IG5vZGUuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICBpZiAoJGlzRGVjb3JhdG9yTm9kZShub2RlKSkge1xuICAgICAgY29uc3QgZGVjb3JhdG9yID0gbm9kZS5kZWNvcmF0ZShhY3RpdmVFZGl0b3IkMSwgYWN0aXZlRWRpdG9yQ29uZmlnKTtcbiAgICAgIGlmIChkZWNvcmF0b3IgIT09IG51bGwpIHtcbiAgICAgICAgcmVjb25jaWxlRGVjb3JhdG9yKGtleSwgZGVjb3JhdG9yKTtcbiAgICAgIH1cbiAgICAgIC8vIERlY29yYXRvcnMgYXJlIGFsd2F5cyBub24gZWRpdGFibGVcbiAgICAgIGRvbS5jb250ZW50RWRpdGFibGUgPSAnZmFsc2UnO1xuICAgIH0gZWxzZSBpZiAoJGlzVGV4dE5vZGUobm9kZSkpIHtcbiAgICAgIGlmICghbm9kZS5pc0RpcmVjdGlvbmxlc3MoKSkge1xuICAgICAgICBzdWJUcmVlRGlyZWN0aW9uZWRUZXh0Q29udGVudCArPSB0ZXh0O1xuICAgICAgfVxuICAgIH1cbiAgICBzdWJUcmVlVGV4dENvbnRlbnQgKz0gdGV4dDtcbiAgICBlZGl0b3JUZXh0Q29udGVudCArPSB0ZXh0O1xuICB9XG4gIGlmIChzbG90ICE9PSBudWxsKSB7XG4gICAgc2xvdC5pbnNlcnRDaGlsZChkb20pO1xuICB9XG4gIHtcbiAgICAvLyBGcmVlemUgdGhlIG5vZGUgaW4gREVWIHRvIHByZXZlbnQgYWNjaWRlbnRhbCBtdXRhdGlvbnNcbiAgICBPYmplY3QuZnJlZXplKG5vZGUpO1xuICB9XG4gIHNldE11dGF0ZWROb2RlKG11dGF0ZWROb2RlcywgYWN0aXZlRWRpdG9yTm9kZXMsIGFjdGl2ZU11dGF0aW9uTGlzdGVuZXJzLCBub2RlLCAnY3JlYXRlZCcpO1xuICByZXR1cm4gZG9tO1xufVxuZnVuY3Rpb24gJGNyZWF0ZUNoaWxkcmVuV2l0aERpcmVjdGlvbihjaGlsZHJlbiwgZW5kSW5kZXgsIGVsZW1lbnQsIGRvbSkge1xuICBjb25zdCBwcmV2aW91c1N1YlRyZWVEaXJlY3Rpb25lZFRleHRDb250ZW50ID0gc3ViVHJlZURpcmVjdGlvbmVkVGV4dENvbnRlbnQ7XG4gIHN1YlRyZWVEaXJlY3Rpb25lZFRleHRDb250ZW50ID0gJyc7XG4gICRjcmVhdGVDaGlsZHJlbihjaGlsZHJlbiwgZWxlbWVudCwgMCwgZW5kSW5kZXgsIGVsZW1lbnQuZ2V0RE9NU2xvdChkb20pKTtcbiAgcmVjb25jaWxlQmxvY2tEaXJlY3Rpb24oZWxlbWVudCwgZG9tKTtcbiAgc3ViVHJlZURpcmVjdGlvbmVkVGV4dENvbnRlbnQgPSBwcmV2aW91c1N1YlRyZWVEaXJlY3Rpb25lZFRleHRDb250ZW50O1xufVxuZnVuY3Rpb24gJGNyZWF0ZUNoaWxkcmVuKGNoaWxkcmVuLCBlbGVtZW50LCBfc3RhcnRJbmRleCwgZW5kSW5kZXgsIHNsb3QpIHtcbiAgY29uc3QgcHJldmlvdXNTdWJUcmVlVGV4dENvbnRlbnQgPSBzdWJUcmVlVGV4dENvbnRlbnQ7XG4gIHN1YlRyZWVUZXh0Q29udGVudCA9ICcnO1xuICBsZXQgc3RhcnRJbmRleCA9IF9zdGFydEluZGV4O1xuICBmb3IgKDsgc3RhcnRJbmRleCA8PSBlbmRJbmRleDsgKytzdGFydEluZGV4KSB7XG4gICAgJGNyZWF0ZU5vZGUoY2hpbGRyZW5bc3RhcnRJbmRleF0sIHNsb3QpO1xuICAgIGNvbnN0IG5vZGUgPSBhY3RpdmVOZXh0Tm9kZU1hcC5nZXQoY2hpbGRyZW5bc3RhcnRJbmRleF0pO1xuICAgIGlmIChub2RlICE9PSBudWxsICYmICRpc1RleHROb2RlKG5vZGUpKSB7XG4gICAgICBpZiAoc3ViVHJlZVRleHRGb3JtYXQgPT09IG51bGwpIHtcbiAgICAgICAgc3ViVHJlZVRleHRGb3JtYXQgPSBub2RlLmdldEZvcm1hdCgpO1xuICAgICAgfVxuICAgICAgaWYgKHN1YlRyZWVUZXh0U3R5bGUgPT09ICcnKSB7XG4gICAgICAgIHN1YlRyZWVUZXh0U3R5bGUgPSBub2RlLmdldFN0eWxlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICgkdGV4dENvbnRlbnRSZXF1aXJlc0RvdWJsZUxpbmVicmVha0F0RW5kKGVsZW1lbnQpKSB7XG4gICAgc3ViVHJlZVRleHRDb250ZW50ICs9IERPVUJMRV9MSU5FX0JSRUFLO1xuICB9XG4gIGNvbnN0IGRvbSA9IHNsb3QuZWxlbWVudDtcbiAgZG9tLl9fbGV4aWNhbFRleHRDb250ZW50ID0gc3ViVHJlZVRleHRDb250ZW50O1xuICBzdWJUcmVlVGV4dENvbnRlbnQgPSBwcmV2aW91c1N1YlRyZWVUZXh0Q29udGVudCArIHN1YlRyZWVUZXh0Q29udGVudDtcbn1cbmZ1bmN0aW9uIGlzTGFzdENoaWxkTGluZUJyZWFrT3JEZWNvcmF0b3IoZWxlbWVudCwgbm9kZU1hcCkge1xuICBpZiAoZWxlbWVudCkge1xuICAgIGNvbnN0IGxhc3RLZXkgPSBlbGVtZW50Ll9fbGFzdDtcbiAgICBpZiAobGFzdEtleSkge1xuICAgICAgY29uc3Qgbm9kZSA9IG5vZGVNYXAuZ2V0KGxhc3RLZXkpO1xuICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuICRpc0xpbmVCcmVha05vZGUobm9kZSkgPyAnbGluZS1icmVhaycgOiAkaXNEZWNvcmF0b3JOb2RlKG5vZGUpICYmIG5vZGUuaXNJbmxpbmUoKSA/ICdkZWNvcmF0b3InIDogbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICdlbXB0eSc7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vIElmIHdlIGVuZCBhbiBlbGVtZW50IHdpdGggYSBMaW5lQnJlYWtOb2RlLCB0aGVuIHdlIG5lZWQgdG8gYWRkIGFuIGFkZGl0aW9uYWwgPGJyPlxuZnVuY3Rpb24gcmVjb25jaWxlRWxlbWVudFRlcm1pbmF0aW5nTGluZUJyZWFrKHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCwgZG9tKSB7XG4gIGNvbnN0IHByZXZMaW5lQnJlYWsgPSBpc0xhc3RDaGlsZExpbmVCcmVha09yRGVjb3JhdG9yKHByZXZFbGVtZW50LCBhY3RpdmVQcmV2Tm9kZU1hcCk7XG4gIGNvbnN0IG5leHRMaW5lQnJlYWsgPSBpc0xhc3RDaGlsZExpbmVCcmVha09yRGVjb3JhdG9yKG5leHRFbGVtZW50LCBhY3RpdmVOZXh0Tm9kZU1hcCk7XG4gIGlmIChwcmV2TGluZUJyZWFrICE9PSBuZXh0TGluZUJyZWFrKSB7XG4gICAgbmV4dEVsZW1lbnQuZ2V0RE9NU2xvdChkb20pLnNldE1hbmFnZWRMaW5lQnJlYWsobmV4dExpbmVCcmVhayk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlY29uY2lsZVRleHRGb3JtYXQoZWxlbWVudCkge1xuICBpZiAoc3ViVHJlZVRleHRGb3JtYXQgIT0gbnVsbCAmJiBzdWJUcmVlVGV4dEZvcm1hdCAhPT0gZWxlbWVudC5fX3RleHRGb3JtYXQgJiYgIWFjdGl2ZUVkaXRvclN0YXRlUmVhZE9ubHkpIHtcbiAgICBlbGVtZW50LnNldFRleHRGb3JtYXQoc3ViVHJlZVRleHRGb3JtYXQpO1xuICAgIGVsZW1lbnQuc2V0VGV4dFN0eWxlKHN1YlRyZWVUZXh0U3R5bGUpO1xuICB9XG59XG5mdW5jdGlvbiByZWNvbmNpbGVUZXh0U3R5bGUoZWxlbWVudCkge1xuICBpZiAoc3ViVHJlZVRleHRTdHlsZSAhPT0gJycgJiYgc3ViVHJlZVRleHRTdHlsZSAhPT0gZWxlbWVudC5fX3RleHRTdHlsZSAmJiAhYWN0aXZlRWRpdG9yU3RhdGVSZWFkT25seSkge1xuICAgIGVsZW1lbnQuc2V0VGV4dFN0eWxlKHN1YlRyZWVUZXh0U3R5bGUpO1xuICB9XG59XG5mdW5jdGlvbiByZWNvbmNpbGVCbG9ja0RpcmVjdGlvbihlbGVtZW50LCBkb20pIHtcbiAgY29uc3QgcHJldmlvdXNTdWJUcmVlRGlyZWN0aW9uVGV4dENvbnRlbnQgPSBkb20uX19sZXhpY2FsRGlyVGV4dENvbnRlbnQgfHwgJyc7XG4gIGNvbnN0IHByZXZpb3VzRGlyZWN0aW9uID0gZG9tLl9fbGV4aWNhbERpciB8fCAnJztcbiAgaWYgKHByZXZpb3VzU3ViVHJlZURpcmVjdGlvblRleHRDb250ZW50ICE9PSBzdWJUcmVlRGlyZWN0aW9uZWRUZXh0Q29udGVudCB8fCBwcmV2aW91c0RpcmVjdGlvbiAhPT0gYWN0aXZlVGV4dERpcmVjdGlvbikge1xuICAgIGNvbnN0IGhhc0VtcHR5RGlyZWN0aW9uZWRUZXh0Q29udGVudCA9IHN1YlRyZWVEaXJlY3Rpb25lZFRleHRDb250ZW50ID09PSAnJztcbiAgICBjb25zdCBkaXJlY3Rpb24gPSBoYXNFbXB0eURpcmVjdGlvbmVkVGV4dENvbnRlbnQgPyBhY3RpdmVUZXh0RGlyZWN0aW9uIDogZ2V0VGV4dERpcmVjdGlvbihzdWJUcmVlRGlyZWN0aW9uZWRUZXh0Q29udGVudCk7XG4gICAgaWYgKGRpcmVjdGlvbiAhPT0gcHJldmlvdXNEaXJlY3Rpb24pIHtcbiAgICAgIGNvbnN0IGNsYXNzTGlzdCA9IGRvbS5jbGFzc0xpc3Q7XG4gICAgICBjb25zdCB0aGVtZSA9IGFjdGl2ZUVkaXRvckNvbmZpZy50aGVtZTtcbiAgICAgIGxldCBwcmV2aW91c0RpcmVjdGlvblRoZW1lID0gcHJldmlvdXNEaXJlY3Rpb24gIT09IG51bGwgPyB0aGVtZVtwcmV2aW91c0RpcmVjdGlvbl0gOiB1bmRlZmluZWQ7XG4gICAgICBsZXQgbmV4dERpcmVjdGlvblRoZW1lID0gZGlyZWN0aW9uICE9PSBudWxsID8gdGhlbWVbZGlyZWN0aW9uXSA6IHVuZGVmaW5lZDtcblxuICAgICAgLy8gUmVtb3ZlIHRoZSBvbGQgdGhlbWUgY2xhc3NlcyBpZiB0aGV5IGV4aXN0XG4gICAgICBpZiAocHJldmlvdXNEaXJlY3Rpb25UaGVtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJldmlvdXNEaXJlY3Rpb25UaGVtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBjb25zdCBjbGFzc05hbWVzQXJyID0gbm9ybWFsaXplQ2xhc3NOYW1lcyhwcmV2aW91c0RpcmVjdGlvblRoZW1lKTtcbiAgICAgICAgICBwcmV2aW91c0RpcmVjdGlvblRoZW1lID0gdGhlbWVbcHJldmlvdXNEaXJlY3Rpb25dID0gY2xhc3NOYW1lc0FycjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEB0cy1pZ25vcmU6IGludGVudGlvbmFsXG4gICAgICAgIGNsYXNzTGlzdC5yZW1vdmUoLi4ucHJldmlvdXNEaXJlY3Rpb25UaGVtZSk7XG4gICAgICB9XG4gICAgICBpZiAoZGlyZWN0aW9uID09PSBudWxsIHx8IGhhc0VtcHR5RGlyZWN0aW9uZWRUZXh0Q29udGVudCAmJiBkaXJlY3Rpb24gPT09ICdsdHInKSB7XG4gICAgICAgIC8vIFJlbW92ZSBkaXJlY3Rpb25cbiAgICAgICAgZG9tLnJlbW92ZUF0dHJpYnV0ZSgnZGlyJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBcHBseSB0aGUgbmV3IHRoZW1lIGNsYXNzZXMgaWYgdGhleSBleGlzdFxuICAgICAgICBpZiAobmV4dERpcmVjdGlvblRoZW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG5leHREaXJlY3Rpb25UaGVtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnN0IGNsYXNzTmFtZXNBcnIgPSBub3JtYWxpemVDbGFzc05hbWVzKG5leHREaXJlY3Rpb25UaGVtZSk7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbnRlbnRpb25hbFxuICAgICAgICAgICAgbmV4dERpcmVjdGlvblRoZW1lID0gdGhlbWVbZGlyZWN0aW9uXSA9IGNsYXNzTmFtZXNBcnI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChuZXh0RGlyZWN0aW9uVGhlbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2xhc3NMaXN0LmFkZCguLi5uZXh0RGlyZWN0aW9uVGhlbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSBkaXJlY3Rpb25cbiAgICAgICAgZG9tLmRpciA9IGRpcmVjdGlvbjtcbiAgICAgIH1cbiAgICAgIGlmICghYWN0aXZlRWRpdG9yU3RhdGVSZWFkT25seSkge1xuICAgICAgICBjb25zdCB3cml0YWJsZU5vZGUgPSBlbGVtZW50LmdldFdyaXRhYmxlKCk7XG4gICAgICAgIHdyaXRhYmxlTm9kZS5fX2RpciA9IGRpcmVjdGlvbjtcbiAgICAgIH1cbiAgICB9XG4gICAgYWN0aXZlVGV4dERpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICBkb20uX19sZXhpY2FsRGlyVGV4dENvbnRlbnQgPSBzdWJUcmVlRGlyZWN0aW9uZWRUZXh0Q29udGVudDtcbiAgICBkb20uX19sZXhpY2FsRGlyID0gZGlyZWN0aW9uO1xuICB9XG59XG5mdW5jdGlvbiAkcmVjb25jaWxlQ2hpbGRyZW5XaXRoRGlyZWN0aW9uKHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCwgZG9tKSB7XG4gIGNvbnN0IHByZXZpb3VzU3ViVHJlZURpcmVjdGlvblRleHRDb250ZW50ID0gc3ViVHJlZURpcmVjdGlvbmVkVGV4dENvbnRlbnQ7XG4gIHN1YlRyZWVEaXJlY3Rpb25lZFRleHRDb250ZW50ID0gJyc7XG4gIHN1YlRyZWVUZXh0Rm9ybWF0ID0gbnVsbDtcbiAgc3ViVHJlZVRleHRTdHlsZSA9ICcnO1xuICAkcmVjb25jaWxlQ2hpbGRyZW4ocHJldkVsZW1lbnQsIG5leHRFbGVtZW50LCBuZXh0RWxlbWVudC5nZXRET01TbG90KGRvbSkpO1xuICByZWNvbmNpbGVCbG9ja0RpcmVjdGlvbihuZXh0RWxlbWVudCwgZG9tKTtcbiAgcmVjb25jaWxlVGV4dEZvcm1hdChuZXh0RWxlbWVudCk7XG4gIHJlY29uY2lsZVRleHRTdHlsZShuZXh0RWxlbWVudCk7XG4gIHN1YlRyZWVEaXJlY3Rpb25lZFRleHRDb250ZW50ID0gcHJldmlvdXNTdWJUcmVlRGlyZWN0aW9uVGV4dENvbnRlbnQ7XG59XG5mdW5jdGlvbiBjcmVhdGVDaGlsZHJlbkFycmF5KGVsZW1lbnQsIG5vZGVNYXApIHtcbiAgY29uc3QgY2hpbGRyZW4gPSBbXTtcbiAgbGV0IG5vZGVLZXkgPSBlbGVtZW50Ll9fZmlyc3Q7XG4gIHdoaWxlIChub2RlS2V5ICE9PSBudWxsKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVNYXAuZ2V0KG5vZGVLZXkpO1xuICAgIGlmIChub2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYGNyZWF0ZUNoaWxkcmVuQXJyYXk6IG5vZGUgZG9lcyBub3QgZXhpc3QgaW4gbm9kZU1hcGApO1xuICAgICAgfVxuICAgIH1cbiAgICBjaGlsZHJlbi5wdXNoKG5vZGVLZXkpO1xuICAgIG5vZGVLZXkgPSBub2RlLl9fbmV4dDtcbiAgfVxuICByZXR1cm4gY2hpbGRyZW47XG59XG5mdW5jdGlvbiAkcmVjb25jaWxlQ2hpbGRyZW4ocHJldkVsZW1lbnQsIG5leHRFbGVtZW50LCBzbG90KSB7XG4gIGNvbnN0IHByZXZpb3VzU3ViVHJlZVRleHRDb250ZW50ID0gc3ViVHJlZVRleHRDb250ZW50O1xuICBjb25zdCBwcmV2Q2hpbGRyZW5TaXplID0gcHJldkVsZW1lbnQuX19zaXplO1xuICBjb25zdCBuZXh0Q2hpbGRyZW5TaXplID0gbmV4dEVsZW1lbnQuX19zaXplO1xuICBzdWJUcmVlVGV4dENvbnRlbnQgPSAnJztcbiAgY29uc3QgZG9tID0gc2xvdC5lbGVtZW50O1xuICBpZiAocHJldkNoaWxkcmVuU2l6ZSA9PT0gMSAmJiBuZXh0Q2hpbGRyZW5TaXplID09PSAxKSB7XG4gICAgY29uc3QgcHJldkZpcnN0Q2hpbGRLZXkgPSBwcmV2RWxlbWVudC5fX2ZpcnN0O1xuICAgIGNvbnN0IG5leHRGaXJzdENoaWxkS2V5ID0gbmV4dEVsZW1lbnQuX19maXJzdDtcbiAgICBpZiAocHJldkZpcnN0Q2hpbGRLZXkgPT09IG5leHRGaXJzdENoaWxkS2V5KSB7XG4gICAgICAkcmVjb25jaWxlTm9kZShwcmV2Rmlyc3RDaGlsZEtleSwgZG9tKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbGFzdERPTSA9IGdldFByZXZFbGVtZW50QnlLZXlPclRocm93KHByZXZGaXJzdENoaWxkS2V5KTtcbiAgICAgIGNvbnN0IHJlcGxhY2VtZW50RE9NID0gJGNyZWF0ZU5vZGUobmV4dEZpcnN0Q2hpbGRLZXksIG51bGwpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZG9tLnJlcGxhY2VDaGlsZChyZXBsYWNlbWVudERPTSwgbGFzdERPTSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAodHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyAmJiBlcnJvciAhPSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgbXNnID0gYCR7ZXJyb3IudG9TdHJpbmcoKX0gUGFyZW50OiAke2RvbS50YWdOYW1lfSwgbmV3IGNoaWxkOiB7dGFnOiAke3JlcGxhY2VtZW50RE9NLnRhZ05hbWV9IGtleTogJHtuZXh0Rmlyc3RDaGlsZEtleX19LCBvbGQgY2hpbGQ6IHt0YWc6ICR7bGFzdERPTS50YWdOYW1lfSwga2V5OiAke3ByZXZGaXJzdENoaWxkS2V5fX0uYDtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGVzdHJveU5vZGUocHJldkZpcnN0Q2hpbGRLZXksIG51bGwpO1xuICAgIH1cbiAgICBjb25zdCBuZXh0Q2hpbGROb2RlID0gYWN0aXZlTmV4dE5vZGVNYXAuZ2V0KG5leHRGaXJzdENoaWxkS2V5KTtcbiAgICBpZiAoJGlzVGV4dE5vZGUobmV4dENoaWxkTm9kZSkpIHtcbiAgICAgIGlmIChzdWJUcmVlVGV4dEZvcm1hdCA9PT0gbnVsbCkge1xuICAgICAgICBzdWJUcmVlVGV4dEZvcm1hdCA9IG5leHRDaGlsZE5vZGUuZ2V0Rm9ybWF0KCk7XG4gICAgICB9XG4gICAgICBpZiAoc3ViVHJlZVRleHRTdHlsZSA9PT0gJycpIHtcbiAgICAgICAgc3ViVHJlZVRleHRTdHlsZSA9IG5leHRDaGlsZE5vZGUuZ2V0U3R5bGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcHJldkNoaWxkcmVuID0gY3JlYXRlQ2hpbGRyZW5BcnJheShwcmV2RWxlbWVudCwgYWN0aXZlUHJldk5vZGVNYXApO1xuICAgIGNvbnN0IG5leHRDaGlsZHJlbiA9IGNyZWF0ZUNoaWxkcmVuQXJyYXkobmV4dEVsZW1lbnQsIGFjdGl2ZU5leHROb2RlTWFwKTtcbiAgICBpZiAoIShwcmV2Q2hpbGRyZW4ubGVuZ3RoID09PSBwcmV2Q2hpbGRyZW5TaXplKSkge1xuICAgICAgdGhyb3cgRXJyb3IoYCRyZWNvbmNpbGVDaGlsZHJlbjogcHJldkNoaWxkcmVuLmxlbmd0aCAhPT0gcHJldkNoaWxkcmVuU2l6ZWApO1xuICAgIH1cbiAgICBpZiAoIShuZXh0Q2hpbGRyZW4ubGVuZ3RoID09PSBuZXh0Q2hpbGRyZW5TaXplKSkge1xuICAgICAgdGhyb3cgRXJyb3IoYCRyZWNvbmNpbGVDaGlsZHJlbjogbmV4dENoaWxkcmVuLmxlbmd0aCAhPT0gbmV4dENoaWxkcmVuU2l6ZWApO1xuICAgIH1cbiAgICBpZiAocHJldkNoaWxkcmVuU2l6ZSA9PT0gMCkge1xuICAgICAgaWYgKG5leHRDaGlsZHJlblNpemUgIT09IDApIHtcbiAgICAgICAgJGNyZWF0ZUNoaWxkcmVuKG5leHRDaGlsZHJlbiwgbmV4dEVsZW1lbnQsIDAsIG5leHRDaGlsZHJlblNpemUgLSAxLCBzbG90KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5leHRDaGlsZHJlblNpemUgPT09IDApIHtcbiAgICAgIGlmIChwcmV2Q2hpbGRyZW5TaXplICE9PSAwKSB7XG4gICAgICAgIGNvbnN0IGNhblVzZUZhc3RQYXRoID0gc2xvdC5hZnRlciA9PSBudWxsICYmIHNsb3QuYmVmb3JlID09IG51bGwgJiYgc2xvdC5lbGVtZW50Ll9fbGV4aWNhbExpbmVCcmVhayA9PSBudWxsO1xuICAgICAgICBkZXN0cm95Q2hpbGRyZW4ocHJldkNoaWxkcmVuLCAwLCBwcmV2Q2hpbGRyZW5TaXplIC0gMSwgY2FuVXNlRmFzdFBhdGggPyBudWxsIDogZG9tKTtcbiAgICAgICAgaWYgKGNhblVzZUZhc3RQYXRoKSB7XG4gICAgICAgICAgLy8gRmFzdCBwYXRoIGZvciByZW1vdmluZyBET00gbm9kZXNcbiAgICAgICAgICBkb20udGV4dENvbnRlbnQgPSAnJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAkcmVjb25jaWxlTm9kZUNoaWxkcmVuKG5leHRFbGVtZW50LCBwcmV2Q2hpbGRyZW4sIG5leHRDaGlsZHJlbiwgcHJldkNoaWxkcmVuU2l6ZSwgbmV4dENoaWxkcmVuU2l6ZSwgc2xvdCk7XG4gICAgfVxuICB9XG4gIGlmICgkdGV4dENvbnRlbnRSZXF1aXJlc0RvdWJsZUxpbmVicmVha0F0RW5kKG5leHRFbGVtZW50KSkge1xuICAgIHN1YlRyZWVUZXh0Q29udGVudCArPSBET1VCTEVfTElORV9CUkVBSztcbiAgfVxuICBkb20uX19sZXhpY2FsVGV4dENvbnRlbnQgPSBzdWJUcmVlVGV4dENvbnRlbnQ7XG4gIHN1YlRyZWVUZXh0Q29udGVudCA9IHByZXZpb3VzU3ViVHJlZVRleHRDb250ZW50ICsgc3ViVHJlZVRleHRDb250ZW50O1xufVxuZnVuY3Rpb24gJHJlY29uY2lsZU5vZGUoa2V5LCBwYXJlbnRET00pIHtcbiAgY29uc3QgcHJldk5vZGUgPSBhY3RpdmVQcmV2Tm9kZU1hcC5nZXQoa2V5KTtcbiAgbGV0IG5leHROb2RlID0gYWN0aXZlTmV4dE5vZGVNYXAuZ2V0KGtleSk7XG4gIGlmIChwcmV2Tm9kZSA9PT0gdW5kZWZpbmVkIHx8IG5leHROb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgcmVjb25jaWxlTm9kZTogcHJldk5vZGUgb3IgbmV4dE5vZGUgZG9lcyBub3QgZXhpc3QgaW4gbm9kZU1hcGApO1xuICAgIH1cbiAgfVxuICBjb25zdCBpc0RpcnR5ID0gdHJlYXRBbGxOb2Rlc0FzRGlydHkgfHwgYWN0aXZlRGlydHlMZWF2ZXMuaGFzKGtleSkgfHwgYWN0aXZlRGlydHlFbGVtZW50cy5oYXMoa2V5KTtcbiAgY29uc3QgZG9tID0gZ2V0RWxlbWVudEJ5S2V5T3JUaHJvdyhhY3RpdmVFZGl0b3IkMSwga2V5KTtcblxuICAvLyBJZiB0aGUgbm9kZSBrZXkgcG9pbnRzIHRvIHRoZSBzYW1lIGluc3RhbmNlIGluIGJvdGggc3RhdGVzXG4gIC8vIGFuZCBpc24ndCBkaXJ0eSwgd2UganVzdCB1cGRhdGUgdGhlIHRleHQgY29udGVudCBjYWNoZVxuICAvLyBhbmQgcmV0dXJuIHRoZSBleGlzdGluZyBET00gTm9kZS5cbiAgaWYgKHByZXZOb2RlID09PSBuZXh0Tm9kZSAmJiAhaXNEaXJ0eSkge1xuICAgIGlmICgkaXNFbGVtZW50Tm9kZShwcmV2Tm9kZSkpIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzU3ViVHJlZVRleHRDb250ZW50ID0gZG9tLl9fbGV4aWNhbFRleHRDb250ZW50O1xuICAgICAgaWYgKHByZXZpb3VzU3ViVHJlZVRleHRDb250ZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3ViVHJlZVRleHRDb250ZW50ICs9IHByZXZpb3VzU3ViVHJlZVRleHRDb250ZW50O1xuICAgICAgICBlZGl0b3JUZXh0Q29udGVudCArPSBwcmV2aW91c1N1YlRyZWVUZXh0Q29udGVudDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByZXZpb3VzU3ViVHJlZURpcmVjdGlvblRleHRDb250ZW50ID0gZG9tLl9fbGV4aWNhbERpclRleHRDb250ZW50O1xuICAgICAgaWYgKHByZXZpb3VzU3ViVHJlZURpcmVjdGlvblRleHRDb250ZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3ViVHJlZURpcmVjdGlvbmVkVGV4dENvbnRlbnQgKz0gcHJldmlvdXNTdWJUcmVlRGlyZWN0aW9uVGV4dENvbnRlbnQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHRleHQgPSBwcmV2Tm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICAgICAgaWYgKCRpc1RleHROb2RlKHByZXZOb2RlKSAmJiAhcHJldk5vZGUuaXNEaXJlY3Rpb25sZXNzKCkpIHtcbiAgICAgICAgc3ViVHJlZURpcmVjdGlvbmVkVGV4dENvbnRlbnQgKz0gdGV4dDtcbiAgICAgIH1cbiAgICAgIGVkaXRvclRleHRDb250ZW50ICs9IHRleHQ7XG4gICAgICBzdWJUcmVlVGV4dENvbnRlbnQgKz0gdGV4dDtcbiAgICB9XG4gICAgcmV0dXJuIGRvbTtcbiAgfVxuICAvLyBJZiB0aGUgbm9kZSBrZXkgZG9lc24ndCBwb2ludCB0byB0aGUgc2FtZSBpbnN0YW5jZSBpbiBib3RoIG1hcHMsXG4gIC8vIGl0IG1lYW5zIGl0IHdlcmUgY2xvbmVkLiBJZiB0aGV5J3JlIGFsc28gZGlydHksIHdlIG1hcmsgdGhlbSBhcyBtdXRhdGVkLlxuICBpZiAocHJldk5vZGUgIT09IG5leHROb2RlICYmIGlzRGlydHkpIHtcbiAgICBzZXRNdXRhdGVkTm9kZShtdXRhdGVkTm9kZXMsIGFjdGl2ZUVkaXRvck5vZGVzLCBhY3RpdmVNdXRhdGlvbkxpc3RlbmVycywgbmV4dE5vZGUsICd1cGRhdGVkJyk7XG4gIH1cblxuICAvLyBVcGRhdGUgbm9kZS4gSWYgaXQgcmV0dXJucyB0cnVlLCB3ZSBuZWVkIHRvIHVubW91bnQgYW5kIHJlLWNyZWF0ZSB0aGUgbm9kZVxuICBpZiAobmV4dE5vZGUudXBkYXRlRE9NKHByZXZOb2RlLCBkb20sIGFjdGl2ZUVkaXRvckNvbmZpZykpIHtcbiAgICBjb25zdCByZXBsYWNlbWVudERPTSA9ICRjcmVhdGVOb2RlKGtleSwgbnVsbCk7XG4gICAgaWYgKHBhcmVudERPTSA9PT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvcihgcmVjb25jaWxlTm9kZTogcGFyZW50RE9NIGlzIG51bGxgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcGFyZW50RE9NLnJlcGxhY2VDaGlsZChyZXBsYWNlbWVudERPTSwgZG9tKTtcbiAgICBkZXN0cm95Tm9kZShrZXksIG51bGwpO1xuICAgIHJldHVybiByZXBsYWNlbWVudERPTTtcbiAgfVxuICBpZiAoJGlzRWxlbWVudE5vZGUocHJldk5vZGUpICYmICRpc0VsZW1lbnROb2RlKG5leHROb2RlKSkge1xuICAgIC8vIFJlY29uY2lsZSBlbGVtZW50IGNoaWxkcmVuXG4gICAgY29uc3QgbmV4dEluZGVudCA9IG5leHROb2RlLl9faW5kZW50O1xuICAgIGlmIChuZXh0SW5kZW50ICE9PSBwcmV2Tm9kZS5fX2luZGVudCkge1xuICAgICAgc2V0RWxlbWVudEluZGVudChkb20sIG5leHRJbmRlbnQpO1xuICAgIH1cbiAgICBjb25zdCBuZXh0Rm9ybWF0ID0gbmV4dE5vZGUuX19mb3JtYXQ7XG4gICAgaWYgKG5leHRGb3JtYXQgIT09IHByZXZOb2RlLl9fZm9ybWF0KSB7XG4gICAgICBzZXRFbGVtZW50Rm9ybWF0KGRvbSwgbmV4dEZvcm1hdCk7XG4gICAgfVxuICAgIGlmIChpc0RpcnR5KSB7XG4gICAgICAkcmVjb25jaWxlQ2hpbGRyZW5XaXRoRGlyZWN0aW9uKHByZXZOb2RlLCBuZXh0Tm9kZSwgZG9tKTtcbiAgICAgIGlmICghJGlzUm9vdE5vZGUobmV4dE5vZGUpICYmICFuZXh0Tm9kZS5pc0lubGluZSgpKSB7XG4gICAgICAgIHJlY29uY2lsZUVsZW1lbnRUZXJtaW5hdGluZ0xpbmVCcmVhayhwcmV2Tm9kZSwgbmV4dE5vZGUsIGRvbSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICgkdGV4dENvbnRlbnRSZXF1aXJlc0RvdWJsZUxpbmVicmVha0F0RW5kKG5leHROb2RlKSkge1xuICAgICAgc3ViVHJlZVRleHRDb250ZW50ICs9IERPVUJMRV9MSU5FX0JSRUFLO1xuICAgICAgZWRpdG9yVGV4dENvbnRlbnQgKz0gRE9VQkxFX0xJTkVfQlJFQUs7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IHRleHQgPSBuZXh0Tm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICAgIGlmICgkaXNEZWNvcmF0b3JOb2RlKG5leHROb2RlKSkge1xuICAgICAgY29uc3QgZGVjb3JhdG9yID0gbmV4dE5vZGUuZGVjb3JhdGUoYWN0aXZlRWRpdG9yJDEsIGFjdGl2ZUVkaXRvckNvbmZpZyk7XG4gICAgICBpZiAoZGVjb3JhdG9yICE9PSBudWxsKSB7XG4gICAgICAgIHJlY29uY2lsZURlY29yYXRvcihrZXksIGRlY29yYXRvcik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgkaXNUZXh0Tm9kZShuZXh0Tm9kZSkgJiYgIW5leHROb2RlLmlzRGlyZWN0aW9ubGVzcygpKSB7XG4gICAgICAvLyBIYW5kbGUgdGV4dCBjb250ZW50LCBmb3IgTFRSLCBMVFIgY2FzZXMuXG4gICAgICBzdWJUcmVlRGlyZWN0aW9uZWRUZXh0Q29udGVudCArPSB0ZXh0O1xuICAgIH1cbiAgICBzdWJUcmVlVGV4dENvbnRlbnQgKz0gdGV4dDtcbiAgICBlZGl0b3JUZXh0Q29udGVudCArPSB0ZXh0O1xuICB9XG4gIGlmICghYWN0aXZlRWRpdG9yU3RhdGVSZWFkT25seSAmJiAkaXNSb290Tm9kZShuZXh0Tm9kZSkgJiYgbmV4dE5vZGUuX19jYWNoZWRUZXh0ICE9PSBlZGl0b3JUZXh0Q29udGVudCkge1xuICAgIC8vIENhY2hlIHRoZSBsYXRlc3QgdGV4dCBjb250ZW50LlxuICAgIGNvbnN0IG5leHRSb290Tm9kZSA9IG5leHROb2RlLmdldFdyaXRhYmxlKCk7XG4gICAgbmV4dFJvb3ROb2RlLl9fY2FjaGVkVGV4dCA9IGVkaXRvclRleHRDb250ZW50O1xuICAgIG5leHROb2RlID0gbmV4dFJvb3ROb2RlO1xuICB9XG4gIHtcbiAgICAvLyBGcmVlemUgdGhlIG5vZGUgaW4gREVWIHRvIHByZXZlbnQgYWNjaWRlbnRhbCBtdXRhdGlvbnNcbiAgICBPYmplY3QuZnJlZXplKG5leHROb2RlKTtcbiAgfVxuICByZXR1cm4gZG9tO1xufVxuZnVuY3Rpb24gcmVjb25jaWxlRGVjb3JhdG9yKGtleSwgZGVjb3JhdG9yKSB7XG4gIGxldCBwZW5kaW5nRGVjb3JhdG9ycyA9IGFjdGl2ZUVkaXRvciQxLl9wZW5kaW5nRGVjb3JhdG9ycztcbiAgY29uc3QgY3VycmVudERlY29yYXRvcnMgPSBhY3RpdmVFZGl0b3IkMS5fZGVjb3JhdG9ycztcbiAgaWYgKHBlbmRpbmdEZWNvcmF0b3JzID09PSBudWxsKSB7XG4gICAgaWYgKGN1cnJlbnREZWNvcmF0b3JzW2tleV0gPT09IGRlY29yYXRvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwZW5kaW5nRGVjb3JhdG9ycyA9IGNsb25lRGVjb3JhdG9ycyhhY3RpdmVFZGl0b3IkMSk7XG4gIH1cbiAgcGVuZGluZ0RlY29yYXRvcnNba2V5XSA9IGRlY29yYXRvcjtcbn1cbmZ1bmN0aW9uIGdldE5leHRTaWJsaW5nKGVsZW1lbnQpIHtcbiAgbGV0IG5leHRTaWJsaW5nID0gZWxlbWVudC5uZXh0U2libGluZztcbiAgaWYgKG5leHRTaWJsaW5nICE9PSBudWxsICYmIG5leHRTaWJsaW5nID09PSBhY3RpdmVFZGl0b3IkMS5fYmxvY2tDdXJzb3JFbGVtZW50KSB7XG4gICAgbmV4dFNpYmxpbmcgPSBuZXh0U2libGluZy5uZXh0U2libGluZztcbiAgfVxuICByZXR1cm4gbmV4dFNpYmxpbmc7XG59XG5mdW5jdGlvbiAkcmVjb25jaWxlTm9kZUNoaWxkcmVuKG5leHRFbGVtZW50LCBwcmV2Q2hpbGRyZW4sIG5leHRDaGlsZHJlbiwgcHJldkNoaWxkcmVuTGVuZ3RoLCBuZXh0Q2hpbGRyZW5MZW5ndGgsIHNsb3QpIHtcbiAgY29uc3QgcHJldkVuZEluZGV4ID0gcHJldkNoaWxkcmVuTGVuZ3RoIC0gMTtcbiAgY29uc3QgbmV4dEVuZEluZGV4ID0gbmV4dENoaWxkcmVuTGVuZ3RoIC0gMTtcbiAgbGV0IHByZXZDaGlsZHJlblNldDtcbiAgbGV0IG5leHRDaGlsZHJlblNldDtcbiAgbGV0IHNpYmxpbmdET00gPSBzbG90LmdldEZpcnN0Q2hpbGQoKTtcbiAgbGV0IHByZXZJbmRleCA9IDA7XG4gIGxldCBuZXh0SW5kZXggPSAwO1xuICB3aGlsZSAocHJldkluZGV4IDw9IHByZXZFbmRJbmRleCAmJiBuZXh0SW5kZXggPD0gbmV4dEVuZEluZGV4KSB7XG4gICAgY29uc3QgcHJldktleSA9IHByZXZDaGlsZHJlbltwcmV2SW5kZXhdO1xuICAgIGNvbnN0IG5leHRLZXkgPSBuZXh0Q2hpbGRyZW5bbmV4dEluZGV4XTtcbiAgICBpZiAocHJldktleSA9PT0gbmV4dEtleSkge1xuICAgICAgc2libGluZ0RPTSA9IGdldE5leHRTaWJsaW5nKCRyZWNvbmNpbGVOb2RlKG5leHRLZXksIHNsb3QuZWxlbWVudCkpO1xuICAgICAgcHJldkluZGV4Kys7XG4gICAgICBuZXh0SW5kZXgrKztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByZXZDaGlsZHJlblNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByZXZDaGlsZHJlblNldCA9IG5ldyBTZXQocHJldkNoaWxkcmVuKTtcbiAgICAgIH1cbiAgICAgIGlmIChuZXh0Q2hpbGRyZW5TZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuZXh0Q2hpbGRyZW5TZXQgPSBuZXcgU2V0KG5leHRDaGlsZHJlbik7XG4gICAgICB9XG4gICAgICBjb25zdCBuZXh0SGFzUHJldktleSA9IG5leHRDaGlsZHJlblNldC5oYXMocHJldktleSk7XG4gICAgICBjb25zdCBwcmV2SGFzTmV4dEtleSA9IHByZXZDaGlsZHJlblNldC5oYXMobmV4dEtleSk7XG4gICAgICBpZiAoIW5leHRIYXNQcmV2S2V5KSB7XG4gICAgICAgIC8vIFJlbW92ZSBwcmV2XG4gICAgICAgIHNpYmxpbmdET00gPSBnZXROZXh0U2libGluZyhnZXRQcmV2RWxlbWVudEJ5S2V5T3JUaHJvdyhwcmV2S2V5KSk7XG4gICAgICAgIGRlc3Ryb3lOb2RlKHByZXZLZXksIHNsb3QuZWxlbWVudCk7XG4gICAgICAgIHByZXZJbmRleCsrO1xuICAgICAgfSBlbHNlIGlmICghcHJldkhhc05leHRLZXkpIHtcbiAgICAgICAgLy8gQ3JlYXRlIG5leHRcbiAgICAgICAgJGNyZWF0ZU5vZGUobmV4dEtleSwgc2xvdC53aXRoQmVmb3JlKHNpYmxpbmdET00pKTtcbiAgICAgICAgbmV4dEluZGV4Kys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBNb3ZlIG5leHRcbiAgICAgICAgY29uc3QgY2hpbGRET00gPSBnZXRFbGVtZW50QnlLZXlPclRocm93KGFjdGl2ZUVkaXRvciQxLCBuZXh0S2V5KTtcbiAgICAgICAgaWYgKGNoaWxkRE9NID09PSBzaWJsaW5nRE9NKSB7XG4gICAgICAgICAgc2libGluZ0RPTSA9IGdldE5leHRTaWJsaW5nKCRyZWNvbmNpbGVOb2RlKG5leHRLZXksIHNsb3QuZWxlbWVudCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNsb3Qud2l0aEJlZm9yZShzaWJsaW5nRE9NKS5pbnNlcnRDaGlsZChjaGlsZERPTSk7XG4gICAgICAgICAgJHJlY29uY2lsZU5vZGUobmV4dEtleSwgc2xvdC5lbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBwcmV2SW5kZXgrKztcbiAgICAgICAgbmV4dEluZGV4Kys7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG5vZGUgPSBhY3RpdmVOZXh0Tm9kZU1hcC5nZXQobmV4dEtleSk7XG4gICAgaWYgKG5vZGUgIT09IG51bGwgJiYgJGlzVGV4dE5vZGUobm9kZSkpIHtcbiAgICAgIGlmIChzdWJUcmVlVGV4dEZvcm1hdCA9PT0gbnVsbCkge1xuICAgICAgICBzdWJUcmVlVGV4dEZvcm1hdCA9IG5vZGUuZ2V0Rm9ybWF0KCk7XG4gICAgICB9XG4gICAgICBpZiAoc3ViVHJlZVRleHRTdHlsZSA9PT0gJycpIHtcbiAgICAgICAgc3ViVHJlZVRleHRTdHlsZSA9IG5vZGUuZ2V0U3R5bGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgYXBwZW5kTmV3Q2hpbGRyZW4gPSBwcmV2SW5kZXggPiBwcmV2RW5kSW5kZXg7XG4gIGNvbnN0IHJlbW92ZU9sZENoaWxkcmVuID0gbmV4dEluZGV4ID4gbmV4dEVuZEluZGV4O1xuICBpZiAoYXBwZW5kTmV3Q2hpbGRyZW4gJiYgIXJlbW92ZU9sZENoaWxkcmVuKSB7XG4gICAgY29uc3QgcHJldmlvdXNOb2RlID0gbmV4dENoaWxkcmVuW25leHRFbmRJbmRleCArIDFdO1xuICAgIGNvbnN0IGluc2VydERPTSA9IHByZXZpb3VzTm9kZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGFjdGl2ZUVkaXRvciQxLmdldEVsZW1lbnRCeUtleShwcmV2aW91c05vZGUpO1xuICAgICRjcmVhdGVDaGlsZHJlbihuZXh0Q2hpbGRyZW4sIG5leHRFbGVtZW50LCBuZXh0SW5kZXgsIG5leHRFbmRJbmRleCwgc2xvdC53aXRoQmVmb3JlKGluc2VydERPTSkpO1xuICB9IGVsc2UgaWYgKHJlbW92ZU9sZENoaWxkcmVuICYmICFhcHBlbmROZXdDaGlsZHJlbikge1xuICAgIGRlc3Ryb3lDaGlsZHJlbihwcmV2Q2hpbGRyZW4sIHByZXZJbmRleCwgcHJldkVuZEluZGV4LCBzbG90LmVsZW1lbnQpO1xuICB9XG59XG5mdW5jdGlvbiAkcmVjb25jaWxlUm9vdChwcmV2RWRpdG9yU3RhdGUsIG5leHRFZGl0b3JTdGF0ZSwgZWRpdG9yLCBkaXJ0eVR5cGUsIGRpcnR5RWxlbWVudHMsIGRpcnR5TGVhdmVzKSB7XG4gIC8vIFdlIGNhY2hlIHRleHQgY29udGVudCB0byBtYWtlIHJldHJpZXZhbCBtb3JlIGVmZmljaWVudC5cbiAgLy8gVGhlIGNhY2hlIG11c3QgYmUgcmVidWlsdCBkdXJpbmcgcmVjb25jaWxpYXRpb24gdG8gYWNjb3VudCBmb3IgYW55IGNoYW5nZXMuXG4gIHN1YlRyZWVUZXh0Q29udGVudCA9ICcnO1xuICBlZGl0b3JUZXh0Q29udGVudCA9ICcnO1xuICBzdWJUcmVlRGlyZWN0aW9uZWRUZXh0Q29udGVudCA9ICcnO1xuICAvLyBSYXRoZXIgdGhhbiBwYXNzIGFyb3VuZCBhIGxvYWQgb2YgYXJndW1lbnRzIHRocm91Z2ggdGhlIHN0YWNrIHJlY3Vyc2l2ZWx5XG4gIC8vIHdlIGluc3RlYWQgc2V0IHRoZW0gYXMgYmluZGluZ3Mgd2l0aGluIHRoZSBzY29wZSBvZiB0aGUgbW9kdWxlLlxuICB0cmVhdEFsbE5vZGVzQXNEaXJ0eSA9IGRpcnR5VHlwZSA9PT0gRlVMTF9SRUNPTkNJTEU7XG4gIGFjdGl2ZVRleHREaXJlY3Rpb24gPSBudWxsO1xuICBhY3RpdmVFZGl0b3IkMSA9IGVkaXRvcjtcbiAgYWN0aXZlRWRpdG9yQ29uZmlnID0gZWRpdG9yLl9jb25maWc7XG4gIGFjdGl2ZUVkaXRvck5vZGVzID0gZWRpdG9yLl9ub2RlcztcbiAgYWN0aXZlTXV0YXRpb25MaXN0ZW5lcnMgPSBhY3RpdmVFZGl0b3IkMS5fbGlzdGVuZXJzLm11dGF0aW9uO1xuICBhY3RpdmVEaXJ0eUVsZW1lbnRzID0gZGlydHlFbGVtZW50cztcbiAgYWN0aXZlRGlydHlMZWF2ZXMgPSBkaXJ0eUxlYXZlcztcbiAgYWN0aXZlUHJldk5vZGVNYXAgPSBwcmV2RWRpdG9yU3RhdGUuX25vZGVNYXA7XG4gIGFjdGl2ZU5leHROb2RlTWFwID0gbmV4dEVkaXRvclN0YXRlLl9ub2RlTWFwO1xuICBhY3RpdmVFZGl0b3JTdGF0ZVJlYWRPbmx5ID0gbmV4dEVkaXRvclN0YXRlLl9yZWFkT25seTtcbiAgYWN0aXZlUHJldktleVRvRE9NTWFwID0gbmV3IE1hcChlZGl0b3IuX2tleVRvRE9NTWFwKTtcbiAgLy8gV2Uga2VlcCB0cmFjayBvZiBtdXRhdGVkIG5vZGVzIHNvIHdlIGNhbiB0cmlnZ2VyIG11dGF0aW9uXG4gIC8vIGxpc3RlbmVycyBsYXRlciBpbiB0aGUgdXBkYXRlIGN5Y2xlLlxuICBjb25zdCBjdXJyZW50TXV0YXRlZE5vZGVzID0gbmV3IE1hcCgpO1xuICBtdXRhdGVkTm9kZXMgPSBjdXJyZW50TXV0YXRlZE5vZGVzO1xuICAkcmVjb25jaWxlTm9kZSgncm9vdCcsIG51bGwpO1xuICAvLyBXZSBkb24ndCB3YW50IGEgYnVuY2ggb2Ygdm9pZCBjaGVja3MgdGhyb3VnaG91dCB0aGUgc2NvcGVcbiAgLy8gc28gaW5zdGVhZCB3ZSBtYWtlIGl0IHNlZW0gdGhhdCB0aGVzZSB2YWx1ZXMgYXJlIGFsd2F5cyBzZXQuXG4gIC8vIFdlIGFsc28gd2FudCB0byBtYWtlIHN1cmUgd2UgY2xlYXIgdGhlbSBkb3duLCBvdGhlcndpc2Ugd2VcbiAgLy8gY2FuIGxlYWsgbWVtb3J5LlxuICAvLyBAdHMtaWdub3JlXG4gIGFjdGl2ZUVkaXRvciQxID0gdW5kZWZpbmVkO1xuICAvLyBAdHMtaWdub3JlXG4gIGFjdGl2ZUVkaXRvck5vZGVzID0gdW5kZWZpbmVkO1xuICAvLyBAdHMtaWdub3JlXG4gIGFjdGl2ZURpcnR5RWxlbWVudHMgPSB1bmRlZmluZWQ7XG4gIC8vIEB0cy1pZ25vcmVcbiAgYWN0aXZlRGlydHlMZWF2ZXMgPSB1bmRlZmluZWQ7XG4gIC8vIEB0cy1pZ25vcmVcbiAgYWN0aXZlUHJldk5vZGVNYXAgPSB1bmRlZmluZWQ7XG4gIC8vIEB0cy1pZ25vcmVcbiAgYWN0aXZlTmV4dE5vZGVNYXAgPSB1bmRlZmluZWQ7XG4gIC8vIEB0cy1pZ25vcmVcbiAgYWN0aXZlRWRpdG9yQ29uZmlnID0gdW5kZWZpbmVkO1xuICAvLyBAdHMtaWdub3JlXG4gIGFjdGl2ZVByZXZLZXlUb0RPTU1hcCA9IHVuZGVmaW5lZDtcbiAgLy8gQHRzLWlnbm9yZVxuICBtdXRhdGVkTm9kZXMgPSB1bmRlZmluZWQ7XG4gIHJldHVybiBjdXJyZW50TXV0YXRlZE5vZGVzO1xufVxuZnVuY3Rpb24gc3RvcmVET01XaXRoS2V5KGtleSwgZG9tLCBlZGl0b3IpIHtcbiAgY29uc3Qga2V5VG9ET01NYXAgPSBlZGl0b3IuX2tleVRvRE9NTWFwO1xuICBzZXROb2RlS2V5T25ET01Ob2RlKGRvbSwgZWRpdG9yLCBrZXkpO1xuICBrZXlUb0RPTU1hcC5zZXQoa2V5LCBkb20pO1xufVxuZnVuY3Rpb24gZ2V0UHJldkVsZW1lbnRCeUtleU9yVGhyb3coa2V5KSB7XG4gIGNvbnN0IGVsZW1lbnQgPSBhY3RpdmVQcmV2S2V5VG9ET01NYXAuZ2V0KGtleSk7XG4gIGlmIChlbGVtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgUmVjb25jaWxpYXRpb246IGNvdWxkIG5vdCBmaW5kIERPTSBlbGVtZW50IGZvciBub2RlIGtleSAke2tleX1gKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuY29uc3QgUEFTU19USFJPVUdIX0NPTU1BTkQgPSBPYmplY3QuZnJlZXplKHt9KTtcbmNvbnN0IEFORFJPSURfQ09NUE9TSVRJT05fTEFURU5DWSA9IDMwO1xuY29uc3Qgcm9vdEVsZW1lbnRFdmVudHMgPSBbWydrZXlkb3duJywgb25LZXlEb3duXSwgWydwb2ludGVyZG93bicsIG9uUG9pbnRlckRvd25dLCBbJ2NvbXBvc2l0aW9uc3RhcnQnLCBvbkNvbXBvc2l0aW9uU3RhcnRdLCBbJ2NvbXBvc2l0aW9uZW5kJywgb25Db21wb3NpdGlvbkVuZF0sIFsnaW5wdXQnLCBvbklucHV0XSwgWydjbGljaycsIG9uQ2xpY2tdLCBbJ2N1dCcsIFBBU1NfVEhST1VHSF9DT01NQU5EXSwgWydjb3B5JywgUEFTU19USFJPVUdIX0NPTU1BTkRdLCBbJ2RyYWdzdGFydCcsIFBBU1NfVEhST1VHSF9DT01NQU5EXSwgWydkcmFnb3ZlcicsIFBBU1NfVEhST1VHSF9DT01NQU5EXSwgWydkcmFnZW5kJywgUEFTU19USFJPVUdIX0NPTU1BTkRdLCBbJ3Bhc3RlJywgUEFTU19USFJPVUdIX0NPTU1BTkRdLCBbJ2ZvY3VzJywgUEFTU19USFJPVUdIX0NPTU1BTkRdLCBbJ2JsdXInLCBQQVNTX1RIUk9VR0hfQ09NTUFORF0sIFsnZHJvcCcsIFBBU1NfVEhST1VHSF9DT01NQU5EXV07XG5pZiAoQ0FOX1VTRV9CRUZPUkVfSU5QVVQpIHtcbiAgcm9vdEVsZW1lbnRFdmVudHMucHVzaChbJ2JlZm9yZWlucHV0JywgKGV2ZW50LCBlZGl0b3IpID0+IG9uQmVmb3JlSW5wdXQoZXZlbnQsIGVkaXRvcildKTtcbn1cbmxldCBsYXN0S2V5RG93blRpbWVTdGFtcCA9IDA7XG5sZXQgbGFzdEtleUNvZGUgPSBudWxsO1xubGV0IGxhc3RCZWZvcmVJbnB1dEluc2VydFRleHRUaW1lU3RhbXAgPSAwO1xubGV0IHVucHJvY2Vzc2VkQmVmb3JlSW5wdXREYXRhID0gbnVsbDtcbmNvbnN0IHJvb3RFbGVtZW50c1JlZ2lzdGVyZWQgPSBuZXcgV2Vha01hcCgpO1xubGV0IGlzU2VsZWN0aW9uQ2hhbmdlRnJvbURPTVVwZGF0ZSA9IGZhbHNlO1xubGV0IGlzU2VsZWN0aW9uQ2hhbmdlRnJvbU1vdXNlRG93biA9IGZhbHNlO1xubGV0IGlzSW5zZXJ0TGluZUJyZWFrID0gZmFsc2U7XG5sZXQgaXNGaXJlZm94RW5kaW5nQ29tcG9zaXRpb24gPSBmYWxzZTtcbmxldCBjb2xsYXBzZWRTZWxlY3Rpb25Gb3JtYXQgPSBbMCwgJycsIDAsICdyb290JywgMF07XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBkZXRlcm1pbmUgaWYgTGV4aWNhbCBzaG91bGQgYXR0ZW1wdCB0byBvdmVycmlkZVxuLy8gdGhlIGRlZmF1bHQgYnJvd3NlciBiZWhhdmlvciBmb3IgaW5zZXJ0aW9uIG9mIHRleHQgYW5kIHVzZSBpdHMgb3duIGludGVybmFsXG4vLyBoZXVyaXN0aWNzLiBUaGlzIGlzIGFuIGV4dHJlbWVseSBpbXBvcnRhbnQgZnVuY3Rpb24sIGFuZCBtYWtlcyBtdWNoIG9mIExleGljYWxcbi8vIHdvcmsgYXMgaW50ZW5kZWQgYmV0d2VlbiBkaWZmZXJlbnQgYnJvd3NlcnMgYW5kIGFjcm9zcyB3b3JkLCBsaW5lIGFuZCBjaGFyYWN0ZXJcbi8vIGJvdW5kYXJ5L2Zvcm1hdHMuIEl0IGFsc28gaXMgaW1wb3J0YW50IGZvciB0ZXh0IHJlcGxhY2VtZW50LCBub2RlIHNjaGVtYXMgYW5kXG4vLyBjb21wb3NpdGlvbiBtZWNoYW5pY3MuXG5cbmZ1bmN0aW9uICRzaG91bGRQcmV2ZW50RGVmYXVsdEFuZEluc2VydFRleHQoc2VsZWN0aW9uLCBkb21UYXJnZXRSYW5nZSwgdGV4dCwgdGltZVN0YW1wLCBpc0JlZm9yZUlucHV0KSB7XG4gIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICBjb25zdCBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgY29uc3QgZWRpdG9yID0gZ2V0QWN0aXZlRWRpdG9yKCk7XG4gIGNvbnN0IGRvbVNlbGVjdGlvbiA9IGdldERPTVNlbGVjdGlvbihlZGl0b3IuX3dpbmRvdyk7XG4gIGNvbnN0IGRvbUFuY2hvck5vZGUgPSBkb21TZWxlY3Rpb24gIT09IG51bGwgPyBkb21TZWxlY3Rpb24uYW5jaG9yTm9kZSA6IG51bGw7XG4gIGNvbnN0IGFuY2hvcktleSA9IGFuY2hvci5rZXk7XG4gIGNvbnN0IGJhY2tpbmdBbmNob3JFbGVtZW50ID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleShhbmNob3JLZXkpO1xuICBjb25zdCB0ZXh0TGVuZ3RoID0gdGV4dC5sZW5ndGg7XG4gIHJldHVybiBhbmNob3JLZXkgIT09IGZvY3VzLmtleSB8fFxuICAvLyBJZiB3ZSdyZSB3b3JraW5nIHdpdGggYSBub24tdGV4dCBub2RlLlxuICAhJGlzVGV4dE5vZGUoYW5jaG9yTm9kZSkgfHxcbiAgLy8gSWYgd2UgYXJlIHJlcGxhY2luZyBhIHJhbmdlIHdpdGggYSBzaW5nbGUgY2hhcmFjdGVyIG9yIGdyYXBoZW1lLCBhbmQgbm90IGNvbXBvc2luZy5cbiAgKCFpc0JlZm9yZUlucHV0ICYmICghQ0FOX1VTRV9CRUZPUkVfSU5QVVQgfHxcbiAgLy8gV2UgY2hlY2sgdG8gc2VlIGlmIHRoZXJlIGhhcyBiZWVuXG4gIC8vIGEgcmVjZW50IGJlZm9yZWlucHV0IGV2ZW50IGZvciBcInRleHRJbnB1dFwiLiBJZiB0aGVyZSBoYXMgYmVlbiBvbmUgaW4gdGhlIGxhc3RcbiAgLy8gNTBtcyB0aGVuIHdlIHByb2NlZWQgYXMgbm9ybWFsLiBIb3dldmVyLCBpZiB0aGVyZSBpcyBub3QsIHRoZW4gdGhpcyBpcyBsaWtlbHlcbiAgLy8gYSBkYW5nbGluZyBgaW5wdXRgIGV2ZW50IGNhdXNlZCBieSBleGVjQ29tbWFuZCgnaW5zZXJ0VGV4dCcpLlxuICBsYXN0QmVmb3JlSW5wdXRJbnNlcnRUZXh0VGltZVN0YW1wIDwgdGltZVN0YW1wICsgNTApIHx8IGFuY2hvck5vZGUuaXNEaXJ0eSgpICYmIHRleHRMZW5ndGggPCAyIHx8IGRvZXNDb250YWluR3JhcGhlbWUodGV4dCkpICYmIGFuY2hvci5vZmZzZXQgIT09IGZvY3VzLm9mZnNldCAmJiAhYW5jaG9yTm9kZS5pc0NvbXBvc2luZygpIHx8XG4gIC8vIEFueSBub24gc3RhbmRhcmQgdGV4dCBub2RlLlxuICAkaXNUb2tlbk9yU2VnbWVudGVkKGFuY2hvck5vZGUpIHx8XG4gIC8vIElmIHRoZSB0ZXh0IGxlbmd0aCBpcyBtb3JlIHRoYW4gYSBzaW5nbGUgY2hhcmFjdGVyIGFuZCB3ZSdyZSBlaXRoZXJcbiAgLy8gZGVhbGluZyB3aXRoIHRoaXMgaW4gXCJiZWZvcmVpbnB1dFwiIG9yIHdoZXJlIHRoZSBub2RlIGhhcyBhbHJlYWR5IHJlY2VudGx5XG4gIC8vIGJlZW4gY2hhbmdlZCAodGh1cyBpcyBkaXJ0eSkuXG4gIGFuY2hvck5vZGUuaXNEaXJ0eSgpICYmIHRleHRMZW5ndGggPiAxIHx8XG4gIC8vIElmIHRoZSBET00gc2VsZWN0aW9uIGVsZW1lbnQgaXMgbm90IHRoZSBzYW1lIGFzIHRoZSBiYWNraW5nIG5vZGUgZHVyaW5nIGJlZm9yZWlucHV0LlxuICAoaXNCZWZvcmVJbnB1dCB8fCAhQ0FOX1VTRV9CRUZPUkVfSU5QVVQpICYmIGJhY2tpbmdBbmNob3JFbGVtZW50ICE9PSBudWxsICYmICFhbmNob3JOb2RlLmlzQ29tcG9zaW5nKCkgJiYgZG9tQW5jaG9yTm9kZSAhPT0gZ2V0RE9NVGV4dE5vZGUoYmFja2luZ0FuY2hvckVsZW1lbnQpIHx8XG4gIC8vIElmIFRhcmdldFJhbmdlIGlzIG5vdCB0aGUgc2FtZSBhcyB0aGUgRE9NIHNlbGVjdGlvbjsgYnJvd3NlciB0cnlpbmcgdG8gZWRpdCByYW5kb20gcGFydHNcbiAgLy8gb2YgdGhlIGVkaXRvci5cbiAgZG9tU2VsZWN0aW9uICE9PSBudWxsICYmIGRvbVRhcmdldFJhbmdlICE9PSBudWxsICYmICghZG9tVGFyZ2V0UmFuZ2UuY29sbGFwc2VkIHx8IGRvbVRhcmdldFJhbmdlLnN0YXJ0Q29udGFpbmVyICE9PSBkb21TZWxlY3Rpb24uYW5jaG9yTm9kZSB8fCBkb21UYXJnZXRSYW5nZS5zdGFydE9mZnNldCAhPT0gZG9tU2VsZWN0aW9uLmFuY2hvck9mZnNldCkgfHxcbiAgLy8gQ2hlY2sgaWYgd2UncmUgY2hhbmdpbmcgZnJvbSBib2xkIHRvIGl0YWxpY3MsIG9yIHNvbWUgb3RoZXIgZm9ybWF0LlxuICBhbmNob3JOb2RlLmdldEZvcm1hdCgpICE9PSBzZWxlY3Rpb24uZm9ybWF0IHx8IGFuY2hvck5vZGUuZ2V0U3R5bGUoKSAhPT0gc2VsZWN0aW9uLnN0eWxlIHx8XG4gIC8vIE9uZSBsYXN0IHNldCBvZiBoZXVyaXN0aWNzIHRvIGNoZWNrIGFnYWluc3QuXG4gICRzaG91bGRJbnNlcnRUZXh0QWZ0ZXJPckJlZm9yZVRleHROb2RlKHNlbGVjdGlvbiwgYW5jaG9yTm9kZSk7XG59XG5mdW5jdGlvbiBzaG91bGRTa2lwU2VsZWN0aW9uQ2hhbmdlKGRvbU5vZGUsIG9mZnNldCkge1xuICByZXR1cm4gaXNET01UZXh0Tm9kZShkb21Ob2RlKSAmJiBkb21Ob2RlLm5vZGVWYWx1ZSAhPT0gbnVsbCAmJiBvZmZzZXQgIT09IDAgJiYgb2Zmc2V0ICE9PSBkb21Ob2RlLm5vZGVWYWx1ZS5sZW5ndGg7XG59XG5mdW5jdGlvbiBvblNlbGVjdGlvbkNoYW5nZShkb21TZWxlY3Rpb24sIGVkaXRvciwgaXNBY3RpdmUpIHtcbiAgY29uc3Qge1xuICAgIGFuY2hvck5vZGU6IGFuY2hvckRPTSxcbiAgICBhbmNob3JPZmZzZXQsXG4gICAgZm9jdXNOb2RlOiBmb2N1c0RPTSxcbiAgICBmb2N1c09mZnNldFxuICB9ID0gZG9tU2VsZWN0aW9uO1xuICBpZiAoaXNTZWxlY3Rpb25DaGFuZ2VGcm9tRE9NVXBkYXRlKSB7XG4gICAgaXNTZWxlY3Rpb25DaGFuZ2VGcm9tRE9NVXBkYXRlID0gZmFsc2U7XG5cbiAgICAvLyBJZiBuYXRpdmUgRE9NIHNlbGVjdGlvbiBpcyBvbiBhIERPTSBlbGVtZW50LCB0aGVuXG4gICAgLy8gd2Ugc2hvdWxkIGNvbnRpbnVlIGFzIHVzdWFsLCBhcyBMZXhpY2FsJ3Mgc2VsZWN0aW9uXG4gICAgLy8gbWF5IGhhdmUgbm9ybWFsaXplZCB0byBhIGJldHRlciBjaGlsZC4gSWYgdGhlIERPTVxuICAgIC8vIGVsZW1lbnQgaXMgYSB0ZXh0IG5vZGUsIHdlIGNhbiBzYWZlbHkgYXBwbHkgdGhpc1xuICAgIC8vIG9wdGltaXphdGlvbiBhbmQgc2tpcCB0aGUgc2VsZWN0aW9uIGNoYW5nZSBlbnRpcmVseS5cbiAgICAvLyBXZSBhbHNvIG5lZWQgdG8gY2hlY2sgaWYgdGhlIG9mZnNldCBpcyBhdCB0aGUgYm91bmRhcnksXG4gICAgLy8gYmVjYXVzZSBpbiB0aGlzIGNhc2UsIHdlIG1pZ2h0IG5lZWQgdG8gbm9ybWFsaXplIHRvIGFcbiAgICAvLyBzaWJsaW5nIGluc3RlYWQuXG4gICAgaWYgKHNob3VsZFNraXBTZWxlY3Rpb25DaGFuZ2UoYW5jaG9yRE9NLCBhbmNob3JPZmZzZXQpICYmIHNob3VsZFNraXBTZWxlY3Rpb25DaGFuZ2UoZm9jdXNET00sIGZvY3VzT2Zmc2V0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICB1cGRhdGVFZGl0b3IoZWRpdG9yLCAoKSA9PiB7XG4gICAgLy8gTm9uLWFjdGl2ZSBlZGl0b3IgZG9uJ3QgbmVlZCBhbnkgZXh0cmEgbG9naWMgZm9yIHNlbGVjdGlvbiwgaXQgb25seSBuZWVkcyB1cGRhdGVcbiAgICAvLyB0byByZWNvbmNpbGUgc2VsZWN0aW9uIChzZXQgaXQgdG8gbnVsbCkgdG8gZW5zdXJlIHRoYXQgb25seSBvbmUgZWRpdG9yIGhhcyBub24tbnVsbCBzZWxlY3Rpb24uXG4gICAgaWYgKCFpc0FjdGl2ZSkge1xuICAgICAgJHNldFNlbGVjdGlvbihudWxsKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFpc1NlbGVjdGlvbldpdGhpbkVkaXRvcihlZGl0b3IsIGFuY2hvckRPTSwgZm9jdXNET00pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcblxuICAgIC8vIFVwZGF0ZSB0aGUgc2VsZWN0aW9uIGZvcm1hdFxuICAgIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICAgICAgY29uc3QgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gICAgICBpZiAoc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgICAgLy8gQmFkbHkgaW50ZXJwcmV0ZWQgcmFuZ2Ugc2VsZWN0aW9uIHdoZW4gY29sbGFwc2VkIC0gIzE0ODJcbiAgICAgICAgaWYgKGRvbVNlbGVjdGlvbi50eXBlID09PSAnUmFuZ2UnICYmIGRvbVNlbGVjdGlvbi5hbmNob3JOb2RlID09PSBkb21TZWxlY3Rpb24uZm9jdXNOb2RlKSB7XG4gICAgICAgICAgc2VsZWN0aW9uLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHdlIGhhdmUgbWFya2VkIGEgY29sbGFwc2VkIHNlbGVjdGlvbiBmb3JtYXQsIGFuZCB3ZSdyZVxuICAgICAgICAvLyB3aXRoaW4gdGhlIGdpdmVuIHRpbWUgcmFuZ2Ug4oCTIHRoZW4gYXR0ZW1wdCB0byB1c2UgdGhhdCBmb3JtYXRcbiAgICAgICAgLy8gaW5zdGVhZCBvZiBnZXR0aW5nIHRoZSBmb3JtYXQgZnJvbSB0aGUgYW5jaG9yIG5vZGUuXG4gICAgICAgIGNvbnN0IHdpbmRvd0V2ZW50ID0gZ2V0V2luZG93KGVkaXRvcikuZXZlbnQ7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRUaW1lU3RhbXAgPSB3aW5kb3dFdmVudCA/IHdpbmRvd0V2ZW50LnRpbWVTdGFtcCA6IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBjb25zdCBbbGFzdEZvcm1hdCwgbGFzdFN0eWxlLCBsYXN0T2Zmc2V0LCBsYXN0S2V5LCB0aW1lU3RhbXBdID0gY29sbGFwc2VkU2VsZWN0aW9uRm9ybWF0O1xuICAgICAgICBjb25zdCByb290ID0gJGdldFJvb3QoKTtcbiAgICAgICAgY29uc3QgaXNSb290VGV4dENvbnRlbnRFbXB0eSA9IGVkaXRvci5pc0NvbXBvc2luZygpID09PSBmYWxzZSAmJiByb290LmdldFRleHRDb250ZW50KCkgPT09ICcnO1xuICAgICAgICBpZiAoY3VycmVudFRpbWVTdGFtcCA8IHRpbWVTdGFtcCArIDIwMCAmJiBhbmNob3Iub2Zmc2V0ID09PSBsYXN0T2Zmc2V0ICYmIGFuY2hvci5rZXkgPT09IGxhc3RLZXkpIHtcbiAgICAgICAgICBzZWxlY3Rpb24uZm9ybWF0ID0gbGFzdEZvcm1hdDtcbiAgICAgICAgICBzZWxlY3Rpb24uc3R5bGUgPSBsYXN0U3R5bGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGFuY2hvci50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgIGlmICghJGlzVGV4dE5vZGUoYW5jaG9yTm9kZSkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoYFBvaW50LmdldE5vZGUoKSBtdXN0IHJldHVybiBUZXh0Tm9kZSB3aGVuIHR5cGUgaXMgdGV4dGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZWN0aW9uLmZvcm1hdCA9IGFuY2hvck5vZGUuZ2V0Rm9ybWF0KCk7XG4gICAgICAgICAgICBzZWxlY3Rpb24uc3R5bGUgPSBhbmNob3JOb2RlLmdldFN0eWxlKCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChhbmNob3IudHlwZSA9PT0gJ2VsZW1lbnQnICYmICFpc1Jvb3RUZXh0Q29udGVudEVtcHR5KSB7XG4gICAgICAgICAgICBpZiAoISRpc0VsZW1lbnROb2RlKGFuY2hvck5vZGUpKSB7XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKGBQb2ludC5nZXROb2RlKCkgbXVzdCByZXR1cm4gRWxlbWVudE5vZGUgd2hlbiB0eXBlIGlzIGVsZW1lbnRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxhc3ROb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgICAgICAgICAgIHNlbGVjdGlvbi5zdHlsZSA9ICcnO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgLy8gVGhpcyBwcmV2aW91c2x5IGFwcGxpZWQgdG8gYWxsIFBhcmFncmFwaE5vZGVcbiAgICAgICAgICAgIGxhc3ROb2RlLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICBzZWxlY3Rpb24uZm9ybWF0ID0gbGFzdE5vZGUuZ2V0VGV4dEZvcm1hdCgpO1xuICAgICAgICAgICAgICBzZWxlY3Rpb24uc3R5bGUgPSBsYXN0Tm9kZS5nZXRUZXh0U3R5bGUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNlbGVjdGlvbi5mb3JtYXQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYW5jaG9yS2V5ID0gYW5jaG9yLmtleTtcbiAgICAgICAgY29uc3QgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXM7XG4gICAgICAgIGNvbnN0IGZvY3VzS2V5ID0gZm9jdXMua2V5O1xuICAgICAgICBjb25zdCBub2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpO1xuICAgICAgICBjb25zdCBub2Rlc0xlbmd0aCA9IG5vZGVzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgaXNCYWNrd2FyZCA9IHNlbGVjdGlvbi5pc0JhY2t3YXJkKCk7XG4gICAgICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gaXNCYWNrd2FyZCA/IGZvY3VzT2Zmc2V0IDogYW5jaG9yT2Zmc2V0O1xuICAgICAgICBjb25zdCBlbmRPZmZzZXQgPSBpc0JhY2t3YXJkID8gYW5jaG9yT2Zmc2V0IDogZm9jdXNPZmZzZXQ7XG4gICAgICAgIGNvbnN0IHN0YXJ0S2V5ID0gaXNCYWNrd2FyZCA/IGZvY3VzS2V5IDogYW5jaG9yS2V5O1xuICAgICAgICBjb25zdCBlbmRLZXkgPSBpc0JhY2t3YXJkID8gYW5jaG9yS2V5IDogZm9jdXNLZXk7XG4gICAgICAgIGxldCBjb21iaW5lZEZvcm1hdCA9IElTX0FMTF9GT1JNQVRUSU5HO1xuICAgICAgICBsZXQgaGFzVGV4dE5vZGVzID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXNMZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICBjb25zdCB0ZXh0Q29udGVudFNpemUgPSBub2RlLmdldFRleHRDb250ZW50U2l6ZSgpO1xuICAgICAgICAgIGlmICgkaXNUZXh0Tm9kZShub2RlKSAmJiB0ZXh0Q29udGVudFNpemUgIT09IDAgJiZcbiAgICAgICAgICAvLyBFeGNsdWRlIGVtcHR5IHRleHQgbm9kZXMgYXQgYm91bmRhcmllcyByZXN1bHRpbmcgZnJvbSB1c2VyJ3Mgc2VsZWN0aW9uXG4gICAgICAgICAgIShpID09PSAwICYmIG5vZGUuX19rZXkgPT09IHN0YXJ0S2V5ICYmIHN0YXJ0T2Zmc2V0ID09PSB0ZXh0Q29udGVudFNpemUgfHwgaSA9PT0gbm9kZXNMZW5ndGggLSAxICYmIG5vZGUuX19rZXkgPT09IGVuZEtleSAmJiBlbmRPZmZzZXQgPT09IDApKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiB3aGF0IGFib3V0IHN0eWxlP1xuICAgICAgICAgICAgaGFzVGV4dE5vZGVzID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbWJpbmVkRm9ybWF0ICY9IG5vZGUuZ2V0Rm9ybWF0KCk7XG4gICAgICAgICAgICBpZiAoY29tYmluZWRGb3JtYXQgPT09IDApIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNlbGVjdGlvbi5mb3JtYXQgPSBoYXNUZXh0Tm9kZXMgPyBjb21iaW5lZEZvcm1hdCA6IDA7XG4gICAgICB9XG4gICAgfVxuICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIFNFTEVDVElPTl9DSEFOR0VfQ09NTUFORCwgdW5kZWZpbmVkKTtcbiAgfSk7XG59XG5cbi8vIFRoaXMgaXMgYSB3b3JrLWFyb3VuZCBpcyBtYWlubHkgQ2hyb21lIHNwZWNpZmljIGJ1ZyB3aGVyZSBpZiB5b3Ugc2VsZWN0XG4vLyB0aGUgY29udGVudHMgb2YgYW4gZW1wdHkgYmxvY2ssIHlvdSBjYW5ub3QgZWFzaWx5IHVuc2VsZWN0IGFueXRoaW5nLlxuLy8gVGhpcyByZXN1bHRzIGluIGEgdGlueSBzZWxlY3Rpb24gYm94IHRoYXQgbG9va3MgYnVnZ3kvYnJva2VuLiBUaGlzIGNhblxuLy8gYWxzbyBoZWxwIG90aGVyIGJyb3dzZXJzIHdoZW4gc2VsZWN0aW9uIG1pZ2h0IFwiYXBwZWFyXCIgbG9zdCwgd2hlbiBpdFxuLy8gcmVhbGx5IGlzbid0LlxuZnVuY3Rpb24gb25DbGljayhldmVudCwgZWRpdG9yKSB7XG4gIHVwZGF0ZUVkaXRvcihlZGl0b3IsICgpID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgY29uc3QgZG9tU2VsZWN0aW9uID0gZ2V0RE9NU2VsZWN0aW9uKGVkaXRvci5fd2luZG93KTtcbiAgICBjb25zdCBsYXN0U2VsZWN0aW9uID0gJGdldFByZXZpb3VzU2VsZWN0aW9uKCk7XG4gICAgaWYgKGRvbVNlbGVjdGlvbikge1xuICAgICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgICAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgICAgICAgY29uc3QgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gICAgICAgIGlmIChhbmNob3IudHlwZSA9PT0gJ2VsZW1lbnQnICYmIGFuY2hvci5vZmZzZXQgPT09IDAgJiYgc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgJiYgISRpc1Jvb3ROb2RlKGFuY2hvck5vZGUpICYmICRnZXRSb290KCkuZ2V0Q2hpbGRyZW5TaXplKCkgPT09IDEgJiYgYW5jaG9yTm9kZS5nZXRUb3BMZXZlbEVsZW1lbnRPclRocm93KCkuaXNFbXB0eSgpICYmIGxhc3RTZWxlY3Rpb24gIT09IG51bGwgJiYgc2VsZWN0aW9uLmlzKGxhc3RTZWxlY3Rpb24pKSB7XG4gICAgICAgICAgZG9tU2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICAgIHNlbGVjdGlvbi5kaXJ0eSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnQuZGV0YWlsID09PSAzICYmICFzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSkge1xuICAgICAgICAgIC8vIFRyaXBsZSBjbGljayBjYXVzaW5nIHNlbGVjdGlvbiB0byBvdmVyZmxvdyBpbnRvIHRoZSBuZWFyZXN0IGVsZW1lbnQuIEluIHRoYXRcbiAgICAgICAgICAvLyBjYXNlIHZpc3VhbGx5IGl0IGxvb2tzIGxpa2UgYSBzaW5nbGUgZWxlbWVudCBjb250ZW50IGlzIHNlbGVjdGVkLCBmb2N1cyBub2RlXG4gICAgICAgICAgLy8gaXMgYWN0dWFsbHkgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgbmV4dCBlbGVtZW50IChpZiBwcmVzZW50KSBhbmQgYW55IG1hbmlwdWxhdGlvbnNcbiAgICAgICAgICAvLyB3aXRoIHNlbGVjdGlvbiAoZm9ybWF0dGluZykgYXJlIGFmZmVjdGluZyBzZWNvbmQgZWxlbWVudCBhcyB3ZWxsXG4gICAgICAgICAgY29uc3QgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXM7XG4gICAgICAgICAgY29uc3QgZm9jdXNOb2RlID0gZm9jdXMuZ2V0Tm9kZSgpO1xuICAgICAgICAgIGlmIChhbmNob3JOb2RlICE9PSBmb2N1c05vZGUpIHtcbiAgICAgICAgICAgIGlmICgkaXNFbGVtZW50Tm9kZShhbmNob3JOb2RlKSkge1xuICAgICAgICAgICAgICBhbmNob3JOb2RlLnNlbGVjdCgwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFuY2hvck5vZGUuZ2V0UGFyZW50T3JUaHJvdygpLnNlbGVjdCgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZXZlbnQucG9pbnRlclR5cGUgPT09ICd0b3VjaCcpIHtcbiAgICAgICAgLy8gVGhpcyBpcyB1c2VkIHRvIHVwZGF0ZSB0aGUgc2VsZWN0aW9uIG9uIHRvdWNoIGRldmljZXMgd2hlbiB0aGUgdXNlciBjbGlja3Mgb24gdGV4dCBhZnRlciBhXG4gICAgICAgIC8vIG5vZGUgc2VsZWN0aW9uLiBTZWUgaXNTZWxlY3Rpb25DaGFuZ2VGcm9tTW91c2VEb3duIGZvciB0aGUgaW52ZXJzZVxuICAgICAgICBjb25zdCBkb21BbmNob3JOb2RlID0gZG9tU2VsZWN0aW9uLmFuY2hvck5vZGU7XG4gICAgICAgIC8vIElmIHRoZSB1c2VyIGlzIGF0dGVtcHRpbmcgdG8gY2xpY2sgc2VsZWN0aW9uIGJhY2sgb250byB0ZXh0LCB0aGVuXG4gICAgICAgIC8vIHdlIHNob3VsZCBhdHRlbXB0IGNyZWF0ZSBhIHJhbmdlIHNlbGVjdGlvbi5cbiAgICAgICAgLy8gV2hlbiB3ZSBjbGljayBvbiBhbiBlbXB0eSBwYXJhZ3JhcGggbm9kZSBvciB0aGUgZW5kIG9mIGEgcGFyYWdyYXBoIHRoYXQgZW5kc1xuICAgICAgICAvLyB3aXRoIGFuIGltYWdlL3BvbGwsIHRoZSBub2RlVHlwZSB3aWxsIGJlIEVMRU1FTlRfTk9ERVxuICAgICAgICBpZiAoaXNIVE1MRWxlbWVudChkb21BbmNob3JOb2RlKSB8fCBpc0RPTVRleHROb2RlKGRvbUFuY2hvck5vZGUpKSB7XG4gICAgICAgICAgY29uc3QgbmV3U2VsZWN0aW9uID0gJGludGVybmFsQ3JlYXRlUmFuZ2VTZWxlY3Rpb24obGFzdFNlbGVjdGlvbiwgZG9tU2VsZWN0aW9uLCBlZGl0b3IsIGV2ZW50KTtcbiAgICAgICAgICAkc2V0U2VsZWN0aW9uKG5ld1NlbGVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgQ0xJQ0tfQ09NTUFORCwgZXZlbnQpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIG9uUG9pbnRlckRvd24oZXZlbnQsIGVkaXRvcikge1xuICAvLyBUT0RPIGltcGxlbWVudCB0ZXh0IGRyYWcgJiBkcm9wXG4gIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgY29uc3QgcG9pbnRlclR5cGUgPSBldmVudC5wb2ludGVyVHlwZTtcbiAgaWYgKGlzRE9NTm9kZSh0YXJnZXQpICYmIHBvaW50ZXJUeXBlICE9PSAndG91Y2gnICYmIGV2ZW50LmJ1dHRvbiA9PT0gMCkge1xuICAgIHVwZGF0ZUVkaXRvcihlZGl0b3IsICgpID0+IHtcbiAgICAgIC8vIERyYWcgJiBkcm9wIHNob3VsZCBub3QgcmVjb21wdXRlIHNlbGVjdGlvbiB1bnRpbCBtb3VzZSB1cDsgb3RoZXJ3aXNlIHRoZSBpbml0aWFsbHlcbiAgICAgIC8vIHNlbGVjdGVkIGNvbnRlbnQgaXMgbG9zdC5cbiAgICAgIGlmICghJGlzU2VsZWN0aW9uQ2FwdHVyZWRJbkRlY29yYXRvcih0YXJnZXQpKSB7XG4gICAgICAgIGlzU2VsZWN0aW9uQ2hhbmdlRnJvbU1vdXNlRG93biA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFRhcmdldFJhbmdlKGV2ZW50KSB7XG4gIGlmICghZXZlbnQuZ2V0VGFyZ2V0UmFuZ2VzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgdGFyZ2V0UmFuZ2VzID0gZXZlbnQuZ2V0VGFyZ2V0UmFuZ2VzKCk7XG4gIGlmICh0YXJnZXRSYW5nZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHRhcmdldFJhbmdlc1swXTtcbn1cbmZ1bmN0aW9uICRjYW5SZW1vdmVUZXh0KGFuY2hvck5vZGUsIGZvY3VzTm9kZSkge1xuICByZXR1cm4gYW5jaG9yTm9kZSAhPT0gZm9jdXNOb2RlIHx8ICRpc0VsZW1lbnROb2RlKGFuY2hvck5vZGUpIHx8ICRpc0VsZW1lbnROb2RlKGZvY3VzTm9kZSkgfHwgIWFuY2hvck5vZGUuaXNUb2tlbigpIHx8ICFmb2N1c05vZGUuaXNUb2tlbigpO1xufVxuZnVuY3Rpb24gaXNQb3NzaWJseUFuZHJvaWRLZXlQcmVzcyh0aW1lU3RhbXApIHtcbiAgcmV0dXJuIGxhc3RLZXlDb2RlID09PSAnTWVkaWFMYXN0JyAmJiB0aW1lU3RhbXAgPCBsYXN0S2V5RG93blRpbWVTdGFtcCArIEFORFJPSURfQ09NUE9TSVRJT05fTEFURU5DWTtcbn1cbmZ1bmN0aW9uIG9uQmVmb3JlSW5wdXQoZXZlbnQsIGVkaXRvcikge1xuICBjb25zdCBpbnB1dFR5cGUgPSBldmVudC5pbnB1dFR5cGU7XG4gIGNvbnN0IHRhcmdldFJhbmdlID0gZ2V0VGFyZ2V0UmFuZ2UoZXZlbnQpO1xuXG4gIC8vIFdlIGxldCB0aGUgYnJvd3NlciBkbyBpdHMgb3duIHRoaW5nIGZvciBjb21wb3NpdGlvbi5cbiAgaWYgKGlucHV0VHlwZSA9PT0gJ2RlbGV0ZUNvbXBvc2l0aW9uVGV4dCcgfHxcbiAgLy8gSWYgd2UncmUgcGFzdGluZyBpbiBGRiwgd2Ugc2hvdWxkbid0IGdldCB0aGlzIGV2ZW50XG4gIC8vIGFzIHRoZSBgcGFzdGVgIGV2ZW50IHNob3VsZCBoYXZlIHRyaWdnZXJlZCwgdW5sZXNzIHRoZVxuICAvLyB1c2VyIGhhcyBkb20uZXZlbnQuY2xpcGJvYXJkZXZlbnRzLmVuYWJsZWQgZGlzYWJsZWQgaW5cbiAgLy8gYWJvdXQ6Y29uZmlnLiBJbiB0aGF0IGNhc2UsIHdlIG5lZWQgdG8gcHJvY2VzcyB0aGVcbiAgLy8gcGFzdGVkIGNvbnRlbnQgaW4gdGhlIERPTSBtdXRhdGlvbiBwaGFzZS5cbiAgSVNfRklSRUZPWCAmJiBpc0ZpcmVmb3hDbGlwYm9hcmRFdmVudHMoZWRpdG9yKSkge1xuICAgIHJldHVybjtcbiAgfSBlbHNlIGlmIChpbnB1dFR5cGUgPT09ICdpbnNlcnRDb21wb3NpdGlvblRleHQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHVwZGF0ZUVkaXRvcihlZGl0b3IsICgpID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKGlucHV0VHlwZSA9PT0gJ2RlbGV0ZUNvbnRlbnRCYWNrd2FyZCcpIHtcbiAgICAgIGlmIChzZWxlY3Rpb24gPT09IG51bGwpIHtcbiAgICAgICAgLy8gVXNlIHByZXZpb3VzIHNlbGVjdGlvblxuICAgICAgICBjb25zdCBwcmV2U2VsZWN0aW9uID0gJGdldFByZXZpb3VzU2VsZWN0aW9uKCk7XG4gICAgICAgIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24ocHJldlNlbGVjdGlvbikpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgJHNldFNlbGVjdGlvbihwcmV2U2VsZWN0aW9uLmNsb25lKCkpO1xuICAgICAgfVxuICAgICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgICAgY29uc3QgaXNTZWxlY3Rpb25BbmNob3JTYW1lQXNGb2N1cyA9IHNlbGVjdGlvbi5hbmNob3Iua2V5ID09PSBzZWxlY3Rpb24uZm9jdXMua2V5O1xuICAgICAgICBpZiAoaXNQb3NzaWJseUFuZHJvaWRLZXlQcmVzcyhldmVudC50aW1lU3RhbXApICYmIGVkaXRvci5pc0NvbXBvc2luZygpICYmIGlzU2VsZWN0aW9uQW5jaG9yU2FtZUFzRm9jdXMpIHtcbiAgICAgICAgICAkc2V0Q29tcG9zaXRpb25LZXkobnVsbCk7XG4gICAgICAgICAgbGFzdEtleURvd25UaW1lU3RhbXAgPSAwO1xuICAgICAgICAgIC8vIEZpeGVzIGFuIEFuZHJvaWQgYnVnIHdoZXJlIHNlbGVjdGlvbiBmbGlja2VycyB3aGVuIGJhY2tzcGFjaW5nXG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB1cGRhdGVFZGl0b3IoZWRpdG9yLCAoKSA9PiB7XG4gICAgICAgICAgICAgICRzZXRDb21wb3NpdGlvbktleShudWxsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sIEFORFJPSURfQ09NUE9TSVRJT05fTEFURU5DWSk7XG4gICAgICAgICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIGNvbnN0IGFuY2hvck5vZGUgPSBzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKTtcbiAgICAgICAgICAgIGFuY2hvck5vZGUubWFya0RpcnR5KCk7XG4gICAgICAgICAgICBzZWxlY3Rpb24uZm9ybWF0ID0gYW5jaG9yTm9kZS5nZXRGb3JtYXQoKTtcbiAgICAgICAgICAgIGlmICghJGlzVGV4dE5vZGUoYW5jaG9yTm9kZSkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoYEFuY2hvciBub2RlIG11c3QgYmUgYSBUZXh0Tm9kZWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZWN0aW9uLnN0eWxlID0gYW5jaG9yTm9kZS5nZXRTdHlsZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkc2V0Q29tcG9zaXRpb25LZXkobnVsbCk7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAvLyBDaHJvbWl1bSBBbmRyb2lkIGF0IHRoZSBtb21lbnQgc2VlbXMgdG8gaWdub3JlIHRoZSBwcmV2ZW50RGVmYXVsdFxuICAgICAgICAgIC8vIG9uICdkZWxldGVDb250ZW50QmFja3dhcmQnIGFuZCBzdGlsbCBkZWxldGVzIHRoZSBjb250ZW50LiBXaGljaCBsZWFkc1xuICAgICAgICAgIC8vIHRvIG11bHRpcGxlIGRlbGV0aW9ucy4gU28gd2UgbGV0IHRoZSBicm93c2VyIGhhbmRsZSB0aGUgZGVsZXRpb24gaW4gdGhpcyBjYXNlLlxuICAgICAgICAgIGNvbnN0IHNlbGVjdGVkTm9kZSA9IHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpO1xuICAgICAgICAgIGNvbnN0IHNlbGVjdGVkTm9kZVRleHQgPSBzZWxlY3RlZE5vZGUuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICAgICAgICAvLyBXaGVuIHRoZSB0YXJnZXQgbm9kZSBoYXMgYGNhbkluc2VydFRleHRBZnRlcmAgc2V0IHRvIGZhbHNlLCB0aGUgZmlyc3QgZGVsZXRpb25cbiAgICAgICAgICAvLyBkb2Vzbid0IGhhdmUgYW4gZWZmZWN0LCBzbyB3ZSBuZWVkIHRvIGhhbmRsZSBpdCB3aXRoIExleGljYWwuXG4gICAgICAgICAgY29uc3Qgc2VsZWN0ZWROb2RlQ2FuSW5zZXJ0VGV4dEFmdGVyID0gc2VsZWN0ZWROb2RlLmNhbkluc2VydFRleHRBZnRlcigpO1xuICAgICAgICAgIGNvbnN0IGhhc1NlbGVjdGVkQWxsVGV4dEluTm9kZSA9IHNlbGVjdGlvbi5hbmNob3Iub2Zmc2V0ID09PSAwICYmIHNlbGVjdGlvbi5mb2N1cy5vZmZzZXQgPT09IHNlbGVjdGVkTm9kZVRleHQubGVuZ3RoO1xuICAgICAgICAgIGNvbnN0IHNob3VsZExldEJyb3dzZXJIYW5kbGVEZWxldGUgPSBJU19BTkRST0lEX0NIUk9NRSAmJiBpc1NlbGVjdGlvbkFuY2hvclNhbWVBc0ZvY3VzICYmICFoYXNTZWxlY3RlZEFsbFRleHRJbk5vZGUgJiYgc2VsZWN0ZWROb2RlQ2FuSW5zZXJ0VGV4dEFmdGVyO1xuICAgICAgICAgIGlmICghc2hvdWxkTGV0QnJvd3NlckhhbmRsZURlbGV0ZSkge1xuICAgICAgICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgREVMRVRFX0NIQVJBQ1RFUl9DT01NQU5ELCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IGV2ZW50LmRhdGE7XG5cbiAgICAvLyBUaGlzIHJlcHJlc2VudHMgdGhlIGNhc2Ugd2hlbiB0d28gYmVmb3JlaW5wdXQgZXZlbnRzIGFyZSB0cmlnZ2VyZWQgYXQgdGhlIHNhbWUgdGltZSAod2l0aG91dCBhXG4gICAgLy8gZnVsbCBldmVudCBsb29wIGVuZGluZyBhdCBpbnB1dCkuIFRoaXMgaGFwcGVucyB3aXRoIE1hY09TIHdpdGggdGhlIGRlZmF1bHQga2V5Ym9hcmQgc2V0dGluZ3MsXG4gICAgLy8gYSBjb21iaW5hdGlvbiBvZiBhdXRvY29ycmVjdGlvbiArIGF1dG9jYXBpdGFsaXphdGlvbi5cbiAgICAvLyBIYXZpbmcgTGV4aWNhbCBydW4gZXZlcnl0aGluZyBpbiBjb250cm9sbGVkIG1vZGUgd291bGQgZml4IHRoZSBpc3N1ZSB3aXRob3V0IGFkZGl0aW9uYWwgY29kZVxuICAgIC8vIGJ1dCB0aGlzIHdvdWxkIGtpbGwgdGhlIG1hc3NpdmUgcGVyZm9ybWFuY2Ugd2luIGZyb20gdGhlIG1vc3QgY29tbW9uIHR5cGluZyBldmVudC5cbiAgICAvLyBBbHRlcm5hdGl2ZWx5LCB3aGVuIHRoaXMgaGFwcGVucyB3ZSBjYW4gcHJlbWF0dXJlbHkgdXBkYXRlIG91ciBFZGl0b3JTdGF0ZSBiYXNlZCBvbiB0aGUgRE9NXG4gICAgLy8gY29udGVudCwgYSBqb2IgdGhhdCB3b3VsZCB1c3VhbGx5IGJlIHRoZSBpbnB1dCBldmVudCdzIHJlc3BvbnNpYmlsaXR5LlxuICAgIGlmICh1bnByb2Nlc3NlZEJlZm9yZUlucHV0RGF0YSAhPT0gbnVsbCkge1xuICAgICAgJHVwZGF0ZVNlbGVjdGVkVGV4dEZyb21ET00oZmFsc2UsIGVkaXRvciwgdW5wcm9jZXNzZWRCZWZvcmVJbnB1dERhdGEpO1xuICAgIH1cbiAgICBpZiAoKCFzZWxlY3Rpb24uZGlydHkgfHwgdW5wcm9jZXNzZWRCZWZvcmVJbnB1dERhdGEgIT09IG51bGwpICYmIHNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpICYmICEkaXNSb290Tm9kZShzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKSkgJiYgdGFyZ2V0UmFuZ2UgIT09IG51bGwpIHtcbiAgICAgIHNlbGVjdGlvbi5hcHBseURPTVJhbmdlKHRhcmdldFJhbmdlKTtcbiAgICB9XG4gICAgdW5wcm9jZXNzZWRCZWZvcmVJbnB1dERhdGEgPSBudWxsO1xuICAgIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gICAgY29uc3QgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXM7XG4gICAgY29uc3QgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gICAgY29uc3QgZm9jdXNOb2RlID0gZm9jdXMuZ2V0Tm9kZSgpO1xuICAgIGlmIChpbnB1dFR5cGUgPT09ICdpbnNlcnRUZXh0JyB8fCBpbnB1dFR5cGUgPT09ICdpbnNlcnRUcmFuc3Bvc2UnKSB7XG4gICAgICBpZiAoZGF0YSA9PT0gJ1xcbicpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgSU5TRVJUX0xJTkVfQlJFQUtfQ09NTUFORCwgZmFsc2UpO1xuICAgICAgfSBlbHNlIGlmIChkYXRhID09PSBET1VCTEVfTElORV9CUkVBSykge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBJTlNFUlRfUEFSQUdSQVBIX0NPTU1BTkQsIHVuZGVmaW5lZCk7XG4gICAgICB9IGVsc2UgaWYgKGRhdGEgPT0gbnVsbCAmJiBldmVudC5kYXRhVHJhbnNmZXIpIHtcbiAgICAgICAgLy8gR2V0cyBhcm91bmQgYSBTYWZhcmkgdGV4dCByZXBsYWNlbWVudCBidWcuXG4gICAgICAgIGNvbnN0IHRleHQgPSBldmVudC5kYXRhVHJhbnNmZXIuZ2V0RGF0YSgndGV4dC9wbGFpbicpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBzZWxlY3Rpb24uaW5zZXJ0UmF3VGV4dCh0ZXh0KTtcbiAgICAgIH0gZWxzZSBpZiAoZGF0YSAhPSBudWxsICYmICRzaG91bGRQcmV2ZW50RGVmYXVsdEFuZEluc2VydFRleHQoc2VsZWN0aW9uLCB0YXJnZXRSYW5nZSwgZGF0YSwgZXZlbnQudGltZVN0YW1wLCB0cnVlKSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBDT05UUk9MTEVEX1RFWFRfSU5TRVJUSU9OX0NPTU1BTkQsIGRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdW5wcm9jZXNzZWRCZWZvcmVJbnB1dERhdGEgPSBkYXRhO1xuICAgICAgfVxuICAgICAgbGFzdEJlZm9yZUlucHV0SW5zZXJ0VGV4dFRpbWVTdGFtcCA9IGV2ZW50LnRpbWVTdGFtcDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBQcmV2ZW50IHRoZSBicm93c2VyIGZyb20gY2Fycnlpbmcgb3V0XG4gICAgLy8gdGhlIGlucHV0IGV2ZW50LCBzbyB3ZSBjYW4gY29udHJvbCB0aGVcbiAgICAvLyBvdXRwdXQuXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBzd2l0Y2ggKGlucHV0VHlwZSkge1xuICAgICAgY2FzZSAnaW5zZXJ0RnJvbVlhbmsnOlxuICAgICAgY2FzZSAnaW5zZXJ0RnJvbURyb3AnOlxuICAgICAgY2FzZSAnaW5zZXJ0UmVwbGFjZW1lbnRUZXh0JzpcbiAgICAgICAge1xuICAgICAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIENPTlRST0xMRURfVEVYVF9JTlNFUlRJT05fQ09NTUFORCwgZXZlbnQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdpbnNlcnRGcm9tQ29tcG9zaXRpb24nOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gVGhpcyBpcyB0aGUgZW5kIG9mIGNvbXBvc2l0aW9uXG4gICAgICAgICAgJHNldENvbXBvc2l0aW9uS2V5KG51bGwpO1xuICAgICAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIENPTlRST0xMRURfVEVYVF9JTlNFUlRJT05fQ09NTUFORCwgZXZlbnQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdpbnNlcnRMaW5lQnJlYWsnOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gVXNlZCBmb3IgQW5kcm9pZFxuICAgICAgICAgICRzZXRDb21wb3NpdGlvbktleShudWxsKTtcbiAgICAgICAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBJTlNFUlRfTElORV9CUkVBS19DT01NQU5ELCBmYWxzZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ2luc2VydFBhcmFncmFwaCc6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBVc2VkIGZvciBBbmRyb2lkXG4gICAgICAgICAgJHNldENvbXBvc2l0aW9uS2V5KG51bGwpO1xuXG4gICAgICAgICAgLy8gU2FmYXJpIGRvZXMgbm90IHByb3ZpZGUgdGhlIHR5cGUgXCJpbnNlcnRMaW5lQnJlYWtcIi5cbiAgICAgICAgICAvLyBTbyBpbnN0ZWFkLCB3ZSBuZWVkIHRvIGluZmVyIGl0IGZyb20gdGhlIGtleWJvYXJkIGV2ZW50LlxuICAgICAgICAgIC8vIFdlIGRvIG5vdCBhcHBseSB0aGlzIGxvZ2ljIHRvIGlPUyB0byBhbGxvdyBuZXdsaW5lIGF1dG8tY2FwaXRhbGl6YXRpb25cbiAgICAgICAgICAvLyB3b3JrIHdpdGhvdXQgY3JlYXRpbmcgbGluZWJyZWFrcyB3aGVuIHByZXNzaW5nIEVudGVyXG4gICAgICAgICAgaWYgKGlzSW5zZXJ0TGluZUJyZWFrICYmICFJU19JT1MpIHtcbiAgICAgICAgICAgIGlzSW5zZXJ0TGluZUJyZWFrID0gZmFsc2U7XG4gICAgICAgICAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBJTlNFUlRfTElORV9CUkVBS19DT01NQU5ELCBmYWxzZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIElOU0VSVF9QQVJBR1JBUEhfQ09NTUFORCwgdW5kZWZpbmVkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ2luc2VydEZyb21QYXN0ZSc6XG4gICAgICBjYXNlICdpbnNlcnRGcm9tUGFzdGVBc1F1b3RhdGlvbic6XG4gICAgICAgIHtcbiAgICAgICAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBQQVNURV9DT01NQU5ELCBldmVudCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ2RlbGV0ZUJ5Q29tcG9zaXRpb24nOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKCRjYW5SZW1vdmVUZXh0KGFuY2hvck5vZGUsIGZvY3VzTm9kZSkpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIFJFTU9WRV9URVhUX0NPTU1BTkQsIGV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ2RlbGV0ZUJ5RHJhZyc6XG4gICAgICBjYXNlICdkZWxldGVCeUN1dCc6XG4gICAgICAgIHtcbiAgICAgICAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBSRU1PVkVfVEVYVF9DT01NQU5ELCBldmVudCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ2RlbGV0ZUNvbnRlbnQnOlxuICAgICAgICB7XG4gICAgICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgREVMRVRFX0NIQVJBQ1RFUl9DT01NQU5ELCBmYWxzZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ2RlbGV0ZVdvcmRCYWNrd2FyZCc6XG4gICAgICAgIHtcbiAgICAgICAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBERUxFVEVfV09SRF9DT01NQU5ELCB0cnVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSAnZGVsZXRlV29yZEZvcndhcmQnOlxuICAgICAgICB7XG4gICAgICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgREVMRVRFX1dPUkRfQ09NTUFORCwgZmFsc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdkZWxldGVIYXJkTGluZUJhY2t3YXJkJzpcbiAgICAgIGNhc2UgJ2RlbGV0ZVNvZnRMaW5lQmFja3dhcmQnOlxuICAgICAgICB7XG4gICAgICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgREVMRVRFX0xJTkVfQ09NTUFORCwgdHJ1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ2RlbGV0ZUNvbnRlbnRGb3J3YXJkJzpcbiAgICAgIGNhc2UgJ2RlbGV0ZUhhcmRMaW5lRm9yd2FyZCc6XG4gICAgICBjYXNlICdkZWxldGVTb2Z0TGluZUZvcndhcmQnOlxuICAgICAgICB7XG4gICAgICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgREVMRVRFX0xJTkVfQ09NTUFORCwgZmFsc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdmb3JtYXRTdHJpa2VUaHJvdWdoJzpcbiAgICAgICAge1xuICAgICAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIEZPUk1BVF9URVhUX0NPTU1BTkQsICdzdHJpa2V0aHJvdWdoJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ2Zvcm1hdEJvbGQnOlxuICAgICAgICB7XG4gICAgICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgRk9STUFUX1RFWFRfQ09NTUFORCwgJ2JvbGQnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSAnZm9ybWF0SXRhbGljJzpcbiAgICAgICAge1xuICAgICAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIEZPUk1BVF9URVhUX0NPTU1BTkQsICdpdGFsaWMnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSAnZm9ybWF0VW5kZXJsaW5lJzpcbiAgICAgICAge1xuICAgICAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIEZPUk1BVF9URVhUX0NPTU1BTkQsICd1bmRlcmxpbmUnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSAnaGlzdG9yeVVuZG8nOlxuICAgICAgICB7XG4gICAgICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgVU5ET19DT01NQU5ELCB1bmRlZmluZWQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdoaXN0b3J5UmVkbyc6XG4gICAgICAgIHtcbiAgICAgICAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBSRURPX0NPTU1BTkQsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIC8vIE5PLU9QXG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIG9uSW5wdXQoZXZlbnQsIGVkaXRvcikge1xuICAvLyBXZSBkb24ndCB3YW50IHRoZSBvbklucHV0IHRvIGJ1YmJsZSwgaW4gdGhlIGNhc2Ugb2YgbmVzdGVkIGVkaXRvcnMuXG4gIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICB1cGRhdGVFZGl0b3IoZWRpdG9yLCAoKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGNvbnN0IGRhdGEgPSBldmVudC5kYXRhO1xuICAgIGNvbnN0IHRhcmdldFJhbmdlID0gZ2V0VGFyZ2V0UmFuZ2UoZXZlbnQpO1xuICAgIGlmIChkYXRhICE9IG51bGwgJiYgJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSAmJiAkc2hvdWxkUHJldmVudERlZmF1bHRBbmRJbnNlcnRUZXh0KHNlbGVjdGlvbiwgdGFyZ2V0UmFuZ2UsIGRhdGEsIGV2ZW50LnRpbWVTdGFtcCwgZmFsc2UpKSB7XG4gICAgICAvLyBHaXZlbiB3ZSdyZSBvdmVyLXJpZGluZyB0aGUgZGVmYXVsdCBiZWhhdmlvciwgd2Ugd2lsbCBuZWVkXG4gICAgICAvLyB0byBlbnN1cmUgdG8gZGlzYWJsZSBjb21wb3NpdGlvbiBiZWZvcmUgZGlzcGF0Y2hpbmcgdGhlXG4gICAgICAvLyBpbnNlcnRUZXh0IGNvbW1hbmQgZm9yIHdoZW4gY2hhbmdpbmcgdGhlIHNlcXVlbmNlIGZvciBGRi5cbiAgICAgIGlmIChpc0ZpcmVmb3hFbmRpbmdDb21wb3NpdGlvbikge1xuICAgICAgICAkb25Db21wb3NpdGlvbkVuZEltcGwoZWRpdG9yLCBkYXRhKTtcbiAgICAgICAgaXNGaXJlZm94RW5kaW5nQ29tcG9zaXRpb24gPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gICAgICBjb25zdCBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgICAgIGNvbnN0IGRvbVNlbGVjdGlvbiA9IGdldERPTVNlbGVjdGlvbihlZGl0b3IuX3dpbmRvdyk7XG4gICAgICBpZiAoZG9tU2VsZWN0aW9uID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzQmFja3dhcmQgPSBzZWxlY3Rpb24uaXNCYWNrd2FyZCgpO1xuICAgICAgY29uc3Qgc3RhcnRPZmZzZXQgPSBpc0JhY2t3YXJkID8gc2VsZWN0aW9uLmFuY2hvci5vZmZzZXQgOiBzZWxlY3Rpb24uZm9jdXMub2Zmc2V0O1xuICAgICAgY29uc3QgZW5kT2Zmc2V0ID0gaXNCYWNrd2FyZCA/IHNlbGVjdGlvbi5mb2N1cy5vZmZzZXQgOiBzZWxlY3Rpb24uYW5jaG9yLm9mZnNldDtcbiAgICAgIC8vIElmIHRoZSBjb250ZW50IGlzIHRoZSBzYW1lIGFzIGluc2VydGVkLCB0aGVuIGRvbid0IGRpc3BhdGNoIGFuIGluc2VydGlvbi5cbiAgICAgIC8vIEdpdmVuIG9uSW5wdXQgZG9lc24ndCB0YWtlIHRoZSBjdXJyZW50IHNlbGVjdGlvbiAoaXQgdXNlcyB0aGUgcHJldmlvdXMpXG4gICAgICAvLyB3ZSBjYW4gY29tcGFyZSB0aGF0IGFnYWluc3Qgd2hhdCB0aGUgRE9NIGN1cnJlbnRseSBzYXlzLlxuICAgICAgaWYgKCFDQU5fVVNFX0JFRk9SRV9JTlBVVCB8fCBzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSB8fCAhJGlzVGV4dE5vZGUoYW5jaG9yTm9kZSkgfHwgZG9tU2VsZWN0aW9uLmFuY2hvck5vZGUgPT09IG51bGwgfHwgYW5jaG9yTm9kZS5nZXRUZXh0Q29udGVudCgpLnNsaWNlKDAsIHN0YXJ0T2Zmc2V0KSArIGRhdGEgKyBhbmNob3JOb2RlLmdldFRleHRDb250ZW50KCkuc2xpY2Uoc3RhcnRPZmZzZXQgKyBlbmRPZmZzZXQpICE9PSBnZXRBbmNob3JUZXh0RnJvbURPTShkb21TZWxlY3Rpb24uYW5jaG9yTm9kZSkpIHtcbiAgICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgQ09OVFJPTExFRF9URVhUX0lOU0VSVElPTl9DT01NQU5ELCBkYXRhKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRleHRMZW5ndGggPSBkYXRhLmxlbmd0aDtcblxuICAgICAgLy8gQW5vdGhlciBoYWNrIGZvciBGRiwgYXMgaXQncyBwb3NzaWJsZSB0aGF0IHRoZSBJTUUgaXMgc3RpbGxcbiAgICAgIC8vIG9wZW4sIGV2ZW4gdGhvdWdoIGNvbXBvc2l0aW9uZW5kIGhhcyBhbHJlYWR5IGZpcmVkIChzaWdoKS5cbiAgICAgIGlmIChJU19GSVJFRk9YICYmIHRleHRMZW5ndGggPiAxICYmIGV2ZW50LmlucHV0VHlwZSA9PT0gJ2luc2VydENvbXBvc2l0aW9uVGV4dCcgJiYgIWVkaXRvci5pc0NvbXBvc2luZygpKSB7XG4gICAgICAgIHNlbGVjdGlvbi5hbmNob3Iub2Zmc2V0IC09IHRleHRMZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIC8vIFRoaXMgZW5zdXJlcyBjb25zaXN0ZW5jeSBvbiBBbmRyb2lkLlxuICAgICAgaWYgKCFJU19TQUZBUkkgJiYgIUlTX0lPUyAmJiAhSVNfQVBQTEVfV0VCS0lUICYmIGVkaXRvci5pc0NvbXBvc2luZygpKSB7XG4gICAgICAgIGxhc3RLZXlEb3duVGltZVN0YW1wID0gMDtcbiAgICAgICAgJHNldENvbXBvc2l0aW9uS2V5KG51bGwpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjaGFyYWN0ZXJEYXRhID0gZGF0YSAhPT0gbnVsbCA/IGRhdGEgOiB1bmRlZmluZWQ7XG4gICAgICAkdXBkYXRlU2VsZWN0ZWRUZXh0RnJvbURPTShmYWxzZSwgZWRpdG9yLCBjaGFyYWN0ZXJEYXRhKTtcblxuICAgICAgLy8gb25JbnB1dCBhbHdheXMgZmlyZXMgYWZ0ZXIgb25Db21wb3NpdGlvbkVuZCBmb3IgRkYuXG4gICAgICBpZiAoaXNGaXJlZm94RW5kaW5nQ29tcG9zaXRpb24pIHtcbiAgICAgICAgJG9uQ29tcG9zaXRpb25FbmRJbXBsKGVkaXRvciwgZGF0YSB8fCB1bmRlZmluZWQpO1xuICAgICAgICBpc0ZpcmVmb3hFbmRpbmdDb21wb3NpdGlvbiA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFsc28gZmx1c2ggYW55IG90aGVyIG11dGF0aW9ucyB0aGF0IG1pZ2h0IGhhdmUgb2NjdXJyZWRcbiAgICAvLyBzaW5jZSB0aGUgY2hhbmdlLlxuICAgICRmbHVzaE11dGF0aW9ucygpO1xuICB9KTtcbiAgdW5wcm9jZXNzZWRCZWZvcmVJbnB1dERhdGEgPSBudWxsO1xufVxuZnVuY3Rpb24gb25Db21wb3NpdGlvblN0YXJ0KGV2ZW50LCBlZGl0b3IpIHtcbiAgdXBkYXRlRWRpdG9yKGVkaXRvciwgKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSAmJiAhZWRpdG9yLmlzQ29tcG9zaW5nKCkpIHtcbiAgICAgIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gICAgICBjb25zdCBub2RlID0gc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCk7XG4gICAgICAkc2V0Q29tcG9zaXRpb25LZXkoYW5jaG9yLmtleSk7XG4gICAgICBpZiAoXG4gICAgICAvLyBJZiBpdCBoYXMgYmVlbiAzMG1zIHNpbmNlIHRoZSBsYXN0IGtleWRvd24sIHRoZW4gd2Ugc2hvdWxkXG4gICAgICAvLyBhcHBseSB0aGUgZW1wdHkgc3BhY2UgaGV1cmlzdGljLiBXZSBjYW4ndCBkbyB0aGlzIGZvciBTYWZhcmksXG4gICAgICAvLyBhcyB0aGUga2V5ZG93biBmaXJlcyBhZnRlciBjb21wb3NpdGlvbiBzdGFydC5cbiAgICAgIGV2ZW50LnRpbWVTdGFtcCA8IGxhc3RLZXlEb3duVGltZVN0YW1wICsgQU5EUk9JRF9DT01QT1NJVElPTl9MQVRFTkNZIHx8XG4gICAgICAvLyBGRiBoYXMgaXNzdWVzIGFyb3VuZCBjb21wb3NpbmcgbXVsdGlieXRlIGNoYXJhY3RlcnMsIHNvIHdlIGFsc29cbiAgICAgIC8vIG5lZWQgdG8gaW52b2tlIHRoZSBlbXB0eSBzcGFjZSBoZXVyaXN0aWMgYmVsb3cuXG4gICAgICBhbmNob3IudHlwZSA9PT0gJ2VsZW1lbnQnIHx8ICFzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSB8fCBub2RlLmdldEZvcm1hdCgpICE9PSBzZWxlY3Rpb24uZm9ybWF0IHx8ICRpc1RleHROb2RlKG5vZGUpICYmIG5vZGUuZ2V0U3R5bGUoKSAhPT0gc2VsZWN0aW9uLnN0eWxlKSB7XG4gICAgICAgIC8vIFdlIGluc2VydCBhIHplcm8gd2lkdGggY2hhcmFjdGVyLCByZWFkeSBmb3IgdGhlIGNvbXBvc2l0aW9uXG4gICAgICAgIC8vIHRvIGdldCBpbnNlcnRlZCBpbnRvIHRoZSBuZXcgbm9kZSB3ZSBjcmVhdGUuIElmXG4gICAgICAgIC8vIHdlIGRvbid0IGRvIHRoaXMsIFNhZmFyaSB3aWxsIGZhaWwgb24gdXMgYmVjYXVzZVxuICAgICAgICAvLyB0aGVyZSBpcyBubyB0ZXh0IG5vZGUgbWF0Y2hpbmcgdGhlIHNlbGVjdGlvbi5cbiAgICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgQ09OVFJPTExFRF9URVhUX0lOU0VSVElPTl9DT01NQU5ELCBDT01QT1NJVElPTl9TVEFSVF9DSEFSKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gJG9uQ29tcG9zaXRpb25FbmRJbXBsKGVkaXRvciwgZGF0YSkge1xuICBjb25zdCBjb21wb3NpdGlvbktleSA9IGVkaXRvci5fY29tcG9zaXRpb25LZXk7XG4gICRzZXRDb21wb3NpdGlvbktleShudWxsKTtcblxuICAvLyBIYW5kbGUgdGVybWluYXRpb24gb2YgY29tcG9zaXRpb24uXG4gIGlmIChjb21wb3NpdGlvbktleSAhPT0gbnVsbCAmJiBkYXRhICE9IG51bGwpIHtcbiAgICAvLyBDb21wb3NpdGlvbiBjYW4gc29tZXRpbWVzIG1vdmUgdG8gYW4gYWRqYWNlbnQgRE9NIG5vZGUgd2hlbiBiYWNrc3BhY2luZy5cbiAgICAvLyBTbyBjaGVjayBmb3IgdGhlIGVtcHR5IGNhc2UuXG4gICAgaWYgKGRhdGEgPT09ICcnKSB7XG4gICAgICBjb25zdCBub2RlID0gJGdldE5vZGVCeUtleShjb21wb3NpdGlvbktleSk7XG4gICAgICBjb25zdCB0ZXh0Tm9kZSA9IGdldERPTVRleHROb2RlKGVkaXRvci5nZXRFbGVtZW50QnlLZXkoY29tcG9zaXRpb25LZXkpKTtcbiAgICAgIGlmICh0ZXh0Tm9kZSAhPT0gbnVsbCAmJiB0ZXh0Tm9kZS5ub2RlVmFsdWUgIT09IG51bGwgJiYgJGlzVGV4dE5vZGUobm9kZSkpIHtcbiAgICAgICAgJHVwZGF0ZVRleHROb2RlRnJvbURPTUNvbnRlbnQobm9kZSwgdGV4dE5vZGUubm9kZVZhbHVlLCBudWxsLCBudWxsLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDb21wb3NpdGlvbiBjYW4gc29tZXRpbWVzIGJlIHRoYXQgb2YgYSBuZXcgbGluZS4gSW4gd2hpY2ggY2FzZSwgd2UgbmVlZCB0b1xuICAgIC8vIGhhbmRsZSB0aGF0IGFjY29yZGluZ2x5LlxuICAgIGlmIChkYXRhW2RhdGEubGVuZ3RoIC0gMV0gPT09ICdcXG4nKSB7XG4gICAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgICAvLyBJZiB0aGUgbGFzdCBjaGFyYWN0ZXIgaXMgYSBsaW5lIGJyZWFrLCB3ZSBhbHNvIG5lZWQgdG8gaW5zZXJ0XG4gICAgICAgIC8vIGEgbGluZSBicmVhay5cbiAgICAgICAgY29uc3QgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXM7XG4gICAgICAgIHNlbGVjdGlvbi5hbmNob3Iuc2V0KGZvY3VzLmtleSwgZm9jdXMub2Zmc2V0LCBmb2N1cy50eXBlKTtcbiAgICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgS0VZX0VOVEVSX0NPTU1BTkQsIG51bGwpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG4gICR1cGRhdGVTZWxlY3RlZFRleHRGcm9tRE9NKHRydWUsIGVkaXRvciwgZGF0YSk7XG59XG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uRW5kKGV2ZW50LCBlZGl0b3IpIHtcbiAgLy8gRmlyZWZveCBmaXJlcyBvbkNvbXBvc2l0aW9uRW5kIGJlZm9yZSBvbklucHV0LCBidXQgQ2hyb21lL1dlYmtpdCxcbiAgLy8gZmlyZSBvbklucHV0IGJlZm9yZSBvbkNvbXBvc2l0aW9uRW5kLiBUbyBlbnN1cmUgdGhlIHNlcXVlbmNlIHdvcmtzXG4gIC8vIGxpa2UgQ2hyb21lL1dlYmtpdCB3ZSB1c2UgdGhlIGlzRmlyZWZveEVuZGluZ0NvbXBvc2l0aW9uIGZsYWcgdG9cbiAgLy8gZGVmZXIgaGFuZGxpbmcgb2Ygb25Db21wb3NpdGlvbkVuZCBpbiBGaXJlZm94IHRpbGwgd2UgaGF2ZSBwcm9jZXNzZWRcbiAgLy8gdGhlIGxvZ2ljIGluIG9uSW5wdXQuXG4gIGlmIChJU19GSVJFRk9YKSB7XG4gICAgaXNGaXJlZm94RW5kaW5nQ29tcG9zaXRpb24gPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHVwZGF0ZUVkaXRvcihlZGl0b3IsICgpID0+IHtcbiAgICAgICRvbkNvbXBvc2l0aW9uRW5kSW1wbChlZGl0b3IsIGV2ZW50LmRhdGEpO1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBvbktleURvd24oZXZlbnQsIGVkaXRvcikge1xuICBsYXN0S2V5RG93blRpbWVTdGFtcCA9IGV2ZW50LnRpbWVTdGFtcDtcbiAgbGFzdEtleUNvZGUgPSBldmVudC5rZXk7XG4gIGlmIChlZGl0b3IuaXNDb21wb3NpbmcoKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB7XG4gICAga2V5LFxuICAgIHNoaWZ0S2V5LFxuICAgIGN0cmxLZXksXG4gICAgbWV0YUtleSxcbiAgICBhbHRLZXlcbiAgfSA9IGV2ZW50O1xuICBpZiAoZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgS0VZX0RPV05fQ09NTUFORCwgZXZlbnQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChrZXkgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaXNNb3ZlRm9yd2FyZChrZXksIGN0cmxLZXksIGFsdEtleSwgbWV0YUtleSkpIHtcbiAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBLRVlfQVJST1dfUklHSFRfQ09NTUFORCwgZXZlbnQpO1xuICB9IGVsc2UgaWYgKGlzTW92ZVRvRW5kKGtleSwgY3RybEtleSwgc2hpZnRLZXksIGFsdEtleSwgbWV0YUtleSkpIHtcbiAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBNT1ZFX1RPX0VORCwgZXZlbnQpO1xuICB9IGVsc2UgaWYgKGlzTW92ZUJhY2t3YXJkKGtleSwgY3RybEtleSwgYWx0S2V5LCBtZXRhS2V5KSkge1xuICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIEtFWV9BUlJPV19MRUZUX0NPTU1BTkQsIGV2ZW50KTtcbiAgfSBlbHNlIGlmIChpc01vdmVUb1N0YXJ0KGtleSwgY3RybEtleSwgc2hpZnRLZXksIGFsdEtleSwgbWV0YUtleSkpIHtcbiAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBNT1ZFX1RPX1NUQVJULCBldmVudCk7XG4gIH0gZWxzZSBpZiAoaXNNb3ZlVXAoa2V5LCBjdHJsS2V5LCBtZXRhS2V5KSkge1xuICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIEtFWV9BUlJPV19VUF9DT01NQU5ELCBldmVudCk7XG4gIH0gZWxzZSBpZiAoaXNNb3ZlRG93bihrZXksIGN0cmxLZXksIG1ldGFLZXkpKSB7XG4gICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgS0VZX0FSUk9XX0RPV05fQ09NTUFORCwgZXZlbnQpO1xuICB9IGVsc2UgaWYgKGlzTGluZUJyZWFrKGtleSwgc2hpZnRLZXkpKSB7XG4gICAgaXNJbnNlcnRMaW5lQnJlYWsgPSB0cnVlO1xuICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIEtFWV9FTlRFUl9DT01NQU5ELCBldmVudCk7XG4gIH0gZWxzZSBpZiAoaXNTcGFjZShrZXkpKSB7XG4gICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgS0VZX1NQQUNFX0NPTU1BTkQsIGV2ZW50KTtcbiAgfSBlbHNlIGlmIChpc09wZW5MaW5lQnJlYWsoa2V5LCBjdHJsS2V5KSkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgaXNJbnNlcnRMaW5lQnJlYWsgPSB0cnVlO1xuICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIElOU0VSVF9MSU5FX0JSRUFLX0NPTU1BTkQsIHRydWUpO1xuICB9IGVsc2UgaWYgKGlzUGFyYWdyYXBoKGtleSwgc2hpZnRLZXkpKSB7XG4gICAgaXNJbnNlcnRMaW5lQnJlYWsgPSBmYWxzZTtcbiAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBLRVlfRU5URVJfQ09NTUFORCwgZXZlbnQpO1xuICB9IGVsc2UgaWYgKGlzRGVsZXRlQmFja3dhcmQoa2V5LCBhbHRLZXksIG1ldGFLZXksIGN0cmxLZXkpKSB7XG4gICAgaWYgKGlzQmFja3NwYWNlKGtleSkpIHtcbiAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIEtFWV9CQUNLU1BBQ0VfQ09NTUFORCwgZXZlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgREVMRVRFX0NIQVJBQ1RFUl9DT01NQU5ELCB0cnVlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNFc2NhcGUoa2V5KSkge1xuICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIEtFWV9FU0NBUEVfQ09NTUFORCwgZXZlbnQpO1xuICB9IGVsc2UgaWYgKGlzRGVsZXRlRm9yd2FyZChrZXksIGN0cmxLZXksIHNoaWZ0S2V5LCBhbHRLZXksIG1ldGFLZXkpKSB7XG4gICAgaWYgKGlzRGVsZXRlKGtleSkpIHtcbiAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIEtFWV9ERUxFVEVfQ09NTUFORCwgZXZlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgREVMRVRFX0NIQVJBQ1RFUl9DT01NQU5ELCBmYWxzZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRGVsZXRlV29yZEJhY2t3YXJkKGtleSwgYWx0S2V5LCBjdHJsS2V5KSkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgREVMRVRFX1dPUkRfQ09NTUFORCwgdHJ1ZSk7XG4gIH0gZWxzZSBpZiAoaXNEZWxldGVXb3JkRm9yd2FyZChrZXksIGFsdEtleSwgY3RybEtleSkpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIERFTEVURV9XT1JEX0NPTU1BTkQsIGZhbHNlKTtcbiAgfSBlbHNlIGlmIChpc0RlbGV0ZUxpbmVCYWNrd2FyZChrZXksIG1ldGFLZXkpKSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBERUxFVEVfTElORV9DT01NQU5ELCB0cnVlKTtcbiAgfSBlbHNlIGlmIChpc0RlbGV0ZUxpbmVGb3J3YXJkKGtleSwgbWV0YUtleSkpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIERFTEVURV9MSU5FX0NPTU1BTkQsIGZhbHNlKTtcbiAgfSBlbHNlIGlmIChpc0JvbGQoa2V5LCBhbHRLZXksIG1ldGFLZXksIGN0cmxLZXkpKSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBGT1JNQVRfVEVYVF9DT01NQU5ELCAnYm9sZCcpO1xuICB9IGVsc2UgaWYgKGlzVW5kZXJsaW5lKGtleSwgYWx0S2V5LCBtZXRhS2V5LCBjdHJsS2V5KSkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgRk9STUFUX1RFWFRfQ09NTUFORCwgJ3VuZGVybGluZScpO1xuICB9IGVsc2UgaWYgKGlzSXRhbGljKGtleSwgYWx0S2V5LCBtZXRhS2V5LCBjdHJsS2V5KSkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgRk9STUFUX1RFWFRfQ09NTUFORCwgJ2l0YWxpYycpO1xuICB9IGVsc2UgaWYgKGlzVGFiKGtleSwgYWx0S2V5LCBjdHJsS2V5LCBtZXRhS2V5KSkge1xuICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIEtFWV9UQUJfQ09NTUFORCwgZXZlbnQpO1xuICB9IGVsc2UgaWYgKGlzVW5kbyhrZXksIHNoaWZ0S2V5LCBtZXRhS2V5LCBjdHJsS2V5KSkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgVU5ET19DT01NQU5ELCB1bmRlZmluZWQpO1xuICB9IGVsc2UgaWYgKGlzUmVkbyhrZXksIHNoaWZ0S2V5LCBtZXRhS2V5LCBjdHJsS2V5KSkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgUkVET19DT01NQU5ELCB1bmRlZmluZWQpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHByZXZTZWxlY3Rpb24gPSBlZGl0b3IuX2VkaXRvclN0YXRlLl9zZWxlY3Rpb247XG4gICAgaWYgKHByZXZTZWxlY3Rpb24gIT09IG51bGwgJiYgISRpc1JhbmdlU2VsZWN0aW9uKHByZXZTZWxlY3Rpb24pKSB7XG4gICAgICAvLyBPbmx5IFJhbmdlU2VsZWN0aW9uIGNhbiB1c2UgdGhlIG5hdGl2ZSBjdXQvY29weS9zZWxlY3QgYWxsXG4gICAgICBpZiAoaXNDb3B5KGtleSwgc2hpZnRLZXksIG1ldGFLZXksIGN0cmxLZXkpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIENPUFlfQ09NTUFORCwgZXZlbnQpO1xuICAgICAgfSBlbHNlIGlmIChpc0N1dChrZXksIHNoaWZ0S2V5LCBtZXRhS2V5LCBjdHJsS2V5KSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBDVVRfQ09NTUFORCwgZXZlbnQpO1xuICAgICAgfSBlbHNlIGlmIChpc1NlbGVjdEFsbChrZXksIG1ldGFLZXksIGN0cmxLZXkpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIFNFTEVDVF9BTExfQ09NTUFORCwgZXZlbnQpO1xuICAgICAgfVxuICAgICAgLy8gRkYgZG9lcyBpdCB3ZWxsIChubyBuZWVkIHRvIG92ZXJyaWRlIGJlaGF2aW9yKVxuICAgIH0gZWxzZSBpZiAoIUlTX0ZJUkVGT1ggJiYgaXNTZWxlY3RBbGwoa2V5LCBtZXRhS2V5LCBjdHJsS2V5KSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIFNFTEVDVF9BTExfQ09NTUFORCwgZXZlbnQpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNNb2RpZmllcihjdHJsS2V5LCBzaGlmdEtleSwgYWx0S2V5LCBtZXRhS2V5KSkge1xuICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIEtFWV9NT0RJRklFUl9DT01NQU5ELCBldmVudCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFJvb3RFbGVtZW50UmVtb3ZlSGFuZGxlcyhyb290RWxlbWVudCkge1xuICAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbnRlcm5hbCBmaWVsZFxuICBsZXQgZXZlbnRIYW5kbGVzID0gcm9vdEVsZW1lbnQuX19sZXhpY2FsRXZlbnRIYW5kbGVzO1xuICBpZiAoZXZlbnRIYW5kbGVzID09PSB1bmRlZmluZWQpIHtcbiAgICBldmVudEhhbmRsZXMgPSBbXTtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbnRlcm5hbCBmaWVsZFxuICAgIHJvb3RFbGVtZW50Ll9fbGV4aWNhbEV2ZW50SGFuZGxlcyA9IGV2ZW50SGFuZGxlcztcbiAgfVxuICByZXR1cm4gZXZlbnRIYW5kbGVzO1xufVxuXG4vLyBNYXBwaW5nIHJvb3QgZWRpdG9ycyB0byB0aGVpciBhY3RpdmUgbmVzdGVkIGVkaXRvcnMsIGNvbnRhaW5zIG5lc3RlZCBlZGl0b3JzXG4vLyBtYXBwaW5nIG9ubHksIHNvIGlmIHJvb3QgZWRpdG9yIGlzIHNlbGVjdGVkIG1hcCB3aWxsIGhhdmUgbm8gcmVmZXJlbmNlIHRvIGZyZWUgdXAgbWVtb3J5XG5jb25zdCBhY3RpdmVOZXN0ZWRFZGl0b3JzTWFwID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gb25Eb2N1bWVudFNlbGVjdGlvbkNoYW5nZShldmVudCkge1xuICBjb25zdCBkb21TZWxlY3Rpb24gPSBnZXRET01TZWxlY3Rpb25Gcm9tVGFyZ2V0KGV2ZW50LnRhcmdldCk7XG4gIGlmIChkb21TZWxlY3Rpb24gPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgbmV4dEFjdGl2ZUVkaXRvciA9IGdldE5lYXJlc3RFZGl0b3JGcm9tRE9NTm9kZShkb21TZWxlY3Rpb24uYW5jaG9yTm9kZSk7XG4gIGlmIChuZXh0QWN0aXZlRWRpdG9yID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChpc1NlbGVjdGlvbkNoYW5nZUZyb21Nb3VzZURvd24pIHtcbiAgICBpc1NlbGVjdGlvbkNoYW5nZUZyb21Nb3VzZURvd24gPSBmYWxzZTtcbiAgICB1cGRhdGVFZGl0b3IobmV4dEFjdGl2ZUVkaXRvciwgKCkgPT4ge1xuICAgICAgY29uc3QgbGFzdFNlbGVjdGlvbiA9ICRnZXRQcmV2aW91c1NlbGVjdGlvbigpO1xuICAgICAgY29uc3QgZG9tQW5jaG9yTm9kZSA9IGRvbVNlbGVjdGlvbi5hbmNob3JOb2RlO1xuICAgICAgaWYgKGlzSFRNTEVsZW1lbnQoZG9tQW5jaG9yTm9kZSkgfHwgaXNET01UZXh0Tm9kZShkb21BbmNob3JOb2RlKSkge1xuICAgICAgICAvLyBJZiB0aGUgdXNlciBpcyBhdHRlbXB0aW5nIHRvIGNsaWNrIHNlbGVjdGlvbiBiYWNrIG9udG8gdGV4dCwgdGhlblxuICAgICAgICAvLyB3ZSBzaG91bGQgYXR0ZW1wdCBjcmVhdGUgYSByYW5nZSBzZWxlY3Rpb24uXG4gICAgICAgIC8vIFdoZW4gd2UgY2xpY2sgb24gYW4gZW1wdHkgcGFyYWdyYXBoIG5vZGUgb3IgdGhlIGVuZCBvZiBhIHBhcmFncmFwaCB0aGF0IGVuZHNcbiAgICAgICAgLy8gd2l0aCBhbiBpbWFnZS9wb2xsLCB0aGUgbm9kZVR5cGUgd2lsbCBiZSBFTEVNRU5UX05PREVcbiAgICAgICAgY29uc3QgbmV3U2VsZWN0aW9uID0gJGludGVybmFsQ3JlYXRlUmFuZ2VTZWxlY3Rpb24obGFzdFNlbGVjdGlvbiwgZG9tU2VsZWN0aW9uLCBuZXh0QWN0aXZlRWRpdG9yLCBldmVudCk7XG4gICAgICAgICRzZXRTZWxlY3Rpb24obmV3U2VsZWN0aW9uKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIFdoZW4gZWRpdG9yIHJlY2VpdmVzIHNlbGVjdGlvbiBjaGFuZ2UgZXZlbnQsIHdlJ3JlIGNoZWNraW5nIGlmXG4gIC8vIGl0IGhhcyBhbnkgc2libGluZyBlZGl0b3JzICh3aXRoaW4gc2FtZSBwYXJlbnQgZWRpdG9yKSB0aGF0IHdlcmUgYWN0aXZlXG4gIC8vIGJlZm9yZSwgYW5kIHRyaWdnZXIgc2VsZWN0aW9uIGNoYW5nZSBvbiBpdCB0byBudWxsaWZ5IHNlbGVjdGlvbi5cbiAgY29uc3QgZWRpdG9ycyA9IGdldEVkaXRvcnNUb1Byb3BhZ2F0ZShuZXh0QWN0aXZlRWRpdG9yKTtcbiAgY29uc3Qgcm9vdEVkaXRvciA9IGVkaXRvcnNbZWRpdG9ycy5sZW5ndGggLSAxXTtcbiAgY29uc3Qgcm9vdEVkaXRvcktleSA9IHJvb3RFZGl0b3IuX2tleTtcbiAgY29uc3QgYWN0aXZlTmVzdGVkRWRpdG9yID0gYWN0aXZlTmVzdGVkRWRpdG9yc01hcC5nZXQocm9vdEVkaXRvcktleSk7XG4gIGNvbnN0IHByZXZBY3RpdmVFZGl0b3IgPSBhY3RpdmVOZXN0ZWRFZGl0b3IgfHwgcm9vdEVkaXRvcjtcbiAgaWYgKHByZXZBY3RpdmVFZGl0b3IgIT09IG5leHRBY3RpdmVFZGl0b3IpIHtcbiAgICBvblNlbGVjdGlvbkNoYW5nZShkb21TZWxlY3Rpb24sIHByZXZBY3RpdmVFZGl0b3IsIGZhbHNlKTtcbiAgfVxuICBvblNlbGVjdGlvbkNoYW5nZShkb21TZWxlY3Rpb24sIG5leHRBY3RpdmVFZGl0b3IsIHRydWUpO1xuXG4gIC8vIElmIG5ld2x5IHNlbGVjdGVkIGVkaXRvciBpcyBuZXN0ZWQsIHRoZW4gYWRkIGl0IHRvIHRoZSBtYXAsIGNsZWFuIG1hcCBvdGhlcndpc2VcbiAgaWYgKG5leHRBY3RpdmVFZGl0b3IgIT09IHJvb3RFZGl0b3IpIHtcbiAgICBhY3RpdmVOZXN0ZWRFZGl0b3JzTWFwLnNldChyb290RWRpdG9yS2V5LCBuZXh0QWN0aXZlRWRpdG9yKTtcbiAgfSBlbHNlIGlmIChhY3RpdmVOZXN0ZWRFZGl0b3IpIHtcbiAgICBhY3RpdmVOZXN0ZWRFZGl0b3JzTWFwLmRlbGV0ZShyb290RWRpdG9yS2V5KTtcbiAgfVxufVxuZnVuY3Rpb24gc3RvcExleGljYWxQcm9wYWdhdGlvbihldmVudCkge1xuICAvLyBXZSBhdHRhY2ggYSBzcGVjaWFsIHByb3BlcnR5IHRvIGVuc3VyZSB0aGUgc2FtZSBldmVudCBkb2Vzbid0IHJlLWZpcmVcbiAgLy8gZm9yIHBhcmVudCBlZGl0b3JzLlxuICAvLyBAdHMtaWdub3JlXG4gIGV2ZW50Ll9sZXhpY2FsSGFuZGxlZCA9IHRydWU7XG59XG5mdW5jdGlvbiBoYXNTdG9wcGVkTGV4aWNhbFByb3BhZ2F0aW9uKGV2ZW50KSB7XG4gIC8vIEB0cy1pZ25vcmVcbiAgY29uc3Qgc3RvcHBlZCA9IGV2ZW50Ll9sZXhpY2FsSGFuZGxlZCA9PT0gdHJ1ZTtcbiAgcmV0dXJuIHN0b3BwZWQ7XG59XG5mdW5jdGlvbiBhZGRSb290RWxlbWVudEV2ZW50cyhyb290RWxlbWVudCwgZWRpdG9yKSB7XG4gIC8vIFdlIG9ubHkgd2FudCB0byBoYXZlIGEgc2luZ2xlIGdsb2JhbCBzZWxlY3Rpb25jaGFuZ2UgZXZlbnQgaGFuZGxlciwgc2hhcmVkXG4gIC8vIGJldHdlZW4gYWxsIGVkaXRvciBpbnN0YW5jZXMuXG4gIGNvbnN0IGRvYyA9IHJvb3RFbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG4gIGNvbnN0IGRvY3VtZW50Um9vdEVsZW1lbnRzQ291bnQgPSByb290RWxlbWVudHNSZWdpc3RlcmVkLmdldChkb2MpO1xuICBpZiAoZG9jdW1lbnRSb290RWxlbWVudHNDb3VudCA9PT0gdW5kZWZpbmVkIHx8IGRvY3VtZW50Um9vdEVsZW1lbnRzQ291bnQgPCAxKSB7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdGlvbmNoYW5nZScsIG9uRG9jdW1lbnRTZWxlY3Rpb25DaGFuZ2UpO1xuICB9XG4gIHJvb3RFbGVtZW50c1JlZ2lzdGVyZWQuc2V0KGRvYywgKGRvY3VtZW50Um9vdEVsZW1lbnRzQ291bnQgfHwgMCkgKyAxKTtcblxuICAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbnRlcm5hbCBmaWVsZFxuICByb290RWxlbWVudC5fX2xleGljYWxFZGl0b3IgPSBlZGl0b3I7XG4gIGNvbnN0IHJlbW92ZUhhbmRsZXMgPSBnZXRSb290RWxlbWVudFJlbW92ZUhhbmRsZXMocm9vdEVsZW1lbnQpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJvb3RFbGVtZW50RXZlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgW2V2ZW50TmFtZSwgb25FdmVudF0gPSByb290RWxlbWVudEV2ZW50c1tpXTtcbiAgICBjb25zdCBldmVudEhhbmRsZXIgPSB0eXBlb2Ygb25FdmVudCA9PT0gJ2Z1bmN0aW9uJyA/IGV2ZW50ID0+IHtcbiAgICAgIGlmIChoYXNTdG9wcGVkTGV4aWNhbFByb3BhZ2F0aW9uKGV2ZW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzdG9wTGV4aWNhbFByb3BhZ2F0aW9uKGV2ZW50KTtcbiAgICAgIGlmIChlZGl0b3IuaXNFZGl0YWJsZSgpIHx8IGV2ZW50TmFtZSA9PT0gJ2NsaWNrJykge1xuICAgICAgICBvbkV2ZW50KGV2ZW50LCBlZGl0b3IpO1xuICAgICAgfVxuICAgIH0gOiBldmVudCA9PiB7XG4gICAgICBpZiAoaGFzU3RvcHBlZExleGljYWxQcm9wYWdhdGlvbihldmVudCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3RvcExleGljYWxQcm9wYWdhdGlvbihldmVudCk7XG4gICAgICBjb25zdCBpc0VkaXRhYmxlID0gZWRpdG9yLmlzRWRpdGFibGUoKTtcbiAgICAgIHN3aXRjaCAoZXZlbnROYW1lKSB7XG4gICAgICAgIGNhc2UgJ2N1dCc6XG4gICAgICAgICAgcmV0dXJuIGlzRWRpdGFibGUgJiYgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgQ1VUX0NPTU1BTkQsIGV2ZW50KTtcbiAgICAgICAgY2FzZSAnY29weSc6XG4gICAgICAgICAgcmV0dXJuIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIENPUFlfQ09NTUFORCwgZXZlbnQpO1xuICAgICAgICBjYXNlICdwYXN0ZSc6XG4gICAgICAgICAgcmV0dXJuIGlzRWRpdGFibGUgJiYgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgUEFTVEVfQ09NTUFORCwgZXZlbnQpO1xuICAgICAgICBjYXNlICdkcmFnc3RhcnQnOlxuICAgICAgICAgIHJldHVybiBpc0VkaXRhYmxlICYmIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIERSQUdTVEFSVF9DT01NQU5ELCBldmVudCk7XG4gICAgICAgIGNhc2UgJ2RyYWdvdmVyJzpcbiAgICAgICAgICByZXR1cm4gaXNFZGl0YWJsZSAmJiBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBEUkFHT1ZFUl9DT01NQU5ELCBldmVudCk7XG4gICAgICAgIGNhc2UgJ2RyYWdlbmQnOlxuICAgICAgICAgIHJldHVybiBpc0VkaXRhYmxlICYmIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIERSQUdFTkRfQ09NTUFORCwgZXZlbnQpO1xuICAgICAgICBjYXNlICdmb2N1cyc6XG4gICAgICAgICAgcmV0dXJuIGlzRWRpdGFibGUgJiYgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgRk9DVVNfQ09NTUFORCwgZXZlbnQpO1xuICAgICAgICBjYXNlICdibHVyJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gaXNFZGl0YWJsZSAmJiBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBCTFVSX0NPTU1BTkQsIGV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2Ryb3AnOlxuICAgICAgICAgIHJldHVybiBpc0VkaXRhYmxlICYmIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIERST1BfQ09NTUFORCwgZXZlbnQpO1xuICAgICAgfVxuICAgIH07XG4gICAgcm9vdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGV2ZW50SGFuZGxlcik7XG4gICAgcmVtb3ZlSGFuZGxlcy5wdXNoKCgpID0+IHtcbiAgICAgIHJvb3RFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBldmVudEhhbmRsZXIpO1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiByZW1vdmVSb290RWxlbWVudEV2ZW50cyhyb290RWxlbWVudCkge1xuICBjb25zdCBkb2MgPSByb290RWxlbWVudC5vd25lckRvY3VtZW50O1xuICBjb25zdCBkb2N1bWVudFJvb3RFbGVtZW50c0NvdW50ID0gcm9vdEVsZW1lbnRzUmVnaXN0ZXJlZC5nZXQoZG9jKTtcbiAgaWYgKCEoZG9jdW1lbnRSb290RWxlbWVudHNDb3VudCAhPT0gdW5kZWZpbmVkKSkge1xuICAgIHRocm93IEVycm9yKGBSb290IGVsZW1lbnQgbm90IHJlZ2lzdGVyZWRgKTtcbiAgfSAvLyBXZSBvbmx5IHdhbnQgdG8gaGF2ZSBhIHNpbmdsZSBnbG9iYWwgc2VsZWN0aW9uY2hhbmdlIGV2ZW50IGhhbmRsZXIsIHNoYXJlZFxuICAvLyBiZXR3ZWVuIGFsbCBlZGl0b3IgaW5zdGFuY2VzLlxuICBjb25zdCBuZXdDb3VudCA9IGRvY3VtZW50Um9vdEVsZW1lbnRzQ291bnQgLSAxO1xuICBpZiAoIShuZXdDb3VudCA+PSAwKSkge1xuICAgIHRocm93IEVycm9yKGBSb290IGVsZW1lbnQgY291bnQgbGVzcyB0aGFuIDBgKTtcbiAgfVxuICByb290RWxlbWVudHNSZWdpc3RlcmVkLnNldChkb2MsIG5ld0NvdW50KTtcbiAgaWYgKG5ld0NvdW50ID09PSAwKSB7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlbGVjdGlvbmNoYW5nZScsIG9uRG9jdW1lbnRTZWxlY3Rpb25DaGFuZ2UpO1xuICB9XG4gIGNvbnN0IGVkaXRvciA9IGdldEVkaXRvclByb3BlcnR5RnJvbURPTU5vZGUocm9vdEVsZW1lbnQpO1xuICBpZiAoaXNMZXhpY2FsRWRpdG9yKGVkaXRvcikpIHtcbiAgICBjbGVhbkFjdGl2ZU5lc3RlZEVkaXRvcnNNYXAoZWRpdG9yKTtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbnRlcm5hbCBmaWVsZFxuICAgIHJvb3RFbGVtZW50Ll9fbGV4aWNhbEVkaXRvciA9IG51bGw7XG4gIH0gZWxzZSBpZiAoZWRpdG9yKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYEF0dGVtcHRlZCB0byByZW1vdmUgZXZlbnQgaGFuZGxlcnMgZnJvbSBhIG5vZGUgdGhhdCBkb2VzIG5vdCBiZWxvbmcgdG8gdGhpcyBidWlsZCBvZiBMZXhpY2FsYCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHJlbW92ZUhhbmRsZXMgPSBnZXRSb290RWxlbWVudFJlbW92ZUhhbmRsZXMocm9vdEVsZW1lbnQpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbW92ZUhhbmRsZXMubGVuZ3RoOyBpKyspIHtcbiAgICByZW1vdmVIYW5kbGVzW2ldKCk7XG4gIH1cblxuICAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbnRlcm5hbCBmaWVsZFxuICByb290RWxlbWVudC5fX2xleGljYWxFdmVudEhhbmRsZXMgPSBbXTtcbn1cbmZ1bmN0aW9uIGNsZWFuQWN0aXZlTmVzdGVkRWRpdG9yc01hcChlZGl0b3IpIHtcbiAgaWYgKGVkaXRvci5fcGFyZW50RWRpdG9yICE9PSBudWxsKSB7XG4gICAgLy8gRm9yIG5lc3RlZCBlZGl0b3IgY2xlYW51cCBtYXAgaWYgdGhpcyBlZGl0b3Igd2FzIG1hcmtlZCBhcyBhY3RpdmVcbiAgICBjb25zdCBlZGl0b3JzID0gZ2V0RWRpdG9yc1RvUHJvcGFnYXRlKGVkaXRvcik7XG4gICAgY29uc3Qgcm9vdEVkaXRvciA9IGVkaXRvcnNbZWRpdG9ycy5sZW5ndGggLSAxXTtcbiAgICBjb25zdCByb290RWRpdG9yS2V5ID0gcm9vdEVkaXRvci5fa2V5O1xuICAgIGlmIChhY3RpdmVOZXN0ZWRFZGl0b3JzTWFwLmdldChyb290RWRpdG9yS2V5KSA9PT0gZWRpdG9yKSB7XG4gICAgICBhY3RpdmVOZXN0ZWRFZGl0b3JzTWFwLmRlbGV0ZShyb290RWRpdG9yS2V5KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gRm9yIHRvcC1sZXZlbCBlZGl0b3JzIGNsZWFudXAgbWFwXG4gICAgYWN0aXZlTmVzdGVkRWRpdG9yc01hcC5kZWxldGUoZWRpdG9yLl9rZXkpO1xuICB9XG59XG5mdW5jdGlvbiBtYXJrU2VsZWN0aW9uQ2hhbmdlRnJvbURPTVVwZGF0ZSgpIHtcbiAgaXNTZWxlY3Rpb25DaGFuZ2VGcm9tRE9NVXBkYXRlID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIG1hcmtDb2xsYXBzZWRTZWxlY3Rpb25Gb3JtYXQoZm9ybWF0LCBzdHlsZSwgb2Zmc2V0LCBrZXksIHRpbWVTdGFtcCkge1xuICBjb2xsYXBzZWRTZWxlY3Rpb25Gb3JtYXQgPSBbZm9ybWF0LCBzdHlsZSwgb2Zmc2V0LCBrZXksIHRpbWVTdGFtcF07XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuXG4vKipcbiAqIFRoZSBiYXNlIHR5cGUgZm9yIGFsbCBzZXJpYWxpemVkIG5vZGVzXG4gKi9cblxuLyoqXG4gKiBPbWl0IHRoZSBjaGlsZHJlbiwgdHlwZSwgYW5kIHZlcnNpb24gcHJvcGVydGllcyBmcm9tIHRoZSBnaXZlbiBTZXJpYWxpemVkTGV4aWNhbE5vZGUgZGVmaW5pdGlvbi5cbiAqL1xuXG4vKiogQGludGVybmFsICovXG5cbmZ1bmN0aW9uICRyZW1vdmVOb2RlKG5vZGVUb1JlbW92ZSwgcmVzdG9yZVNlbGVjdGlvbiwgcHJlc2VydmVFbXB0eVBhcmVudCkge1xuICBlcnJvck9uUmVhZE9ubHkoKTtcbiAgY29uc3Qga2V5ID0gbm9kZVRvUmVtb3ZlLl9fa2V5O1xuICBjb25zdCBwYXJlbnQgPSBub2RlVG9SZW1vdmUuZ2V0UGFyZW50KCk7XG4gIGlmIChwYXJlbnQgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgc2VsZWN0aW9uID0gJG1heWJlTW92ZUNoaWxkcmVuU2VsZWN0aW9uVG9QYXJlbnQobm9kZVRvUmVtb3ZlKTtcbiAgbGV0IHNlbGVjdGlvbk1vdmVkID0gZmFsc2U7XG4gIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pICYmIHJlc3RvcmVTZWxlY3Rpb24pIHtcbiAgICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICAgIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICAgIGlmIChhbmNob3Iua2V5ID09PSBrZXkpIHtcbiAgICAgIG1vdmVTZWxlY3Rpb25Qb2ludFRvU2libGluZyhhbmNob3IsIG5vZGVUb1JlbW92ZSwgcGFyZW50LCBub2RlVG9SZW1vdmUuZ2V0UHJldmlvdXNTaWJsaW5nKCksIG5vZGVUb1JlbW92ZS5nZXROZXh0U2libGluZygpKTtcbiAgICAgIHNlbGVjdGlvbk1vdmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGZvY3VzLmtleSA9PT0ga2V5KSB7XG4gICAgICBtb3ZlU2VsZWN0aW9uUG9pbnRUb1NpYmxpbmcoZm9jdXMsIG5vZGVUb1JlbW92ZSwgcGFyZW50LCBub2RlVG9SZW1vdmUuZ2V0UHJldmlvdXNTaWJsaW5nKCksIG5vZGVUb1JlbW92ZS5nZXROZXh0U2libGluZygpKTtcbiAgICAgIHNlbGVjdGlvbk1vdmVkID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoJGlzTm9kZVNlbGVjdGlvbihzZWxlY3Rpb24pICYmIHJlc3RvcmVTZWxlY3Rpb24gJiYgbm9kZVRvUmVtb3ZlLmlzU2VsZWN0ZWQoKSkge1xuICAgIG5vZGVUb1JlbW92ZS5zZWxlY3RQcmV2aW91cygpO1xuICB9XG4gIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pICYmIHJlc3RvcmVTZWxlY3Rpb24gJiYgIXNlbGVjdGlvbk1vdmVkKSB7XG4gICAgLy8gRG9pbmcgdGhpcyBpcyBPKG4pIHNvIGxldHMgYXZvaWQgaXQgdW5sZXNzIHdlIG5lZWQgdG8gZG8gaXRcbiAgICBjb25zdCBpbmRleCA9IG5vZGVUb1JlbW92ZS5nZXRJbmRleFdpdGhpblBhcmVudCgpO1xuICAgIHJlbW92ZUZyb21QYXJlbnQobm9kZVRvUmVtb3ZlKTtcbiAgICAkdXBkYXRlRWxlbWVudFNlbGVjdGlvbk9uQ3JlYXRlRGVsZXRlTm9kZShzZWxlY3Rpb24sIHBhcmVudCwgaW5kZXgsIC0xKTtcbiAgfSBlbHNlIHtcbiAgICByZW1vdmVGcm9tUGFyZW50KG5vZGVUb1JlbW92ZSk7XG4gIH1cbiAgaWYgKCFwcmVzZXJ2ZUVtcHR5UGFyZW50ICYmICEkaXNSb290T3JTaGFkb3dSb290KHBhcmVudCkgJiYgIXBhcmVudC5jYW5CZUVtcHR5KCkgJiYgcGFyZW50LmlzRW1wdHkoKSkge1xuICAgICRyZW1vdmVOb2RlKHBhcmVudCwgcmVzdG9yZVNlbGVjdGlvbik7XG4gIH1cbiAgaWYgKHJlc3RvcmVTZWxlY3Rpb24gJiYgJGlzUm9vdE5vZGUocGFyZW50KSAmJiBwYXJlbnQuaXNFbXB0eSgpKSB7XG4gICAgcGFyZW50LnNlbGVjdEVuZCgpO1xuICB9XG59XG5jbGFzcyBMZXhpY2FsTm9kZSB7XG4gIC8vIEFsbG93IHVzIHRvIGxvb2sgdXAgdGhlIHR5cGUgaW5jbHVkaW5nIHN0YXRpYyBwcm9wc1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG4gIC8vQHRzLWlnbm9yZSBXZSBzZXQgdGhlIGtleSBpbiB0aGUgY29uc3RydWN0b3IuXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLy8gRmxvdyBkb2Vzbid0IHN1cHBvcnQgYWJzdHJhY3QgY2xhc3NlcyB1bmZvcnR1bmF0ZWx5LCBzbyB3ZSBjYW4ndCBfZm9yY2VfXG4gIC8vIHN1YmNsYXNzZXMgb2YgTm9kZSB0byBpbXBsZW1lbnQgc3RhdGljcy4gQWxsIHN1YmNsYXNzZXMgb2YgTm9kZSBzaG91bGQgaGF2ZVxuICAvLyBhIHN0YXRpYyBnZXRUeXBlIGFuZCBjbG9uZSBtZXRob2QgdGhvdWdoLiBXZSBkZWZpbmUgZ2V0VHlwZSBhbmQgY2xvbmUgaGVyZSBzbyB3ZSBjYW4gY2FsbCBpdFxuICAvLyBvbiBhbnkgIE5vZGUsIGFuZCB3ZSB0aHJvdyB0aGlzIGVycm9yIGJ5IGRlZmF1bHQgc2luY2UgdGhlIHN1YmNsYXNzIHNob3VsZCBwcm92aWRlXG4gIC8vIHRoZWlyIG93biBpbXBsZW1lbnRhdGlvbi5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHN0cmluZyB0eXBlIG9mIHRoaXMgbm9kZS4gRXZlcnkgbm9kZSBtdXN0XG4gICAqIGltcGxlbWVudCB0aGlzIGFuZCBpdCBNVVNUIEJFIFVOSVFVRSBhbW9uZ3N0IG5vZGVzIHJlZ2lzdGVyZWRcbiAgICogb24gdGhlIGVkaXRvci5cbiAgICpcbiAgICovXG4gIHN0YXRpYyBnZXRUeXBlKCkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGBMZXhpY2FsTm9kZTogTm9kZSAke3RoaXMubmFtZX0gZG9lcyBub3QgaW1wbGVtZW50IC5nZXRUeXBlKCkuYCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENsb25lcyB0aGlzIG5vZGUsIGNyZWF0aW5nIGEgbmV3IG5vZGUgd2l0aCBhIGRpZmZlcmVudCBrZXlcbiAgICogYW5kIGFkZGluZyBpdCB0byB0aGUgRWRpdG9yU3RhdGUgKGJ1dCBub3QgYXR0YWNoaW5nIGl0IGFueXdoZXJlISkuIEFsbCBub2RlcyBtdXN0XG4gICAqIGltcGxlbWVudCB0aGlzIG1ldGhvZC5cbiAgICpcbiAgICovXG4gIHN0YXRpYyBjbG9uZShfZGF0YSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGBMZXhpY2FsTm9kZTogTm9kZSAke3RoaXMubmFtZX0gZG9lcyBub3QgaW1wbGVtZW50IC5jbG9uZSgpLmApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIGFueSBzdGF0ZSB1cGRhdGVzIG9uIHRoZSBjbG9uZSBvZiBwcmV2Tm9kZSB0aGF0IGFyZSBub3QgYWxyZWFkeVxuICAgKiBoYW5kbGVkIGJ5IHRoZSBjb25zdHJ1Y3RvciBjYWxsIGluIHRoZSBzdGF0aWMgY2xvbmUgbWV0aG9kLiBJZiB5b3UgaGF2ZVxuICAgKiBzdGF0ZSB0byB1cGRhdGUgaW4geW91ciBjbG9uZSB0aGF0IGlzIG5vdCBoYW5kbGVkIGRpcmVjdGx5IGJ5IHRoZVxuICAgKiBjb25zdHJ1Y3RvciwgaXQgaXMgYWR2aXNhYmxlIHRvIG92ZXJyaWRlIHRoaXMgbWV0aG9kIGJ1dCBpdCBpcyByZXF1aXJlZFxuICAgKiB0byBpbmNsdWRlIGEgY2FsbCB0byBgc3VwZXIuYWZ0ZXJDbG9uZUZyb20ocHJldk5vZGUpYCBpbiB5b3VyXG4gICAqIGltcGxlbWVudGF0aW9uLiBUaGlzIGlzIG9ubHkgaW50ZW5kZWQgdG8gYmUgY2FsbGVkIGJ5XG4gICAqIHtAbGluayAkY2xvbmVXaXRoUHJvcGVydGllc30gZnVuY3Rpb24gb3IgdmlhIGEgc3VwZXIgY2FsbC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogY2xhc3MgQ2xhc3Nlc1RleHROb2RlIGV4dGVuZHMgVGV4dE5vZGUge1xuICAgKiAgIC8vIE5vdCBzaG93bjogc3RhdGljIGdldFR5cGUsIHN0YXRpYyBpbXBvcnRKU09OLCBleHBvcnRKU09OLCBjcmVhdGVET00sIHVwZGF0ZURPTVxuICAgKiAgIF9fY2xhc3NlcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgKiAgIHN0YXRpYyBjbG9uZShub2RlOiBDbGFzc2VzVGV4dE5vZGUpOiBDbGFzc2VzVGV4dE5vZGUge1xuICAgKiAgICAgLy8gVGhlIGluaGVyaXRlZCBUZXh0Tm9kZSBjb25zdHJ1Y3RvciBpcyB1c2VkIGhlcmUsIHNvXG4gICAqICAgICAvLyBjbGFzc2VzIGlzIG5vdCBzZXQgYnkgdGhpcyBtZXRob2QuXG4gICAqICAgICByZXR1cm4gbmV3IENsYXNzZXNUZXh0Tm9kZShub2RlLl9fdGV4dCwgbm9kZS5fX2tleSk7XG4gICAqICAgfVxuICAgKiAgIGFmdGVyQ2xvbmVGcm9tKG5vZGU6IHRoaXMpOiB2b2lkIHtcbiAgICogICAgIC8vIFRoaXMgY2FsbHMgVGV4dE5vZGUuYWZ0ZXJDbG9uZUZyb20gYW5kIExleGljYWxOb2RlLmFmdGVyQ2xvbmVGcm9tXG4gICAqICAgICAvLyBmb3IgbmVjZXNzYXJ5IHN0YXRlIHVwZGF0ZXNcbiAgICogICAgIHN1cGVyLmFmdGVyQ2xvbmVGcm9tKG5vZGUpO1xuICAgKiAgICAgdGhpcy5fX2FkZENsYXNzZXMobm9kZS5fX2NsYXNzZXMpO1xuICAgKiAgIH1cbiAgICogICAvLyBUaGlzIG1ldGhvZCBpcyBhIHByaXZhdGUgaW1wbGVtZW50YXRpb24gZGV0YWlsLCBpdCBpcyBub3RcbiAgICogICAvLyBzdWl0YWJsZSBmb3IgdGhlIHB1YmxpYyBBUEkgYmVjYXVzZSBpdCBkb2VzIG5vdCBjYWxsIGdldFdyaXRhYmxlXG4gICAqICAgX19hZGRDbGFzc2VzKGNsYXNzTmFtZXM6IEl0ZXJhYmxlPHN0cmluZz4pOiB0aGlzIHtcbiAgICogICAgIGZvciAoY29uc3QgY2xhc3NOYW1lIG9mIGNsYXNzTmFtZXMpIHtcbiAgICogICAgICAgdGhpcy5fX2NsYXNzZXMuYWRkKGNsYXNzTmFtZSk7XG4gICAqICAgICB9XG4gICAqICAgICByZXR1cm4gdGhpcztcbiAgICogICB9XG4gICAqICAgYWRkQ2xhc3MoLi4uY2xhc3NOYW1lczogc3RyaW5nW10pOiB0aGlzIHtcbiAgICogICAgIHJldHVybiB0aGlzLmdldFdyaXRhYmxlKCkuX19hZGRDbGFzc2VzKGNsYXNzTmFtZXMpO1xuICAgKiAgIH1cbiAgICogICByZW1vdmVDbGFzcyguLi5jbGFzc05hbWVzOiBzdHJpbmdbXSk6IHRoaXMge1xuICAgKiAgICAgY29uc3Qgbm9kZSA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICogICAgIGZvciAoY29uc3QgY2xhc3NOYW1lIG9mIGNsYXNzTmFtZXMpIHtcbiAgICogICAgICAgdGhpcy5fX2NsYXNzZXMuZGVsZXRlKGNsYXNzTmFtZSk7XG4gICAqICAgICB9XG4gICAqICAgICByZXR1cm4gdGhpcztcbiAgICogICB9XG4gICAqICAgZ2V0Q2xhc3NlcygpOiBTZXQ8c3RyaW5nPiB7XG4gICAqICAgICByZXR1cm4gdGhpcy5nZXRMYXRlc3QoKS5fX2NsYXNzZXM7XG4gICAqICAgfVxuICAgKiB9XG4gICAqIGBgYFxuICAgKlxuICAgKi9cbiAgYWZ0ZXJDbG9uZUZyb20ocHJldk5vZGUpIHtcbiAgICB0aGlzLl9fcGFyZW50ID0gcHJldk5vZGUuX19wYXJlbnQ7XG4gICAgdGhpcy5fX25leHQgPSBwcmV2Tm9kZS5fX25leHQ7XG4gICAgdGhpcy5fX3ByZXYgPSBwcmV2Tm9kZS5fX3ByZXY7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuXG4gIGNvbnN0cnVjdG9yKGtleSkge1xuICAgIHRoaXMuX190eXBlID0gdGhpcy5jb25zdHJ1Y3Rvci5nZXRUeXBlKCk7XG4gICAgdGhpcy5fX3BhcmVudCA9IG51bGw7XG4gICAgdGhpcy5fX3ByZXYgPSBudWxsO1xuICAgIHRoaXMuX19uZXh0ID0gbnVsbDtcbiAgICAkc2V0Tm9kZUtleSh0aGlzLCBrZXkpO1xuICAgIHtcbiAgICAgIGlmICh0aGlzLl9fdHlwZSAhPT0gJ3Jvb3QnKSB7XG4gICAgICAgIGVycm9yT25SZWFkT25seSgpO1xuICAgICAgICBlcnJvck9uVHlwZUtsYXNzTWlzbWF0Y2godGhpcy5fX3R5cGUsIHRoaXMuY29uc3RydWN0b3IpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBHZXR0ZXJzIGFuZCBUcmF2ZXJzZXJzXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHN0cmluZyB0eXBlIG9mIHRoaXMgbm9kZS5cbiAgICovXG4gIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX190eXBlO1xuICB9XG4gIGlzSW5saW5lKCkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGBMZXhpY2FsTm9kZTogTm9kZSAke3RoaXMuY29uc3RydWN0b3IubmFtZX0gZG9lcyBub3QgaW1wbGVtZW50IC5pc0lubGluZSgpLmApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlcmUgaXMgYSBwYXRoIGJldHdlZW4gdGhpcyBub2RlIGFuZCB0aGUgUm9vdE5vZGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICogVGhpcyBpcyBhIHdheSBvZiBkZXRlcm1pbmluZyBpZiB0aGUgbm9kZSBpcyBcImF0dGFjaGVkXCIgRWRpdG9yU3RhdGUuIFVuYXR0YWNoZWQgbm9kZXNcbiAgICogd29uJ3QgYmUgcmVjb25jaWxlZCBhbmQgd2lsbCB1bHRpbWF0ZWx0IGJlIGNsZWFuZWQgdXAgYnkgdGhlIExleGljYWwgR0MuXG4gICAqL1xuICBpc0F0dGFjaGVkKCkge1xuICAgIGxldCBub2RlS2V5ID0gdGhpcy5fX2tleTtcbiAgICB3aGlsZSAobm9kZUtleSAhPT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGVLZXkgPT09ICdyb290Jykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5vZGUgPSAkZ2V0Tm9kZUJ5S2V5KG5vZGVLZXkpO1xuICAgICAgaWYgKG5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBub2RlS2V5ID0gbm9kZS5fX3BhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIG5vZGUgaXMgY29udGFpbmVkIHdpdGhpbiB0aGUgcHJvdmlkZWQgU2VsZWN0aW9uLiwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBSZWxpZXMgb24gdGhlIGFsZ29yaXRobXMgaW1wbGVtZW50ZWQgaW4ge0BsaW5rIEJhc2VTZWxlY3Rpb24uZ2V0Tm9kZXN9IHRvIGRldGVybWluZVxuICAgKiB3aGF0J3MgaW5jbHVkZWQuXG4gICAqXG4gICAqIEBwYXJhbSBzZWxlY3Rpb24gLSBUaGUgc2VsZWN0aW9uIHRoYXQgd2Ugd2FudCB0byBkZXRlcm1pbmUgaWYgdGhlIG5vZGUgaXMgaW4uXG4gICAqL1xuICBpc1NlbGVjdGVkKHNlbGVjdGlvbikge1xuICAgIGNvbnN0IHRhcmdldFNlbGVjdGlvbiA9IHNlbGVjdGlvbiB8fCAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKHRhcmdldFNlbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGlzU2VsZWN0ZWQgPSB0YXJnZXRTZWxlY3Rpb24uZ2V0Tm9kZXMoKS5zb21lKG4gPT4gbi5fX2tleSA9PT0gdGhpcy5fX2tleSk7XG4gICAgaWYgKCRpc1RleHROb2RlKHRoaXMpKSB7XG4gICAgICByZXR1cm4gaXNTZWxlY3RlZDtcbiAgICB9XG4gICAgLy8gRm9yIGlubGluZSBpbWFnZXMgaW5zaWRlIG9mIGVsZW1lbnQgbm9kZXMuXG4gICAgLy8gV2l0aG91dCB0aGlzIGNoYW5nZSB0aGUgaW1hZ2Ugd2lsbCBiZSBzZWxlY3RlZCBpZiB0aGUgY3Vyc29yIGlzIGJlZm9yZSBvciBhZnRlciBpdC5cbiAgICBjb25zdCBpc0VsZW1lbnRSYW5nZVNlbGVjdGlvbiA9ICRpc1JhbmdlU2VsZWN0aW9uKHRhcmdldFNlbGVjdGlvbikgJiYgdGFyZ2V0U2VsZWN0aW9uLmFuY2hvci50eXBlID09PSAnZWxlbWVudCcgJiYgdGFyZ2V0U2VsZWN0aW9uLmZvY3VzLnR5cGUgPT09ICdlbGVtZW50JztcbiAgICBpZiAoaXNFbGVtZW50UmFuZ2VTZWxlY3Rpb24pIHtcbiAgICAgIGlmICh0YXJnZXRTZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCBwYXJlbnROb2RlID0gdGhpcy5nZXRQYXJlbnQoKTtcbiAgICAgIGlmICgkaXNEZWNvcmF0b3JOb2RlKHRoaXMpICYmIHRoaXMuaXNJbmxpbmUoKSAmJiBwYXJlbnROb2RlKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0UG9pbnQgPSB0YXJnZXRTZWxlY3Rpb24uaXNCYWNrd2FyZCgpID8gdGFyZ2V0U2VsZWN0aW9uLmZvY3VzIDogdGFyZ2V0U2VsZWN0aW9uLmFuY2hvcjtcbiAgICAgICAgY29uc3QgZmlyc3RFbGVtZW50ID0gZmlyc3RQb2ludC5nZXROb2RlKCk7XG4gICAgICAgIGlmIChmaXJzdFBvaW50Lm9mZnNldCA9PT0gZmlyc3RFbGVtZW50LmdldENoaWxkcmVuU2l6ZSgpICYmIGZpcnN0RWxlbWVudC5pcyhwYXJlbnROb2RlKSAmJiBmaXJzdEVsZW1lbnQuZ2V0TGFzdENoaWxkT3JUaHJvdygpLmlzKHRoaXMpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpc1NlbGVjdGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhpcyBub2RlcyBrZXkuXG4gICAqL1xuICBnZXRLZXkoKSB7XG4gICAgLy8gS2V5IGlzIHN0YWJsZSBiZXR3ZWVuIGNvcGllc1xuICAgIHJldHVybiB0aGlzLl9fa2V5O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHplcm8tYmFzZWQgaW5kZXggb2YgdGhpcyBub2RlIHdpdGhpbiB0aGUgcGFyZW50LlxuICAgKi9cbiAgZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKSB7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnQoKTtcbiAgICBpZiAocGFyZW50ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGxldCBub2RlID0gcGFyZW50LmdldEZpcnN0Q2hpbGQoKTtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBpZiAodGhpcy5pcyhub2RlKSkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgICBpbmRleCsrO1xuICAgICAgbm9kZSA9IG5vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHBhcmVudCBvZiB0aGlzIG5vZGUsIG9yIG51bGwgaWYgbm9uZSBpcyBmb3VuZC5cbiAgICovXG4gIGdldFBhcmVudCgpIHtcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmdldExhdGVzdCgpLl9fcGFyZW50O1xuICAgIGlmIChwYXJlbnQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gJGdldE5vZGVCeUtleShwYXJlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHBhcmVudCBvZiB0aGlzIG5vZGUsIG9yIHRocm93cyBpZiBub25lIGlzIGZvdW5kLlxuICAgKi9cbiAgZ2V0UGFyZW50T3JUaHJvdygpIHtcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmdldFBhcmVudCgpO1xuICAgIGlmIChwYXJlbnQgPT09IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIG5vZGUgJHt0aGlzLl9fa2V5fSB0byBoYXZlIGEgcGFyZW50LmApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFyZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGhpZ2hlc3QgKGluIHRoZSBFZGl0b3JTdGF0ZSB0cmVlKVxuICAgKiBub24tcm9vdCBhbmNlc3RvciBvZiB0aGlzIG5vZGUsIG9yIG51bGwgaWYgbm9uZSBpcyBmb3VuZC4gU2VlIHtAbGluayBsZXhpY2FsISRpc1Jvb3RPclNoYWRvd1Jvb3R9XG4gICAqIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHdoaWNoIEVsZW1lbnRzIGNvbXByaXNlIFwicm9vdHNcIi5cbiAgICovXG4gIGdldFRvcExldmVsRWxlbWVudCgpIHtcbiAgICBsZXQgbm9kZSA9IHRoaXM7XG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IG5vZGUuZ2V0UGFyZW50KCk7XG4gICAgICBpZiAoJGlzUm9vdE9yU2hhZG93Um9vdChwYXJlbnQpKSB7XG4gICAgICAgIGlmICghKCRpc0VsZW1lbnROb2RlKG5vZGUpIHx8IG5vZGUgPT09IHRoaXMgJiYgJGlzRGVjb3JhdG9yTm9kZShub2RlKSkpIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihgQ2hpbGRyZW4gb2Ygcm9vdCBub2RlcyBtdXN0IGJlIGVsZW1lbnRzIG9yIGRlY29yYXRvcnNgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGhpZ2hlc3QgKGluIHRoZSBFZGl0b3JTdGF0ZSB0cmVlKVxuICAgKiBub24tcm9vdCBhbmNlc3RvciBvZiB0aGlzIG5vZGUsIG9yIHRocm93cyBpZiBub25lIGlzIGZvdW5kLiBTZWUge0BsaW5rIGxleGljYWwhJGlzUm9vdE9yU2hhZG93Um9vdH1cbiAgICogZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gd2hpY2ggRWxlbWVudHMgY29tcHJpc2UgXCJyb290c1wiLlxuICAgKi9cbiAgZ2V0VG9wTGV2ZWxFbGVtZW50T3JUaHJvdygpIHtcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmdldFRvcExldmVsRWxlbWVudCgpO1xuICAgIGlmIChwYXJlbnQgPT09IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIG5vZGUgJHt0aGlzLl9fa2V5fSB0byBoYXZlIGEgdG9wIHBhcmVudCBlbGVtZW50LmApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFyZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsaXN0IG9mIHRoZSBldmVyeSBhbmNlc3RvciBvZiB0aGlzIG5vZGUsXG4gICAqIGFsbCB0aGUgd2F5IHVwIHRvIHRoZSBSb290Tm9kZS5cbiAgICpcbiAgICovXG4gIGdldFBhcmVudHMoKSB7XG4gICAgY29uc3QgcGFyZW50cyA9IFtdO1xuICAgIGxldCBub2RlID0gdGhpcy5nZXRQYXJlbnQoKTtcbiAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgcGFyZW50cy5wdXNoKG5vZGUpO1xuICAgICAgbm9kZSA9IG5vZGUuZ2V0UGFyZW50KCk7XG4gICAgfVxuICAgIHJldHVybiBwYXJlbnRzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsaXN0IG9mIHRoZSBrZXlzIG9mIGV2ZXJ5IGFuY2VzdG9yIG9mIHRoaXMgbm9kZSxcbiAgICogYWxsIHRoZSB3YXkgdXAgdG8gdGhlIFJvb3ROb2RlLlxuICAgKlxuICAgKi9cbiAgZ2V0UGFyZW50S2V5cygpIHtcbiAgICBjb25zdCBwYXJlbnRzID0gW107XG4gICAgbGV0IG5vZGUgPSB0aGlzLmdldFBhcmVudCgpO1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBwYXJlbnRzLnB1c2gobm9kZS5fX2tleSk7XG4gICAgICBub2RlID0gbm9kZS5nZXRQYXJlbnQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmVudHM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgXCJwcmV2aW91c1wiIHNpYmxpbmdzIC0gdGhhdCBpcywgdGhlIG5vZGUgdGhhdCBjb21lc1xuICAgKiBiZWZvcmUgdGhpcyBvbmUgaW4gdGhlIHNhbWUgcGFyZW50LlxuICAgKlxuICAgKi9cbiAgZ2V0UHJldmlvdXNTaWJsaW5nKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIGNvbnN0IHByZXZLZXkgPSBzZWxmLl9fcHJldjtcbiAgICByZXR1cm4gcHJldktleSA9PT0gbnVsbCA/IG51bGwgOiAkZ2V0Tm9kZUJ5S2V5KHByZXZLZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIFwicHJldmlvdXNcIiBzaWJsaW5ncyAtIHRoYXQgaXMsIHRoZSBub2RlcyB0aGF0IGNvbWUgYmV0d2VlblxuICAgKiB0aGlzIG9uZSBhbmQgdGhlIGZpcnN0IGNoaWxkIG9mIGl0J3MgcGFyZW50LCBpbmNsdXNpdmUuXG4gICAqXG4gICAqL1xuICBnZXRQcmV2aW91c1NpYmxpbmdzKCkge1xuICAgIGNvbnN0IHNpYmxpbmdzID0gW107XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnQoKTtcbiAgICBpZiAocGFyZW50ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gc2libGluZ3M7XG4gICAgfVxuICAgIGxldCBub2RlID0gcGFyZW50LmdldEZpcnN0Q2hpbGQoKTtcbiAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGUuaXModGhpcykpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzaWJsaW5ncy5wdXNoKG5vZGUpO1xuICAgICAgbm9kZSA9IG5vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIHNpYmxpbmdzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIFwibmV4dFwiIHNpYmxpbmdzIC0gdGhhdCBpcywgdGhlIG5vZGUgdGhhdCBjb21lc1xuICAgKiBhZnRlciB0aGlzIG9uZSBpbiB0aGUgc2FtZSBwYXJlbnRcbiAgICpcbiAgICovXG4gIGdldE5leHRTaWJsaW5nKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIGNvbnN0IG5leHRLZXkgPSBzZWxmLl9fbmV4dDtcbiAgICByZXR1cm4gbmV4dEtleSA9PT0gbnVsbCA/IG51bGwgOiAkZ2V0Tm9kZUJ5S2V5KG5leHRLZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIFwibmV4dFwiIHNpYmxpbmdzIC0gdGhhdCBpcywgdGhlIG5vZGVzIHRoYXQgY29tZSBiZXR3ZWVuIHRoaXNcbiAgICogb25lIGFuZCB0aGUgbGFzdCBjaGlsZCBvZiBpdCdzIHBhcmVudCwgaW5jbHVzaXZlLlxuICAgKlxuICAgKi9cbiAgZ2V0TmV4dFNpYmxpbmdzKCkge1xuICAgIGNvbnN0IHNpYmxpbmdzID0gW107XG4gICAgbGV0IG5vZGUgPSB0aGlzLmdldE5leHRTaWJsaW5nKCk7XG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIHNpYmxpbmdzLnB1c2gobm9kZSk7XG4gICAgICBub2RlID0gbm9kZS5nZXROZXh0U2libGluZygpO1xuICAgIH1cbiAgICByZXR1cm4gc2libGluZ3M7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY2xvc2VzdCBjb21tb24gYW5jZXN0b3Igb2YgdGhpcyBub2RlIGFuZCB0aGUgcHJvdmlkZWQgb25lIG9yIG51bGxcbiAgICogaWYgb25lIGNhbm5vdCBiZSBmb3VuZC5cbiAgICpcbiAgICogQHBhcmFtIG5vZGUgLSB0aGUgb3RoZXIgbm9kZSB0byBmaW5kIHRoZSBjb21tb24gYW5jZXN0b3Igb2YuXG4gICAqL1xuICBnZXRDb21tb25BbmNlc3Rvcihub2RlKSB7XG4gICAgY29uc3QgYSA9IHRoaXMuZ2V0UGFyZW50cygpO1xuICAgIGNvbnN0IGIgPSBub2RlLmdldFBhcmVudHMoKTtcbiAgICBpZiAoJGlzRWxlbWVudE5vZGUodGhpcykpIHtcbiAgICAgIGEudW5zaGlmdCh0aGlzKTtcbiAgICB9XG4gICAgaWYgKCRpc0VsZW1lbnROb2RlKG5vZGUpKSB7XG4gICAgICBiLnVuc2hpZnQobm9kZSk7XG4gICAgfVxuICAgIGNvbnN0IGFMZW5ndGggPSBhLmxlbmd0aDtcbiAgICBjb25zdCBiTGVuZ3RoID0gYi5sZW5ndGg7XG4gICAgaWYgKGFMZW5ndGggPT09IDAgfHwgYkxlbmd0aCA9PT0gMCB8fCBhW2FMZW5ndGggLSAxXSAhPT0gYltiTGVuZ3RoIC0gMV0pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBiU2V0ID0gbmV3IFNldChiKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFMZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYW5jZXN0b3IgPSBhW2ldO1xuICAgICAgaWYgKGJTZXQuaGFzKGFuY2VzdG9yKSkge1xuICAgICAgICByZXR1cm4gYW5jZXN0b3I7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvdmlkZWQgbm9kZSBpcyB0aGUgZXhhY3Qgc2FtZSBvbmUgYXMgdGhpcyBub2RlLCBmcm9tIExleGljYWwncyBwZXJzcGVjdGl2ZS5cbiAgICogQWx3YXlzIHVzZSB0aGlzIGluc3RlYWQgb2YgcmVmZXJlbnRpYWwgZXF1YWxpdHkuXG4gICAqXG4gICAqIEBwYXJhbSBvYmplY3QgLSB0aGUgbm9kZSB0byBwZXJmb3JtIHRoZSBlcXVhbGl0eSBjb21wYXJpc29uIG9uLlxuICAgKi9cbiAgaXMob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9fa2V5ID09PSBvYmplY3QuX19rZXk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgbm9kZSBsb2dpY2FsIHByZWNlZGVzIHRoZSB0YXJnZXQgbm9kZSBpbiB0aGUgZWRpdG9yIHN0YXRlLlxuICAgKlxuICAgKiBAcGFyYW0gdGFyZ2V0Tm9kZSAtIHRoZSBub2RlIHdlJ3JlIHRlc3RpbmcgdG8gc2VlIGlmIGl0J3MgYWZ0ZXIgdGhpcyBvbmUuXG4gICAqL1xuICBpc0JlZm9yZSh0YXJnZXROb2RlKSB7XG4gICAgaWYgKHRoaXMgPT09IHRhcmdldE5vZGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRhcmdldE5vZGUuaXNQYXJlbnRPZih0aGlzKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzUGFyZW50T2YodGFyZ2V0Tm9kZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgY29tbW9uQW5jZXN0b3IgPSB0aGlzLmdldENvbW1vbkFuY2VzdG9yKHRhcmdldE5vZGUpO1xuICAgIGxldCBpbmRleEEgPSAwO1xuICAgIGxldCBpbmRleEIgPSAwO1xuICAgIGxldCBub2RlID0gdGhpcztcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29uc3QgcGFyZW50ID0gbm9kZS5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgICBpZiAocGFyZW50ID09PSBjb21tb25BbmNlc3Rvcikge1xuICAgICAgICBpbmRleEEgPSBub2RlLmdldEluZGV4V2l0aGluUGFyZW50KCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICB9XG4gICAgbm9kZSA9IHRhcmdldE5vZGU7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IG5vZGUuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgICAgaWYgKHBhcmVudCA9PT0gY29tbW9uQW5jZXN0b3IpIHtcbiAgICAgICAgaW5kZXhCID0gbm9kZS5nZXRJbmRleFdpdGhpblBhcmVudCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBpbmRleEEgPCBpbmRleEI7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgbm9kZSBpcyB0aGUgcGFyZW50IG9mIHRoZSB0YXJnZXQgbm9kZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKlxuICAgKiBAcGFyYW0gdGFyZ2V0Tm9kZSAtIHRoZSB3b3VsZC1iZSBjaGlsZCBub2RlLlxuICAgKi9cbiAgaXNQYXJlbnRPZih0YXJnZXROb2RlKSB7XG4gICAgY29uc3Qga2V5ID0gdGhpcy5fX2tleTtcbiAgICBpZiAoa2V5ID09PSB0YXJnZXROb2RlLl9fa2V5KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBub2RlID0gdGFyZ2V0Tm9kZTtcbiAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGUuX19rZXkgPT09IGtleSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlLmdldFBhcmVudCgpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBUTy1ETzogdGhpcyBmdW5jdGlvbiBjYW4gYmUgc2ltcGxpZmllZCBhIGxvdFxuICAvKipcbiAgICogUmV0dXJucyBhIGxpc3Qgb2Ygbm9kZXMgdGhhdCBhcmUgYmV0d2VlbiB0aGlzIG5vZGUgYW5kXG4gICAqIHRoZSB0YXJnZXQgbm9kZSBpbiB0aGUgRWRpdG9yU3RhdGUuXG4gICAqXG4gICAqIEBwYXJhbSB0YXJnZXROb2RlIC0gdGhlIG5vZGUgdGhhdCBtYXJrcyB0aGUgb3RoZXIgZW5kIG9mIHRoZSByYW5nZSBvZiBub2RlcyB0byBiZSByZXR1cm5lZC5cbiAgICovXG4gIGdldE5vZGVzQmV0d2Vlbih0YXJnZXROb2RlKSB7XG4gICAgY29uc3QgaXNCZWZvcmUgPSB0aGlzLmlzQmVmb3JlKHRhcmdldE5vZGUpO1xuICAgIGNvbnN0IG5vZGVzID0gW107XG4gICAgY29uc3QgdmlzaXRlZCA9IG5ldyBTZXQoKTtcbiAgICBsZXQgbm9kZSA9IHRoaXM7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChub2RlID09PSBudWxsKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY29uc3Qga2V5ID0gbm9kZS5fX2tleTtcbiAgICAgIGlmICghdmlzaXRlZC5oYXMoa2V5KSkge1xuICAgICAgICB2aXNpdGVkLmFkZChrZXkpO1xuICAgICAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUgPT09IHRhcmdldE5vZGUpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjb25zdCBjaGlsZCA9ICRpc0VsZW1lbnROb2RlKG5vZGUpID8gaXNCZWZvcmUgPyBub2RlLmdldEZpcnN0Q2hpbGQoKSA6IG5vZGUuZ2V0TGFzdENoaWxkKCkgOiBudWxsO1xuICAgICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUgPSBjaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBuZXh0U2libGluZyA9IGlzQmVmb3JlID8gbm9kZS5nZXROZXh0U2libGluZygpIDogbm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICAgIGlmIChuZXh0U2libGluZyAhPT0gbnVsbCkge1xuICAgICAgICBub2RlID0gbmV4dFNpYmxpbmc7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFyZW50ID0gbm9kZS5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgICBpZiAoIXZpc2l0ZWQuaGFzKHBhcmVudC5fX2tleSkpIHtcbiAgICAgICAgbm9kZXMucHVzaChwYXJlbnQpO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmVudCA9PT0gdGFyZ2V0Tm9kZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGxldCBwYXJlbnRTaWJsaW5nID0gbnVsbDtcbiAgICAgIGxldCBhbmNlc3RvciA9IHBhcmVudDtcbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKGFuY2VzdG9yID09PSBudWxsKSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYGdldE5vZGVzQmV0d2VlbjogYW5jZXN0b3IgaXMgbnVsbGApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwYXJlbnRTaWJsaW5nID0gaXNCZWZvcmUgPyBhbmNlc3Rvci5nZXROZXh0U2libGluZygpIDogYW5jZXN0b3IuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IuZ2V0UGFyZW50KCk7XG4gICAgICAgIGlmIChhbmNlc3RvciAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChwYXJlbnRTaWJsaW5nID09PSBudWxsICYmICF2aXNpdGVkLmhhcyhhbmNlc3Rvci5fX2tleSkpIHtcbiAgICAgICAgICAgIG5vZGVzLnB1c2goYW5jZXN0b3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAocGFyZW50U2libGluZyA9PT0gbnVsbCk7XG4gICAgICBub2RlID0gcGFyZW50U2libGluZztcbiAgICB9XG4gICAgaWYgKCFpc0JlZm9yZSkge1xuICAgICAgbm9kZXMucmV2ZXJzZSgpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZXM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgbm9kZSBoYXMgYmVlbiBtYXJrZWQgZGlydHkgZHVyaW5nIHRoaXMgdXBkYXRlIGN5Y2xlLlxuICAgKlxuICAgKi9cbiAgaXNEaXJ0eSgpIHtcbiAgICBjb25zdCBlZGl0b3IgPSBnZXRBY3RpdmVFZGl0b3IoKTtcbiAgICBjb25zdCBkaXJ0eUxlYXZlcyA9IGVkaXRvci5fZGlydHlMZWF2ZXM7XG4gICAgcmV0dXJuIGRpcnR5TGVhdmVzICE9PSBudWxsICYmIGRpcnR5TGVhdmVzLmhhcyh0aGlzLl9fa2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsYXRlc3QgdmVyc2lvbiBvZiB0aGUgbm9kZSBmcm9tIHRoZSBhY3RpdmUgRWRpdG9yU3RhdGUuXG4gICAqIFRoaXMgaXMgdXNlZCB0byBhdm9pZCBnZXR0aW5nIHZhbHVlcyBmcm9tIHN0YWxlIG5vZGUgcmVmZXJlbmNlcy5cbiAgICpcbiAgICovXG4gIGdldExhdGVzdCgpIHtcbiAgICBjb25zdCBsYXRlc3QgPSAkZ2V0Tm9kZUJ5S2V5KHRoaXMuX19rZXkpO1xuICAgIGlmIChsYXRlc3QgPT09IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYExleGljYWwgbm9kZSBkb2VzIG5vdCBleGlzdCBpbiBhY3RpdmUgZWRpdG9yIHN0YXRlLiBBdm9pZCB1c2luZyB0aGUgc2FtZSBub2RlIHJlZmVyZW5jZXMgYmV0d2VlbiBuZXN0ZWQgY2xvc3VyZXMgZnJvbSBlZGl0b3JTdGF0ZS5yZWFkL2VkaXRvci51cGRhdGUuYCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsYXRlc3Q7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIG11dGFibGUgdmVyc2lvbiBvZiB0aGUgbm9kZSB1c2luZyB7QGxpbmsgJGNsb25lV2l0aFByb3BlcnRpZXN9XG4gICAqIGlmIG5lY2Vzc2FyeS4gV2lsbCB0aHJvdyBhbiBlcnJvciBpZiBjYWxsZWQgb3V0c2lkZSBvZiBhIExleGljYWwgRWRpdG9yXG4gICAqIHtAbGluayBMZXhpY2FsRWRpdG9yLnVwZGF0ZX0gY2FsbGJhY2suXG4gICAqXG4gICAqL1xuICBnZXRXcml0YWJsZSgpIHtcbiAgICBlcnJvck9uUmVhZE9ubHkoKTtcbiAgICBjb25zdCBlZGl0b3JTdGF0ZSA9IGdldEFjdGl2ZUVkaXRvclN0YXRlKCk7XG4gICAgY29uc3QgZWRpdG9yID0gZ2V0QWN0aXZlRWRpdG9yKCk7XG4gICAgY29uc3Qgbm9kZU1hcCA9IGVkaXRvclN0YXRlLl9ub2RlTWFwO1xuICAgIGNvbnN0IGtleSA9IHRoaXMuX19rZXk7XG4gICAgLy8gRW5zdXJlIHdlIGdldCB0aGUgbGF0ZXN0IG5vZGUgZnJvbSBwZW5kaW5nIHN0YXRlXG4gICAgY29uc3QgbGF0ZXN0Tm9kZSA9IHRoaXMuZ2V0TGF0ZXN0KCk7XG4gICAgY29uc3QgY2xvbmVOb3ROZWVkZWQgPSBlZGl0b3IuX2Nsb25lTm90TmVlZGVkO1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoc2VsZWN0aW9uICE9PSBudWxsKSB7XG4gICAgICBzZWxlY3Rpb24uc2V0Q2FjaGVkTm9kZXMobnVsbCk7XG4gICAgfVxuICAgIGlmIChjbG9uZU5vdE5lZWRlZC5oYXMoa2V5KSkge1xuICAgICAgLy8gVHJhbnNmb3JtcyBjbGVhciB0aGUgZGlydHkgbm9kZSBzZXQgb24gZWFjaCBpdGVyYXRpb24gdG8ga2VlcCB0cmFjayBvbiBuZXdseSBkaXJ0eSBub2Rlc1xuICAgICAgaW50ZXJuYWxNYXJrTm9kZUFzRGlydHkobGF0ZXN0Tm9kZSk7XG4gICAgICByZXR1cm4gbGF0ZXN0Tm9kZTtcbiAgICB9XG4gICAgY29uc3QgbXV0YWJsZU5vZGUgPSAkY2xvbmVXaXRoUHJvcGVydGllcyhsYXRlc3ROb2RlKTtcbiAgICBjbG9uZU5vdE5lZWRlZC5hZGQoa2V5KTtcbiAgICBpbnRlcm5hbE1hcmtOb2RlQXNEaXJ0eShtdXRhYmxlTm9kZSk7XG4gICAgLy8gVXBkYXRlIHJlZmVyZW5jZSBpbiBub2RlIG1hcFxuICAgIG5vZGVNYXAuc2V0KGtleSwgbXV0YWJsZU5vZGUpO1xuICAgIHJldHVybiBtdXRhYmxlTm9kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0ZXh0IGNvbnRlbnQgb2YgdGhlIG5vZGUuIE92ZXJyaWRlIHRoaXMgZm9yXG4gICAqIGN1c3RvbSBub2RlcyB0aGF0IHNob3VsZCBoYXZlIGEgcmVwcmVzZW50YXRpb24gaW4gcGxhaW4gdGV4dFxuICAgKiBmb3JtYXQgKGZvciBjb3B5ICsgcGFzdGUsIGZvciBleGFtcGxlKVxuICAgKlxuICAgKi9cbiAgZ2V0VGV4dENvbnRlbnQoKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGUgc3RyaW5nIHByb2R1Y2VkIGJ5IGNhbGxpbmcgZ2V0VGV4dENvbnRlbnQgb24gdGhpcyBub2RlLlxuICAgKlxuICAgKi9cbiAgZ2V0VGV4dENvbnRlbnRTaXplKCkge1xuICAgIHJldHVybiB0aGlzLmdldFRleHRDb250ZW50KCkubGVuZ3RoO1xuICB9XG5cbiAgLy8gVmlld1xuXG4gIC8qKlxuICAgKiBDYWxsZWQgZHVyaW5nIHRoZSByZWNvbmNpbGlhdGlvbiBwcm9jZXNzIHRvIGRldGVybWluZSB3aGljaCBub2Rlc1xuICAgKiB0byBpbnNlcnQgaW50byB0aGUgRE9NIGZvciB0aGlzIExleGljYWwgTm9kZS5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgbXVzdCByZXR1cm4gZXhhY3RseSBvbmUgSFRNTEVsZW1lbnQuIE5lc3RlZCBlbGVtZW50cyBhcmUgbm90IHN1cHBvcnRlZC5cbiAgICpcbiAgICogRG8gbm90IGF0dGVtcHQgdG8gdXBkYXRlIHRoZSBMZXhpY2FsIEVkaXRvclN0YXRlIGR1cmluZyB0aGlzIHBoYXNlIG9mIHRoZSB1cGRhdGUgbGlmZWN5bGUuXG4gICAqXG4gICAqIEBwYXJhbSBfY29uZmlnIC0gYWxsb3dzIGFjY2VzcyB0byB0aGluZ3MgbGlrZSB0aGUgRWRpdG9yVGhlbWUgKHRvIGFwcGx5IGNsYXNzZXMpIGR1cmluZyByZWNvbmNpbGlhdGlvbi5cbiAgICogQHBhcmFtIF9lZGl0b3IgLSBhbGxvd3MgYWNjZXNzIHRvIHRoZSBlZGl0b3IgZm9yIGNvbnRleHQgZHVyaW5nIHJlY29uY2lsaWF0aW9uLlxuICAgKlxuICAgKiAqL1xuICBjcmVhdGVET00oX2NvbmZpZywgX2VkaXRvcikge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGBjcmVhdGVET006IGJhc2UgbWV0aG9kIG5vdCBleHRlbmRlZGApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBhIG5vZGUgY2hhbmdlcyBhbmQgc2hvdWxkIHVwZGF0ZSB0aGUgRE9NXG4gICAqIGluIHdoYXRldmVyIHdheSBpcyBuZWNlc3NhcnkgdG8gbWFrZSBpdCBhbGlnbiB3aXRoIGFueSBjaGFuZ2VzIHRoYXQgbWlnaHRcbiAgICogaGF2ZSBoYXBwZW5lZCBkdXJpbmcgdGhlIHVwZGF0ZS5cbiAgICpcbiAgICogUmV0dXJuaW5nIFwidHJ1ZVwiIGhlcmUgd2lsbCBjYXVzZSBsZXhpY2FsIHRvIHVubW91bnQgYW5kIHJlY3JlYXRlIHRoZSBET00gbm9kZVxuICAgKiAoYnkgY2FsbGluZyBjcmVhdGVET00pLiBZb3Ugd291bGQgbmVlZCB0byBkbyB0aGlzIGlmIHRoZSBlbGVtZW50IHRhZyBjaGFuZ2VzLFxuICAgKiBmb3IgaW5zdGFuY2UuXG4gICAqXG4gICAqICovXG4gIHVwZGF0ZURPTShfcHJldk5vZGUsIF9kb20sIF9jb25maWcpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgdXBkYXRlRE9NOiBiYXNlIG1ldGhvZCBub3QgZXh0ZW5kZWRgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29udHJvbHMgaG93IHRoZSB0aGlzIG5vZGUgaXMgc2VyaWFsaXplZCB0byBIVE1MLiBUaGlzIGlzIGltcG9ydGFudCBmb3JcbiAgICogY29weSBhbmQgcGFzdGUgYmV0d2VlbiBMZXhpY2FsIGFuZCBub24tTGV4aWNhbCBlZGl0b3JzLCBvciBMZXhpY2FsIGVkaXRvcnMgd2l0aCBkaWZmZXJlbnQgbmFtZXNwYWNlcyxcbiAgICogaW4gd2hpY2ggY2FzZSB0aGUgcHJpbWFyeSB0cmFuc2ZlciBmb3JtYXQgaXMgSFRNTC4gSXQncyBhbHNvIGltcG9ydGFudCBpZiB5b3UncmUgc2VyaWFsaXppbmdcbiAgICogdG8gSFRNTCBmb3IgYW55IG90aGVyIHJlYXNvbiB2aWEge0BsaW5rIEBsZXhpY2FsL2h0bWwhJGdlbmVyYXRlSHRtbEZyb21Ob2Rlc30uIFlvdSBjb3VsZFxuICAgKiBhbHNvIHVzZSB0aGlzIG1ldGhvZCB0byBidWlsZCB5b3VyIG93biBIVE1MIHJlbmRlcmVyLlxuICAgKlxuICAgKiAqL1xuICBleHBvcnRET00oZWRpdG9yKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuY3JlYXRlRE9NKGVkaXRvci5fY29uZmlnLCBlZGl0b3IpO1xuICAgIHJldHVybiB7XG4gICAgICBlbGVtZW50XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb250cm9scyBob3cgdGhlIHRoaXMgbm9kZSBpcyBzZXJpYWxpemVkIHRvIEpTT04uIFRoaXMgaXMgaW1wb3J0YW50IGZvclxuICAgKiBjb3B5IGFuZCBwYXN0ZSBiZXR3ZWVuIExleGljYWwgZWRpdG9ycyBzaGFyaW5nIHRoZSBzYW1lIG5hbWVzcGFjZS4gSXQncyBhbHNvIGltcG9ydGFudFxuICAgKiBpZiB5b3UncmUgc2VyaWFsaXppbmcgdG8gSlNPTiBmb3IgcGVyc2lzdGVudCBzdG9yYWdlIHNvbWV3aGVyZS5cbiAgICogU2VlIFtTZXJpYWxpemF0aW9uICYgRGVzZXJpYWxpemF0aW9uXShodHRwczovL2xleGljYWwuZGV2L2RvY3MvY29uY2VwdHMvc2VyaWFsaXphdGlvbiNsZXhpY2FsLS0taHRtbCkuXG4gICAqXG4gICAqICovXG4gIGV4cG9ydEpTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IHRoaXMuX190eXBlLFxuICAgICAgdmVyc2lvbjogMVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ29udHJvbHMgaG93IHRoZSB0aGlzIG5vZGUgaXMgZGVzZXJpYWxpemVkIGZyb20gSlNPTi4gVGhpcyBpcyB1c3VhbGx5IGJvaWxlcnBsYXRlLFxuICAgKiBidXQgcHJvdmlkZXMgYW4gYWJzdHJhY3Rpb24gYmV0d2VlbiB0aGUgbm9kZSBpbXBsZW1lbnRhdGlvbiBhbmQgc2VyaWFsaXplZCBpbnRlcmZhY2UgdGhhdCBjYW5cbiAgICogYmUgaW1wb3J0YW50IGlmIHlvdSBldmVyIG1ha2UgYnJlYWtpbmcgY2hhbmdlcyB0byBhIG5vZGUgc2NoZW1hIChieSBhZGRpbmcgb3IgcmVtb3ZpbmcgcHJvcGVydGllcykuXG4gICAqIFNlZSBbU2VyaWFsaXphdGlvbiAmIERlc2VyaWFsaXphdGlvbl0oaHR0cHM6Ly9sZXhpY2FsLmRldi9kb2NzL2NvbmNlcHRzL3NlcmlhbGl6YXRpb24jbGV4aWNhbC0tLWh0bWwpLlxuICAgKlxuICAgKiAqL1xuICBzdGF0aWMgaW1wb3J0SlNPTihfc2VyaWFsaXplZE5vZGUpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgTGV4aWNhbE5vZGU6IE5vZGUgJHt0aGlzLm5hbWV9IGRvZXMgbm90IGltcGxlbWVudCAuaW1wb3J0SlNPTigpLmApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhpcyBMZXhpY2FsTm9kZSBpbnN0YW5jZSBmcm9tIHNlcmlhbGl6ZWQgSlNPTi4gSXQncyByZWNvbW1lbmRlZFxuICAgKiB0byBpbXBsZW1lbnQgYXMgbXVjaCBsb2dpYyBhcyBwb3NzaWJsZSBpbiB0aGlzIG1ldGhvZCBpbnN0ZWFkIG9mIHRoZVxuICAgKiBzdGF0aWMgaW1wb3J0SlNPTiBtZXRob2QsIHNvIHRoYXQgdGhlIGZ1bmN0aW9uYWxpdHkgY2FuIGJlIGluaGVyaXRlZCBpbiBzdWJjbGFzc2VzLlxuICAgKlxuICAgKiBUaGUgTGV4aWNhbFVwZGF0ZUpTT04gdXRpbGl0eSB0eXBlIHNob3VsZCBiZSB1c2VkIHRvIGlnbm9yZSBhbnkgdHlwZSwgdmVyc2lvbixcbiAgICogb3IgY2hpbGRyZW4gcHJvcGVydGllcyBpbiB0aGUgSlNPTiBzbyB0aGF0IHRoZSBleHRlbmRlZCBKU09OIGZyb20gc3ViY2xhc3Nlc1xuICAgKiBhcmUgYWNjZXB0YWJsZSBwYXJhbWV0ZXJzIGZvciB0aGUgc3VwZXIgY2FsbC5cbiAgICpcbiAgICogSWYgb3ZlcnJpZGRlbiwgdGhpcyBtZXRob2QgbXVzdCBjYWxsIHN1cGVyLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiBjbGFzcyBNeVRleHROb2RlIGV4dGVuZHMgVGV4dE5vZGUge1xuICAgKiAgIC8vIC4uLlxuICAgKiAgIHN0YXRpYyBpbXBvcnRKU09OKHNlcmlhbGl6ZWROb2RlOiBTZXJpYWxpemVkTXlUZXh0Tm9kZSk6IE15VGV4dE5vZGUge1xuICAgKiAgICAgcmV0dXJuICRjcmVhdGVNeVRleHROb2RlKClcbiAgICogICAgICAgLnVwZGF0ZUZyb21KU09OKHNlcmlhbGl6ZWROb2RlKTtcbiAgICogICB9XG4gICAqICAgdXBkYXRlRnJvbUpTT04oXG4gICAqICAgICBzZXJpYWxpemVkTm9kZTogTGV4aWNhbFVwZGF0ZUpTT048U2VyaWFsaXplZE15VGV4dE5vZGU+LFxuICAgKiAgICk6IHRoaXMge1xuICAgKiAgICAgcmV0dXJuIHN1cGVyLnVwZGF0ZUZyb21KU09OKHNlcmlhbGl6ZWROb2RlKVxuICAgKiAgICAgICAuc2V0TXlQcm9wZXJ0eShzZXJpYWxpemVkTm9kZS5teVByb3BlcnR5KTtcbiAgICogICB9XG4gICAqIH1cbiAgICogYGBgXG4gICAqKi9cbiAgdXBkYXRlRnJvbUpTT04oc2VyaWFsaXplZE5vZGUpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAZXhwZXJpbWVudGFsXG4gICAqXG4gICAqIFJlZ2lzdGVycyB0aGUgcmV0dXJuZWQgZnVuY3Rpb24gYXMgYSB0cmFuc2Zvcm0gb24gdGhlIG5vZGUgZHVyaW5nXG4gICAqIEVkaXRvciBpbml0aWFsaXphdGlvbi4gTW9zdCBzdWNoIHVzZSBjYXNlcyBzaG91bGQgYmUgYWRkcmVzc2VkIHZpYVxuICAgKiB0aGUge0BsaW5rIExleGljYWxFZGl0b3IucmVnaXN0ZXJOb2RlVHJhbnNmb3JtfSBBUEkuXG4gICAqXG4gICAqIEV4cGVyaW1lbnRhbCAtIHVzZSBhdCB5b3VyIG93biByaXNrLlxuICAgKi9cbiAgc3RhdGljIHRyYW5zZm9ybSgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIFNldHRlcnMgYW5kIG11dGF0b3JzXG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhpcyBMZXhpY2FsTm9kZSBmcm9tIHRoZSBFZGl0b3JTdGF0ZS4gSWYgdGhlIG5vZGUgaXNuJ3QgcmUtaW5zZXJ0ZWRcbiAgICogc29tZXdoZXJlLCB0aGUgTGV4aWNhbCBnYXJiYWdlIGNvbGxlY3RvciB3aWxsIGV2ZW50dWFsbHkgY2xlYW4gaXQgdXAuXG4gICAqXG4gICAqIEBwYXJhbSBwcmVzZXJ2ZUVtcHR5UGFyZW50IC0gSWYgZmFsc3ksIHRoZSBub2RlJ3MgcGFyZW50IHdpbGwgYmUgcmVtb3ZlZCBpZlxuICAgKiBpdCdzIGVtcHR5IGFmdGVyIHRoZSByZW1vdmFsIG9wZXJhdGlvbi4gVGhpcyBpcyB0aGUgZGVmYXVsdCBiZWhhdmlvciwgc3ViamVjdCB0b1xuICAgKiBvdGhlciBub2RlIGhldXJpc3RpY3Mgc3VjaCBhcyB7QGxpbmsgRWxlbWVudE5vZGUjY2FuQmVFbXB0eX1cbiAgICogKi9cbiAgcmVtb3ZlKHByZXNlcnZlRW1wdHlQYXJlbnQpIHtcbiAgICAkcmVtb3ZlTm9kZSh0aGlzLCB0cnVlLCBwcmVzZXJ2ZUVtcHR5UGFyZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyB0aGlzIExleGljYWxOb2RlIHdpdGggdGhlIHByb3ZpZGVkIG5vZGUsIG9wdGlvbmFsbHkgdHJhbnNmZXJyaW5nIHRoZSBjaGlsZHJlblxuICAgKiBvZiB0aGUgcmVwbGFjZWQgbm9kZSB0byB0aGUgcmVwbGFjaW5nIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSByZXBsYWNlV2l0aCAtIFRoZSBub2RlIHRvIHJlcGxhY2UgdGhpcyBvbmUgd2l0aC5cbiAgICogQHBhcmFtIGluY2x1ZGVDaGlsZHJlbiAtIFdoZXRoZXIgb3Igbm90IHRvIHRyYW5zZmVyIHRoZSBjaGlsZHJlbiBvZiB0aGlzIG5vZGUgdG8gdGhlIHJlcGxhY2luZyBub2RlLlxuICAgKiAqL1xuICByZXBsYWNlKHJlcGxhY2VXaXRoLCBpbmNsdWRlQ2hpbGRyZW4pIHtcbiAgICBlcnJvck9uUmVhZE9ubHkoKTtcbiAgICBsZXQgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmIChzZWxlY3Rpb24gIT09IG51bGwpIHtcbiAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdGlvbi5jbG9uZSgpO1xuICAgIH1cbiAgICBlcnJvck9uSW5zZXJ0VGV4dE5vZGVPblJvb3QodGhpcywgcmVwbGFjZVdpdGgpO1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIGNvbnN0IHRvUmVwbGFjZUtleSA9IHRoaXMuX19rZXk7XG4gICAgY29uc3Qga2V5ID0gcmVwbGFjZVdpdGguX19rZXk7XG4gICAgY29uc3Qgd3JpdGFibGVSZXBsYWNlV2l0aCA9IHJlcGxhY2VXaXRoLmdldFdyaXRhYmxlKCk7XG4gICAgY29uc3Qgd3JpdGFibGVQYXJlbnQgPSB0aGlzLmdldFBhcmVudE9yVGhyb3coKS5nZXRXcml0YWJsZSgpO1xuICAgIGNvbnN0IHNpemUgPSB3cml0YWJsZVBhcmVudC5fX3NpemU7XG4gICAgcmVtb3ZlRnJvbVBhcmVudCh3cml0YWJsZVJlcGxhY2VXaXRoKTtcbiAgICBjb25zdCBwcmV2U2libGluZyA9IHNlbGYuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgY29uc3QgbmV4dFNpYmxpbmcgPSBzZWxmLmdldE5leHRTaWJsaW5nKCk7XG4gICAgY29uc3QgcHJldktleSA9IHNlbGYuX19wcmV2O1xuICAgIGNvbnN0IG5leHRLZXkgPSBzZWxmLl9fbmV4dDtcbiAgICBjb25zdCBwYXJlbnRLZXkgPSBzZWxmLl9fcGFyZW50O1xuICAgICRyZW1vdmVOb2RlKHNlbGYsIGZhbHNlLCB0cnVlKTtcbiAgICBpZiAocHJldlNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgIHdyaXRhYmxlUGFyZW50Ll9fZmlyc3QgPSBrZXk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHdyaXRhYmxlUHJldlNpYmxpbmcgPSBwcmV2U2libGluZy5nZXRXcml0YWJsZSgpO1xuICAgICAgd3JpdGFibGVQcmV2U2libGluZy5fX25leHQgPSBrZXk7XG4gICAgfVxuICAgIHdyaXRhYmxlUmVwbGFjZVdpdGguX19wcmV2ID0gcHJldktleTtcbiAgICBpZiAobmV4dFNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgIHdyaXRhYmxlUGFyZW50Ll9fbGFzdCA9IGtleTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgd3JpdGFibGVOZXh0U2libGluZyA9IG5leHRTaWJsaW5nLmdldFdyaXRhYmxlKCk7XG4gICAgICB3cml0YWJsZU5leHRTaWJsaW5nLl9fcHJldiA9IGtleTtcbiAgICB9XG4gICAgd3JpdGFibGVSZXBsYWNlV2l0aC5fX25leHQgPSBuZXh0S2V5O1xuICAgIHdyaXRhYmxlUmVwbGFjZVdpdGguX19wYXJlbnQgPSBwYXJlbnRLZXk7XG4gICAgd3JpdGFibGVQYXJlbnQuX19zaXplID0gc2l6ZTtcbiAgICBpZiAoaW5jbHVkZUNoaWxkcmVuKSB7XG4gICAgICBpZiAoISgkaXNFbGVtZW50Tm9kZSh0aGlzKSAmJiAkaXNFbGVtZW50Tm9kZSh3cml0YWJsZVJlcGxhY2VXaXRoKSkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYGluY2x1ZGVDaGlsZHJlbiBzaG91bGQgb25seSBiZSB0cnVlIGZvciBFbGVtZW50Tm9kZXNgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZ2V0Q2hpbGRyZW4oKS5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgd3JpdGFibGVSZXBsYWNlV2l0aC5hcHBlbmQoY2hpbGQpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICAkc2V0U2VsZWN0aW9uKHNlbGVjdGlvbik7XG4gICAgICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICAgICAgY29uc3QgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXM7XG4gICAgICBpZiAoYW5jaG9yLmtleSA9PT0gdG9SZXBsYWNlS2V5KSB7XG4gICAgICAgICRtb3ZlU2VsZWN0aW9uUG9pbnRUb0VuZChhbmNob3IsIHdyaXRhYmxlUmVwbGFjZVdpdGgpO1xuICAgICAgfVxuICAgICAgaWYgKGZvY3VzLmtleSA9PT0gdG9SZXBsYWNlS2V5KSB7XG4gICAgICAgICRtb3ZlU2VsZWN0aW9uUG9pbnRUb0VuZChmb2N1cywgd3JpdGFibGVSZXBsYWNlV2l0aCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICgkZ2V0Q29tcG9zaXRpb25LZXkoKSA9PT0gdG9SZXBsYWNlS2V5KSB7XG4gICAgICAkc2V0Q29tcG9zaXRpb25LZXkoa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIHdyaXRhYmxlUmVwbGFjZVdpdGg7XG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0cyBhIG5vZGUgYWZ0ZXIgdGhpcyBMZXhpY2FsTm9kZSAoYXMgdGhlIG5leHQgc2libGluZykuXG4gICAqXG4gICAqIEBwYXJhbSBub2RlVG9JbnNlcnQgLSBUaGUgbm9kZSB0byBpbnNlcnQgYWZ0ZXIgdGhpcyBvbmUuXG4gICAqIEBwYXJhbSByZXN0b3JlU2VsZWN0aW9uIC0gV2hldGhlciBvciBub3QgdG8gYXR0ZW1wdCB0byByZXNvbHZlIHRoZVxuICAgKiBzZWxlY3Rpb24gdG8gdGhlIGFwcHJvcHJpYXRlIHBsYWNlIGFmdGVyIHRoZSBvcGVyYXRpb24gaXMgY29tcGxldGUuXG4gICAqICovXG4gIGluc2VydEFmdGVyKG5vZGVUb0luc2VydCwgcmVzdG9yZVNlbGVjdGlvbiA9IHRydWUpIHtcbiAgICBlcnJvck9uUmVhZE9ubHkoKTtcbiAgICBlcnJvck9uSW5zZXJ0VGV4dE5vZGVPblJvb3QodGhpcywgbm9kZVRvSW5zZXJ0KTtcbiAgICBjb25zdCB3cml0YWJsZVNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgY29uc3Qgd3JpdGFibGVOb2RlVG9JbnNlcnQgPSBub2RlVG9JbnNlcnQuZ2V0V3JpdGFibGUoKTtcbiAgICBjb25zdCBvbGRQYXJlbnQgPSB3cml0YWJsZU5vZGVUb0luc2VydC5nZXRQYXJlbnQoKTtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgbGV0IGVsZW1lbnRBbmNob3JTZWxlY3Rpb25Pbk5vZGUgPSBmYWxzZTtcbiAgICBsZXQgZWxlbWVudEZvY3VzU2VsZWN0aW9uT25Ob2RlID0gZmFsc2U7XG4gICAgaWYgKG9sZFBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgLy8gVE9ETzogdGhpcyBpcyBPKG4pLCBjYW4gd2UgaW1wcm92ZT9cbiAgICAgIGNvbnN0IG9sZEluZGV4ID0gbm9kZVRvSW5zZXJ0LmdldEluZGV4V2l0aGluUGFyZW50KCk7XG4gICAgICByZW1vdmVGcm9tUGFyZW50KHdyaXRhYmxlTm9kZVRvSW5zZXJ0KTtcbiAgICAgIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICAgIGNvbnN0IG9sZFBhcmVudEtleSA9IG9sZFBhcmVudC5fX2tleTtcbiAgICAgICAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgICAgICAgY29uc3QgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXM7XG4gICAgICAgIGVsZW1lbnRBbmNob3JTZWxlY3Rpb25Pbk5vZGUgPSBhbmNob3IudHlwZSA9PT0gJ2VsZW1lbnQnICYmIGFuY2hvci5rZXkgPT09IG9sZFBhcmVudEtleSAmJiBhbmNob3Iub2Zmc2V0ID09PSBvbGRJbmRleCArIDE7XG4gICAgICAgIGVsZW1lbnRGb2N1c1NlbGVjdGlvbk9uTm9kZSA9IGZvY3VzLnR5cGUgPT09ICdlbGVtZW50JyAmJiBmb2N1cy5rZXkgPT09IG9sZFBhcmVudEtleSAmJiBmb2N1cy5vZmZzZXQgPT09IG9sZEluZGV4ICsgMTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbmV4dFNpYmxpbmcgPSB0aGlzLmdldE5leHRTaWJsaW5nKCk7XG4gICAgY29uc3Qgd3JpdGFibGVQYXJlbnQgPSB0aGlzLmdldFBhcmVudE9yVGhyb3coKS5nZXRXcml0YWJsZSgpO1xuICAgIGNvbnN0IGluc2VydEtleSA9IHdyaXRhYmxlTm9kZVRvSW5zZXJ0Ll9fa2V5O1xuICAgIGNvbnN0IG5leHRLZXkgPSB3cml0YWJsZVNlbGYuX19uZXh0O1xuICAgIGlmIChuZXh0U2libGluZyA9PT0gbnVsbCkge1xuICAgICAgd3JpdGFibGVQYXJlbnQuX19sYXN0ID0gaW5zZXJ0S2V5O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB3cml0YWJsZU5leHRTaWJsaW5nID0gbmV4dFNpYmxpbmcuZ2V0V3JpdGFibGUoKTtcbiAgICAgIHdyaXRhYmxlTmV4dFNpYmxpbmcuX19wcmV2ID0gaW5zZXJ0S2V5O1xuICAgIH1cbiAgICB3cml0YWJsZVBhcmVudC5fX3NpemUrKztcbiAgICB3cml0YWJsZVNlbGYuX19uZXh0ID0gaW5zZXJ0S2V5O1xuICAgIHdyaXRhYmxlTm9kZVRvSW5zZXJ0Ll9fbmV4dCA9IG5leHRLZXk7XG4gICAgd3JpdGFibGVOb2RlVG9JbnNlcnQuX19wcmV2ID0gd3JpdGFibGVTZWxmLl9fa2V5O1xuICAgIHdyaXRhYmxlTm9kZVRvSW5zZXJ0Ll9fcGFyZW50ID0gd3JpdGFibGVTZWxmLl9fcGFyZW50O1xuICAgIGlmIChyZXN0b3JlU2VsZWN0aW9uICYmICRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5nZXRJbmRleFdpdGhpblBhcmVudCgpO1xuICAgICAgJHVwZGF0ZUVsZW1lbnRTZWxlY3Rpb25PbkNyZWF0ZURlbGV0ZU5vZGUoc2VsZWN0aW9uLCB3cml0YWJsZVBhcmVudCwgaW5kZXggKyAxKTtcbiAgICAgIGNvbnN0IHdyaXRhYmxlUGFyZW50S2V5ID0gd3JpdGFibGVQYXJlbnQuX19rZXk7XG4gICAgICBpZiAoZWxlbWVudEFuY2hvclNlbGVjdGlvbk9uTm9kZSkge1xuICAgICAgICBzZWxlY3Rpb24uYW5jaG9yLnNldCh3cml0YWJsZVBhcmVudEtleSwgaW5kZXggKyAyLCAnZWxlbWVudCcpO1xuICAgICAgfVxuICAgICAgaWYgKGVsZW1lbnRGb2N1c1NlbGVjdGlvbk9uTm9kZSkge1xuICAgICAgICBzZWxlY3Rpb24uZm9jdXMuc2V0KHdyaXRhYmxlUGFyZW50S2V5LCBpbmRleCArIDIsICdlbGVtZW50Jyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlVG9JbnNlcnQ7XG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0cyBhIG5vZGUgYmVmb3JlIHRoaXMgTGV4aWNhbE5vZGUgKGFzIHRoZSBwcmV2aW91cyBzaWJsaW5nKS5cbiAgICpcbiAgICogQHBhcmFtIG5vZGVUb0luc2VydCAtIFRoZSBub2RlIHRvIGluc2VydCBiZWZvcmUgdGhpcyBvbmUuXG4gICAqIEBwYXJhbSByZXN0b3JlU2VsZWN0aW9uIC0gV2hldGhlciBvciBub3QgdG8gYXR0ZW1wdCB0byByZXNvbHZlIHRoZVxuICAgKiBzZWxlY3Rpb24gdG8gdGhlIGFwcHJvcHJpYXRlIHBsYWNlIGFmdGVyIHRoZSBvcGVyYXRpb24gaXMgY29tcGxldGUuXG4gICAqICovXG4gIGluc2VydEJlZm9yZShub2RlVG9JbnNlcnQsIHJlc3RvcmVTZWxlY3Rpb24gPSB0cnVlKSB7XG4gICAgZXJyb3JPblJlYWRPbmx5KCk7XG4gICAgZXJyb3JPbkluc2VydFRleHROb2RlT25Sb290KHRoaXMsIG5vZGVUb0luc2VydCk7XG4gICAgY29uc3Qgd3JpdGFibGVTZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIGNvbnN0IHdyaXRhYmxlTm9kZVRvSW5zZXJ0ID0gbm9kZVRvSW5zZXJ0LmdldFdyaXRhYmxlKCk7XG4gICAgY29uc3QgaW5zZXJ0S2V5ID0gd3JpdGFibGVOb2RlVG9JbnNlcnQuX19rZXk7XG4gICAgcmVtb3ZlRnJvbVBhcmVudCh3cml0YWJsZU5vZGVUb0luc2VydCk7XG4gICAgY29uc3QgcHJldlNpYmxpbmcgPSB0aGlzLmdldFByZXZpb3VzU2libGluZygpO1xuICAgIGNvbnN0IHdyaXRhYmxlUGFyZW50ID0gdGhpcy5nZXRQYXJlbnRPclRocm93KCkuZ2V0V3JpdGFibGUoKTtcbiAgICBjb25zdCBwcmV2S2V5ID0gd3JpdGFibGVTZWxmLl9fcHJldjtcbiAgICAvLyBUT0RPOiB0aGlzIGlzIE8obiksIGNhbiB3ZSBpbXByb3ZlP1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5nZXRJbmRleFdpdGhpblBhcmVudCgpO1xuICAgIGlmIChwcmV2U2libGluZyA9PT0gbnVsbCkge1xuICAgICAgd3JpdGFibGVQYXJlbnQuX19maXJzdCA9IGluc2VydEtleTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgd3JpdGFibGVQcmV2U2libGluZyA9IHByZXZTaWJsaW5nLmdldFdyaXRhYmxlKCk7XG4gICAgICB3cml0YWJsZVByZXZTaWJsaW5nLl9fbmV4dCA9IGluc2VydEtleTtcbiAgICB9XG4gICAgd3JpdGFibGVQYXJlbnQuX19zaXplKys7XG4gICAgd3JpdGFibGVTZWxmLl9fcHJldiA9IGluc2VydEtleTtcbiAgICB3cml0YWJsZU5vZGVUb0luc2VydC5fX3ByZXYgPSBwcmV2S2V5O1xuICAgIHdyaXRhYmxlTm9kZVRvSW5zZXJ0Ll9fbmV4dCA9IHdyaXRhYmxlU2VsZi5fX2tleTtcbiAgICB3cml0YWJsZU5vZGVUb0luc2VydC5fX3BhcmVudCA9IHdyaXRhYmxlU2VsZi5fX3BhcmVudDtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKHJlc3RvcmVTZWxlY3Rpb24gJiYgJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgICAkdXBkYXRlRWxlbWVudFNlbGVjdGlvbk9uQ3JlYXRlRGVsZXRlTm9kZShzZWxlY3Rpb24sIHBhcmVudCwgaW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZVRvSW5zZXJ0O1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgb3Igbm90IHRoaXMgbm9kZSBoYXMgYSByZXF1aXJlZCBwYXJlbnQuIFVzZWQgZHVyaW5nIGNvcHkgKyBwYXN0ZSBvcGVyYXRpb25zXG4gICAqIHRvIG5vcm1hbGl6ZSBub2RlcyB0aGF0IHdvdWxkIG90aGVyd2lzZSBiZSBvcnBoYW5lZC4gRm9yIGV4YW1wbGUsIExpc3RJdGVtTm9kZXMgd2l0aG91dFxuICAgKiBhIExpc3ROb2RlIHBhcmVudCBvciBUZXh0Tm9kZXMgd2l0aCBhIFBhcmFncmFwaE5vZGUgcGFyZW50LlxuICAgKlxuICAgKiAqL1xuICBpc1BhcmVudFJlcXVpcmVkKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgY3JlYXRpb24gbG9naWMgZm9yIGFueSByZXF1aXJlZCBwYXJlbnQuIFNob3VsZCBiZSBpbXBsZW1lbnRlZCBpZiB7QGxpbmsgaXNQYXJlbnRSZXF1aXJlZH0gcmV0dXJucyB0cnVlLlxuICAgKlxuICAgKiAqL1xuICBjcmVhdGVQYXJlbnRFbGVtZW50Tm9kZSgpIHtcbiAgICByZXR1cm4gJGNyZWF0ZVBhcmFncmFwaE5vZGUoKTtcbiAgfVxuICBzZWxlY3RTdGFydCgpIHtcbiAgICByZXR1cm4gdGhpcy5zZWxlY3RQcmV2aW91cygpO1xuICB9XG4gIHNlbGVjdEVuZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zZWxlY3ROZXh0KDAsIDApO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vdmVzIHNlbGVjdGlvbiB0byB0aGUgcHJldmlvdXMgc2libGluZyBvZiB0aGlzIG5vZGUsIGF0IHRoZSBzcGVjaWZpZWQgb2Zmc2V0cy5cbiAgICpcbiAgICogQHBhcmFtIGFuY2hvck9mZnNldCAtIFRoZSBhbmNob3Igb2Zmc2V0IGZvciBzZWxlY3Rpb24uXG4gICAqIEBwYXJhbSBmb2N1c09mZnNldCAtICBUaGUgZm9jdXMgb2Zmc2V0IGZvciBzZWxlY3Rpb25cbiAgICogKi9cbiAgc2VsZWN0UHJldmlvdXMoYW5jaG9yT2Zmc2V0LCBmb2N1c09mZnNldCkge1xuICAgIGVycm9yT25SZWFkT25seSgpO1xuICAgIGNvbnN0IHByZXZTaWJsaW5nID0gdGhpcy5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmdldFBhcmVudE9yVGhyb3coKTtcbiAgICBpZiAocHJldlNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBwYXJlbnQuc2VsZWN0KDAsIDApO1xuICAgIH1cbiAgICBpZiAoJGlzRWxlbWVudE5vZGUocHJldlNpYmxpbmcpKSB7XG4gICAgICByZXR1cm4gcHJldlNpYmxpbmcuc2VsZWN0KCk7XG4gICAgfSBlbHNlIGlmICghJGlzVGV4dE5vZGUocHJldlNpYmxpbmcpKSB7XG4gICAgICBjb25zdCBpbmRleCA9IHByZXZTaWJsaW5nLmdldEluZGV4V2l0aGluUGFyZW50KCkgKyAxO1xuICAgICAgcmV0dXJuIHBhcmVudC5zZWxlY3QoaW5kZXgsIGluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHByZXZTaWJsaW5nLnNlbGVjdChhbmNob3JPZmZzZXQsIGZvY3VzT2Zmc2V0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlcyBzZWxlY3Rpb24gdG8gdGhlIG5leHQgc2libGluZyBvZiB0aGlzIG5vZGUsIGF0IHRoZSBzcGVjaWZpZWQgb2Zmc2V0cy5cbiAgICpcbiAgICogQHBhcmFtIGFuY2hvck9mZnNldCAtIFRoZSBhbmNob3Igb2Zmc2V0IGZvciBzZWxlY3Rpb24uXG4gICAqIEBwYXJhbSBmb2N1c09mZnNldCAtICBUaGUgZm9jdXMgb2Zmc2V0IGZvciBzZWxlY3Rpb25cbiAgICogKi9cbiAgc2VsZWN0TmV4dChhbmNob3JPZmZzZXQsIGZvY3VzT2Zmc2V0KSB7XG4gICAgZXJyb3JPblJlYWRPbmx5KCk7XG4gICAgY29uc3QgbmV4dFNpYmxpbmcgPSB0aGlzLmdldE5leHRTaWJsaW5nKCk7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgaWYgKG5leHRTaWJsaW5nID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gcGFyZW50LnNlbGVjdCgpO1xuICAgIH1cbiAgICBpZiAoJGlzRWxlbWVudE5vZGUobmV4dFNpYmxpbmcpKSB7XG4gICAgICByZXR1cm4gbmV4dFNpYmxpbmcuc2VsZWN0KDAsIDApO1xuICAgIH0gZWxzZSBpZiAoISRpc1RleHROb2RlKG5leHRTaWJsaW5nKSkge1xuICAgICAgY29uc3QgaW5kZXggPSBuZXh0U2libGluZy5nZXRJbmRleFdpdGhpblBhcmVudCgpO1xuICAgICAgcmV0dXJuIHBhcmVudC5zZWxlY3QoaW5kZXgsIGluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIG5leHRTaWJsaW5nLnNlbGVjdChhbmNob3JPZmZzZXQsIGZvY3VzT2Zmc2V0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYXJrcyBhIG5vZGUgZGlydHksIHRyaWdnZXJpbmcgdHJhbnNmb3JtcyBhbmRcbiAgICogZm9yY2luZyBpdCB0byBiZSByZWNvbmNpbGVkIGR1cmluZyB0aGUgdXBkYXRlIGN5Y2xlLlxuICAgKlxuICAgKiAqL1xuICBtYXJrRGlydHkoKSB7XG4gICAgdGhpcy5nZXRXcml0YWJsZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKlxuICAgKiBXaGVuIHRoZSByZWNvbmNpbGVyIGRldGVjdHMgdGhhdCBhIG5vZGUgd2FzIG11dGF0ZWQsIHRoaXMgbWV0aG9kXG4gICAqIG1heSBiZSBjYWxsZWQgdG8gcmVzdG9yZSB0aGUgbm9kZSB0byBhIGtub3duIGdvb2Qgc3RhdGUuXG4gICAqL1xuICByZWNvbmNpbGVPYnNlcnZlZE11dGF0aW9uKGRvbSwgZWRpdG9yKSB7XG4gICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgfVxufVxuZnVuY3Rpb24gZXJyb3JPblR5cGVLbGFzc01pc21hdGNoKHR5cGUsIGtsYXNzKSB7XG4gIGNvbnN0IHJlZ2lzdGVyZWROb2RlID0gZ2V0QWN0aXZlRWRpdG9yKCkuX25vZGVzLmdldCh0eXBlKTtcbiAgLy8gQ29tbW9uIGVycm9yIC0gc3BsaXQgaW4gaXRzIG93biBpbnZhcmlhbnRcbiAgaWYgKHJlZ2lzdGVyZWROb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgQ3JlYXRlIG5vZGU6IEF0dGVtcHRlZCB0byBjcmVhdGUgbm9kZSAke2tsYXNzLm5hbWV9IHRoYXQgd2FzIG5vdCBjb25maWd1cmVkIHRvIGJlIHVzZWQgb24gdGhlIGVkaXRvci5gKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZWRpdG9yS2xhc3MgPSByZWdpc3RlcmVkTm9kZS5rbGFzcztcbiAgaWYgKGVkaXRvcktsYXNzICE9PSBrbGFzcykge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGBDcmVhdGUgbm9kZTogVHlwZSAke3R5cGV9IGluIG5vZGUgJHtrbGFzcy5uYW1lfSBkb2VzIG5vdCBtYXRjaCByZWdpc3RlcmVkIG5vZGUgJHtlZGl0b3JLbGFzcy5uYW1lfSB3aXRoIHRoZSBzYW1lIHR5cGVgKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBJbnNlcnQgYSBzZXJpZXMgb2Ygbm9kZXMgYWZ0ZXIgdGhpcyBMZXhpY2FsTm9kZSAoYXMgbmV4dCBzaWJsaW5ncylcbiAqXG4gKiBAcGFyYW0gZmlyc3RUb0luc2VydCAtIFRoZSBmaXJzdCBub2RlIHRvIGluc2VydCBhZnRlciB0aGlzIG9uZS5cbiAqIEBwYXJhbSBsYXN0VG9JbnNlcnQgLSBUaGUgbGFzdCBub2RlIHRvIGluc2VydCBhZnRlciB0aGlzIG9uZS4gTXVzdCBiZSBhXG4gKiBsYXRlciBzaWJsaW5nIG9mIEZpcnN0Tm9kZS4gSWYgbm90IHByb3ZpZGVkLCBpdCB3aWxsIGJlIGl0cyBsYXN0IHNpYmxpbmcuXG4gKi9cbmZ1bmN0aW9uIGluc2VydFJhbmdlQWZ0ZXIobm9kZSwgZmlyc3RUb0luc2VydCwgbGFzdFRvSW5zZXJ0KSB7XG4gIGNvbnN0IGxhc3RUb0luc2VydDIgPSBmaXJzdFRvSW5zZXJ0LmdldFBhcmVudE9yVGhyb3coKS5nZXRMYXN0Q2hpbGQoKTtcbiAgbGV0IGN1cnJlbnQgPSBmaXJzdFRvSW5zZXJ0O1xuICBjb25zdCBub2Rlc1RvSW5zZXJ0ID0gW2ZpcnN0VG9JbnNlcnRdO1xuICB3aGlsZSAoY3VycmVudCAhPT0gbGFzdFRvSW5zZXJ0Mikge1xuICAgIGlmICghY3VycmVudC5nZXROZXh0U2libGluZygpKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKGBpbnNlcnRSYW5nZUFmdGVyOiBsYXN0VG9JbnNlcnQgbXVzdCBiZSBhIGxhdGVyIHNpYmxpbmcgb2YgZmlyc3RUb0luc2VydGApO1xuICAgICAgfVxuICAgIH1cbiAgICBjdXJyZW50ID0gY3VycmVudC5nZXROZXh0U2libGluZygpO1xuICAgIG5vZGVzVG9JbnNlcnQucHVzaChjdXJyZW50KTtcbiAgfVxuICBsZXQgY3VycmVudE5vZGUgPSBub2RlO1xuICBmb3IgKGNvbnN0IG5vZGVUb0luc2VydCBvZiBub2Rlc1RvSW5zZXJ0KSB7XG4gICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5pbnNlcnRBZnRlcihub2RlVG9JbnNlcnQpO1xuICB9XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLyoqIEBub0luaGVyaXREb2MgKi9cbmNsYXNzIExpbmVCcmVha05vZGUgZXh0ZW5kcyBMZXhpY2FsTm9kZSB7XG4gIHN0YXRpYyBnZXRUeXBlKCkge1xuICAgIHJldHVybiAnbGluZWJyZWFrJztcbiAgfVxuICBzdGF0aWMgY2xvbmUobm9kZSkge1xuICAgIHJldHVybiBuZXcgTGluZUJyZWFrTm9kZShub2RlLl9fa2V5KTtcbiAgfVxuICBjb25zdHJ1Y3RvcihrZXkpIHtcbiAgICBzdXBlcihrZXkpO1xuICB9XG4gIGdldFRleHRDb250ZW50KCkge1xuICAgIHJldHVybiAnXFxuJztcbiAgfVxuICBjcmVhdGVET00oKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2JyJyk7XG4gIH1cbiAgdXBkYXRlRE9NKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGF0aWMgaW1wb3J0RE9NKCkge1xuICAgIHJldHVybiB7XG4gICAgICBicjogbm9kZSA9PiB7XG4gICAgICAgIGlmIChpc09ubHlDaGlsZEluQmxvY2tOb2RlKG5vZGUpIHx8IGlzTGFzdENoaWxkSW5CbG9ja05vZGUobm9kZSkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNvbnZlcnNpb246ICRjb252ZXJ0TGluZUJyZWFrRWxlbWVudCxcbiAgICAgICAgICBwcmlvcml0eTogMFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgc3RhdGljIGltcG9ydEpTT04oc2VyaWFsaXplZExpbmVCcmVha05vZGUpIHtcbiAgICByZXR1cm4gJGNyZWF0ZUxpbmVCcmVha05vZGUoKS51cGRhdGVGcm9tSlNPTihzZXJpYWxpemVkTGluZUJyZWFrTm9kZSk7XG4gIH1cbn1cbmZ1bmN0aW9uICRjb252ZXJ0TGluZUJyZWFrRWxlbWVudChub2RlKSB7XG4gIHJldHVybiB7XG4gICAgbm9kZTogJGNyZWF0ZUxpbmVCcmVha05vZGUoKVxuICB9O1xufVxuZnVuY3Rpb24gJGNyZWF0ZUxpbmVCcmVha05vZGUoKSB7XG4gIHJldHVybiAkYXBwbHlOb2RlUmVwbGFjZW1lbnQobmV3IExpbmVCcmVha05vZGUoKSk7XG59XG5mdW5jdGlvbiAkaXNMaW5lQnJlYWtOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBMaW5lQnJlYWtOb2RlO1xufVxuZnVuY3Rpb24gaXNPbmx5Q2hpbGRJbkJsb2NrTm9kZShub2RlKSB7XG4gIGNvbnN0IHBhcmVudEVsZW1lbnQgPSBub2RlLnBhcmVudEVsZW1lbnQ7XG4gIGlmIChwYXJlbnRFbGVtZW50ICE9PSBudWxsICYmIGlzQmxvY2tEb21Ob2RlKHBhcmVudEVsZW1lbnQpKSB7XG4gICAgY29uc3QgZmlyc3RDaGlsZCA9IHBhcmVudEVsZW1lbnQuZmlyc3RDaGlsZDtcbiAgICBpZiAoZmlyc3RDaGlsZCA9PT0gbm9kZSB8fCBmaXJzdENoaWxkLm5leHRTaWJsaW5nID09PSBub2RlICYmIGlzV2hpdGVzcGFjZURvbVRleHROb2RlKGZpcnN0Q2hpbGQpKSB7XG4gICAgICBjb25zdCBsYXN0Q2hpbGQgPSBwYXJlbnRFbGVtZW50Lmxhc3RDaGlsZDtcbiAgICAgIGlmIChsYXN0Q2hpbGQgPT09IG5vZGUgfHwgbGFzdENoaWxkLnByZXZpb3VzU2libGluZyA9PT0gbm9kZSAmJiBpc1doaXRlc3BhY2VEb21UZXh0Tm9kZShsYXN0Q2hpbGQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc0xhc3RDaGlsZEluQmxvY2tOb2RlKG5vZGUpIHtcbiAgY29uc3QgcGFyZW50RWxlbWVudCA9IG5vZGUucGFyZW50RWxlbWVudDtcbiAgaWYgKHBhcmVudEVsZW1lbnQgIT09IG51bGwgJiYgaXNCbG9ja0RvbU5vZGUocGFyZW50RWxlbWVudCkpIHtcbiAgICAvLyBjaGVjayBpZiBub2RlIGlzIGZpcnN0IGNoaWxkLCBiZWNhdXNlIG9ubHkgY2hpbGRzIGRvbnQgY291bnRcbiAgICBjb25zdCBmaXJzdENoaWxkID0gcGFyZW50RWxlbWVudC5maXJzdENoaWxkO1xuICAgIGlmIChmaXJzdENoaWxkID09PSBub2RlIHx8IGZpcnN0Q2hpbGQubmV4dFNpYmxpbmcgPT09IG5vZGUgJiYgaXNXaGl0ZXNwYWNlRG9tVGV4dE5vZGUoZmlyc3RDaGlsZCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBpZiBpdHMgbGFzdCBjaGlsZFxuICAgIGNvbnN0IGxhc3RDaGlsZCA9IHBhcmVudEVsZW1lbnQubGFzdENoaWxkO1xuICAgIGlmIChsYXN0Q2hpbGQgPT09IG5vZGUgfHwgbGFzdENoaWxkLnByZXZpb3VzU2libGluZyA9PT0gbm9kZSAmJiBpc1doaXRlc3BhY2VEb21UZXh0Tm9kZShsYXN0Q2hpbGQpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlRG9tVGV4dE5vZGUobm9kZSkge1xuICByZXR1cm4gaXNET01UZXh0Tm9kZShub2RlKSAmJiAvXiggfFxcdHxcXHI/XFxuKSskLy50ZXN0KG5vZGUudGV4dENvbnRlbnQgfHwgJycpO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uIGdldEVsZW1lbnRPdXRlclRhZyhub2RlLCBmb3JtYXQpIHtcbiAgaWYgKGZvcm1hdCAmIElTX0NPREUpIHtcbiAgICByZXR1cm4gJ2NvZGUnO1xuICB9XG4gIGlmIChmb3JtYXQgJiBJU19ISUdITElHSFQpIHtcbiAgICByZXR1cm4gJ21hcmsnO1xuICB9XG4gIGlmIChmb3JtYXQgJiBJU19TVUJTQ1JJUFQpIHtcbiAgICByZXR1cm4gJ3N1Yic7XG4gIH1cbiAgaWYgKGZvcm1hdCAmIElTX1NVUEVSU0NSSVBUKSB7XG4gICAgcmV0dXJuICdzdXAnO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0RWxlbWVudElubmVyVGFnKG5vZGUsIGZvcm1hdCkge1xuICBpZiAoZm9ybWF0ICYgSVNfQk9MRCkge1xuICAgIHJldHVybiAnc3Ryb25nJztcbiAgfVxuICBpZiAoZm9ybWF0ICYgSVNfSVRBTElDKSB7XG4gICAgcmV0dXJuICdlbSc7XG4gIH1cbiAgcmV0dXJuICdzcGFuJztcbn1cbmZ1bmN0aW9uIHNldFRleHRUaGVtZUNsYXNzTmFtZXModGFnLCBwcmV2Rm9ybWF0LCBuZXh0Rm9ybWF0LCBkb20sIHRleHRDbGFzc05hbWVzKSB7XG4gIGNvbnN0IGRvbUNsYXNzTGlzdCA9IGRvbS5jbGFzc0xpc3Q7XG4gIC8vIEZpcnN0bHkgd2UgaGFuZGxlIHRoZSBiYXNlIHRoZW1lLlxuICBsZXQgY2xhc3NOYW1lcyA9IGdldENhY2hlZENsYXNzTmFtZUFycmF5KHRleHRDbGFzc05hbWVzLCAnYmFzZScpO1xuICBpZiAoY2xhc3NOYW1lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZG9tQ2xhc3NMaXN0LmFkZCguLi5jbGFzc05hbWVzKTtcbiAgfVxuICAvLyBTZWNvbmRseSB3ZSBoYW5kbGUgdGhlIHNwZWNpYWwgY2FzZTogdW5kZXJsaW5lICsgc3RyaWtldGhyb3VnaC5cbiAgLy8gV2UgaGF2ZSB0byBkbyB0aGlzIGFzIHdlIG5lZWQgYSB3YXkgdG8gY29tcG9zZSB0aGUgZmFjdCB0aGF0XG4gIC8vIHRoZSBzYW1lIENTUyBwcm9wZXJ0eSB3aWxsIG5lZWQgdG8gYmUgdXNlZDogdGV4dC1kZWNvcmF0aW9uLlxuICAvLyBJbiBhbiBpZGVhbCB3b3JsZCB3ZSBzaG91bGRuJ3QgaGF2ZSB0byBkbyB0aGlzLCBidXQgdGhlcmUncyBub1xuICAvLyBlYXN5IHdvcmthcm91bmQgZm9yIG1hbnkgYXRvbWljIENTUyBzeXN0ZW1zIHRvZGF5LlxuICBjbGFzc05hbWVzID0gZ2V0Q2FjaGVkQ2xhc3NOYW1lQXJyYXkodGV4dENsYXNzTmFtZXMsICd1bmRlcmxpbmVTdHJpa2V0aHJvdWdoJyk7XG4gIGxldCBoYXNVbmRlcmxpbmVTdHJpa2V0aHJvdWdoID0gZmFsc2U7XG4gIGNvbnN0IHByZXZVbmRlcmxpbmVTdHJpa2V0aHJvdWdoID0gcHJldkZvcm1hdCAmIElTX1VOREVSTElORSAmJiBwcmV2Rm9ybWF0ICYgSVNfU1RSSUtFVEhST1VHSDtcbiAgY29uc3QgbmV4dFVuZGVybGluZVN0cmlrZXRocm91Z2ggPSBuZXh0Rm9ybWF0ICYgSVNfVU5ERVJMSU5FICYmIG5leHRGb3JtYXQgJiBJU19TVFJJS0VUSFJPVUdIO1xuICBpZiAoY2xhc3NOYW1lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKG5leHRVbmRlcmxpbmVTdHJpa2V0aHJvdWdoKSB7XG4gICAgICBoYXNVbmRlcmxpbmVTdHJpa2V0aHJvdWdoID0gdHJ1ZTtcbiAgICAgIGlmICghcHJldlVuZGVybGluZVN0cmlrZXRocm91Z2gpIHtcbiAgICAgICAgZG9tQ2xhc3NMaXN0LmFkZCguLi5jbGFzc05hbWVzKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByZXZVbmRlcmxpbmVTdHJpa2V0aHJvdWdoKSB7XG4gICAgICBkb21DbGFzc0xpc3QucmVtb3ZlKC4uLmNsYXNzTmFtZXMpO1xuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IGtleSBpbiBURVhUX1RZUEVfVE9fRk9STUFUKSB7XG4gICAgY29uc3QgZm9ybWF0ID0ga2V5O1xuICAgIGNvbnN0IGZsYWcgPSBURVhUX1RZUEVfVE9fRk9STUFUW2Zvcm1hdF07XG4gICAgY2xhc3NOYW1lcyA9IGdldENhY2hlZENsYXNzTmFtZUFycmF5KHRleHRDbGFzc05hbWVzLCBrZXkpO1xuICAgIGlmIChjbGFzc05hbWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChuZXh0Rm9ybWF0ICYgZmxhZykge1xuICAgICAgICBpZiAoaGFzVW5kZXJsaW5lU3RyaWtldGhyb3VnaCAmJiAoa2V5ID09PSAndW5kZXJsaW5lJyB8fCBrZXkgPT09ICdzdHJpa2V0aHJvdWdoJykpIHtcbiAgICAgICAgICBpZiAocHJldkZvcm1hdCAmIGZsYWcpIHtcbiAgICAgICAgICAgIGRvbUNsYXNzTGlzdC5yZW1vdmUoLi4uY2xhc3NOYW1lcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICgocHJldkZvcm1hdCAmIGZsYWcpID09PSAwIHx8IHByZXZVbmRlcmxpbmVTdHJpa2V0aHJvdWdoICYmIGtleSA9PT0gJ3VuZGVybGluZScgfHwga2V5ID09PSAnc3RyaWtldGhyb3VnaCcpIHtcbiAgICAgICAgICBkb21DbGFzc0xpc3QuYWRkKC4uLmNsYXNzTmFtZXMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHByZXZGb3JtYXQgJiBmbGFnKSB7XG4gICAgICAgIGRvbUNsYXNzTGlzdC5yZW1vdmUoLi4uY2xhc3NOYW1lcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkaWZmQ29tcG9zZWRUZXh0KGEsIGIpIHtcbiAgY29uc3QgYUxlbmd0aCA9IGEubGVuZ3RoO1xuICBjb25zdCBiTGVuZ3RoID0gYi5sZW5ndGg7XG4gIGxldCBsZWZ0ID0gMDtcbiAgbGV0IHJpZ2h0ID0gMDtcbiAgd2hpbGUgKGxlZnQgPCBhTGVuZ3RoICYmIGxlZnQgPCBiTGVuZ3RoICYmIGFbbGVmdF0gPT09IGJbbGVmdF0pIHtcbiAgICBsZWZ0Kys7XG4gIH1cbiAgd2hpbGUgKHJpZ2h0ICsgbGVmdCA8IGFMZW5ndGggJiYgcmlnaHQgKyBsZWZ0IDwgYkxlbmd0aCAmJiBhW2FMZW5ndGggLSByaWdodCAtIDFdID09PSBiW2JMZW5ndGggLSByaWdodCAtIDFdKSB7XG4gICAgcmlnaHQrKztcbiAgfVxuICByZXR1cm4gW2xlZnQsIGFMZW5ndGggLSBsZWZ0IC0gcmlnaHQsIGIuc2xpY2UobGVmdCwgYkxlbmd0aCAtIHJpZ2h0KV07XG59XG5mdW5jdGlvbiBzZXRUZXh0Q29udGVudChuZXh0VGV4dCwgZG9tLCBub2RlKSB7XG4gIGNvbnN0IGZpcnN0Q2hpbGQgPSBkb20uZmlyc3RDaGlsZDtcbiAgY29uc3QgaXNDb21wb3NpbmcgPSBub2RlLmlzQ29tcG9zaW5nKCk7XG4gIC8vIEFsd2F5cyBhZGQgYSBzdWZmaXggaWYgd2UncmUgY29tcG9zaW5nIGEgbm9kZVxuICBjb25zdCBzdWZmaXggPSBpc0NvbXBvc2luZyA/IENPTVBPU0lUSU9OX1NVRkZJWCA6ICcnO1xuICBjb25zdCB0ZXh0ID0gbmV4dFRleHQgKyBzdWZmaXg7XG4gIGlmIChmaXJzdENoaWxkID09IG51bGwpIHtcbiAgICBkb20udGV4dENvbnRlbnQgPSB0ZXh0O1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG5vZGVWYWx1ZSA9IGZpcnN0Q2hpbGQubm9kZVZhbHVlO1xuICAgIGlmIChub2RlVmFsdWUgIT09IHRleHQpIHtcbiAgICAgIGlmIChpc0NvbXBvc2luZyB8fCBJU19GSVJFRk9YKSB7XG4gICAgICAgIC8vIFdlIGFsc28gdXNlIHRoZSBkaWZmIGNvbXBvc2VkIHRleHQgZm9yIGdlbmVyYWwgdGV4dCBpbiBGRiB0byBhdm9pZFxuICAgICAgICAvLyB0aGUgc3BlbGxjaGVjayByZWQgbGluZSBmcm9tIGZsaWNrZXJpbmcuXG4gICAgICAgIGNvbnN0IFtpbmRleCwgcmVtb3ZlLCBpbnNlcnRdID0gZGlmZkNvbXBvc2VkVGV4dChub2RlVmFsdWUsIHRleHQpO1xuICAgICAgICBpZiAocmVtb3ZlICE9PSAwKSB7XG4gICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgIGZpcnN0Q2hpbGQuZGVsZXRlRGF0YShpbmRleCwgcmVtb3ZlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGZpcnN0Q2hpbGQuaW5zZXJ0RGF0YShpbmRleCwgaW5zZXJ0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpcnN0Q2hpbGQubm9kZVZhbHVlID0gdGV4dDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVRleHRJbm5lckRPTShpbm5lckRPTSwgbm9kZSwgaW5uZXJUYWcsIGZvcm1hdCwgdGV4dCwgY29uZmlnKSB7XG4gIHNldFRleHRDb250ZW50KHRleHQsIGlubmVyRE9NLCBub2RlKTtcbiAgY29uc3QgdGhlbWUgPSBjb25maWcudGhlbWU7XG4gIC8vIEFwcGx5IHRoZW1lIGNsYXNzIG5hbWVzXG4gIGNvbnN0IHRleHRDbGFzc05hbWVzID0gdGhlbWUudGV4dDtcbiAgaWYgKHRleHRDbGFzc05hbWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICBzZXRUZXh0VGhlbWVDbGFzc05hbWVzKGlubmVyVGFnLCAwLCBmb3JtYXQsIGlubmVyRE9NLCB0ZXh0Q2xhc3NOYW1lcyk7XG4gIH1cbn1cbmZ1bmN0aW9uIHdyYXBFbGVtZW50V2l0aChlbGVtZW50LCB0YWcpIHtcbiAgY29uc3QgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gIGVsLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICByZXR1cm4gZWw7XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWRlY2xhcmF0aW9uLW1lcmdpbmdcblxuLyoqIEBub0luaGVyaXREb2MgKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWRlY2xhcmF0aW9uLW1lcmdpbmdcbmNsYXNzIFRleHROb2RlIGV4dGVuZHMgTGV4aWNhbE5vZGUge1xuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgc3RhdGljIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuICd0ZXh0JztcbiAgfVxuICBzdGF0aWMgY2xvbmUobm9kZSkge1xuICAgIHJldHVybiBuZXcgVGV4dE5vZGUobm9kZS5fX3RleHQsIG5vZGUuX19rZXkpO1xuICB9XG4gIGFmdGVyQ2xvbmVGcm9tKHByZXZOb2RlKSB7XG4gICAgc3VwZXIuYWZ0ZXJDbG9uZUZyb20ocHJldk5vZGUpO1xuICAgIHRoaXMuX190ZXh0ID0gcHJldk5vZGUuX190ZXh0O1xuICAgIHRoaXMuX19mb3JtYXQgPSBwcmV2Tm9kZS5fX2Zvcm1hdDtcbiAgICB0aGlzLl9fc3R5bGUgPSBwcmV2Tm9kZS5fX3N0eWxlO1xuICAgIHRoaXMuX19tb2RlID0gcHJldk5vZGUuX19tb2RlO1xuICAgIHRoaXMuX19kZXRhaWwgPSBwcmV2Tm9kZS5fX2RldGFpbDtcbiAgfVxuICBjb25zdHJ1Y3Rvcih0ZXh0ID0gJycsIGtleSkge1xuICAgIHN1cGVyKGtleSk7XG4gICAgdGhpcy5fX3RleHQgPSB0ZXh0O1xuICAgIHRoaXMuX19mb3JtYXQgPSAwO1xuICAgIHRoaXMuX19zdHlsZSA9ICcnO1xuICAgIHRoaXMuX19tb2RlID0gMDtcbiAgICB0aGlzLl9fZGV0YWlsID0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgMzItYml0IGludGVnZXIgdGhhdCByZXByZXNlbnRzIHRoZSBUZXh0Rm9ybWF0VHlwZXMgY3VycmVudGx5IGFwcGxpZWQgdG8gdGhlXG4gICAqIFRleHROb2RlLiBZb3UgcHJvYmFibHkgZG9uJ3Qgd2FudCB0byB1c2UgdGhpcyBtZXRob2QgZGlyZWN0bHkgLSBjb25zaWRlciB1c2luZyBUZXh0Tm9kZS5oYXNGb3JtYXQgaW5zdGVhZC5cbiAgICpcbiAgICogQHJldHVybnMgYSBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSBmb3JtYXQgb2YgdGhlIHRleHQgbm9kZS5cbiAgICovXG4gIGdldEZvcm1hdCgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICByZXR1cm4gc2VsZi5fX2Zvcm1hdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgMzItYml0IGludGVnZXIgdGhhdCByZXByZXNlbnRzIHRoZSBUZXh0RGV0YWlsVHlwZXMgY3VycmVudGx5IGFwcGxpZWQgdG8gdGhlXG4gICAqIFRleHROb2RlLiBZb3UgcHJvYmFibHkgZG9uJ3Qgd2FudCB0byB1c2UgdGhpcyBtZXRob2QgZGlyZWN0bHkgLSBjb25zaWRlciB1c2luZyBUZXh0Tm9kZS5pc0RpcmVjdGlvbmxlc3NcbiAgICogb3IgVGV4dE5vZGUuaXNVbm1lcmdlYWJsZSBpbnN0ZWFkLlxuICAgKlxuICAgKiBAcmV0dXJucyBhIG51bWJlciByZXByZXNlbnRpbmcgdGhlIGRldGFpbCBvZiB0aGUgdGV4dCBub2RlLlxuICAgKi9cbiAgZ2V0RGV0YWlsKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIHJldHVybiBzZWxmLl9fZGV0YWlsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG1vZGUgKFRleHRNb2RlVHlwZSkgb2YgdGhlIFRleHROb2RlLCB3aGljaCBtYXkgYmUgXCJub3JtYWxcIiwgXCJ0b2tlblwiLCBvciBcInNlZ21lbnRlZFwiXG4gICAqXG4gICAqIEByZXR1cm5zIFRleHRNb2RlVHlwZS5cbiAgICovXG4gIGdldE1vZGUoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0TGF0ZXN0KCk7XG4gICAgcmV0dXJuIFRFWFRfVFlQRV9UT19NT0RFW3NlbGYuX19tb2RlXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdHlsZXMgY3VycmVudGx5IGFwcGxpZWQgdG8gdGhlIG5vZGUuIFRoaXMgaXMgYW5hbG9nb3VzIHRvIENTU1RleHQgaW4gdGhlIERPTS5cbiAgICpcbiAgICogQHJldHVybnMgQ1NTVGV4dC1saWtlIHN0cmluZyBvZiBzdHlsZXMgYXBwbGllZCB0byB0aGUgdW5kZXJseWluZyBET00gbm9kZS5cbiAgICovXG4gIGdldFN0eWxlKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIHJldHVybiBzZWxmLl9fc3R5bGU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBpbiBcInRva2VuXCIgbW9kZS4gVGV4dE5vZGVzIGluIHRva2VuIG1vZGUgY2FuIGJlIG5hdmlnYXRlZCB0aHJvdWdoIGNoYXJhY3Rlci1ieS1jaGFyYWN0ZXJcbiAgICogd2l0aCBhIFJhbmdlU2VsZWN0aW9uLCBidXQgYXJlIGRlbGV0ZWQgYXMgYSBzaW5nbGUgZW50aXR5IChub3QgaW52ZGl2aWR1YWxseSBieSBjaGFyYWN0ZXIpLlxuICAgKlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBub2RlIGlzIGluIHRva2VuIG1vZGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGlzVG9rZW4oKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0TGF0ZXN0KCk7XG4gICAgcmV0dXJuIHNlbGYuX19tb2RlID09PSBJU19UT0tFTjtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIExleGljYWwgZGV0ZWN0cyB0aGF0IGFuIElNRSBvciBvdGhlciAzcmQtcGFydHkgc2NyaXB0IGlzIGF0dGVtcHRpbmcgdG9cbiAgICogbXV0YXRlIHRoZSBUZXh0Tm9kZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgaXNDb21wb3NpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19rZXkgPT09ICRnZXRDb21wb3NpdGlvbktleSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG5vZGUgaXMgaW4gXCJzZWdlbWVudGVkXCIgbW9kZS4gVGV4dE5vZGVzIGluIHNlZ2VtZW50ZWQgbW9kZSBjYW4gYmUgbmF2aWdhdGVkIHRocm91Z2ggY2hhcmFjdGVyLWJ5LWNoYXJhY3RlclxuICAgKiB3aXRoIGEgUmFuZ2VTZWxlY3Rpb24sIGJ1dCBhcmUgZGVsZXRlZCBpbiBzcGFjZS1kZWxpbWl0ZWQgXCJzZWdtZW50c1wiLlxuICAgKlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBub2RlIGlzIGluIHNlZ21lbnRlZCBtb2RlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBpc1NlZ21lbnRlZCgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICByZXR1cm4gc2VsZi5fX21vZGUgPT09IElTX1NFR01FTlRFRDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBcImRpcmVjdGlvbmxlc3NcIi4gRGlyZWN0aW9ubGVzcyBub2RlcyBkb24ndCByZXNwZWN0IGNoYW5nZXMgYmV0d2VlbiBSVEwgYW5kIExUUiBtb2Rlcy5cbiAgICpcbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgbm9kZSBpcyBkaXJlY3Rpb25sZXNzLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBpc0RpcmVjdGlvbmxlc3MoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0TGF0ZXN0KCk7XG4gICAgcmV0dXJuIChzZWxmLl9fZGV0YWlsICYgSVNfRElSRUNUSU9OTEVTUykgIT09IDA7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG5vZGUgaXMgdW5tZXJnZWFibGUuIEluIHNvbWUgc2NlbmFyaW9zLCBMZXhpY2FsIHRyaWVzIHRvIG1lcmdlXG4gICAqIGFkamFjZW50IFRleHROb2RlcyBpbnRvIGEgc2luZ2xlIFRleHROb2RlLiBJZiBhIFRleHROb2RlIGlzIHVubWVyZ2VhYmxlLCB0aGlzIHdvbid0IGhhcHBlbi5cbiAgICpcbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgbm9kZSBpcyB1bm1lcmdlYWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgaXNVbm1lcmdlYWJsZSgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICByZXR1cm4gKHNlbGYuX19kZXRhaWwgJiBJU19VTk1FUkdFQUJMRSkgIT09IDA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBoYXMgdGhlIHByb3ZpZGVkIGZvcm1hdCBhcHBsaWVkLiBVc2UgdGhpcyB3aXRoIHRoZSBodW1hbi1yZWFkYWJsZSBUZXh0Rm9ybWF0VHlwZVxuICAgKiBzdHJpbmcgdmFsdWVzIHRvIGdldCB0aGUgZm9ybWF0IG9mIGEgVGV4dE5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB0eXBlIC0gdGhlIFRleHRGb3JtYXRUeXBlIHRvIGNoZWNrIGZvci5cbiAgICpcbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgbm9kZSBoYXMgdGhlIHByb3ZpZGVkIGZvcm1hdCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgaGFzRm9ybWF0KHR5cGUpIHtcbiAgICBjb25zdCBmb3JtYXRGbGFnID0gVEVYVF9UWVBFX1RPX0ZPUk1BVFt0eXBlXTtcbiAgICByZXR1cm4gKHRoaXMuZ2V0Rm9ybWF0KCkgJiBmb3JtYXRGbGFnKSAhPT0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIHNpbXBsZSB0ZXh0LiBTaW1wbGUgdGV4dCBpcyBkZWZpbmVkIGFzIGEgVGV4dE5vZGUgdGhhdCBoYXMgdGhlIHN0cmluZyB0eXBlIFwidGV4dFwiXG4gICAqIChpLmUuLCBub3QgYSBzdWJjbGFzcykgYW5kIGhhcyBubyBtb2RlIGFwcGxpZWQgdG8gaXQgKGkuZS4sIG5vdCBzZWdtZW50ZWQgb3IgdG9rZW4pLlxuICAgKlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBub2RlIGlzIHNpbXBsZSB0ZXh0LCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBpc1NpbXBsZVRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX190eXBlID09PSAndGV4dCcgJiYgdGhpcy5fX21vZGUgPT09IDA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdGV4dCBjb250ZW50IG9mIHRoZSBub2RlIGFzIGEgc3RyaW5nLlxuICAgKlxuICAgKiBAcmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHRleHQgY29udGVudCBvZiB0aGUgbm9kZS5cbiAgICovXG4gIGdldFRleHRDb250ZW50KCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIHJldHVybiBzZWxmLl9fdGV4dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmb3JtYXQgZmxhZ3MgYXBwbGllZCB0byB0aGUgbm9kZSBhcyBhIDMyLWJpdCBpbnRlZ2VyLlxuICAgKlxuICAgKiBAcmV0dXJucyBhIG51bWJlciByZXByZXNlbnRpbmcgdGhlIFRleHRGb3JtYXRUeXBlcyBhcHBsaWVkIHRvIHRoZSBub2RlLlxuICAgKi9cbiAgZ2V0Rm9ybWF0RmxhZ3ModHlwZSwgYWxpZ25XaXRoRm9ybWF0KSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0TGF0ZXN0KCk7XG4gICAgY29uc3QgZm9ybWF0ID0gc2VsZi5fX2Zvcm1hdDtcbiAgICByZXR1cm4gdG9nZ2xlVGV4dEZvcm1hdFR5cGUoZm9ybWF0LCB0eXBlLCBhbGlnbldpdGhGb3JtYXQpO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHRleHQgbm9kZSBzdXBwb3J0cyBmb250IHN0eWxpbmcsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGNhbkhhdmVGb3JtYXQoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBWaWV3XG5cbiAgY3JlYXRlRE9NKGNvbmZpZywgZWRpdG9yKSB7XG4gICAgY29uc3QgZm9ybWF0ID0gdGhpcy5fX2Zvcm1hdDtcbiAgICBjb25zdCBvdXRlclRhZyA9IGdldEVsZW1lbnRPdXRlclRhZyh0aGlzLCBmb3JtYXQpO1xuICAgIGNvbnN0IGlubmVyVGFnID0gZ2V0RWxlbWVudElubmVyVGFnKHRoaXMsIGZvcm1hdCk7XG4gICAgY29uc3QgdGFnID0gb3V0ZXJUYWcgPT09IG51bGwgPyBpbm5lclRhZyA6IG91dGVyVGFnO1xuICAgIGNvbnN0IGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICBsZXQgaW5uZXJET00gPSBkb207XG4gICAgaWYgKHRoaXMuaGFzRm9ybWF0KCdjb2RlJykpIHtcbiAgICAgIGRvbS5zZXRBdHRyaWJ1dGUoJ3NwZWxsY2hlY2snLCAnZmFsc2UnKTtcbiAgICB9XG4gICAgaWYgKG91dGVyVGFnICE9PSBudWxsKSB7XG4gICAgICBpbm5lckRPTSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaW5uZXJUYWcpO1xuICAgICAgZG9tLmFwcGVuZENoaWxkKGlubmVyRE9NKTtcbiAgICB9XG4gICAgY29uc3QgdGV4dCA9IHRoaXMuX190ZXh0O1xuICAgIGNyZWF0ZVRleHRJbm5lckRPTShpbm5lckRPTSwgdGhpcywgaW5uZXJUYWcsIGZvcm1hdCwgdGV4dCwgY29uZmlnKTtcbiAgICBjb25zdCBzdHlsZSA9IHRoaXMuX19zdHlsZTtcbiAgICBpZiAoc3R5bGUgIT09ICcnKSB7XG4gICAgICBkb20uc3R5bGUuY3NzVGV4dCA9IHN0eWxlO1xuICAgIH1cbiAgICByZXR1cm4gZG9tO1xuICB9XG4gIHVwZGF0ZURPTShwcmV2Tm9kZSwgZG9tLCBjb25maWcpIHtcbiAgICBjb25zdCBuZXh0VGV4dCA9IHRoaXMuX190ZXh0O1xuICAgIGNvbnN0IHByZXZGb3JtYXQgPSBwcmV2Tm9kZS5fX2Zvcm1hdDtcbiAgICBjb25zdCBuZXh0Rm9ybWF0ID0gdGhpcy5fX2Zvcm1hdDtcbiAgICBjb25zdCBwcmV2T3V0ZXJUYWcgPSBnZXRFbGVtZW50T3V0ZXJUYWcodGhpcywgcHJldkZvcm1hdCk7XG4gICAgY29uc3QgbmV4dE91dGVyVGFnID0gZ2V0RWxlbWVudE91dGVyVGFnKHRoaXMsIG5leHRGb3JtYXQpO1xuICAgIGNvbnN0IHByZXZJbm5lclRhZyA9IGdldEVsZW1lbnRJbm5lclRhZyh0aGlzLCBwcmV2Rm9ybWF0KTtcbiAgICBjb25zdCBuZXh0SW5uZXJUYWcgPSBnZXRFbGVtZW50SW5uZXJUYWcodGhpcywgbmV4dEZvcm1hdCk7XG4gICAgY29uc3QgcHJldlRhZyA9IHByZXZPdXRlclRhZyA9PT0gbnVsbCA/IHByZXZJbm5lclRhZyA6IHByZXZPdXRlclRhZztcbiAgICBjb25zdCBuZXh0VGFnID0gbmV4dE91dGVyVGFnID09PSBudWxsID8gbmV4dElubmVyVGFnIDogbmV4dE91dGVyVGFnO1xuICAgIGlmIChwcmV2VGFnICE9PSBuZXh0VGFnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHByZXZPdXRlclRhZyA9PT0gbmV4dE91dGVyVGFnICYmIHByZXZJbm5lclRhZyAhPT0gbmV4dElubmVyVGFnKSB7XG4gICAgICAvLyBzaG91bGQgYWx3YXlzIGJlIGFuIGVsZW1lbnRcbiAgICAgIGNvbnN0IHByZXZJbm5lckRPTSA9IGRvbS5maXJzdENoaWxkO1xuICAgICAgaWYgKHByZXZJbm5lckRPTSA9PSBudWxsKSB7XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihgdXBkYXRlRE9NOiBwcmV2SW5uZXJET00gaXMgbnVsbCBvciB1bmRlZmluZWRgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgbmV4dElubmVyRE9NID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuZXh0SW5uZXJUYWcpO1xuICAgICAgY3JlYXRlVGV4dElubmVyRE9NKG5leHRJbm5lckRPTSwgdGhpcywgbmV4dElubmVyVGFnLCBuZXh0Rm9ybWF0LCBuZXh0VGV4dCwgY29uZmlnKTtcbiAgICAgIGRvbS5yZXBsYWNlQ2hpbGQobmV4dElubmVyRE9NLCBwcmV2SW5uZXJET00pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgaW5uZXJET00gPSBkb207XG4gICAgaWYgKG5leHRPdXRlclRhZyAhPT0gbnVsbCkge1xuICAgICAgaWYgKHByZXZPdXRlclRhZyAhPT0gbnVsbCkge1xuICAgICAgICBpbm5lckRPTSA9IGRvbS5maXJzdENoaWxkO1xuICAgICAgICBpZiAoaW5uZXJET00gPT0gbnVsbCkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGB1cGRhdGVET006IGlubmVyRE9NIGlzIG51bGwgb3IgdW5kZWZpbmVkYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHNldFRleHRDb250ZW50KG5leHRUZXh0LCBpbm5lckRPTSwgdGhpcyk7XG4gICAgY29uc3QgdGhlbWUgPSBjb25maWcudGhlbWU7XG4gICAgLy8gQXBwbHkgdGhlbWUgY2xhc3MgbmFtZXNcbiAgICBjb25zdCB0ZXh0Q2xhc3NOYW1lcyA9IHRoZW1lLnRleHQ7XG4gICAgaWYgKHRleHRDbGFzc05hbWVzICE9PSB1bmRlZmluZWQgJiYgcHJldkZvcm1hdCAhPT0gbmV4dEZvcm1hdCkge1xuICAgICAgc2V0VGV4dFRoZW1lQ2xhc3NOYW1lcyhuZXh0SW5uZXJUYWcsIHByZXZGb3JtYXQsIG5leHRGb3JtYXQsIGlubmVyRE9NLCB0ZXh0Q2xhc3NOYW1lcyk7XG4gICAgfVxuICAgIGNvbnN0IHByZXZTdHlsZSA9IHByZXZOb2RlLl9fc3R5bGU7XG4gICAgY29uc3QgbmV4dFN0eWxlID0gdGhpcy5fX3N0eWxlO1xuICAgIGlmIChwcmV2U3R5bGUgIT09IG5leHRTdHlsZSkge1xuICAgICAgZG9tLnN0eWxlLmNzc1RleHQgPSBuZXh0U3R5bGU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGF0aWMgaW1wb3J0RE9NKCkge1xuICAgIHJldHVybiB7XG4gICAgICAnI3RleHQnOiAoKSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiAkY29udmVydFRleHRET01Ob2RlLFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSksXG4gICAgICBiOiAoKSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiBjb252ZXJ0QnJpbmdBdHRlbnRpb25Ub0VsZW1lbnQsXG4gICAgICAgIHByaW9yaXR5OiAwXG4gICAgICB9KSxcbiAgICAgIGNvZGU6ICgpID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246IGNvbnZlcnRUZXh0Rm9ybWF0RWxlbWVudCxcbiAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgIH0pLFxuICAgICAgZW06ICgpID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246IGNvbnZlcnRUZXh0Rm9ybWF0RWxlbWVudCxcbiAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgIH0pLFxuICAgICAgaTogKCkgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogY29udmVydFRleHRGb3JtYXRFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSksXG4gICAgICBzOiAoKSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiBjb252ZXJ0VGV4dEZvcm1hdEVsZW1lbnQsXG4gICAgICAgIHByaW9yaXR5OiAwXG4gICAgICB9KSxcbiAgICAgIHNwYW46ICgpID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246IGNvbnZlcnRTcGFuRWxlbWVudCxcbiAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgIH0pLFxuICAgICAgc3Ryb25nOiAoKSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiBjb252ZXJ0VGV4dEZvcm1hdEVsZW1lbnQsXG4gICAgICAgIHByaW9yaXR5OiAwXG4gICAgICB9KSxcbiAgICAgIHN1YjogKCkgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogY29udmVydFRleHRGb3JtYXRFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSksXG4gICAgICBzdXA6ICgpID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246IGNvbnZlcnRUZXh0Rm9ybWF0RWxlbWVudCxcbiAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgIH0pLFxuICAgICAgdTogKCkgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogY29udmVydFRleHRGb3JtYXRFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSlcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBpbXBvcnRKU09OKHNlcmlhbGl6ZWROb2RlKSB7XG4gICAgcmV0dXJuICRjcmVhdGVUZXh0Tm9kZSgpLnVwZGF0ZUZyb21KU09OKHNlcmlhbGl6ZWROb2RlKTtcbiAgfVxuICB1cGRhdGVGcm9tSlNPTihzZXJpYWxpemVkTm9kZSkge1xuICAgIHJldHVybiBzdXBlci51cGRhdGVGcm9tSlNPTihzZXJpYWxpemVkTm9kZSkuc2V0VGV4dENvbnRlbnQoc2VyaWFsaXplZE5vZGUudGV4dCkuc2V0Rm9ybWF0KHNlcmlhbGl6ZWROb2RlLmZvcm1hdCkuc2V0RGV0YWlsKHNlcmlhbGl6ZWROb2RlLmRldGFpbCkuc2V0TW9kZShzZXJpYWxpemVkTm9kZS5tb2RlKS5zZXRTdHlsZShzZXJpYWxpemVkTm9kZS5zdHlsZSk7XG4gIH1cblxuICAvLyBUaGlzIGltcHJvdmVzIExleGljYWwncyBiYXNpYyB0ZXh0IG91dHB1dCBpbiBjb3B5K3Bhc3RlIHBsdXNcbiAgLy8gZm9yIGhlYWRsZXNzIG1vZGUgd2hlcmUgcGVvcGxlIG1pZ2h0IHVzZSBMZXhpY2FsIHRvIGdlbmVyYXRlXG4gIC8vIEhUTUwgY29udGVudCBhbmQgbm90IGhhdmUgdGhlIGFiaWxpdHkgdG8gdXNlIENTUyBjbGFzc2VzLlxuICBleHBvcnRET00oZWRpdG9yKSB7XG4gICAgbGV0IHtcbiAgICAgIGVsZW1lbnRcbiAgICB9ID0gc3VwZXIuZXhwb3J0RE9NKGVkaXRvcik7XG4gICAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgVGV4dE5vZGUgY3JlYXRlRE9NIHRvIGFsd2F5cyByZXR1cm4gYSBIVE1MRWxlbWVudGApO1xuICAgIH1cbiAgICBlbGVtZW50LnN0eWxlLndoaXRlU3BhY2UgPSAncHJlLXdyYXAnO1xuICAgIC8vIFRoaXMgaXMgdGhlIG9ubHkgd2F5IHRvIHByb3Blcmx5IGFkZCBzdXBwb3J0IGZvciBtb3N0IGNsaWVudHMsXG4gICAgLy8gZXZlbiBpZiBpdCdzIHNlbWFudGljYWxseSBpbmNvcnJlY3QgdG8gaGF2ZSB0byByZXNvcnQgdG8gdXNpbmdcbiAgICAvLyA8Yj4sIDx1PiwgPHM+LCA8aT4gZWxlbWVudHMuXG4gICAgaWYgKHRoaXMuaGFzRm9ybWF0KCdib2xkJykpIHtcbiAgICAgIGVsZW1lbnQgPSB3cmFwRWxlbWVudFdpdGgoZWxlbWVudCwgJ2InKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaGFzRm9ybWF0KCdpdGFsaWMnKSkge1xuICAgICAgZWxlbWVudCA9IHdyYXBFbGVtZW50V2l0aChlbGVtZW50LCAnaScpO1xuICAgIH1cbiAgICBpZiAodGhpcy5oYXNGb3JtYXQoJ3N0cmlrZXRocm91Z2gnKSkge1xuICAgICAgZWxlbWVudCA9IHdyYXBFbGVtZW50V2l0aChlbGVtZW50LCAncycpO1xuICAgIH1cbiAgICBpZiAodGhpcy5oYXNGb3JtYXQoJ3VuZGVybGluZScpKSB7XG4gICAgICBlbGVtZW50ID0gd3JhcEVsZW1lbnRXaXRoKGVsZW1lbnQsICd1Jyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBlbGVtZW50XG4gICAgfTtcbiAgfVxuICBleHBvcnRKU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBkZXRhaWw6IHRoaXMuZ2V0RGV0YWlsKCksXG4gICAgICBmb3JtYXQ6IHRoaXMuZ2V0Rm9ybWF0KCksXG4gICAgICBtb2RlOiB0aGlzLmdldE1vZGUoKSxcbiAgICAgIHN0eWxlOiB0aGlzLmdldFN0eWxlKCksXG4gICAgICB0ZXh0OiB0aGlzLmdldFRleHRDb250ZW50KCksXG4gICAgICAvLyBBcyBhbiBleGNlcHRpb24gaGVyZSB3ZSBpbnZva2Ugc3VwZXIgYXQgdGhlIGVuZCBmb3IgaGlzdG9yaWNhbCByZWFzb25zLlxuICAgICAgLy8gTmFtZWx5LCB0byBwcmVzZXJ2ZSB0aGUgb3JkZXIgb2YgdGhlIHByb3BlcnRpZXMgYW5kIG5vdCB0byBicmVhayB0aGUgdGVzdHNcbiAgICAgIC8vIHRoYXQgdXNlIHRoZSBzZXJpYWxpemVkIHN0cmluZyByZXByZXNlbnRhdGlvbi5cbiAgICAgIC4uLnN1cGVyLmV4cG9ydEpTT04oKVxuICAgIH07XG4gIH1cblxuICAvLyBNdXRhdG9yc1xuICBzZWxlY3Rpb25UcmFuc2Zvcm0ocHJldlNlbGVjdGlvbiwgbmV4dFNlbGVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBub2RlIGZvcm1hdCB0byB0aGUgcHJvdmlkZWQgVGV4dEZvcm1hdFR5cGUgb3IgMzItYml0IGludGVnZXIuIE5vdGUgdGhhdCB0aGUgVGV4dEZvcm1hdFR5cGVcbiAgICogdmVyc2lvbiBvZiB0aGUgYXJndW1lbnQgY2FuIG9ubHkgc3BlY2lmeSBvbmUgZm9ybWF0IGFuZCBkb2luZyBzbyB3aWxsIHJlbW92ZSBhbGwgb3RoZXIgZm9ybWF0cyB0aGF0XG4gICAqIG1heSBiZSBhcHBsaWVkIHRvIHRoZSBub2RlLiBGb3IgdG9nZ2xpbmcgYmVoYXZpb3IsIGNvbnNpZGVyIHVzaW5nIHtAbGluayBUZXh0Tm9kZS50b2dnbGVGb3JtYXR9XG4gICAqXG4gICAqIEBwYXJhbSBmb3JtYXQgLSBUZXh0Rm9ybWF0VHlwZSBvciAzMi1iaXQgaW50ZWdlciByZXByZXNlbnRpbmcgdGhlIG5vZGUgZm9ybWF0LlxuICAgKlxuICAgKiBAcmV0dXJucyB0aGlzIFRleHROb2RlLlxuICAgKiAvLyBUT0RPIDAuMTIgVGhpcyBzaG91bGQganVzdCBiZSBhIGBzdHJpbmdgLlxuICAgKi9cbiAgc2V0Rm9ybWF0KGZvcm1hdCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgc2VsZi5fX2Zvcm1hdCA9IHR5cGVvZiBmb3JtYXQgPT09ICdzdHJpbmcnID8gVEVYVF9UWVBFX1RPX0ZPUk1BVFtmb3JtYXRdIDogZm9ybWF0O1xuICAgIHJldHVybiBzZWxmO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIG5vZGUgZGV0YWlsIHRvIHRoZSBwcm92aWRlZCBUZXh0RGV0YWlsVHlwZSBvciAzMi1iaXQgaW50ZWdlci4gTm90ZSB0aGF0IHRoZSBUZXh0RGV0YWlsVHlwZVxuICAgKiB2ZXJzaW9uIG9mIHRoZSBhcmd1bWVudCBjYW4gb25seSBzcGVjaWZ5IG9uZSBkZXRhaWwgdmFsdWUgYW5kIGRvaW5nIHNvIHdpbGwgcmVtb3ZlIGFsbCBvdGhlciBkZXRhaWwgdmFsdWVzIHRoYXRcbiAgICogbWF5IGJlIGFwcGxpZWQgdG8gdGhlIG5vZGUuIEZvciB0b2dnbGluZyBiZWhhdmlvciwgY29uc2lkZXIgdXNpbmcge0BsaW5rIFRleHROb2RlLnRvZ2dsZURpcmVjdGlvbmxlc3N9XG4gICAqIG9yIHtAbGluayBUZXh0Tm9kZS50b2dnbGVVbm1lcmdlYWJsZX1cbiAgICpcbiAgICogQHBhcmFtIGRldGFpbCAtIFRleHREZXRhaWxUeXBlIG9yIDMyLWJpdCBpbnRlZ2VyIHJlcHJlc2VudGluZyB0aGUgbm9kZSBkZXRhaWwuXG4gICAqXG4gICAqIEByZXR1cm5zIHRoaXMgVGV4dE5vZGUuXG4gICAqIC8vIFRPRE8gMC4xMiBUaGlzIHNob3VsZCBqdXN0IGJlIGEgYHN0cmluZ2AuXG4gICAqL1xuICBzZXREZXRhaWwoZGV0YWlsKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICBzZWxmLl9fZGV0YWlsID0gdHlwZW9mIGRldGFpbCA9PT0gJ3N0cmluZycgPyBERVRBSUxfVFlQRV9UT19ERVRBSUxbZGV0YWlsXSA6IGRldGFpbDtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBub2RlIHN0eWxlIHRvIHRoZSBwcm92aWRlZCBDU1NUZXh0LWxpa2Ugc3RyaW5nLiBTZXQgdGhpcyBwcm9wZXJ0eSBhcyB5b3VcbiAgICogd291bGQgYW4gSFRNTEVsZW1lbnQgc3R5bGUgYXR0cmlidXRlIHRvIGFwcGx5IGlubGluZSBzdHlsZXMgdG8gdGhlIHVuZGVybHlpbmcgRE9NIEVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSBzdHlsZSAtIENTU1RleHQgdG8gYmUgYXBwbGllZCB0byB0aGUgdW5kZXJseWluZyBIVE1MRWxlbWVudC5cbiAgICpcbiAgICogQHJldHVybnMgdGhpcyBUZXh0Tm9kZS5cbiAgICovXG4gIHNldFN0eWxlKHN0eWxlKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICBzZWxmLl9fc3R5bGUgPSBzdHlsZTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIHRoZSBwcm92aWRlZCBmb3JtYXQgdG8gdGhpcyBUZXh0Tm9kZSBpZiBpdCdzIG5vdCBwcmVzZW50LiBSZW1vdmVzIGl0IGlmIGl0J3MgcHJlc2VudC5cbiAgICogVGhlIHN1YnNjcmlwdCBhbmQgc3VwZXJzY3JpcHQgZm9ybWF0cyBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlLlxuICAgKiBQcmVmZXIgdXNpbmcgdGhpcyBtZXRob2QgdG8gdHVybiBzcGVjaWZpYyBmb3JtYXRzIG9uIGFuZCBvZmYuXG4gICAqXG4gICAqIEBwYXJhbSB0eXBlIC0gVGV4dEZvcm1hdFR5cGUgdG8gdG9nZ2xlLlxuICAgKlxuICAgKiBAcmV0dXJucyB0aGlzIFRleHROb2RlLlxuICAgKi9cbiAgdG9nZ2xlRm9ybWF0KHR5cGUpIHtcbiAgICBjb25zdCBmb3JtYXQgPSB0aGlzLmdldEZvcm1hdCgpO1xuICAgIGNvbnN0IG5ld0Zvcm1hdCA9IHRvZ2dsZVRleHRGb3JtYXRUeXBlKGZvcm1hdCwgdHlwZSwgbnVsbCk7XG4gICAgcmV0dXJuIHRoaXMuc2V0Rm9ybWF0KG5ld0Zvcm1hdCk7XG4gIH1cblxuICAvKipcbiAgICogVG9nZ2xlcyB0aGUgZGlyZWN0aW9ubGVzcyBkZXRhaWwgdmFsdWUgb2YgdGhlIG5vZGUuIFByZWZlciB1c2luZyB0aGlzIG1ldGhvZCBvdmVyIHNldERldGFpbC5cbiAgICpcbiAgICogQHJldHVybnMgdGhpcyBUZXh0Tm9kZS5cbiAgICovXG4gIHRvZ2dsZURpcmVjdGlvbmxlc3MoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICBzZWxmLl9fZGV0YWlsIF49IElTX0RJUkVDVElPTkxFU1M7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cblxuICAvKipcbiAgICogVG9nZ2xlcyB0aGUgdW5tZXJnZWFibGUgZGV0YWlsIHZhbHVlIG9mIHRoZSBub2RlLiBQcmVmZXIgdXNpbmcgdGhpcyBtZXRob2Qgb3ZlciBzZXREZXRhaWwuXG4gICAqXG4gICAqIEByZXR1cm5zIHRoaXMgVGV4dE5vZGUuXG4gICAqL1xuICB0b2dnbGVVbm1lcmdlYWJsZSgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX19kZXRhaWwgXj0gSVNfVU5NRVJHRUFCTEU7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgbW9kZSBvZiB0aGUgbm9kZS5cbiAgICpcbiAgICogQHJldHVybnMgdGhpcyBUZXh0Tm9kZS5cbiAgICovXG4gIHNldE1vZGUodHlwZSkge1xuICAgIGNvbnN0IG1vZGUgPSBURVhUX01PREVfVE9fVFlQRVt0eXBlXTtcbiAgICBpZiAodGhpcy5fX21vZGUgPT09IG1vZGUpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX19tb2RlID0gbW9kZTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB0ZXh0IGNvbnRlbnQgb2YgdGhlIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB0ZXh0IC0gdGhlIHN0cmluZyB0byBzZXQgYXMgdGhlIHRleHQgdmFsdWUgb2YgdGhlIG5vZGUuXG4gICAqXG4gICAqIEByZXR1cm5zIHRoaXMgVGV4dE5vZGUuXG4gICAqL1xuICBzZXRUZXh0Q29udGVudCh0ZXh0KSB7XG4gICAgaWYgKHRoaXMuX190ZXh0ID09PSB0ZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICBzZWxmLl9fdGV4dCA9IHRleHQ7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgY3VycmVudCBMZXhpY2FsIHNlbGVjdGlvbiB0byBiZSBhIFJhbmdlU2VsZWN0aW9uIHdpdGggYW5jaG9yIGFuZCBmb2N1cyBvbiB0aGlzIFRleHROb2RlIGF0IHRoZSBwcm92aWRlZCBvZmZzZXRzLlxuICAgKlxuICAgKiBAcGFyYW0gX2FuY2hvck9mZnNldCAtIHRoZSBvZmZzZXQgYXQgd2hpY2ggdGhlIFNlbGVjdGlvbiBhbmNob3Igd2lsbCBiZSBwbGFjZWQuXG4gICAqIEBwYXJhbSBfZm9jdXNPZmZzZXQgLSB0aGUgb2Zmc2V0IGF0IHdoaWNoIHRoZSBTZWxlY3Rpb24gZm9jdXMgd2lsbCBiZSBwbGFjZWQuXG4gICAqXG4gICAqIEByZXR1cm5zIHRoZSBuZXcgUmFuZ2VTZWxlY3Rpb24uXG4gICAqL1xuICBzZWxlY3QoX2FuY2hvck9mZnNldCwgX2ZvY3VzT2Zmc2V0KSB7XG4gICAgZXJyb3JPblJlYWRPbmx5KCk7XG4gICAgbGV0IGFuY2hvck9mZnNldCA9IF9hbmNob3JPZmZzZXQ7XG4gICAgbGV0IGZvY3VzT2Zmc2V0ID0gX2ZvY3VzT2Zmc2V0O1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBjb25zdCB0ZXh0ID0gdGhpcy5nZXRUZXh0Q29udGVudCgpO1xuICAgIGNvbnN0IGtleSA9IHRoaXMuX19rZXk7XG4gICAgaWYgKHR5cGVvZiB0ZXh0ID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgbGFzdE9mZnNldCA9IHRleHQubGVuZ3RoO1xuICAgICAgaWYgKGFuY2hvck9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFuY2hvck9mZnNldCA9IGxhc3RPZmZzZXQ7XG4gICAgICB9XG4gICAgICBpZiAoZm9jdXNPZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBmb2N1c09mZnNldCA9IGxhc3RPZmZzZXQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGFuY2hvck9mZnNldCA9IDA7XG4gICAgICBmb2N1c09mZnNldCA9IDA7XG4gICAgfVxuICAgIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuICRpbnRlcm5hbE1ha2VSYW5nZVNlbGVjdGlvbihrZXksIGFuY2hvck9mZnNldCwga2V5LCBmb2N1c09mZnNldCwgJ3RleHQnLCAndGV4dCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjb21wb3NpdGlvbktleSA9ICRnZXRDb21wb3NpdGlvbktleSgpO1xuICAgICAgaWYgKGNvbXBvc2l0aW9uS2V5ID09PSBzZWxlY3Rpb24uYW5jaG9yLmtleSB8fCBjb21wb3NpdGlvbktleSA9PT0gc2VsZWN0aW9uLmZvY3VzLmtleSkge1xuICAgICAgICAkc2V0Q29tcG9zaXRpb25LZXkoa2V5KTtcbiAgICAgIH1cbiAgICAgIHNlbGVjdGlvbi5zZXRUZXh0Tm9kZVJhbmdlKHRoaXMsIGFuY2hvck9mZnNldCwgdGhpcywgZm9jdXNPZmZzZXQpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0aW9uO1xuICB9XG4gIHNlbGVjdFN0YXJ0KCkge1xuICAgIHJldHVybiB0aGlzLnNlbGVjdCgwLCAwKTtcbiAgfVxuICBzZWxlY3RFbmQoKSB7XG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMuZ2V0VGV4dENvbnRlbnRTaXplKCk7XG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0KHNpemUsIHNpemUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydHMgdGhlIHByb3ZpZGVkIHRleHQgaW50byB0aGlzIFRleHROb2RlIGF0IHRoZSBwcm92aWRlZCBvZmZzZXQsIGRlbGV0aW5nIHRoZSBudW1iZXIgb2YgY2hhcmFjdGVyc1xuICAgKiBzcGVjaWZpZWQuIENhbiBvcHRpb25hbGx5IGNhbGN1bGF0ZSBhIG5ldyBzZWxlY3Rpb24gYWZ0ZXIgdGhlIG9wZXJhdGlvbiBpcyBjb21wbGV0ZS5cbiAgICpcbiAgICogQHBhcmFtIG9mZnNldCAtIHRoZSBvZmZzZXQgYXQgd2hpY2ggdGhlIHNwbGljZSBvcGVyYXRpb24gc2hvdWxkIGJlZ2luLlxuICAgKiBAcGFyYW0gZGVsQ291bnQgLSB0aGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgdG8gZGVsZXRlLCBzdGFydGluZyBmcm9tIHRoZSBvZmZzZXQuXG4gICAqIEBwYXJhbSBuZXdUZXh0IC0gdGhlIHRleHQgdG8gaW5zZXJ0IGludG8gdGhlIFRleHROb2RlIGF0IHRoZSBvZmZzZXQuXG4gICAqIEBwYXJhbSBtb3ZlU2VsZWN0aW9uIC0gb3B0aW9uYWwsIHdoZXRoZXIgb3Igbm90IHRvIG1vdmUgc2VsZWN0aW9uIHRvIHRoZSBlbmQgb2YgdGhlIGluc2VydGVkIHN1YnN0cmluZy5cbiAgICpcbiAgICogQHJldHVybnMgdGhpcyBUZXh0Tm9kZS5cbiAgICovXG4gIHNwbGljZVRleHQob2Zmc2V0LCBkZWxDb3VudCwgbmV3VGV4dCwgbW92ZVNlbGVjdGlvbikge1xuICAgIGNvbnN0IHdyaXRhYmxlU2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICBjb25zdCB0ZXh0ID0gd3JpdGFibGVTZWxmLl9fdGV4dDtcbiAgICBjb25zdCBoYW5kbGVkVGV4dExlbmd0aCA9IG5ld1RleHQubGVuZ3RoO1xuICAgIGxldCBpbmRleCA9IG9mZnNldDtcbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICBpbmRleCA9IGhhbmRsZWRUZXh0TGVuZ3RoICsgaW5kZXg7XG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIGluZGV4ID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmIChtb3ZlU2VsZWN0aW9uICYmICRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIGNvbnN0IG5ld09mZnNldCA9IG9mZnNldCArIGhhbmRsZWRUZXh0TGVuZ3RoO1xuICAgICAgc2VsZWN0aW9uLnNldFRleHROb2RlUmFuZ2Uod3JpdGFibGVTZWxmLCBuZXdPZmZzZXQsIHdyaXRhYmxlU2VsZiwgbmV3T2Zmc2V0KTtcbiAgICB9XG4gICAgY29uc3QgdXBkYXRlZFRleHQgPSB0ZXh0LnNsaWNlKDAsIGluZGV4KSArIG5ld1RleHQgKyB0ZXh0LnNsaWNlKGluZGV4ICsgZGVsQ291bnQpO1xuICAgIHdyaXRhYmxlU2VsZi5fX3RleHQgPSB1cGRhdGVkVGV4dDtcbiAgICByZXR1cm4gd3JpdGFibGVTZWxmO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGlzIG1lYW50IHRvIGJlIG92ZXJyaWRlbiBieSBUZXh0Tm9kZSBzdWJjbGFzc2VzIHRvIGNvbnRyb2wgdGhlIGJlaGF2aW9yIG9mIHRob3NlIG5vZGVzXG4gICAqIHdoZW4gYSB1c2VyIGV2ZW50IHdvdWxkIGNhdXNlIHRleHQgdG8gYmUgaW5zZXJ0ZWQgYmVmb3JlIHRoZW0gaW4gdGhlIGVkaXRvci4gSWYgdHJ1ZSwgTGV4aWNhbCB3aWxsIGF0dGVtcHRcbiAgICogdG8gaW5zZXJ0IHRleHQgaW50byB0aGlzIG5vZGUuIElmIGZhbHNlLCBpdCB3aWxsIGluc2VydCB0aGUgdGV4dCBpbiBhIG5ldyBzaWJsaW5nIG5vZGUuXG4gICAqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGV4dCBjYW4gYmUgaW5zZXJ0ZWQgYmVmb3JlIHRoZSBub2RlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBjYW5JbnNlcnRUZXh0QmVmb3JlKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGlzIG1lYW50IHRvIGJlIG92ZXJyaWRlbiBieSBUZXh0Tm9kZSBzdWJjbGFzc2VzIHRvIGNvbnRyb2wgdGhlIGJlaGF2aW9yIG9mIHRob3NlIG5vZGVzXG4gICAqIHdoZW4gYSB1c2VyIGV2ZW50IHdvdWxkIGNhdXNlIHRleHQgdG8gYmUgaW5zZXJ0ZWQgYWZ0ZXIgdGhlbSBpbiB0aGUgZWRpdG9yLiBJZiB0cnVlLCBMZXhpY2FsIHdpbGwgYXR0ZW1wdFxuICAgKiB0byBpbnNlcnQgdGV4dCBpbnRvIHRoaXMgbm9kZS4gSWYgZmFsc2UsIGl0IHdpbGwgaW5zZXJ0IHRoZSB0ZXh0IGluIGEgbmV3IHNpYmxpbmcgbm9kZS5cbiAgICpcbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0ZXh0IGNhbiBiZSBpbnNlcnRlZCBhZnRlciB0aGUgbm9kZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgY2FuSW5zZXJ0VGV4dEFmdGVyKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwbGl0cyB0aGlzIFRleHROb2RlIGF0IHRoZSBwcm92aWRlZCBjaGFyYWN0ZXIgb2Zmc2V0cywgZm9ybWluZyBuZXcgVGV4dE5vZGVzIGZyb20gdGhlIHN1YnN0cmluZ3NcbiAgICogZm9ybWVkIGJ5IHRoZSBzcGxpdCwgYW5kIGluc2VydGluZyB0aG9zZSBuZXcgVGV4dE5vZGVzIGludG8gdGhlIGVkaXRvciwgcmVwbGFjaW5nIHRoZSBvbmUgdGhhdCB3YXMgc3BsaXQuXG4gICAqXG4gICAqIEBwYXJhbSBzcGxpdE9mZnNldHMgLSByZXN0IHBhcmFtIG9mIHRoZSB0ZXh0IGNvbnRlbnQgY2hhcmFjdGVyIG9mZnNldHMgYXQgd2hpY2ggdGhpcyBub2RlIHNob3VsZCBiZSBzcGxpdC5cbiAgICpcbiAgICogQHJldHVybnMgYW4gQXJyYXkgY29udGFpbmluZyB0aGUgbmV3bHktY3JlYXRlZCBUZXh0Tm9kZXMuXG4gICAqL1xuICBzcGxpdFRleHQoLi4uc3BsaXRPZmZzZXRzKSB7XG4gICAgZXJyb3JPblJlYWRPbmx5KCk7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0TGF0ZXN0KCk7XG4gICAgY29uc3QgdGV4dENvbnRlbnQgPSBzZWxmLmdldFRleHRDb250ZW50KCk7XG4gICAgY29uc3Qga2V5ID0gc2VsZi5fX2tleTtcbiAgICBjb25zdCBjb21wb3NpdGlvbktleSA9ICRnZXRDb21wb3NpdGlvbktleSgpO1xuICAgIGNvbnN0IG9mZnNldHNTZXQgPSBuZXcgU2V0KHNwbGl0T2Zmc2V0cyk7XG4gICAgY29uc3QgcGFydHMgPSBbXTtcbiAgICBjb25zdCB0ZXh0TGVuZ3RoID0gdGV4dENvbnRlbnQubGVuZ3RoO1xuICAgIGxldCBzdHJpbmcgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHRMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHN0cmluZyAhPT0gJycgJiYgb2Zmc2V0c1NldC5oYXMoaSkpIHtcbiAgICAgICAgcGFydHMucHVzaChzdHJpbmcpO1xuICAgICAgICBzdHJpbmcgPSAnJztcbiAgICAgIH1cbiAgICAgIHN0cmluZyArPSB0ZXh0Q29udGVudFtpXTtcbiAgICB9XG4gICAgaWYgKHN0cmluZyAhPT0gJycpIHtcbiAgICAgIHBhcnRzLnB1c2goc3RyaW5nKTtcbiAgICB9XG4gICAgY29uc3QgcGFydHNMZW5ndGggPSBwYXJ0cy5sZW5ndGg7XG4gICAgaWYgKHBhcnRzTGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfSBlbHNlIGlmIChwYXJ0c1swXSA9PT0gdGV4dENvbnRlbnQpIHtcbiAgICAgIHJldHVybiBbc2VsZl07XG4gICAgfVxuICAgIGNvbnN0IGZpcnN0UGFydCA9IHBhcnRzWzBdO1xuICAgIGNvbnN0IHBhcmVudCA9IHNlbGYuZ2V0UGFyZW50KCk7XG4gICAgbGV0IHdyaXRhYmxlTm9kZTtcbiAgICBjb25zdCBmb3JtYXQgPSBzZWxmLmdldEZvcm1hdCgpO1xuICAgIGNvbnN0IHN0eWxlID0gc2VsZi5nZXRTdHlsZSgpO1xuICAgIGNvbnN0IGRldGFpbCA9IHNlbGYuX19kZXRhaWw7XG4gICAgbGV0IGhhc1JlcGxhY2VkU2VsZiA9IGZhbHNlO1xuICAgIGlmIChzZWxmLmlzU2VnbWVudGVkKCkpIHtcbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBUZXh0Tm9kZVxuICAgICAgd3JpdGFibGVOb2RlID0gJGNyZWF0ZVRleHROb2RlKGZpcnN0UGFydCk7XG4gICAgICB3cml0YWJsZU5vZGUuX19mb3JtYXQgPSBmb3JtYXQ7XG4gICAgICB3cml0YWJsZU5vZGUuX19zdHlsZSA9IHN0eWxlO1xuICAgICAgd3JpdGFibGVOb2RlLl9fZGV0YWlsID0gZGV0YWlsO1xuICAgICAgaGFzUmVwbGFjZWRTZWxmID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRm9yIHRoZSBmaXJzdCBwYXJ0LCB1cGRhdGUgdGhlIGV4aXN0aW5nIG5vZGVcbiAgICAgIHdyaXRhYmxlTm9kZSA9IHNlbGYuZ2V0V3JpdGFibGUoKTtcbiAgICAgIHdyaXRhYmxlTm9kZS5fX3RleHQgPSBmaXJzdFBhcnQ7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHNlbGVjdGlvblxuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcblxuICAgIC8vIFRoZW4gaGFuZGxlIGFsbCBvdGhlciBwYXJ0c1xuICAgIGNvbnN0IHNwbGl0Tm9kZXMgPSBbd3JpdGFibGVOb2RlXTtcbiAgICBsZXQgdGV4dFNpemUgPSBmaXJzdFBhcnQubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcGFydHNMZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcGFydCA9IHBhcnRzW2ldO1xuICAgICAgY29uc3QgcGFydFNpemUgPSBwYXJ0Lmxlbmd0aDtcbiAgICAgIGNvbnN0IHNpYmxpbmcgPSAkY3JlYXRlVGV4dE5vZGUocGFydCkuZ2V0V3JpdGFibGUoKTtcbiAgICAgIHNpYmxpbmcuX19mb3JtYXQgPSBmb3JtYXQ7XG4gICAgICBzaWJsaW5nLl9fc3R5bGUgPSBzdHlsZTtcbiAgICAgIHNpYmxpbmcuX19kZXRhaWwgPSBkZXRhaWw7XG4gICAgICBjb25zdCBzaWJsaW5nS2V5ID0gc2libGluZy5fX2tleTtcbiAgICAgIGNvbnN0IG5leHRUZXh0U2l6ZSA9IHRleHRTaXplICsgcGFydFNpemU7XG4gICAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICAgICAgICBjb25zdCBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cztcbiAgICAgICAgaWYgKGFuY2hvci5rZXkgPT09IGtleSAmJiBhbmNob3IudHlwZSA9PT0gJ3RleHQnICYmIGFuY2hvci5vZmZzZXQgPiB0ZXh0U2l6ZSAmJiBhbmNob3Iub2Zmc2V0IDw9IG5leHRUZXh0U2l6ZSkge1xuICAgICAgICAgIGFuY2hvci5rZXkgPSBzaWJsaW5nS2V5O1xuICAgICAgICAgIGFuY2hvci5vZmZzZXQgLT0gdGV4dFNpemU7XG4gICAgICAgICAgc2VsZWN0aW9uLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9jdXMua2V5ID09PSBrZXkgJiYgZm9jdXMudHlwZSA9PT0gJ3RleHQnICYmIGZvY3VzLm9mZnNldCA+IHRleHRTaXplICYmIGZvY3VzLm9mZnNldCA8PSBuZXh0VGV4dFNpemUpIHtcbiAgICAgICAgICBmb2N1cy5rZXkgPSBzaWJsaW5nS2V5O1xuICAgICAgICAgIGZvY3VzLm9mZnNldCAtPSB0ZXh0U2l6ZTtcbiAgICAgICAgICBzZWxlY3Rpb24uZGlydHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY29tcG9zaXRpb25LZXkgPT09IGtleSkge1xuICAgICAgICAkc2V0Q29tcG9zaXRpb25LZXkoc2libGluZ0tleSk7XG4gICAgICB9XG4gICAgICB0ZXh0U2l6ZSA9IG5leHRUZXh0U2l6ZTtcbiAgICAgIHNwbGl0Tm9kZXMucHVzaChzaWJsaW5nKTtcbiAgICB9XG5cbiAgICAvLyBJbnNlcnQgdGhlIG5vZGVzIGludG8gdGhlIHBhcmVudCdzIGNoaWxkcmVuXG4gICAgaWYgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgaW50ZXJuYWxNYXJrU2libGluZ3NBc0RpcnR5KHRoaXMpO1xuICAgICAgY29uc3Qgd3JpdGFibGVQYXJlbnQgPSBwYXJlbnQuZ2V0V3JpdGFibGUoKTtcbiAgICAgIGNvbnN0IGluc2VydGlvbkluZGV4ID0gdGhpcy5nZXRJbmRleFdpdGhpblBhcmVudCgpO1xuICAgICAgaWYgKGhhc1JlcGxhY2VkU2VsZikge1xuICAgICAgICB3cml0YWJsZVBhcmVudC5zcGxpY2UoaW5zZXJ0aW9uSW5kZXgsIDAsIHNwbGl0Tm9kZXMpO1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JpdGFibGVQYXJlbnQuc3BsaWNlKGluc2VydGlvbkluZGV4LCAxLCBzcGxpdE5vZGVzKTtcbiAgICAgIH1cbiAgICAgIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICAgICR1cGRhdGVFbGVtZW50U2VsZWN0aW9uT25DcmVhdGVEZWxldGVOb2RlKHNlbGVjdGlvbiwgcGFyZW50LCBpbnNlcnRpb25JbmRleCwgcGFydHNMZW5ndGggLSAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNwbGl0Tm9kZXM7XG4gIH1cblxuICAvKipcbiAgICogTWVyZ2VzIHRoZSB0YXJnZXQgVGV4dE5vZGUgaW50byB0aGlzIFRleHROb2RlLCByZW1vdmluZyB0aGUgdGFyZ2V0IG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB0YXJnZXQgLSB0aGUgVGV4dE5vZGUgdG8gbWVyZ2UgaW50byB0aGlzIG9uZS5cbiAgICpcbiAgICogQHJldHVybnMgdGhpcyBUZXh0Tm9kZS5cbiAgICovXG4gIG1lcmdlV2l0aFNpYmxpbmcodGFyZ2V0KSB7XG4gICAgY29uc3QgaXNCZWZvcmUgPSB0YXJnZXQgPT09IHRoaXMuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgaWYgKCFpc0JlZm9yZSAmJiB0YXJnZXQgIT09IHRoaXMuZ2V0TmV4dFNpYmxpbmcoKSkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvcihgbWVyZ2VXaXRoU2libGluZzogc2libGluZyBtdXN0IGJlIGEgcHJldmlvdXMgb3IgbmV4dCBzaWJsaW5nYCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGtleSA9IHRoaXMuX19rZXk7XG4gICAgY29uc3QgdGFyZ2V0S2V5ID0gdGFyZ2V0Ll9fa2V5O1xuICAgIGNvbnN0IHRleHQgPSB0aGlzLl9fdGV4dDtcbiAgICBjb25zdCB0ZXh0TGVuZ3RoID0gdGV4dC5sZW5ndGg7XG4gICAgY29uc3QgY29tcG9zaXRpb25LZXkgPSAkZ2V0Q29tcG9zaXRpb25LZXkoKTtcbiAgICBpZiAoY29tcG9zaXRpb25LZXkgPT09IHRhcmdldEtleSkge1xuICAgICAgJHNldENvbXBvc2l0aW9uS2V5KGtleSk7XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgICAgIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICAgICAgaWYgKGFuY2hvciAhPT0gbnVsbCAmJiBhbmNob3Iua2V5ID09PSB0YXJnZXRLZXkpIHtcbiAgICAgICAgYWRqdXN0UG9pbnRPZmZzZXRGb3JNZXJnZWRTaWJsaW5nKGFuY2hvciwgaXNCZWZvcmUsIGtleSwgdGFyZ2V0LCB0ZXh0TGVuZ3RoKTtcbiAgICAgICAgc2VsZWN0aW9uLmRpcnR5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChmb2N1cyAhPT0gbnVsbCAmJiBmb2N1cy5rZXkgPT09IHRhcmdldEtleSkge1xuICAgICAgICBhZGp1c3RQb2ludE9mZnNldEZvck1lcmdlZFNpYmxpbmcoZm9jdXMsIGlzQmVmb3JlLCBrZXksIHRhcmdldCwgdGV4dExlbmd0aCk7XG4gICAgICAgIHNlbGVjdGlvbi5kaXJ0eSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldFRleHQgPSB0YXJnZXQuX190ZXh0O1xuICAgIGNvbnN0IG5ld1RleHQgPSBpc0JlZm9yZSA/IHRhcmdldFRleHQgKyB0ZXh0IDogdGV4dCArIHRhcmdldFRleHQ7XG4gICAgdGhpcy5zZXRUZXh0Q29udGVudChuZXdUZXh0KTtcbiAgICBjb25zdCB3cml0YWJsZVNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgdGFyZ2V0LnJlbW92ZSgpO1xuICAgIHJldHVybiB3cml0YWJsZVNlbGY7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgaXMgbWVhbnQgdG8gYmUgb3ZlcnJpZGVuIGJ5IFRleHROb2RlIHN1YmNsYXNzZXMgdG8gY29udHJvbCB0aGUgYmVoYXZpb3Igb2YgdGhvc2Ugbm9kZXNcbiAgICogd2hlbiB1c2VkIHdpdGggdGhlIHJlZ2lzdGVyTGV4aWNhbFRleHRFbnRpdHkgZnVuY3Rpb24uIElmIHlvdSdyZSB1c2luZyByZWdpc3RlckxleGljYWxUZXh0RW50aXR5LCB0aGVcbiAgICogbm9kZSBjbGFzcyB0aGF0IHlvdSBjcmVhdGUgYW5kIHJlcGxhY2UgbWF0Y2hlZCB0ZXh0IHdpdGggc2hvdWxkIHJldHVybiB0cnVlIGZyb20gdGhpcyBtZXRob2QuXG4gICAqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIG5vZGUgaXMgdG8gYmUgdHJlYXRlZCBhcyBhIFwidGV4dCBlbnRpdHlcIiwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgaXNUZXh0RW50aXR5KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gY29udmVydFNwYW5FbGVtZW50KGRvbU5vZGUpIHtcbiAgLy8gZG9tTm9kZSBpcyBhIDxzcGFuPiBzaW5jZSB3ZSBtYXRjaGVkIGl0IGJ5IG5vZGVOYW1lXG4gIGNvbnN0IHNwYW4gPSBkb21Ob2RlO1xuICBjb25zdCBzdHlsZSA9IHNwYW4uc3R5bGU7XG4gIHJldHVybiB7XG4gICAgZm9yQ2hpbGQ6IGFwcGx5VGV4dEZvcm1hdEZyb21TdHlsZShzdHlsZSksXG4gICAgbm9kZTogbnVsbFxuICB9O1xufVxuZnVuY3Rpb24gY29udmVydEJyaW5nQXR0ZW50aW9uVG9FbGVtZW50KGRvbU5vZGUpIHtcbiAgLy8gZG9tTm9kZSBpcyBhIDxiPiBzaW5jZSB3ZSBtYXRjaGVkIGl0IGJ5IG5vZGVOYW1lXG4gIGNvbnN0IGIgPSBkb21Ob2RlO1xuICAvLyBHb29nbGUgRG9jcyB3cmFwcyBhbGwgY29waWVkIEhUTUwgaW4gYSA8Yj4gd2l0aCBmb250LXdlaWdodCBub3JtYWxcbiAgY29uc3QgaGFzTm9ybWFsRm9udFdlaWdodCA9IGIuc3R5bGUuZm9udFdlaWdodCA9PT0gJ25vcm1hbCc7XG4gIHJldHVybiB7XG4gICAgZm9yQ2hpbGQ6IGFwcGx5VGV4dEZvcm1hdEZyb21TdHlsZShiLnN0eWxlLCBoYXNOb3JtYWxGb250V2VpZ2h0ID8gdW5kZWZpbmVkIDogJ2JvbGQnKSxcbiAgICBub2RlOiBudWxsXG4gIH07XG59XG5jb25zdCBwcmVQYXJlbnRDYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBpc05vZGVQcmUobm9kZSkge1xuICBpZiAoIWlzSFRNTEVsZW1lbnQobm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAobm9kZS5ub2RlTmFtZSA9PT0gJ1BSRScpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCB3aGl0ZVNwYWNlID0gbm9kZS5zdHlsZS53aGl0ZVNwYWNlO1xuICByZXR1cm4gdHlwZW9mIHdoaXRlU3BhY2UgPT09ICdzdHJpbmcnICYmIHdoaXRlU3BhY2Uuc3RhcnRzV2l0aCgncHJlJyk7XG59XG5mdW5jdGlvbiBmaW5kUGFyZW50UHJlRE9NTm9kZShub2RlKSB7XG4gIGxldCBjYWNoZWQ7XG4gIGxldCBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XG4gIGNvbnN0IHZpc2l0ZWQgPSBbbm9kZV07XG4gIHdoaWxlIChwYXJlbnQgIT09IG51bGwgJiYgKGNhY2hlZCA9IHByZVBhcmVudENhY2hlLmdldChwYXJlbnQpKSA9PT0gdW5kZWZpbmVkICYmICFpc05vZGVQcmUocGFyZW50KSkge1xuICAgIHZpc2l0ZWQucHVzaChwYXJlbnQpO1xuICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICB9XG4gIGNvbnN0IHJlc3VsdE5vZGUgPSBjYWNoZWQgPT09IHVuZGVmaW5lZCA/IHBhcmVudCA6IGNhY2hlZDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2aXNpdGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgcHJlUGFyZW50Q2FjaGUuc2V0KHZpc2l0ZWRbaV0sIHJlc3VsdE5vZGUpO1xuICB9XG4gIHJldHVybiByZXN1bHROb2RlO1xufVxuZnVuY3Rpb24gJGNvbnZlcnRUZXh0RE9NTm9kZShkb21Ob2RlKSB7XG4gIGNvbnN0IGRvbU5vZGVfID0gZG9tTm9kZTtcbiAgY29uc3QgcGFyZW50RG9tID0gZG9tTm9kZS5wYXJlbnRFbGVtZW50O1xuICBpZiAoIShwYXJlbnREb20gIT09IG51bGwpKSB7XG4gICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIHBhcmVudEVsZW1lbnQgb2YgVGV4dCBub3QgdG8gYmUgbnVsbGApO1xuICB9XG4gIGxldCB0ZXh0Q29udGVudCA9IGRvbU5vZGVfLnRleHRDb250ZW50IHx8ICcnO1xuICAvLyBObyBjb2xsYXBzZSBhbmQgcHJlc2VydmUgc2VnbWVudCBicmVhayBmb3IgcHJlLCBwcmUtd3JhcCBhbmQgcHJlLWxpbmVcbiAgaWYgKGZpbmRQYXJlbnRQcmVET01Ob2RlKGRvbU5vZGVfKSAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHBhcnRzID0gdGV4dENvbnRlbnQuc3BsaXQoLyhcXHI/XFxufFxcdCkvKTtcbiAgICBjb25zdCBub2RlcyA9IFtdO1xuICAgIGNvbnN0IGxlbmd0aCA9IHBhcnRzLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwYXJ0ID0gcGFydHNbaV07XG4gICAgICBpZiAocGFydCA9PT0gJ1xcbicgfHwgcGFydCA9PT0gJ1xcclxcbicpIHtcbiAgICAgICAgbm9kZXMucHVzaCgkY3JlYXRlTGluZUJyZWFrTm9kZSgpKTtcbiAgICAgIH0gZWxzZSBpZiAocGFydCA9PT0gJ1xcdCcpIHtcbiAgICAgICAgbm9kZXMucHVzaCgkY3JlYXRlVGFiTm9kZSgpKTtcbiAgICAgIH0gZWxzZSBpZiAocGFydCAhPT0gJycpIHtcbiAgICAgICAgbm9kZXMucHVzaCgkY3JlYXRlVGV4dE5vZGUocGFydCkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgbm9kZTogbm9kZXNcbiAgICB9O1xuICB9XG4gIHRleHRDb250ZW50ID0gdGV4dENvbnRlbnQucmVwbGFjZSgvXFxyL2csICcnKS5yZXBsYWNlKC9bIFxcdFxcbl0rL2csICcgJyk7XG4gIGlmICh0ZXh0Q29udGVudCA9PT0gJycpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbm9kZTogbnVsbFxuICAgIH07XG4gIH1cbiAgaWYgKHRleHRDb250ZW50WzBdID09PSAnICcpIHtcbiAgICAvLyBUcmF2ZXJzZSBiYWNrd2FyZCB3aGlsZSBpbiB0aGUgc2FtZSBsaW5lLiBJZiBjb250ZW50IGNvbnRhaW5zIG5ldyBsaW5lIG9yIHRhYiAtPiBwb250ZW50aWFsXG4gICAgLy8gZGVsZXRlLCBvdGhlciBlbGVtZW50cyBjYW4gYm9ycm93IGZyb20gdGhpcyBvbmUuIERlbGV0aW9uIGRlcGVuZHMgb24gd2hldGhlciBpdCdzIGFsc28gdGhlXG4gICAgLy8gbGFzdCBzcGFjZSAoc2VlIG5leHQgY29uZGl0aW9uOiB0ZXh0Q29udGVudFt0ZXh0Q29udGVudC5sZW5ndGggLSAxXSA9PT0gJyAnKSlcbiAgICBsZXQgcHJldmlvdXNUZXh0ID0gZG9tTm9kZV87XG4gICAgbGV0IGlzU3RhcnRPZkxpbmUgPSB0cnVlO1xuICAgIHdoaWxlIChwcmV2aW91c1RleHQgIT09IG51bGwgJiYgKHByZXZpb3VzVGV4dCA9IGZpbmRUZXh0SW5MaW5lKHByZXZpb3VzVGV4dCwgZmFsc2UpKSAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgcHJldmlvdXNUZXh0Q29udGVudCA9IHByZXZpb3VzVGV4dC50ZXh0Q29udGVudCB8fCAnJztcbiAgICAgIGlmIChwcmV2aW91c1RleHRDb250ZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKC9bIFxcdFxcbl0kLy50ZXN0KHByZXZpb3VzVGV4dENvbnRlbnQpKSB7XG4gICAgICAgICAgdGV4dENvbnRlbnQgPSB0ZXh0Q29udGVudC5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICBpc1N0YXJ0T2ZMaW5lID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNTdGFydE9mTGluZSkge1xuICAgICAgdGV4dENvbnRlbnQgPSB0ZXh0Q29udGVudC5zbGljZSgxKTtcbiAgICB9XG4gIH1cbiAgaWYgKHRleHRDb250ZW50W3RleHRDb250ZW50Lmxlbmd0aCAtIDFdID09PSAnICcpIHtcbiAgICAvLyBUcmF2ZXJzZSBmb3J3YXJkIHdoaWxlIGluIHRoZSBzYW1lIGxpbmUsIHByZXNlcnZlIGlmIG5leHQgaW5saW5lIHdpbGwgcmVxdWlyZSBhIHNwYWNlXG4gICAgbGV0IG5leHRUZXh0ID0gZG9tTm9kZV87XG4gICAgbGV0IGlzRW5kT2ZMaW5lID0gdHJ1ZTtcbiAgICB3aGlsZSAobmV4dFRleHQgIT09IG51bGwgJiYgKG5leHRUZXh0ID0gZmluZFRleHRJbkxpbmUobmV4dFRleHQsIHRydWUpKSAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgbmV4dFRleHRDb250ZW50ID0gKG5leHRUZXh0LnRleHRDb250ZW50IHx8ICcnKS5yZXBsYWNlKC9eKCB8XFx0fFxccj9cXG4pKy8sICcnKTtcbiAgICAgIGlmIChuZXh0VGV4dENvbnRlbnQubGVuZ3RoID4gMCkge1xuICAgICAgICBpc0VuZE9mTGluZSA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzRW5kT2ZMaW5lKSB7XG4gICAgICB0ZXh0Q29udGVudCA9IHRleHRDb250ZW50LnNsaWNlKDAsIHRleHRDb250ZW50Lmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgfVxuICBpZiAodGV4dENvbnRlbnQgPT09ICcnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5vZGU6IG51bGxcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbm9kZTogJGNyZWF0ZVRleHROb2RlKHRleHRDb250ZW50KVxuICB9O1xufVxuZnVuY3Rpb24gZmluZFRleHRJbkxpbmUodGV4dCwgZm9yd2FyZCkge1xuICBsZXQgbm9kZSA9IHRleHQ7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBsZXQgc2libGluZztcbiAgICB3aGlsZSAoKHNpYmxpbmcgPSBmb3J3YXJkID8gbm9kZS5uZXh0U2libGluZyA6IG5vZGUucHJldmlvdXNTaWJsaW5nKSA9PT0gbnVsbCkge1xuICAgICAgY29uc3QgcGFyZW50RWxlbWVudCA9IG5vZGUucGFyZW50RWxlbWVudDtcbiAgICAgIGlmIChwYXJlbnRFbGVtZW50ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgbm9kZSA9IHBhcmVudEVsZW1lbnQ7XG4gICAgfVxuICAgIG5vZGUgPSBzaWJsaW5nO1xuICAgIGlmIChpc0hUTUxFbGVtZW50KG5vZGUpKSB7XG4gICAgICBjb25zdCBkaXNwbGF5ID0gbm9kZS5zdHlsZS5kaXNwbGF5O1xuICAgICAgaWYgKGRpc3BsYXkgPT09ICcnICYmICFpc0lubGluZURvbU5vZGUobm9kZSkgfHwgZGlzcGxheSAhPT0gJycgJiYgIWRpc3BsYXkuc3RhcnRzV2l0aCgnaW5saW5lJykpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBkZXNjZW5kYW50ID0gbm9kZTtcbiAgICB3aGlsZSAoKGRlc2NlbmRhbnQgPSBmb3J3YXJkID8gbm9kZS5maXJzdENoaWxkIDogbm9kZS5sYXN0Q2hpbGQpICE9PSBudWxsKSB7XG4gICAgICBub2RlID0gZGVzY2VuZGFudDtcbiAgICB9XG4gICAgaWYgKGlzRE9NVGV4dE5vZGUobm9kZSkpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0gZWxzZSBpZiAobm9kZS5ub2RlTmFtZSA9PT0gJ0JSJykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG59XG5jb25zdCBub2RlTmFtZVRvVGV4dEZvcm1hdCA9IHtcbiAgY29kZTogJ2NvZGUnLFxuICBlbTogJ2l0YWxpYycsXG4gIGk6ICdpdGFsaWMnLFxuICBzOiAnc3RyaWtldGhyb3VnaCcsXG4gIHN0cm9uZzogJ2JvbGQnLFxuICBzdWI6ICdzdWJzY3JpcHQnLFxuICBzdXA6ICdzdXBlcnNjcmlwdCcsXG4gIHU6ICd1bmRlcmxpbmUnXG59O1xuZnVuY3Rpb24gY29udmVydFRleHRGb3JtYXRFbGVtZW50KGRvbU5vZGUpIHtcbiAgY29uc3QgZm9ybWF0ID0gbm9kZU5hbWVUb1RleHRGb3JtYXRbZG9tTm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpXTtcbiAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5vZGU6IG51bGxcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgZm9yQ2hpbGQ6IGFwcGx5VGV4dEZvcm1hdEZyb21TdHlsZShkb21Ob2RlLnN0eWxlLCBmb3JtYXQpLFxuICAgIG5vZGU6IG51bGxcbiAgfTtcbn1cbmZ1bmN0aW9uICRjcmVhdGVUZXh0Tm9kZSh0ZXh0ID0gJycpIHtcbiAgcmV0dXJuICRhcHBseU5vZGVSZXBsYWNlbWVudChuZXcgVGV4dE5vZGUodGV4dCkpO1xufVxuZnVuY3Rpb24gJGlzVGV4dE5vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIFRleHROb2RlO1xufVxuZnVuY3Rpb24gYXBwbHlUZXh0Rm9ybWF0RnJvbVN0eWxlKHN0eWxlLCBzaG91bGRBcHBseSkge1xuICBjb25zdCBmb250V2VpZ2h0ID0gc3R5bGUuZm9udFdlaWdodDtcbiAgY29uc3QgdGV4dERlY29yYXRpb24gPSBzdHlsZS50ZXh0RGVjb3JhdGlvbi5zcGxpdCgnICcpO1xuICAvLyBHb29nbGUgRG9jcyB1c2VzIHNwYW4gdGFncyArIGZvbnQtd2VpZ2h0IGZvciBib2xkIHRleHRcbiAgY29uc3QgaGFzQm9sZEZvbnRXZWlnaHQgPSBmb250V2VpZ2h0ID09PSAnNzAwJyB8fCBmb250V2VpZ2h0ID09PSAnYm9sZCc7XG4gIC8vIEdvb2dsZSBEb2NzIHVzZXMgc3BhbiB0YWdzICsgdGV4dC1kZWNvcmF0aW9uOiBsaW5lLXRocm91Z2ggZm9yIHN0cmlrZXRocm91Z2ggdGV4dFxuICBjb25zdCBoYXNMaW5ldGhyb3VnaFRleHREZWNvcmF0aW9uID0gdGV4dERlY29yYXRpb24uaW5jbHVkZXMoJ2xpbmUtdGhyb3VnaCcpO1xuICAvLyBHb29nbGUgRG9jcyB1c2VzIHNwYW4gdGFncyArIGZvbnQtc3R5bGUgZm9yIGl0YWxpYyB0ZXh0XG4gIGNvbnN0IGhhc0l0YWxpY0ZvbnRTdHlsZSA9IHN0eWxlLmZvbnRTdHlsZSA9PT0gJ2l0YWxpYyc7XG4gIC8vIEdvb2dsZSBEb2NzIHVzZXMgc3BhbiB0YWdzICsgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmUgZm9yIHVuZGVybGluZSB0ZXh0XG4gIGNvbnN0IGhhc1VuZGVybGluZVRleHREZWNvcmF0aW9uID0gdGV4dERlY29yYXRpb24uaW5jbHVkZXMoJ3VuZGVybGluZScpO1xuICAvLyBHb29nbGUgRG9jcyB1c2VzIHNwYW4gdGFncyArIHZlcnRpY2FsLWFsaWduIHRvIHNwZWNpZnkgc3Vic2NyaXB0IGFuZCBzdXBlcnNjcmlwdFxuICBjb25zdCB2ZXJ0aWNhbEFsaWduID0gc3R5bGUudmVydGljYWxBbGlnbjtcbiAgcmV0dXJuIGxleGljYWxOb2RlID0+IHtcbiAgICBpZiAoISRpc1RleHROb2RlKGxleGljYWxOb2RlKSkge1xuICAgICAgcmV0dXJuIGxleGljYWxOb2RlO1xuICAgIH1cbiAgICBpZiAoaGFzQm9sZEZvbnRXZWlnaHQgJiYgIWxleGljYWxOb2RlLmhhc0Zvcm1hdCgnYm9sZCcpKSB7XG4gICAgICBsZXhpY2FsTm9kZS50b2dnbGVGb3JtYXQoJ2JvbGQnKTtcbiAgICB9XG4gICAgaWYgKGhhc0xpbmV0aHJvdWdoVGV4dERlY29yYXRpb24gJiYgIWxleGljYWxOb2RlLmhhc0Zvcm1hdCgnc3RyaWtldGhyb3VnaCcpKSB7XG4gICAgICBsZXhpY2FsTm9kZS50b2dnbGVGb3JtYXQoJ3N0cmlrZXRocm91Z2gnKTtcbiAgICB9XG4gICAgaWYgKGhhc0l0YWxpY0ZvbnRTdHlsZSAmJiAhbGV4aWNhbE5vZGUuaGFzRm9ybWF0KCdpdGFsaWMnKSkge1xuICAgICAgbGV4aWNhbE5vZGUudG9nZ2xlRm9ybWF0KCdpdGFsaWMnKTtcbiAgICB9XG4gICAgaWYgKGhhc1VuZGVybGluZVRleHREZWNvcmF0aW9uICYmICFsZXhpY2FsTm9kZS5oYXNGb3JtYXQoJ3VuZGVybGluZScpKSB7XG4gICAgICBsZXhpY2FsTm9kZS50b2dnbGVGb3JtYXQoJ3VuZGVybGluZScpO1xuICAgIH1cbiAgICBpZiAodmVydGljYWxBbGlnbiA9PT0gJ3N1YicgJiYgIWxleGljYWxOb2RlLmhhc0Zvcm1hdCgnc3Vic2NyaXB0JykpIHtcbiAgICAgIGxleGljYWxOb2RlLnRvZ2dsZUZvcm1hdCgnc3Vic2NyaXB0Jyk7XG4gICAgfVxuICAgIGlmICh2ZXJ0aWNhbEFsaWduID09PSAnc3VwZXInICYmICFsZXhpY2FsTm9kZS5oYXNGb3JtYXQoJ3N1cGVyc2NyaXB0JykpIHtcbiAgICAgIGxleGljYWxOb2RlLnRvZ2dsZUZvcm1hdCgnc3VwZXJzY3JpcHQnKTtcbiAgICB9XG4gICAgaWYgKHNob3VsZEFwcGx5ICYmICFsZXhpY2FsTm9kZS5oYXNGb3JtYXQoc2hvdWxkQXBwbHkpKSB7XG4gICAgICBsZXhpY2FsTm9kZS50b2dnbGVGb3JtYXQoc2hvdWxkQXBwbHkpO1xuICAgIH1cbiAgICByZXR1cm4gbGV4aWNhbE5vZGU7XG4gIH07XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLyoqIEBub0luaGVyaXREb2MgKi9cbmNsYXNzIFRhYk5vZGUgZXh0ZW5kcyBUZXh0Tm9kZSB7XG4gIHN0YXRpYyBnZXRUeXBlKCkge1xuICAgIHJldHVybiAndGFiJztcbiAgfVxuICBzdGF0aWMgY2xvbmUobm9kZSkge1xuICAgIHJldHVybiBuZXcgVGFiTm9kZShub2RlLl9fa2V5KTtcbiAgfVxuICBjb25zdHJ1Y3RvcihrZXkpIHtcbiAgICBzdXBlcignXFx0Jywga2V5KTtcbiAgICB0aGlzLl9fZGV0YWlsID0gSVNfVU5NRVJHRUFCTEU7XG4gIH1cbiAgc3RhdGljIGltcG9ydERPTSgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjcmVhdGVET00oY29uZmlnKSB7XG4gICAgY29uc3QgZG9tID0gc3VwZXIuY3JlYXRlRE9NKGNvbmZpZyk7XG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGdldENhY2hlZENsYXNzTmFtZUFycmF5KGNvbmZpZy50aGVtZSwgJ3RhYicpO1xuICAgIGlmIChjbGFzc05hbWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IGRvbUNsYXNzTGlzdCA9IGRvbS5jbGFzc0xpc3Q7XG4gICAgICBkb21DbGFzc0xpc3QuYWRkKC4uLmNsYXNzTmFtZXMpO1xuICAgIH1cbiAgICByZXR1cm4gZG9tO1xuICB9XG4gIHN0YXRpYyBpbXBvcnRKU09OKHNlcmlhbGl6ZWRUYWJOb2RlKSB7XG4gICAgcmV0dXJuICRjcmVhdGVUYWJOb2RlKCkudXBkYXRlRnJvbUpTT04oc2VyaWFsaXplZFRhYk5vZGUpO1xuICB9XG4gIHNldFRleHRDb250ZW50KHRleHQpIHtcbiAgICBpZiAoISh0ZXh0ID09PSAnXFx0JyB8fCB0ZXh0ID09PSAnJykpIHtcbiAgICAgIHRocm93IEVycm9yKGBUYWJOb2RlIGRvZXMgbm90IHN1cHBvcnQgc2V0VGV4dENvbnRlbnRgKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLnNldFRleHRDb250ZW50KHRleHQpO1xuICB9XG4gIHNldERldGFpbChkZXRhaWwpIHtcbiAgICBpZiAoIShkZXRhaWwgPT09IElTX1VOTUVSR0VBQkxFKSkge1xuICAgICAgdGhyb3cgRXJyb3IoYFRhYk5vZGUgZG9lcyBub3Qgc3VwcG9ydCBzZXREZXRhaWxgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2V0TW9kZSh0eXBlKSB7XG4gICAgaWYgKCEodHlwZSA9PT0gJ25vcm1hbCcpKSB7XG4gICAgICB0aHJvdyBFcnJvcihgVGFiTm9kZSBkb2VzIG5vdCBzdXBwb3J0IHNldE1vZGVgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgY2FuSW5zZXJ0VGV4dEJlZm9yZSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY2FuSW5zZXJ0VGV4dEFmdGVyKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gJGNyZWF0ZVRhYk5vZGUoKSB7XG4gIHJldHVybiAkYXBwbHlOb2RlUmVwbGFjZW1lbnQobmV3IFRhYk5vZGUoKSk7XG59XG5mdW5jdGlvbiAkaXNUYWJOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBUYWJOb2RlO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNsYXNzIFBvaW50IHtcbiAgY29uc3RydWN0b3Ioa2V5LCBvZmZzZXQsIHR5cGUpIHtcbiAgICB7XG4gICAgICAvLyBUaGlzIHByZXZlbnRzIGEgY2lyY3VsYXIgcmVmZXJlbmNlIGVycm9yIHdoZW4gc2VyaWFsaXplZCBhcyBKU09OLFxuICAgICAgLy8gd2hpY2ggaGFwcGVucyBvbiB1bml0IHRlc3QgZmFpbHVyZXNcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnX3NlbGVjdGlvbicsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fc2VsZWN0aW9uID0gbnVsbDtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICB9XG4gIGlzKHBvaW50KSB7XG4gICAgcmV0dXJuIHRoaXMua2V5ID09PSBwb2ludC5rZXkgJiYgdGhpcy5vZmZzZXQgPT09IHBvaW50Lm9mZnNldCAmJiB0aGlzLnR5cGUgPT09IHBvaW50LnR5cGU7XG4gIH1cbiAgaXNCZWZvcmUoYikge1xuICAgIGxldCBhTm9kZSA9IHRoaXMuZ2V0Tm9kZSgpO1xuICAgIGxldCBiTm9kZSA9IGIuZ2V0Tm9kZSgpO1xuICAgIGNvbnN0IGFPZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICBjb25zdCBiT2Zmc2V0ID0gYi5vZmZzZXQ7XG4gICAgaWYgKCRpc0VsZW1lbnROb2RlKGFOb2RlKSkge1xuICAgICAgY29uc3QgYU5vZGVEZXNjZW5kYW50ID0gYU5vZGUuZ2V0RGVzY2VuZGFudEJ5SW5kZXgoYU9mZnNldCk7XG4gICAgICBhTm9kZSA9IGFOb2RlRGVzY2VuZGFudCAhPSBudWxsID8gYU5vZGVEZXNjZW5kYW50IDogYU5vZGU7XG4gICAgfVxuICAgIGlmICgkaXNFbGVtZW50Tm9kZShiTm9kZSkpIHtcbiAgICAgIGNvbnN0IGJOb2RlRGVzY2VuZGFudCA9IGJOb2RlLmdldERlc2NlbmRhbnRCeUluZGV4KGJPZmZzZXQpO1xuICAgICAgYk5vZGUgPSBiTm9kZURlc2NlbmRhbnQgIT0gbnVsbCA/IGJOb2RlRGVzY2VuZGFudCA6IGJOb2RlO1xuICAgIH1cbiAgICBpZiAoYU5vZGUgPT09IGJOb2RlKSB7XG4gICAgICByZXR1cm4gYU9mZnNldCA8IGJPZmZzZXQ7XG4gICAgfVxuICAgIHJldHVybiBhTm9kZS5pc0JlZm9yZShiTm9kZSk7XG4gIH1cbiAgZ2V0Tm9kZSgpIHtcbiAgICBjb25zdCBrZXkgPSB0aGlzLmtleTtcbiAgICBjb25zdCBub2RlID0gJGdldE5vZGVCeUtleShrZXkpO1xuICAgIGlmIChub2RlID09PSBudWxsKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKGBQb2ludC5nZXROb2RlOiBub2RlIG5vdCBmb3VuZGApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBzZXQoa2V5LCBvZmZzZXQsIHR5cGUpIHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSB0aGlzLl9zZWxlY3Rpb247XG4gICAgY29uc3Qgb2xkS2V5ID0gdGhpcy5rZXk7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICBpZiAoIWlzQ3VycmVudGx5UmVhZE9ubHlNb2RlKCkpIHtcbiAgICAgIGlmICgkZ2V0Q29tcG9zaXRpb25LZXkoKSA9PT0gb2xkS2V5KSB7XG4gICAgICAgICRzZXRDb21wb3NpdGlvbktleShrZXkpO1xuICAgICAgfVxuICAgICAgaWYgKHNlbGVjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICBzZWxlY3Rpb24uc2V0Q2FjaGVkTm9kZXMobnVsbCk7XG4gICAgICAgIHNlbGVjdGlvbi5kaXJ0eSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiAkY3JlYXRlUG9pbnQoa2V5LCBvZmZzZXQsIHR5cGUpIHtcbiAgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW50ZW50aW9uYWxseSBjYXN0IGFzIHdlIHVzZSBhIGNsYXNzIGZvciBwZXJmIHJlYXNvbnNcbiAgcmV0dXJuIG5ldyBQb2ludChrZXksIG9mZnNldCwgdHlwZSk7XG59XG5mdW5jdGlvbiBzZWxlY3RQb2ludE9uTm9kZShwb2ludCwgbm9kZSkge1xuICBsZXQga2V5ID0gbm9kZS5fX2tleTtcbiAgbGV0IG9mZnNldCA9IHBvaW50Lm9mZnNldDtcbiAgbGV0IHR5cGUgPSAnZWxlbWVudCc7XG4gIGlmICgkaXNUZXh0Tm9kZShub2RlKSkge1xuICAgIHR5cGUgPSAndGV4dCc7XG4gICAgY29uc3QgdGV4dENvbnRlbnRMZW5ndGggPSBub2RlLmdldFRleHRDb250ZW50U2l6ZSgpO1xuICAgIGlmIChvZmZzZXQgPiB0ZXh0Q29udGVudExlbmd0aCkge1xuICAgICAgb2Zmc2V0ID0gdGV4dENvbnRlbnRMZW5ndGg7XG4gICAgfVxuICB9IGVsc2UgaWYgKCEkaXNFbGVtZW50Tm9kZShub2RlKSkge1xuICAgIGNvbnN0IG5leHRTaWJsaW5nID0gbm9kZS5nZXROZXh0U2libGluZygpO1xuICAgIGlmICgkaXNUZXh0Tm9kZShuZXh0U2libGluZykpIHtcbiAgICAgIGtleSA9IG5leHRTaWJsaW5nLl9fa2V5O1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgIHR5cGUgPSAndGV4dCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSBub2RlLmdldFBhcmVudCgpO1xuICAgICAgaWYgKHBhcmVudE5vZGUpIHtcbiAgICAgICAga2V5ID0gcGFyZW50Tm9kZS5fX2tleTtcbiAgICAgICAgb2Zmc2V0ID0gbm9kZS5nZXRJbmRleFdpdGhpblBhcmVudCgpICsgMTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcG9pbnQuc2V0KGtleSwgb2Zmc2V0LCB0eXBlKTtcbn1cbmZ1bmN0aW9uICRtb3ZlU2VsZWN0aW9uUG9pbnRUb0VuZChwb2ludCwgbm9kZSkge1xuICBpZiAoJGlzRWxlbWVudE5vZGUobm9kZSkpIHtcbiAgICBjb25zdCBsYXN0Tm9kZSA9IG5vZGUuZ2V0TGFzdERlc2NlbmRhbnQoKTtcbiAgICBpZiAoJGlzRWxlbWVudE5vZGUobGFzdE5vZGUpIHx8ICRpc1RleHROb2RlKGxhc3ROb2RlKSkge1xuICAgICAgc2VsZWN0UG9pbnRPbk5vZGUocG9pbnQsIGxhc3ROb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZWN0UG9pbnRPbk5vZGUocG9pbnQsIG5vZGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzZWxlY3RQb2ludE9uTm9kZShwb2ludCwgbm9kZSk7XG4gIH1cbn1cbmZ1bmN0aW9uICR0cmFuc2ZlclN0YXJ0aW5nRWxlbWVudFBvaW50VG9UZXh0UG9pbnQoc3RhcnQsIGVuZCwgZm9ybWF0LCBzdHlsZSkge1xuICBjb25zdCBlbGVtZW50ID0gc3RhcnQuZ2V0Tm9kZSgpO1xuICBjb25zdCBwbGFjZW1lbnROb2RlID0gZWxlbWVudC5nZXRDaGlsZEF0SW5kZXgoc3RhcnQub2Zmc2V0KTtcbiAgY29uc3QgdGV4dE5vZGUgPSAkY3JlYXRlVGV4dE5vZGUoKTtcbiAgY29uc3QgdGFyZ2V0ID0gJGlzUm9vdE5vZGUoZWxlbWVudCkgPyAkY3JlYXRlUGFyYWdyYXBoTm9kZSgpLmFwcGVuZCh0ZXh0Tm9kZSkgOiB0ZXh0Tm9kZTtcbiAgdGV4dE5vZGUuc2V0Rm9ybWF0KGZvcm1hdCk7XG4gIHRleHROb2RlLnNldFN0eWxlKHN0eWxlKTtcbiAgaWYgKHBsYWNlbWVudE5vZGUgPT09IG51bGwpIHtcbiAgICBlbGVtZW50LmFwcGVuZCh0YXJnZXQpO1xuICB9IGVsc2Uge1xuICAgIHBsYWNlbWVudE5vZGUuaW5zZXJ0QmVmb3JlKHRhcmdldCk7XG4gIH1cbiAgLy8gVHJhbnNmZXIgdGhlIGVsZW1lbnQgcG9pbnQgdG8gYSB0ZXh0IHBvaW50LlxuICBpZiAoc3RhcnQuaXMoZW5kKSkge1xuICAgIGVuZC5zZXQodGV4dE5vZGUuX19rZXksIDAsICd0ZXh0Jyk7XG4gIH1cbiAgc3RhcnQuc2V0KHRleHROb2RlLl9fa2V5LCAwLCAndGV4dCcpO1xufVxuZnVuY3Rpb24gJHNldFBvaW50VmFsdWVzKHBvaW50LCBrZXksIG9mZnNldCwgdHlwZSkge1xuICBwb2ludC5rZXkgPSBrZXk7XG4gIHBvaW50Lm9mZnNldCA9IG9mZnNldDtcbiAgcG9pbnQudHlwZSA9IHR5cGU7XG59XG5jbGFzcyBOb2RlU2VsZWN0aW9uIHtcbiAgY29uc3RydWN0b3Iob2JqZWN0cykge1xuICAgIHRoaXMuX2NhY2hlZE5vZGVzID0gbnVsbDtcbiAgICB0aGlzLl9ub2RlcyA9IG9iamVjdHM7XG4gICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICB9XG4gIGdldENhY2hlZE5vZGVzKCkge1xuICAgIHJldHVybiB0aGlzLl9jYWNoZWROb2RlcztcbiAgfVxuICBzZXRDYWNoZWROb2Rlcyhub2Rlcykge1xuICAgIHRoaXMuX2NhY2hlZE5vZGVzID0gbm9kZXM7XG4gIH1cbiAgaXMoc2VsZWN0aW9uKSB7XG4gICAgaWYgKCEkaXNOb2RlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgYSA9IHRoaXMuX25vZGVzO1xuICAgIGNvbnN0IGIgPSBzZWxlY3Rpb24uX25vZGVzO1xuICAgIHJldHVybiBhLnNpemUgPT09IGIuc2l6ZSAmJiBBcnJheS5mcm9tKGEpLmV2ZXJ5KGtleSA9PiBiLmhhcyhrZXkpKTtcbiAgfVxuICBpc0NvbGxhcHNlZCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaXNCYWNrd2FyZCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZ2V0U3RhcnRFbmRQb2ludHMoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgYWRkKGtleSkge1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIHRoaXMuX25vZGVzLmFkZChrZXkpO1xuICAgIHRoaXMuX2NhY2hlZE5vZGVzID0gbnVsbDtcbiAgfVxuICBkZWxldGUoa2V5KSB7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgdGhpcy5fbm9kZXMuZGVsZXRlKGtleSk7XG4gICAgdGhpcy5fY2FjaGVkTm9kZXMgPSBudWxsO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIHRoaXMuX25vZGVzLmNsZWFyKCk7XG4gICAgdGhpcy5fY2FjaGVkTm9kZXMgPSBudWxsO1xuICB9XG4gIGhhcyhrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5fbm9kZXMuaGFzKGtleSk7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBOb2RlU2VsZWN0aW9uKG5ldyBTZXQodGhpcy5fbm9kZXMpKTtcbiAgfVxuICBleHRyYWN0KCkge1xuICAgIHJldHVybiB0aGlzLmdldE5vZGVzKCk7XG4gIH1cbiAgaW5zZXJ0UmF3VGV4dCh0ZXh0KSB7XG4gICAgLy8gRG8gbm90aGluZz9cbiAgfVxuICBpbnNlcnRUZXh0KCkge1xuICAgIC8vIERvIG5vdGhpbmc/XG4gIH1cbiAgaW5zZXJ0Tm9kZXMobm9kZXMpIHtcbiAgICBjb25zdCBzZWxlY3RlZE5vZGVzID0gdGhpcy5nZXROb2RlcygpO1xuICAgIGNvbnN0IHNlbGVjdGVkTm9kZXNMZW5ndGggPSBzZWxlY3RlZE5vZGVzLmxlbmd0aDtcbiAgICBjb25zdCBsYXN0U2VsZWN0ZWROb2RlID0gc2VsZWN0ZWROb2Rlc1tzZWxlY3RlZE5vZGVzTGVuZ3RoIC0gMV07XG4gICAgbGV0IHNlbGVjdGlvbkF0RW5kO1xuICAgIC8vIEluc2VydCBub2Rlc1xuICAgIGlmICgkaXNUZXh0Tm9kZShsYXN0U2VsZWN0ZWROb2RlKSkge1xuICAgICAgc2VsZWN0aW9uQXRFbmQgPSBsYXN0U2VsZWN0ZWROb2RlLnNlbGVjdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBpbmRleCA9IGxhc3RTZWxlY3RlZE5vZGUuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKSArIDE7XG4gICAgICBzZWxlY3Rpb25BdEVuZCA9IGxhc3RTZWxlY3RlZE5vZGUuZ2V0UGFyZW50T3JUaHJvdygpLnNlbGVjdChpbmRleCwgaW5kZXgpO1xuICAgIH1cbiAgICBzZWxlY3Rpb25BdEVuZC5pbnNlcnROb2Rlcyhub2Rlcyk7XG4gICAgLy8gUmVtb3ZlIHNlbGVjdGVkIG5vZGVzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWxlY3RlZE5vZGVzTGVuZ3RoOyBpKyspIHtcbiAgICAgIHNlbGVjdGVkTm9kZXNbaV0ucmVtb3ZlKCk7XG4gICAgfVxuICB9XG4gIGdldE5vZGVzKCkge1xuICAgIGNvbnN0IGNhY2hlZE5vZGVzID0gdGhpcy5fY2FjaGVkTm9kZXM7XG4gICAgaWYgKGNhY2hlZE5vZGVzICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gY2FjaGVkTm9kZXM7XG4gICAgfVxuICAgIGNvbnN0IG9iamVjdHMgPSB0aGlzLl9ub2RlcztcbiAgICBjb25zdCBub2RlcyA9IFtdO1xuICAgIGZvciAoY29uc3Qgb2JqZWN0IG9mIG9iamVjdHMpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSAkZ2V0Tm9kZUJ5S2V5KG9iamVjdCk7XG4gICAgICBpZiAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWlzQ3VycmVudGx5UmVhZE9ubHlNb2RlKCkpIHtcbiAgICAgIHRoaXMuX2NhY2hlZE5vZGVzID0gbm9kZXM7XG4gICAgfVxuICAgIHJldHVybiBub2RlcztcbiAgfVxuICBnZXRUZXh0Q29udGVudCgpIHtcbiAgICBjb25zdCBub2RlcyA9IHRoaXMuZ2V0Tm9kZXMoKTtcbiAgICBsZXQgdGV4dENvbnRlbnQgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0ZXh0Q29udGVudCArPSBub2Rlc1tpXS5nZXRUZXh0Q29udGVudCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dENvbnRlbnQ7XG4gIH1cbn1cbmZ1bmN0aW9uICRpc1JhbmdlU2VsZWN0aW9uKHgpIHtcbiAgcmV0dXJuIHggaW5zdGFuY2VvZiBSYW5nZVNlbGVjdGlvbjtcbn1cbmNsYXNzIFJhbmdlU2VsZWN0aW9uIHtcbiAgY29uc3RydWN0b3IoYW5jaG9yLCBmb2N1cywgZm9ybWF0LCBzdHlsZSkge1xuICAgIHRoaXMuYW5jaG9yID0gYW5jaG9yO1xuICAgIHRoaXMuZm9jdXMgPSBmb2N1cztcbiAgICBhbmNob3IuX3NlbGVjdGlvbiA9IHRoaXM7XG4gICAgZm9jdXMuX3NlbGVjdGlvbiA9IHRoaXM7XG4gICAgdGhpcy5fY2FjaGVkTm9kZXMgPSBudWxsO1xuICAgIHRoaXMuZm9ybWF0ID0gZm9ybWF0O1xuICAgIHRoaXMuc3R5bGUgPSBzdHlsZTtcbiAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gIH1cbiAgZ2V0Q2FjaGVkTm9kZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZE5vZGVzO1xuICB9XG4gIHNldENhY2hlZE5vZGVzKG5vZGVzKSB7XG4gICAgdGhpcy5fY2FjaGVkTm9kZXMgPSBub2RlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGNoZWNrIGlmIHRoZSBwcm92aWRlZCBzZWxlY3Rpb25zIGlzIGVxdWFsIHRvIHRoaXMgb25lIGJ5IHZhbHVlLFxuICAgKiBpbmx1ZGluZyBhbmNob3IsIGZvY3VzLCBmb3JtYXQsIGFuZCBzdHlsZSBwcm9wZXJ0aWVzLlxuICAgKiBAcGFyYW0gc2VsZWN0aW9uIC0gdGhlIFNlbGVjdGlvbiB0byBjb21wYXJlIHRoaXMgb25lIHRvLlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBTZWxlY3Rpb25zIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgaXMoc2VsZWN0aW9uKSB7XG4gICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmFuY2hvci5pcyhzZWxlY3Rpb24uYW5jaG9yKSAmJiB0aGlzLmZvY3VzLmlzKHNlbGVjdGlvbi5mb2N1cykgJiYgdGhpcy5mb3JtYXQgPT09IHNlbGVjdGlvbi5mb3JtYXQgJiYgdGhpcy5zdHlsZSA9PT0gc2VsZWN0aW9uLnN0eWxlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgU2VsZWN0aW9uIGlzIFwiY29sbGFwc2VkXCIsIG1lYW5pbmcgdGhlIGFuY2hvciBhbmQgZm9jdXMgYXJlXG4gICAqIHRoZSBzYW1lIG5vZGUgYW5kIGhhdmUgdGhlIHNhbWUgb2Zmc2V0LlxuICAgKlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBTZWxlY3Rpb24gaXMgY29sbGFwc2VkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBpc0NvbGxhcHNlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5hbmNob3IuaXModGhpcy5mb2N1cyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhbGwgdGhlIG5vZGVzIGluIHRoZSBTZWxlY3Rpb24uIFVzZXMgY2FjaGluZyB0byBtYWtlIGl0IGdlbmVyYWxseSBzdWl0YWJsZVxuICAgKiBmb3IgdXNlIGluIGhvdCBwYXRocy5cbiAgICpcbiAgICogQHJldHVybnMgYW4gQXJyYXkgY29udGFpbmluZyBhbGwgdGhlIG5vZGVzIGluIHRoZSBTZWxlY3Rpb25cbiAgICovXG4gIGdldE5vZGVzKCkge1xuICAgIGNvbnN0IGNhY2hlZE5vZGVzID0gdGhpcy5fY2FjaGVkTm9kZXM7XG4gICAgaWYgKGNhY2hlZE5vZGVzICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gY2FjaGVkTm9kZXM7XG4gICAgfVxuICAgIGNvbnN0IGFuY2hvciA9IHRoaXMuYW5jaG9yO1xuICAgIGNvbnN0IGZvY3VzID0gdGhpcy5mb2N1cztcbiAgICBjb25zdCBpc0JlZm9yZSA9IGFuY2hvci5pc0JlZm9yZShmb2N1cyk7XG4gICAgY29uc3QgZmlyc3RQb2ludCA9IGlzQmVmb3JlID8gYW5jaG9yIDogZm9jdXM7XG4gICAgY29uc3QgbGFzdFBvaW50ID0gaXNCZWZvcmUgPyBmb2N1cyA6IGFuY2hvcjtcbiAgICBsZXQgZmlyc3ROb2RlID0gZmlyc3RQb2ludC5nZXROb2RlKCk7XG4gICAgbGV0IGxhc3ROb2RlID0gbGFzdFBvaW50LmdldE5vZGUoKTtcbiAgICBjb25zdCBvdmVyc2VsZWN0ZWRGaXJzdE5vZGUgPSAkaXNFbGVtZW50Tm9kZShmaXJzdE5vZGUpICYmIGZpcnN0UG9pbnQub2Zmc2V0ID4gMCAmJiBmaXJzdFBvaW50Lm9mZnNldCA+PSBmaXJzdE5vZGUuZ2V0Q2hpbGRyZW5TaXplKCk7XG4gICAgY29uc3Qgc3RhcnRPZmZzZXQgPSBmaXJzdFBvaW50Lm9mZnNldDtcbiAgICBjb25zdCBlbmRPZmZzZXQgPSBsYXN0UG9pbnQub2Zmc2V0O1xuICAgIGlmICgkaXNFbGVtZW50Tm9kZShmaXJzdE5vZGUpKSB7XG4gICAgICBjb25zdCBmaXJzdE5vZGVEZXNjZW5kYW50ID0gZmlyc3ROb2RlLmdldERlc2NlbmRhbnRCeUluZGV4KHN0YXJ0T2Zmc2V0KTtcbiAgICAgIGZpcnN0Tm9kZSA9IGZpcnN0Tm9kZURlc2NlbmRhbnQgIT0gbnVsbCA/IGZpcnN0Tm9kZURlc2NlbmRhbnQgOiBmaXJzdE5vZGU7XG4gICAgfVxuICAgIGlmICgkaXNFbGVtZW50Tm9kZShsYXN0Tm9kZSkpIHtcbiAgICAgIGxldCBsYXN0Tm9kZURlc2NlbmRhbnQgPSBsYXN0Tm9kZS5nZXREZXNjZW5kYW50QnlJbmRleChlbmRPZmZzZXQpO1xuICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBvdmVyLXNlbGVjdCwgYXMgbm9kZSBzZWxlY3Rpb24gaW5mZXJzIHRoZSBjaGlsZCBiZWZvcmVcbiAgICAgIC8vIHRoZSBsYXN0IGRlc2NlbmRhbnQsIG5vdCBpbmNsdWRpbmcgdGhhdCBkZXNjZW5kYW50LlxuICAgICAgaWYgKGxhc3ROb2RlRGVzY2VuZGFudCAhPT0gbnVsbCAmJiBsYXN0Tm9kZURlc2NlbmRhbnQgIT09IGZpcnN0Tm9kZSAmJiBsYXN0Tm9kZS5nZXRDaGlsZEF0SW5kZXgoZW5kT2Zmc2V0KSA9PT0gbGFzdE5vZGVEZXNjZW5kYW50KSB7XG4gICAgICAgIGxhc3ROb2RlRGVzY2VuZGFudCA9IGxhc3ROb2RlRGVzY2VuZGFudC5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICAgIH1cbiAgICAgIGxhc3ROb2RlID0gbGFzdE5vZGVEZXNjZW5kYW50ICE9IG51bGwgPyBsYXN0Tm9kZURlc2NlbmRhbnQgOiBsYXN0Tm9kZTtcbiAgICB9XG4gICAgbGV0IG5vZGVzO1xuICAgIGlmIChmaXJzdE5vZGUuaXMobGFzdE5vZGUpKSB7XG4gICAgICBpZiAoJGlzRWxlbWVudE5vZGUoZmlyc3ROb2RlKSAmJiBmaXJzdE5vZGUuZ2V0Q2hpbGRyZW5TaXplKCkgPiAwKSB7XG4gICAgICAgIG5vZGVzID0gW107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlcyA9IFtmaXJzdE5vZGVdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBub2RlcyA9IGZpcnN0Tm9kZS5nZXROb2Rlc0JldHdlZW4obGFzdE5vZGUpO1xuICAgICAgLy8gUHJldmVudCBvdmVyLXNlbGVjdGlvbiBkdWUgdG8gdGhlIGVkZ2UgY2FzZSBvZiBnZXREZXNjZW5kYW50QnlJbmRleCBhbHdheXMgcmV0dXJuaW5nIHNvbWV0aGluZyAjNjk3NFxuICAgICAgaWYgKG92ZXJzZWxlY3RlZEZpcnN0Tm9kZSkge1xuICAgICAgICBjb25zdCBkZWxldGVDb3VudCA9IG5vZGVzLmZpbmRJbmRleChub2RlID0+ICFub2RlLmlzKGZpcnN0Tm9kZSkgJiYgIW5vZGUuaXNCZWZvcmUoZmlyc3ROb2RlKSk7XG4gICAgICAgIG5vZGVzLnNwbGljZSgwLCBkZWxldGVDb3VudCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghaXNDdXJyZW50bHlSZWFkT25seU1vZGUoKSkge1xuICAgICAgdGhpcy5fY2FjaGVkTm9kZXMgPSBub2RlcztcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhpcyBTZWxlY3Rpb24gdG8gYmUgb2YgdHlwZSBcInRleHRcIiBhdCB0aGUgcHJvdmlkZWQgYW5jaG9yIGFuZCBmb2N1cyB2YWx1ZXMuXG4gICAqXG4gICAqIEBwYXJhbSBhbmNob3JOb2RlIC0gdGhlIGFuY2hvciBub2RlIHRvIHNldCBvbiB0aGUgU2VsZWN0aW9uXG4gICAqIEBwYXJhbSBhbmNob3JPZmZzZXQgLSB0aGUgb2Zmc2V0IHRvIHNldCBvbiB0aGUgU2VsZWN0aW9uXG4gICAqIEBwYXJhbSBmb2N1c05vZGUgLSB0aGUgZm9jdXMgbm9kZSB0byBzZXQgb24gdGhlIFNlbGVjdGlvblxuICAgKiBAcGFyYW0gZm9jdXNPZmZzZXQgLSB0aGUgZm9jdXMgb2Zmc2V0IHRvIHNldCBvbiB0aGUgU2VsZWN0aW9uXG4gICAqL1xuICBzZXRUZXh0Tm9kZVJhbmdlKGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCkge1xuICAgICRzZXRQb2ludFZhbHVlcyh0aGlzLmFuY2hvciwgYW5jaG9yTm9kZS5fX2tleSwgYW5jaG9yT2Zmc2V0LCAndGV4dCcpO1xuICAgICRzZXRQb2ludFZhbHVlcyh0aGlzLmZvY3VzLCBmb2N1c05vZGUuX19rZXksIGZvY3VzT2Zmc2V0LCAndGV4dCcpO1xuICAgIHRoaXMuX2NhY2hlZE5vZGVzID0gbnVsbDtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSAocGxhaW4pIHRleHQgY29udGVudCBvZiBhbGwgdGhlIG5vZGVzIGluIHRoZSBzZWxlY3Rpb24uXG4gICAqXG4gICAqIEByZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdGV4dCBjb250ZW50IG9mIGFsbCB0aGUgbm9kZXMgaW4gdGhlIFNlbGVjdGlvblxuICAgKi9cbiAgZ2V0VGV4dENvbnRlbnQoKSB7XG4gICAgY29uc3Qgbm9kZXMgPSB0aGlzLmdldE5vZGVzKCk7XG4gICAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBjb25zdCBmaXJzdE5vZGUgPSBub2Rlc1swXTtcbiAgICBjb25zdCBsYXN0Tm9kZSA9IG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IGFuY2hvciA9IHRoaXMuYW5jaG9yO1xuICAgIGNvbnN0IGZvY3VzID0gdGhpcy5mb2N1cztcbiAgICBjb25zdCBpc0JlZm9yZSA9IGFuY2hvci5pc0JlZm9yZShmb2N1cyk7XG4gICAgY29uc3QgW2FuY2hvck9mZnNldCwgZm9jdXNPZmZzZXRdID0gJGdldENoYXJhY3Rlck9mZnNldHModGhpcyk7XG4gICAgbGV0IHRleHRDb250ZW50ID0gJyc7XG4gICAgbGV0IHByZXZXYXNFbGVtZW50ID0gdHJ1ZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICBpZiAoJGlzRWxlbWVudE5vZGUobm9kZSkgJiYgIW5vZGUuaXNJbmxpbmUoKSkge1xuICAgICAgICBpZiAoIXByZXZXYXNFbGVtZW50KSB7XG4gICAgICAgICAgdGV4dENvbnRlbnQgKz0gJ1xcbic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgcHJldldhc0VsZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2V2FzRWxlbWVudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByZXZXYXNFbGVtZW50ID0gZmFsc2U7XG4gICAgICAgIGlmICgkaXNUZXh0Tm9kZShub2RlKSkge1xuICAgICAgICAgIGxldCB0ZXh0ID0gbm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICAgICAgICAgIGlmIChub2RlID09PSBmaXJzdE5vZGUpIHtcbiAgICAgICAgICAgIGlmIChub2RlID09PSBsYXN0Tm9kZSkge1xuICAgICAgICAgICAgICBpZiAoYW5jaG9yLnR5cGUgIT09ICdlbGVtZW50JyB8fCBmb2N1cy50eXBlICE9PSAnZWxlbWVudCcgfHwgZm9jdXMub2Zmc2V0ID09PSBhbmNob3Iub2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IGFuY2hvck9mZnNldCA8IGZvY3VzT2Zmc2V0ID8gdGV4dC5zbGljZShhbmNob3JPZmZzZXQsIGZvY3VzT2Zmc2V0KSA6IHRleHQuc2xpY2UoZm9jdXNPZmZzZXQsIGFuY2hvck9mZnNldCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRleHQgPSBpc0JlZm9yZSA/IHRleHQuc2xpY2UoYW5jaG9yT2Zmc2V0KSA6IHRleHQuc2xpY2UoZm9jdXNPZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAobm9kZSA9PT0gbGFzdE5vZGUpIHtcbiAgICAgICAgICAgIHRleHQgPSBpc0JlZm9yZSA/IHRleHQuc2xpY2UoMCwgZm9jdXNPZmZzZXQpIDogdGV4dC5zbGljZSgwLCBhbmNob3JPZmZzZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0ZXh0Q29udGVudCArPSB0ZXh0O1xuICAgICAgICB9IGVsc2UgaWYgKCgkaXNEZWNvcmF0b3JOb2RlKG5vZGUpIHx8ICRpc0xpbmVCcmVha05vZGUobm9kZSkpICYmIChub2RlICE9PSBsYXN0Tm9kZSB8fCAhdGhpcy5pc0NvbGxhcHNlZCgpKSkge1xuICAgICAgICAgIHRleHRDb250ZW50ICs9IG5vZGUuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGV4dENvbnRlbnQ7XG4gIH1cblxuICAvKipcbiAgICogQXR0ZW1wdHMgdG8gbWFwIGEgRE9NIHNlbGVjdGlvbiByYW5nZSBvbnRvIHRoaXMgTGV4aWNhbCBTZWxlY3Rpb24sXG4gICAqIHNldHRpbmcgdGhlIGFuY2hvciwgZm9jdXMsIGFuZCB0eXBlIGFjY29yZGluZ2x5XG4gICAqXG4gICAqIEBwYXJhbSByYW5nZSBhIERPTSBTZWxlY3Rpb24gcmFuZ2UgY29uZm9ybWluZyB0byB0aGUgU3RhdGljUmFuZ2UgaW50ZXJmYWNlLlxuICAgKi9cbiAgYXBwbHlET01SYW5nZShyYW5nZSkge1xuICAgIGNvbnN0IGVkaXRvciA9IGdldEFjdGl2ZUVkaXRvcigpO1xuICAgIGNvbnN0IGN1cnJlbnRFZGl0b3JTdGF0ZSA9IGVkaXRvci5nZXRFZGl0b3JTdGF0ZSgpO1xuICAgIGNvbnN0IGxhc3RTZWxlY3Rpb24gPSBjdXJyZW50RWRpdG9yU3RhdGUuX3NlbGVjdGlvbjtcbiAgICBjb25zdCByZXNvbHZlZFNlbGVjdGlvblBvaW50cyA9ICRpbnRlcm5hbFJlc29sdmVTZWxlY3Rpb25Qb2ludHMocmFuZ2Uuc3RhcnRDb250YWluZXIsIHJhbmdlLnN0YXJ0T2Zmc2V0LCByYW5nZS5lbmRDb250YWluZXIsIHJhbmdlLmVuZE9mZnNldCwgZWRpdG9yLCBsYXN0U2VsZWN0aW9uKTtcbiAgICBpZiAocmVzb2x2ZWRTZWxlY3Rpb25Qb2ludHMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgW2FuY2hvclBvaW50LCBmb2N1c1BvaW50XSA9IHJlc29sdmVkU2VsZWN0aW9uUG9pbnRzO1xuICAgICRzZXRQb2ludFZhbHVlcyh0aGlzLmFuY2hvciwgYW5jaG9yUG9pbnQua2V5LCBhbmNob3JQb2ludC5vZmZzZXQsIGFuY2hvclBvaW50LnR5cGUpO1xuICAgICRzZXRQb2ludFZhbHVlcyh0aGlzLmZvY3VzLCBmb2N1c1BvaW50LmtleSwgZm9jdXNQb2ludC5vZmZzZXQsIGZvY3VzUG9pbnQudHlwZSk7XG4gICAgdGhpcy5fY2FjaGVkTm9kZXMgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgUmFuZ2VTZWxlY3Rpb24sIGNvcHlpbmcgb3ZlciBhbGwgdGhlIHByb3BlcnR5IHZhbHVlcyBmcm9tIHRoaXMgb25lLlxuICAgKlxuICAgKiBAcmV0dXJucyBhIG5ldyBSYW5nZVNlbGVjdGlvbiB3aXRoIHRoZSBzYW1lIHByb3BlcnR5IHZhbHVlcyBhcyB0aGlzIG9uZS5cbiAgICovXG4gIGNsb25lKCkge1xuICAgIGNvbnN0IGFuY2hvciA9IHRoaXMuYW5jaG9yO1xuICAgIGNvbnN0IGZvY3VzID0gdGhpcy5mb2N1cztcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBuZXcgUmFuZ2VTZWxlY3Rpb24oJGNyZWF0ZVBvaW50KGFuY2hvci5rZXksIGFuY2hvci5vZmZzZXQsIGFuY2hvci50eXBlKSwgJGNyZWF0ZVBvaW50KGZvY3VzLmtleSwgZm9jdXMub2Zmc2V0LCBmb2N1cy50eXBlKSwgdGhpcy5mb3JtYXQsIHRoaXMuc3R5bGUpO1xuICAgIHJldHVybiBzZWxlY3Rpb247XG4gIH1cblxuICAvKipcbiAgICogVG9nZ2xlcyB0aGUgcHJvdmlkZWQgZm9ybWF0IG9uIGFsbCB0aGUgVGV4dE5vZGVzIGluIHRoZSBTZWxlY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSBmb3JtYXQgYSBzdHJpbmcgVGV4dEZvcm1hdFR5cGUgdG8gdG9nZ2xlIG9uIHRoZSBUZXh0Tm9kZXMgaW4gdGhlIHNlbGVjdGlvblxuICAgKi9cbiAgdG9nZ2xlRm9ybWF0KGZvcm1hdCkge1xuICAgIHRoaXMuZm9ybWF0ID0gdG9nZ2xlVGV4dEZvcm1hdFR5cGUodGhpcy5mb3JtYXQsIGZvcm1hdCwgbnVsbCk7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgdmFsdWUgb2YgdGhlIHN0eWxlIHByb3BlcnR5IG9uIHRoZSBTZWxlY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHN0eWxlIC0gdGhlIHN0eWxlIHRvIHNldCBhdCB0aGUgdmFsdWUgb2YgdGhlIHN0eWxlIHByb3BlcnR5LlxuICAgKi9cbiAgc2V0U3R5bGUoc3R5bGUpIHtcbiAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBwcm92aWRlZCBUZXh0Rm9ybWF0VHlwZSBpcyBwcmVzZW50IG9uIHRoZSBTZWxlY3Rpb24uIFRoaXMgd2lsbCBiZSB0cnVlIGlmIGFueSBub2RlIGluIHRoZSBTZWxlY3Rpb25cbiAgICogaGFzIHRoZSBzcGVjaWZpZWQgZm9ybWF0LlxuICAgKlxuICAgKiBAcGFyYW0gdHlwZSB0aGUgVGV4dEZvcm1hdFR5cGUgdG8gY2hlY2sgZm9yLlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBwcm92aWRlZCBmb3JtYXQgaXMgY3VycmVudGx5IHRvZ2dsZWQgb24gb24gdGhlIFNlbGVjdGlvbiwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgaGFzRm9ybWF0KHR5cGUpIHtcbiAgICBjb25zdCBmb3JtYXRGbGFnID0gVEVYVF9UWVBFX1RPX0ZPUk1BVFt0eXBlXTtcbiAgICByZXR1cm4gKHRoaXMuZm9ybWF0ICYgZm9ybWF0RmxhZykgIT09IDA7XG4gIH1cblxuICAvKipcbiAgICogQXR0ZW1wdHMgdG8gaW5zZXJ0IHRoZSBwcm92aWRlZCB0ZXh0IGludG8gdGhlIEVkaXRvclN0YXRlIGF0IHRoZSBjdXJyZW50IFNlbGVjdGlvbi5cbiAgICogY29udmVydHMgdGFicywgbmV3bGluZXMsIGFuZCBjYXJyaWFnZSByZXR1cm5zIGludG8gTGV4aWNhbE5vZGVzLlxuICAgKlxuICAgKiBAcGFyYW0gdGV4dCB0aGUgdGV4dCB0byBpbnNlcnQgaW50byB0aGUgU2VsZWN0aW9uXG4gICAqL1xuICBpbnNlcnRSYXdUZXh0KHRleHQpIHtcbiAgICBjb25zdCBwYXJ0cyA9IHRleHQuc3BsaXQoLyhcXHI/XFxufFxcdCkvKTtcbiAgICBjb25zdCBub2RlcyA9IFtdO1xuICAgIGNvbnN0IGxlbmd0aCA9IHBhcnRzLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwYXJ0ID0gcGFydHNbaV07XG4gICAgICBpZiAocGFydCA9PT0gJ1xcbicgfHwgcGFydCA9PT0gJ1xcclxcbicpIHtcbiAgICAgICAgbm9kZXMucHVzaCgkY3JlYXRlTGluZUJyZWFrTm9kZSgpKTtcbiAgICAgIH0gZWxzZSBpZiAocGFydCA9PT0gJ1xcdCcpIHtcbiAgICAgICAgbm9kZXMucHVzaCgkY3JlYXRlVGFiTm9kZSgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVzLnB1c2goJGNyZWF0ZVRleHROb2RlKHBhcnQpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5pbnNlcnROb2Rlcyhub2Rlcyk7XG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0IHRoZSBwcm92aWRlZCB0ZXh0IGludG8gdGhlIEVkaXRvclN0YXRlIGF0IHRoZSBjdXJyZW50IFNlbGVjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHRleHQgdGhlIHRleHQgdG8gaW5zZXJ0IGludG8gdGhlIFNlbGVjdGlvblxuICAgKi9cbiAgaW5zZXJ0VGV4dCh0ZXh0KSB7XG4gICAgLy8gTm93IHRoYXQgXCJyZW1vdmVUZXh0XCIgaGFzIGJlZW4gaW1wcm92ZWQgYW5kIGRvZXMgbm90IGRlcGVuZCBvblxuICAgIC8vIGluc2VydFRleHQsIGluc2VydFRleHQgY2FuIGJlIGdyZWF0bHkgc2ltcGxpZmllZC4gVGhlIG5leHRcbiAgICAvLyBjb21tZW50ZWQgdmVyc2lvbiBpcyBhIFdJUCAoYWJvdXQgNSB0ZXN0cyBmYWlsKS5cbiAgICAvL1xuICAgIC8vIHRoaXMucmVtb3ZlVGV4dCgpO1xuICAgIC8vIGlmICh0ZXh0ID09PSAnJykge1xuICAgIC8vICAgcmV0dXJuO1xuICAgIC8vIH1cbiAgICAvLyBjb25zdCBhbmNob3JOb2RlID0gdGhpcy5hbmNob3IuZ2V0Tm9kZSgpO1xuICAgIC8vIGNvbnN0IHRleHROb2RlID0gJGNyZWF0ZVRleHROb2RlKHRleHQpO1xuICAgIC8vIHRleHROb2RlLnNldEZvcm1hdCh0aGlzLmZvcm1hdCk7XG4gICAgLy8gdGV4dE5vZGUuc2V0U3R5bGUodGhpcy5zdHlsZSk7XG4gICAgLy8gaWYgKCRpc1RleHROb2RlKGFuY2hvck5vZGUpKSB7XG4gICAgLy8gICBjb25zdCBwYXJlbnQgPSBhbmNob3JOb2RlLmdldFBhcmVudE9yVGhyb3coKTtcbiAgICAvLyAgIGlmICh0aGlzLmFuY2hvci5vZmZzZXQgPT09IDApIHtcbiAgICAvLyAgICAgaWYgKHBhcmVudC5pc0lubGluZSgpICYmICFhbmNob3JOb2RlLl9fcHJldikge1xuICAgIC8vICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUodGV4dE5vZGUpO1xuICAgIC8vICAgICB9IGVsc2Uge1xuICAgIC8vICAgICAgIGFuY2hvck5vZGUuaW5zZXJ0QmVmb3JlKHRleHROb2RlKTtcbiAgICAvLyAgICAgfVxuICAgIC8vICAgfSBlbHNlIGlmICh0aGlzLmFuY2hvci5vZmZzZXQgPT09IGFuY2hvck5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCkpIHtcbiAgICAvLyAgICAgaWYgKHBhcmVudC5pc0lubGluZSgpICYmICFhbmNob3JOb2RlLl9fbmV4dCkge1xuICAgIC8vICAgICAgIHBhcmVudC5pbnNlcnRBZnRlcih0ZXh0Tm9kZSk7XG4gICAgLy8gICAgIH0gZWxzZSB7XG4gICAgLy8gICAgICAgYW5jaG9yTm9kZS5pbnNlcnRBZnRlcih0ZXh0Tm9kZSk7XG4gICAgLy8gICAgIH1cbiAgICAvLyAgIH0gZWxzZSB7XG4gICAgLy8gICAgIGNvbnN0IFtiZWZvcmVdID0gYW5jaG9yTm9kZS5zcGxpdFRleHQodGhpcy5hbmNob3Iub2Zmc2V0KTtcbiAgICAvLyAgICAgYmVmb3JlLmluc2VydEFmdGVyKHRleHROb2RlKTtcbiAgICAvLyAgIH1cbiAgICAvLyB9IGVsc2Uge1xuICAgIC8vICAgYW5jaG9yTm9kZS5zcGxpY2UodGhpcy5hbmNob3Iub2Zmc2V0LCAwLCBbdGV4dE5vZGVdKTtcbiAgICAvLyB9XG4gICAgLy8gY29uc3Qgbm9kZVRvU2VsZWN0ID0gdGV4dE5vZGUuaXNBdHRhY2hlZCgpID8gdGV4dE5vZGUgOiBhbmNob3JOb2RlO1xuICAgIC8vIG5vZGVUb1NlbGVjdC5zZWxlY3RFbmQoKTtcbiAgICAvLyAvLyBXaGVuIGNvbXBvc2luZywgd2UgbmVlZCB0byBhZGp1c3QgdGhlIGFuY2hvciBvZmZzZXQgc28gdGhhdFxuICAgIC8vIC8vIHdlIGNvcnJlY3RseSByZXBsYWNlIHRoYXQgcmlnaHQgcmFuZ2UuXG4gICAgLy8gaWYgKFxuICAgIC8vICAgdGV4dE5vZGUuaXNDb21wb3NpbmcoKSAmJlxuICAgIC8vICAgdGhpcy5hbmNob3IudHlwZSA9PT0gJ3RleHQnICYmXG4gICAgLy8gICBhbmNob3JOb2RlLmdldFRleHRDb250ZW50KCkgIT09ICcnXG4gICAgLy8gKSB7XG4gICAgLy8gICB0aGlzLmFuY2hvci5vZmZzZXQgLT0gdGV4dC5sZW5ndGg7XG4gICAgLy8gfVxuXG4gICAgY29uc3QgYW5jaG9yID0gdGhpcy5hbmNob3I7XG4gICAgY29uc3QgZm9jdXMgPSB0aGlzLmZvY3VzO1xuICAgIGNvbnN0IGZvcm1hdCA9IHRoaXMuZm9ybWF0O1xuICAgIGNvbnN0IHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICBsZXQgZmlyc3RQb2ludCA9IGFuY2hvcjtcbiAgICBsZXQgZW5kUG9pbnQgPSBmb2N1cztcbiAgICBpZiAoIXRoaXMuaXNDb2xsYXBzZWQoKSAmJiBmb2N1cy5pc0JlZm9yZShhbmNob3IpKSB7XG4gICAgICBmaXJzdFBvaW50ID0gZm9jdXM7XG4gICAgICBlbmRQb2ludCA9IGFuY2hvcjtcbiAgICB9XG4gICAgaWYgKGZpcnN0UG9pbnQudHlwZSA9PT0gJ2VsZW1lbnQnKSB7XG4gICAgICAkdHJhbnNmZXJTdGFydGluZ0VsZW1lbnRQb2ludFRvVGV4dFBvaW50KGZpcnN0UG9pbnQsIGVuZFBvaW50LCBmb3JtYXQsIHN0eWxlKTtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnRPZmZzZXQgPSBmaXJzdFBvaW50Lm9mZnNldDtcbiAgICBsZXQgZW5kT2Zmc2V0ID0gZW5kUG9pbnQub2Zmc2V0O1xuICAgIGNvbnN0IHNlbGVjdGVkTm9kZXMgPSB0aGlzLmdldE5vZGVzKCk7XG4gICAgY29uc3Qgc2VsZWN0ZWROb2Rlc0xlbmd0aCA9IHNlbGVjdGVkTm9kZXMubGVuZ3RoO1xuICAgIGxldCBmaXJzdE5vZGUgPSBzZWxlY3RlZE5vZGVzWzBdO1xuICAgIGlmICghJGlzVGV4dE5vZGUoZmlyc3ROb2RlKSkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvcihgaW5zZXJ0VGV4dDogZmlyc3Qgbm9kZSBpcyBub3QgYSB0ZXh0IG5vZGVgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZmlyc3ROb2RlVGV4dCA9IGZpcnN0Tm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICAgIGNvbnN0IGZpcnN0Tm9kZVRleHRMZW5ndGggPSBmaXJzdE5vZGVUZXh0Lmxlbmd0aDtcbiAgICBjb25zdCBmaXJzdE5vZGVQYXJlbnQgPSBmaXJzdE5vZGUuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgIGNvbnN0IGxhc3RJbmRleCA9IHNlbGVjdGVkTm9kZXNMZW5ndGggLSAxO1xuICAgIGxldCBsYXN0Tm9kZSA9IHNlbGVjdGVkTm9kZXNbbGFzdEluZGV4XTtcbiAgICBpZiAoc2VsZWN0ZWROb2Rlc0xlbmd0aCA9PT0gMSAmJiBlbmRQb2ludC50eXBlID09PSAnZWxlbWVudCcpIHtcbiAgICAgIGVuZE9mZnNldCA9IGZpcnN0Tm9kZVRleHRMZW5ndGg7XG4gICAgICBlbmRQb2ludC5zZXQoZmlyc3RQb2ludC5rZXksIGVuZE9mZnNldCwgJ3RleHQnKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNDb2xsYXBzZWQoKSAmJiBzdGFydE9mZnNldCA9PT0gZmlyc3ROb2RlVGV4dExlbmd0aCAmJiAoZmlyc3ROb2RlLmlzU2VnbWVudGVkKCkgfHwgZmlyc3ROb2RlLmlzVG9rZW4oKSB8fCAhZmlyc3ROb2RlLmNhbkluc2VydFRleHRBZnRlcigpIHx8ICFmaXJzdE5vZGVQYXJlbnQuY2FuSW5zZXJ0VGV4dEFmdGVyKCkgJiYgZmlyc3ROb2RlLmdldE5leHRTaWJsaW5nKCkgPT09IG51bGwpKSB7XG4gICAgICBsZXQgbmV4dFNpYmxpbmcgPSBmaXJzdE5vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICAgIGlmICghJGlzVGV4dE5vZGUobmV4dFNpYmxpbmcpIHx8ICFuZXh0U2libGluZy5jYW5JbnNlcnRUZXh0QmVmb3JlKCkgfHwgJGlzVG9rZW5PclNlZ21lbnRlZChuZXh0U2libGluZykpIHtcbiAgICAgICAgbmV4dFNpYmxpbmcgPSAkY3JlYXRlVGV4dE5vZGUoKTtcbiAgICAgICAgbmV4dFNpYmxpbmcuc2V0Rm9ybWF0KGZvcm1hdCk7XG4gICAgICAgIG5leHRTaWJsaW5nLnNldFN0eWxlKHN0eWxlKTtcbiAgICAgICAgaWYgKCFmaXJzdE5vZGVQYXJlbnQuY2FuSW5zZXJ0VGV4dEFmdGVyKCkpIHtcbiAgICAgICAgICBmaXJzdE5vZGVQYXJlbnQuaW5zZXJ0QWZ0ZXIobmV4dFNpYmxpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZpcnN0Tm9kZS5pbnNlcnRBZnRlcihuZXh0U2libGluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5leHRTaWJsaW5nLnNlbGVjdCgwLCAwKTtcbiAgICAgIGZpcnN0Tm9kZSA9IG5leHRTaWJsaW5nO1xuICAgICAgaWYgKHRleHQgIT09ICcnKSB7XG4gICAgICAgIHRoaXMuaW5zZXJ0VGV4dCh0ZXh0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5pc0NvbGxhcHNlZCgpICYmIHN0YXJ0T2Zmc2V0ID09PSAwICYmIChmaXJzdE5vZGUuaXNTZWdtZW50ZWQoKSB8fCBmaXJzdE5vZGUuaXNUb2tlbigpIHx8ICFmaXJzdE5vZGUuY2FuSW5zZXJ0VGV4dEJlZm9yZSgpIHx8ICFmaXJzdE5vZGVQYXJlbnQuY2FuSW5zZXJ0VGV4dEJlZm9yZSgpICYmIGZpcnN0Tm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKSA9PT0gbnVsbCkpIHtcbiAgICAgIGxldCBwcmV2U2libGluZyA9IGZpcnN0Tm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICAgIGlmICghJGlzVGV4dE5vZGUocHJldlNpYmxpbmcpIHx8ICRpc1Rva2VuT3JTZWdtZW50ZWQocHJldlNpYmxpbmcpKSB7XG4gICAgICAgIHByZXZTaWJsaW5nID0gJGNyZWF0ZVRleHROb2RlKCk7XG4gICAgICAgIHByZXZTaWJsaW5nLnNldEZvcm1hdChmb3JtYXQpO1xuICAgICAgICBpZiAoIWZpcnN0Tm9kZVBhcmVudC5jYW5JbnNlcnRUZXh0QmVmb3JlKCkpIHtcbiAgICAgICAgICBmaXJzdE5vZGVQYXJlbnQuaW5zZXJ0QmVmb3JlKHByZXZTaWJsaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmaXJzdE5vZGUuaW5zZXJ0QmVmb3JlKHByZXZTaWJsaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcHJldlNpYmxpbmcuc2VsZWN0KCk7XG4gICAgICBmaXJzdE5vZGUgPSBwcmV2U2libGluZztcbiAgICAgIGlmICh0ZXh0ICE9PSAnJykge1xuICAgICAgICB0aGlzLmluc2VydFRleHQodGV4dCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGZpcnN0Tm9kZS5pc1NlZ21lbnRlZCgpICYmIHN0YXJ0T2Zmc2V0ICE9PSBmaXJzdE5vZGVUZXh0TGVuZ3RoKSB7XG4gICAgICBjb25zdCB0ZXh0Tm9kZSA9ICRjcmVhdGVUZXh0Tm9kZShmaXJzdE5vZGUuZ2V0VGV4dENvbnRlbnQoKSk7XG4gICAgICB0ZXh0Tm9kZS5zZXRGb3JtYXQoZm9ybWF0KTtcbiAgICAgIGZpcnN0Tm9kZS5yZXBsYWNlKHRleHROb2RlKTtcbiAgICAgIGZpcnN0Tm9kZSA9IHRleHROb2RlO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuaXNDb2xsYXBzZWQoKSAmJiB0ZXh0ICE9PSAnJykge1xuICAgICAgLy8gV2hlbiB0aGUgZmlyc3ROb2RlIG9yIGxhc3ROb2RlIHBhcmVudHMgYXJlIGVsZW1lbnRzIHRoYXRcbiAgICAgIC8vIGRvIG5vdCBhbGxvdyB0ZXh0IHRvIGJlIGluc2VydGVkIGJlZm9yZSBvciBhZnRlciwgd2UgZmlyc3RcbiAgICAgIC8vIGNsZWFyIHRoZSBjb250ZW50LiBUaGVuIHdlIG5vcm1hbGl6ZSBzZWxlY3Rpb24sIHRoZW4gaW5zZXJ0XG4gICAgICAvLyB0aGUgbmV3IGNvbnRlbnQuXG4gICAgICBjb25zdCBsYXN0Tm9kZVBhcmVudCA9IGxhc3ROb2RlLmdldFBhcmVudCgpO1xuICAgICAgaWYgKCFmaXJzdE5vZGVQYXJlbnQuY2FuSW5zZXJ0VGV4dEJlZm9yZSgpIHx8ICFmaXJzdE5vZGVQYXJlbnQuY2FuSW5zZXJ0VGV4dEFmdGVyKCkgfHwgJGlzRWxlbWVudE5vZGUobGFzdE5vZGVQYXJlbnQpICYmICghbGFzdE5vZGVQYXJlbnQuY2FuSW5zZXJ0VGV4dEJlZm9yZSgpIHx8ICFsYXN0Tm9kZVBhcmVudC5jYW5JbnNlcnRUZXh0QWZ0ZXIoKSkpIHtcbiAgICAgICAgdGhpcy5pbnNlcnRUZXh0KCcnKTtcbiAgICAgICAgJG5vcm1hbGl6ZVNlbGVjdGlvblBvaW50c0ZvckJvdW5kYXJpZXModGhpcy5hbmNob3IsIHRoaXMuZm9jdXMsIG51bGwpO1xuICAgICAgICB0aGlzLmluc2VydFRleHQodGV4dCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNlbGVjdGVkTm9kZXNMZW5ndGggPT09IDEpIHtcbiAgICAgIGlmIChmaXJzdE5vZGUuaXNUb2tlbigpKSB7XG4gICAgICAgIGNvbnN0IHRleHROb2RlID0gJGNyZWF0ZVRleHROb2RlKHRleHQpO1xuICAgICAgICB0ZXh0Tm9kZS5zZWxlY3QoKTtcbiAgICAgICAgZmlyc3ROb2RlLnJlcGxhY2UodGV4dE5vZGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBmaXJzdE5vZGVGb3JtYXQgPSBmaXJzdE5vZGUuZ2V0Rm9ybWF0KCk7XG4gICAgICBjb25zdCBmaXJzdE5vZGVTdHlsZSA9IGZpcnN0Tm9kZS5nZXRTdHlsZSgpO1xuICAgICAgaWYgKHN0YXJ0T2Zmc2V0ID09PSBlbmRPZmZzZXQgJiYgKGZpcnN0Tm9kZUZvcm1hdCAhPT0gZm9ybWF0IHx8IGZpcnN0Tm9kZVN0eWxlICE9PSBzdHlsZSkpIHtcbiAgICAgICAgaWYgKGZpcnN0Tm9kZS5nZXRUZXh0Q29udGVudCgpID09PSAnJykge1xuICAgICAgICAgIGZpcnN0Tm9kZS5zZXRGb3JtYXQoZm9ybWF0KTtcbiAgICAgICAgICBmaXJzdE5vZGUuc2V0U3R5bGUoc3R5bGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHRleHROb2RlID0gJGNyZWF0ZVRleHROb2RlKHRleHQpO1xuICAgICAgICAgIHRleHROb2RlLnNldEZvcm1hdChmb3JtYXQpO1xuICAgICAgICAgIHRleHROb2RlLnNldFN0eWxlKHN0eWxlKTtcbiAgICAgICAgICB0ZXh0Tm9kZS5zZWxlY3QoKTtcbiAgICAgICAgICBpZiAoc3RhcnRPZmZzZXQgPT09IDApIHtcbiAgICAgICAgICAgIGZpcnN0Tm9kZS5pbnNlcnRCZWZvcmUodGV4dE5vZGUsIGZhbHNlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgW3RhcmdldE5vZGVdID0gZmlyc3ROb2RlLnNwbGl0VGV4dChzdGFydE9mZnNldCk7XG4gICAgICAgICAgICB0YXJnZXROb2RlLmluc2VydEFmdGVyKHRleHROb2RlLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFdoZW4gY29tcG9zaW5nLCB3ZSBuZWVkIHRvIGFkanVzdCB0aGUgYW5jaG9yIG9mZnNldCBzbyB0aGF0XG4gICAgICAgICAgLy8gd2UgY29ycmVjdGx5IHJlcGxhY2UgdGhhdCByaWdodCByYW5nZS5cbiAgICAgICAgICBpZiAodGV4dE5vZGUuaXNDb21wb3NpbmcoKSAmJiB0aGlzLmFuY2hvci50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgIHRoaXMuYW5jaG9yLm9mZnNldCAtPSB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCRpc1RhYk5vZGUoZmlyc3ROb2RlKSkge1xuICAgICAgICAvLyBXZSBkb24ndCBuZWVkIHRvIGNoZWNrIGZvciBkZWxDb3VudCBiZWNhdXNlIHRoZXJlIGlzIG9ubHkgdGhlIGVudGlyZSBzZWxlY3RlZCBub2RlIGNhc2VcbiAgICAgICAgLy8gdGhhdCBjYW4gaGl0IGhlcmUgZm9yIGNvbnRlbnQgc2l6ZSAxIGFuZCB3aXRoIGNhbkluc2VydFRleHRCZWZvcmVBZnRlciBmYWxzZVxuICAgICAgICBjb25zdCB0ZXh0Tm9kZSA9ICRjcmVhdGVUZXh0Tm9kZSh0ZXh0KTtcbiAgICAgICAgdGV4dE5vZGUuc2V0Rm9ybWF0KGZvcm1hdCk7XG4gICAgICAgIHRleHROb2RlLnNldFN0eWxlKHN0eWxlKTtcbiAgICAgICAgdGV4dE5vZGUuc2VsZWN0KCk7XG4gICAgICAgIGZpcnN0Tm9kZS5yZXBsYWNlKHRleHROb2RlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZGVsQ291bnQgPSBlbmRPZmZzZXQgLSBzdGFydE9mZnNldDtcbiAgICAgIGZpcnN0Tm9kZSA9IGZpcnN0Tm9kZS5zcGxpY2VUZXh0KHN0YXJ0T2Zmc2V0LCBkZWxDb3VudCwgdGV4dCwgdHJ1ZSk7XG4gICAgICBpZiAoZmlyc3ROb2RlLmdldFRleHRDb250ZW50KCkgPT09ICcnKSB7XG4gICAgICAgIGZpcnN0Tm9kZS5yZW1vdmUoKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5hbmNob3IudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgIGlmIChmaXJzdE5vZGUuaXNDb21wb3NpbmcoKSkge1xuICAgICAgICAgIC8vIFdoZW4gY29tcG9zaW5nLCB3ZSBuZWVkIHRvIGFkanVzdCB0aGUgYW5jaG9yIG9mZnNldCBzbyB0aGF0XG4gICAgICAgICAgLy8gd2UgY29ycmVjdGx5IHJlcGxhY2UgdGhhdCByaWdodCByYW5nZS5cbiAgICAgICAgICB0aGlzLmFuY2hvci5vZmZzZXQgLT0gdGV4dC5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5mb3JtYXQgPSBmaXJzdE5vZGVGb3JtYXQ7XG4gICAgICAgICAgdGhpcy5zdHlsZSA9IGZpcnN0Tm9kZVN0eWxlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG1hcmtlZE5vZGVLZXlzRm9yS2VlcCA9IG5ldyBTZXQoWy4uLmZpcnN0Tm9kZS5nZXRQYXJlbnRLZXlzKCksIC4uLmxhc3ROb2RlLmdldFBhcmVudEtleXMoKV0pO1xuXG4gICAgICAvLyBXZSBoYXZlIHRvIGdldCB0aGUgcGFyZW50IGVsZW1lbnRzIGJlZm9yZSB0aGUgbmV4dCBzZWN0aW9uLFxuICAgICAgLy8gYXMgaW4gdGhhdCBzZWN0aW9uIHdlIG1pZ2h0IG11dGF0ZSB0aGUgbGFzdE5vZGUuXG4gICAgICBjb25zdCBmaXJzdEVsZW1lbnQgPSAkaXNFbGVtZW50Tm9kZShmaXJzdE5vZGUpID8gZmlyc3ROb2RlIDogZmlyc3ROb2RlLmdldFBhcmVudE9yVGhyb3coKTtcbiAgICAgIGxldCBsYXN0RWxlbWVudCA9ICRpc0VsZW1lbnROb2RlKGxhc3ROb2RlKSA/IGxhc3ROb2RlIDogbGFzdE5vZGUuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgICAgbGV0IGxhc3RFbGVtZW50Q2hpbGQgPSBsYXN0Tm9kZTtcblxuICAgICAgLy8gSWYgdGhlIGxhc3QgZWxlbWVudCBpcyBpbmxpbmUsIHdlIHNob3VsZCBpbnN0ZWFkIGxvb2sgYXQgZ2V0dGluZ1xuICAgICAgLy8gdGhlIG5vZGVzIG9mIGl0cyBwYXJlbnQsIHJhdGhlciB0aGFuIGl0c2VsZi4gVGhpcyBiZWhhdmlvciB3aWxsXG4gICAgICAvLyB0aGVuIGJldHRlciBtYXRjaCBob3cgdGV4dCBub2RlIGluc2VydGlvbnMgd29yay4gV2Ugd2lsbCBuZWVkIHRvXG4gICAgICAvLyBhbHNvIHVwZGF0ZSB0aGUgbGFzdCBlbGVtZW50J3MgY2hpbGQgYWNjb3JkaW5nbHkgYXMgd2UgZG8gdGhpcy5cbiAgICAgIGlmICghZmlyc3RFbGVtZW50LmlzKGxhc3RFbGVtZW50KSAmJiBsYXN0RWxlbWVudC5pc0lubGluZSgpKSB7XG4gICAgICAgIC8vIEtlZXAgdHJhdmVyc2luZyB0aWxsIHdlIGhhdmUgYSBub24taW5saW5lIGVsZW1lbnQgcGFyZW50LlxuICAgICAgICBkbyB7XG4gICAgICAgICAgbGFzdEVsZW1lbnRDaGlsZCA9IGxhc3RFbGVtZW50O1xuICAgICAgICAgIGxhc3RFbGVtZW50ID0gbGFzdEVsZW1lbnQuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgICAgICB9IHdoaWxlIChsYXN0RWxlbWVudC5pc0lubGluZSgpKTtcbiAgICAgIH1cblxuICAgICAgLy8gSGFuZGxlIG11dGF0aW9ucyB0byB0aGUgbGFzdCBub2RlLlxuICAgICAgaWYgKGVuZFBvaW50LnR5cGUgPT09ICd0ZXh0JyAmJiAoZW5kT2Zmc2V0ICE9PSAwIHx8IGxhc3ROb2RlLmdldFRleHRDb250ZW50KCkgPT09ICcnKSB8fCBlbmRQb2ludC50eXBlID09PSAnZWxlbWVudCcgJiYgbGFzdE5vZGUuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKSA8IGVuZE9mZnNldCkge1xuICAgICAgICBpZiAoJGlzVGV4dE5vZGUobGFzdE5vZGUpICYmICFsYXN0Tm9kZS5pc1Rva2VuKCkgJiYgZW5kT2Zmc2V0ICE9PSBsYXN0Tm9kZS5nZXRUZXh0Q29udGVudFNpemUoKSkge1xuICAgICAgICAgIGlmIChsYXN0Tm9kZS5pc1NlZ21lbnRlZCgpKSB7XG4gICAgICAgICAgICBjb25zdCB0ZXh0Tm9kZSA9ICRjcmVhdGVUZXh0Tm9kZShsYXN0Tm9kZS5nZXRUZXh0Q29udGVudCgpKTtcbiAgICAgICAgICAgIGxhc3ROb2RlLnJlcGxhY2UodGV4dE5vZGUpO1xuICAgICAgICAgICAgbGFzdE5vZGUgPSB0ZXh0Tm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gcm9vdCBub2RlIHNlbGVjdGlvbnMgb25seSBzZWxlY3Qgd2hvbGUgbm9kZXMsIHNvIG5vIHRleHQgc3BsaWNlIGlzIG5lY2Vzc2FyeVxuICAgICAgICAgIGlmICghJGlzUm9vdE5vZGUoZW5kUG9pbnQuZ2V0Tm9kZSgpKSAmJiBlbmRQb2ludC50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgIGxhc3ROb2RlID0gbGFzdE5vZGUuc3BsaWNlVGV4dCgwLCBlbmRPZmZzZXQsICcnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWFya2VkTm9kZUtleXNGb3JLZWVwLmFkZChsYXN0Tm9kZS5fX2tleSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgbGFzdE5vZGVQYXJlbnQgPSBsYXN0Tm9kZS5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgICAgICAgaWYgKCFsYXN0Tm9kZVBhcmVudC5jYW5CZUVtcHR5KCkgJiYgbGFzdE5vZGVQYXJlbnQuZ2V0Q2hpbGRyZW5TaXplKCkgPT09IDEpIHtcbiAgICAgICAgICAgIGxhc3ROb2RlUGFyZW50LnJlbW92ZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsYXN0Tm9kZS5yZW1vdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hcmtlZE5vZGVLZXlzRm9yS2VlcC5hZGQobGFzdE5vZGUuX19rZXkpO1xuICAgICAgfVxuXG4gICAgICAvLyBFaXRoZXIgbW92ZSB0aGUgcmVtYWluaW5nIG5vZGVzIG9mIHRoZSBsYXN0IHBhcmVudCB0byBhZnRlclxuICAgICAgLy8gdGhlIGZpcnN0IGNoaWxkLCBvciByZW1vdmUgdGhlbSBlbnRpcmVseS4gSWYgdGhlIGxhc3QgcGFyZW50XG4gICAgICAvLyBpcyB0aGUgc2FtZSBhcyB0aGUgZmlyc3QgcGFyZW50LCB0aGlzIGxvZ2ljIGFsc28gd29ya3MuXG4gICAgICBjb25zdCBsYXN0Tm9kZUNoaWxkcmVuID0gbGFzdEVsZW1lbnQuZ2V0Q2hpbGRyZW4oKTtcbiAgICAgIGNvbnN0IHNlbGVjdGVkTm9kZXNTZXQgPSBuZXcgU2V0KHNlbGVjdGVkTm9kZXMpO1xuICAgICAgY29uc3QgZmlyc3RBbmRMYXN0RWxlbWVudHNBcmVFcXVhbCA9IGZpcnN0RWxlbWVudC5pcyhsYXN0RWxlbWVudCk7XG5cbiAgICAgIC8vIFdlIGNob29zZSBhIHRhcmdldCB0byBpbnNlcnQgYWxsIG5vZGVzIGFmdGVyLiBJbiB0aGUgY2FzZSBvZiBoYXZpbmdcbiAgICAgIC8vIGFuZCBpbmxpbmUgc3RhcnRpbmcgcGFyZW50IGVsZW1lbnQgd2l0aCBhIHN0YXJ0aW5nIG5vZGUgdGhhdCBoYXMgbm9cbiAgICAgIC8vIHNpYmxpbmdzLCB3ZSBzaG91bGQgaW5zZXJ0IGFmdGVyIHRoZSBzdGFydGluZyBwYXJlbnQgZWxlbWVudCwgb3RoZXJ3aXNlXG4gICAgICAvLyB3ZSB3aWxsIGluY29ycmVjdGx5IG1lcmdlIGludG8gdGhlIHN0YXJ0aW5nIHBhcmVudCBlbGVtZW50LlxuICAgICAgLy8gVE9ETzogc2hvdWxkIHdlIGtlZXAgb24gdHJhdmVyc2luZyBwYXJlbnRzIGlmIHdlJ3JlIGluc2lkZSBhbm90aGVyXG4gICAgICAvLyBuZXN0ZWQgaW5saW5lIGVsZW1lbnQ/XG4gICAgICBjb25zdCBpbnNlcnRpb25UYXJnZXQgPSBmaXJzdEVsZW1lbnQuaXNJbmxpbmUoKSAmJiBmaXJzdE5vZGUuZ2V0TmV4dFNpYmxpbmcoKSA9PT0gbnVsbCA/IGZpcnN0RWxlbWVudCA6IGZpcnN0Tm9kZTtcbiAgICAgIGZvciAobGV0IGkgPSBsYXN0Tm9kZUNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IGxhc3ROb2RlQ2hpbGQgPSBsYXN0Tm9kZUNoaWxkcmVuW2ldO1xuICAgICAgICBpZiAobGFzdE5vZGVDaGlsZC5pcyhmaXJzdE5vZGUpIHx8ICRpc0VsZW1lbnROb2RlKGxhc3ROb2RlQ2hpbGQpICYmIGxhc3ROb2RlQ2hpbGQuaXNQYXJlbnRPZihmaXJzdE5vZGUpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3ROb2RlQ2hpbGQuaXNBdHRhY2hlZCgpKSB7XG4gICAgICAgICAgaWYgKCFzZWxlY3RlZE5vZGVzU2V0LmhhcyhsYXN0Tm9kZUNoaWxkKSB8fCBsYXN0Tm9kZUNoaWxkLmlzKGxhc3RFbGVtZW50Q2hpbGQpKSB7XG4gICAgICAgICAgICBpZiAoIWZpcnN0QW5kTGFzdEVsZW1lbnRzQXJlRXF1YWwpIHtcbiAgICAgICAgICAgICAgaW5zZXJ0aW9uVGFyZ2V0Lmluc2VydEFmdGVyKGxhc3ROb2RlQ2hpbGQsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGFzdE5vZGVDaGlsZC5yZW1vdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghZmlyc3RBbmRMYXN0RWxlbWVudHNBcmVFcXVhbCkge1xuICAgICAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIGFscmVhZHkgbW92ZWQgb3V0IGFsbCB0aGUgbm9kZXMgb2YgdGhlXG4gICAgICAgIC8vIGxhc3QgcGFyZW50LCBhbmQgaWYgc28sIHRyYXZlcnNlIHRoZSBwYXJlbnQgdHJlZSBhbmQgbWFya1xuICAgICAgICAvLyB0aGVtIGFsbCBhcyBiZWluZyBhYmxlIHRvIGRlbGV0ZWQgdG9vLlxuICAgICAgICBsZXQgcGFyZW50ID0gbGFzdEVsZW1lbnQ7XG4gICAgICAgIGxldCBsYXN0UmVtb3ZlZFBhcmVudCA9IG51bGw7XG4gICAgICAgIHdoaWxlIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudC5nZXRDaGlsZHJlbigpO1xuICAgICAgICAgIGNvbnN0IGNoaWxkcmVuTGVuZ3RoID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMCB8fCBjaGlsZHJlbltjaGlsZHJlbkxlbmd0aCAtIDFdLmlzKGxhc3RSZW1vdmVkUGFyZW50KSkge1xuICAgICAgICAgICAgbWFya2VkTm9kZUtleXNGb3JLZWVwLmRlbGV0ZShwYXJlbnQuX19rZXkpO1xuICAgICAgICAgICAgbGFzdFJlbW92ZWRQYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5nZXRQYXJlbnQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBFbnN1cmUgd2UgZG8gc3BsaWNpbmcgYWZ0ZXIgbW92aW5nIG9mIG5vZGVzLCBhcyBzcGxpY2luZ1xuICAgICAgLy8gY2FuIGhhdmUgc2lkZS1lZmZlY3RzIChpbiB0aGUgY2FzZSBvZiBoYXNodGFncykuXG4gICAgICBpZiAoIWZpcnN0Tm9kZS5pc1Rva2VuKCkpIHtcbiAgICAgICAgZmlyc3ROb2RlID0gZmlyc3ROb2RlLnNwbGljZVRleHQoc3RhcnRPZmZzZXQsIGZpcnN0Tm9kZVRleHRMZW5ndGggLSBzdGFydE9mZnNldCwgdGV4dCwgdHJ1ZSk7XG4gICAgICAgIGlmIChmaXJzdE5vZGUuZ2V0VGV4dENvbnRlbnQoKSA9PT0gJycpIHtcbiAgICAgICAgICBmaXJzdE5vZGUucmVtb3ZlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlyc3ROb2RlLmlzQ29tcG9zaW5nKCkgJiYgdGhpcy5hbmNob3IudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgLy8gV2hlbiBjb21wb3NpbmcsIHdlIG5lZWQgdG8gYWRqdXN0IHRoZSBhbmNob3Igb2Zmc2V0IHNvIHRoYXRcbiAgICAgICAgICAvLyB3ZSBjb3JyZWN0bHkgcmVwbGFjZSB0aGF0IHJpZ2h0IHJhbmdlLlxuICAgICAgICAgIHRoaXMuYW5jaG9yLm9mZnNldCAtPSB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzdGFydE9mZnNldCA9PT0gZmlyc3ROb2RlVGV4dExlbmd0aCkge1xuICAgICAgICBmaXJzdE5vZGUuc2VsZWN0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0ZXh0Tm9kZSA9ICRjcmVhdGVUZXh0Tm9kZSh0ZXh0KTtcbiAgICAgICAgdGV4dE5vZGUuc2VsZWN0KCk7XG4gICAgICAgIGZpcnN0Tm9kZS5yZXBsYWNlKHRleHROb2RlKTtcbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIGFsbCBzZWxlY3RlZCBub2RlcyB0aGF0IGhhdmVuJ3QgYWxyZWFkeSBiZWVuIHJlbW92ZWQuXG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHNlbGVjdGVkTm9kZXNMZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBzZWxlY3RlZE5vZGUgPSBzZWxlY3RlZE5vZGVzW2ldO1xuICAgICAgICBjb25zdCBrZXkgPSBzZWxlY3RlZE5vZGUuX19rZXk7XG4gICAgICAgIGlmICghbWFya2VkTm9kZUtleXNGb3JLZWVwLmhhcyhrZXkpKSB7XG4gICAgICAgICAgc2VsZWN0ZWROb2RlLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIHRleHQgaW4gdGhlIFNlbGVjdGlvbiwgYWRqdXN0aW5nIHRoZSBFZGl0b3JTdGF0ZSBhY2NvcmRpbmdseS5cbiAgICovXG4gIHJlbW92ZVRleHQoKSB7XG4gICAgaWYgKHRoaXMuaXNDb2xsYXBzZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBhbmNob3IsXG4gICAgICBmb2N1c1xuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHNlbGVjdGVkTm9kZXMgPSB0aGlzLmdldE5vZGVzKCk7XG4gICAgY29uc3QgZmlyc3RQb2ludCA9IHRoaXMuaXNCYWNrd2FyZCgpID8gZm9jdXMgOiBhbmNob3I7XG4gICAgY29uc3QgbGFzdFBvaW50ID0gdGhpcy5pc0JhY2t3YXJkKCkgPyBhbmNob3IgOiBmb2N1cztcbiAgICBsZXQgZmlyc3ROb2RlID0gZmlyc3RQb2ludC5nZXROb2RlKCk7XG4gICAgbGV0IGxhc3ROb2RlID0gbGFzdFBvaW50LmdldE5vZGUoKTtcbiAgICBjb25zdCBmaXJzdEJsb2NrID0gJGdldEFuY2VzdG9yKGZpcnN0Tm9kZSwgSU5URVJOQUxfJGlzQmxvY2spO1xuICAgIGNvbnN0IGxhc3RCbG9jayA9ICRnZXRBbmNlc3RvcihsYXN0Tm9kZSwgSU5URVJOQUxfJGlzQmxvY2spO1xuICAgIC8vIElmIGEgdG9rZW4gaXMgcGFydGlhbGx5IHNlbGVjdGVkIHRoZW4gbW92ZSB0aGUgc2VsZWN0aW9uIHRvIGNvdmVyIHRoZSB3aG9sZSBzZWxlY3Rpb25cbiAgICBpZiAoJGlzVGV4dE5vZGUoZmlyc3ROb2RlKSAmJiBmaXJzdE5vZGUuaXNUb2tlbigpICYmIGZpcnN0UG9pbnQub2Zmc2V0IDwgZmlyc3ROb2RlLmdldFRleHRDb250ZW50U2l6ZSgpKSB7XG4gICAgICBmaXJzdFBvaW50Lm9mZnNldCA9IDA7XG4gICAgfVxuICAgIGlmIChsYXN0UG9pbnQub2Zmc2V0ID4gMCAmJiAkaXNUZXh0Tm9kZShsYXN0Tm9kZSkgJiYgbGFzdE5vZGUuaXNUb2tlbigpKSB7XG4gICAgICBsYXN0UG9pbnQub2Zmc2V0ID0gbGFzdE5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBzZWxlY3RlZE5vZGVzKSB7XG4gICAgICBpZiAoISRoYXNBbmNlc3RvcihmaXJzdE5vZGUsIG5vZGUpICYmICEkaGFzQW5jZXN0b3IobGFzdE5vZGUsIG5vZGUpICYmIG5vZGUuZ2V0S2V5KCkgIT09IGZpcnN0Tm9kZS5nZXRLZXkoKSAmJiBub2RlLmdldEtleSgpICE9PSBsYXN0Tm9kZS5nZXRLZXkoKSkge1xuICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBmaXhUZXh0ID0gKG5vZGUsIGRlbCkgPT4ge1xuICAgICAgaWYgKG5vZGUuZ2V0VGV4dENvbnRlbnQoKSA9PT0gJycpIHtcbiAgICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICAgIH0gZWxzZSBpZiAoZGVsICE9PSAwICYmICRpc1Rva2VuT3JTZWdtZW50ZWQobm9kZSkpIHtcbiAgICAgICAgY29uc3QgdGV4dE5vZGUgPSAkY3JlYXRlVGV4dE5vZGUobm9kZS5nZXRUZXh0Q29udGVudCgpKTtcbiAgICAgICAgdGV4dE5vZGUuc2V0Rm9ybWF0KG5vZGUuZ2V0Rm9ybWF0KCkpO1xuICAgICAgICB0ZXh0Tm9kZS5zZXRTdHlsZShub2RlLmdldFN0eWxlKCkpO1xuICAgICAgICByZXR1cm4gbm9kZS5yZXBsYWNlKHRleHROb2RlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChmaXJzdE5vZGUgPT09IGxhc3ROb2RlICYmICRpc1RleHROb2RlKGZpcnN0Tm9kZSkpIHtcbiAgICAgIGNvbnN0IGRlbCA9IE1hdGguYWJzKGZvY3VzLm9mZnNldCAtIGFuY2hvci5vZmZzZXQpO1xuICAgICAgZmlyc3ROb2RlLnNwbGljZVRleHQoZmlyc3RQb2ludC5vZmZzZXQsIGRlbCwgJycsIHRydWUpO1xuICAgICAgZml4VGV4dChmaXJzdE5vZGUsIGRlbCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICgkaXNUZXh0Tm9kZShmaXJzdE5vZGUpKSB7XG4gICAgICBjb25zdCBkZWwgPSBmaXJzdE5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCkgLSBmaXJzdFBvaW50Lm9mZnNldDtcbiAgICAgIGZpcnN0Tm9kZS5zcGxpY2VUZXh0KGZpcnN0UG9pbnQub2Zmc2V0LCBkZWwsICcnKTtcbiAgICAgIGZpcnN0Tm9kZSA9IGZpeFRleHQoZmlyc3ROb2RlLCBkZWwpIHx8IGZpcnN0Tm9kZTtcbiAgICB9XG4gICAgaWYgKCRpc1RleHROb2RlKGxhc3ROb2RlKSkge1xuICAgICAgbGFzdE5vZGUuc3BsaWNlVGV4dCgwLCBsYXN0UG9pbnQub2Zmc2V0LCAnJyk7XG4gICAgICBsYXN0Tm9kZSA9IGZpeFRleHQobGFzdE5vZGUsIGxhc3RQb2ludC5vZmZzZXQpIHx8IGxhc3ROb2RlO1xuICAgIH1cbiAgICBpZiAoZmlyc3ROb2RlLmlzQXR0YWNoZWQoKSAmJiAkaXNUZXh0Tm9kZShmaXJzdE5vZGUpKSB7XG4gICAgICBmaXJzdE5vZGUuc2VsZWN0RW5kKCk7XG4gICAgfSBlbHNlIGlmIChsYXN0Tm9kZS5pc0F0dGFjaGVkKCkgJiYgJGlzVGV4dE5vZGUobGFzdE5vZGUpKSB7XG4gICAgICBsYXN0Tm9kZS5zZWxlY3RTdGFydCgpO1xuICAgIH1cblxuICAgIC8vIE1lcmdlIGJsb2Nrc1xuICAgIGNvbnN0IGJvdGhFbGVtID0gJGlzRWxlbWVudE5vZGUoZmlyc3RCbG9jaykgJiYgJGlzRWxlbWVudE5vZGUobGFzdEJsb2NrKTtcbiAgICBpZiAoYm90aEVsZW0gJiYgZmlyc3RCbG9jayAhPT0gbGFzdEJsb2NrKSB7XG4gICAgICBmaXJzdEJsb2NrLmFwcGVuZCguLi5sYXN0QmxvY2suZ2V0Q2hpbGRyZW4oKSk7XG4gICAgICBsYXN0QmxvY2sucmVtb3ZlKCk7XG4gICAgICBsYXN0UG9pbnQuc2V0KGZpcnN0UG9pbnQua2V5LCBmaXJzdFBvaW50Lm9mZnNldCwgZmlyc3RQb2ludC50eXBlKTtcbiAgICB9XG4gIH1cblxuICAvLyBUTy1ETzogTWlncmF0ZSB0aGlzIG1ldGhvZCB0byB0aGUgbmV3IHV0aWxpdHkgZnVuY3Rpb24gJGZvckVhY2hTZWxlY3RlZFRleHROb2RlIChzaGFyZSBzaW1pbGFyIGxvZ2ljKVxuICAvKipcbiAgICogQXBwbGllcyB0aGUgcHJvdmlkZWQgZm9ybWF0IHRvIHRoZSBUZXh0Tm9kZXMgaW4gdGhlIFNlbGVjdGlvbiwgc3BsaXR0aW5nIG9yXG4gICAqIG1lcmdpbmcgbm9kZXMgYXMgbmVjZXNzYXJ5LlxuICAgKlxuICAgKiBAcGFyYW0gZm9ybWF0VHlwZSB0aGUgZm9ybWF0IHR5cGUgdG8gYXBwbHkgdG8gdGhlIG5vZGVzIGluIHRoZSBTZWxlY3Rpb24uXG4gICAqIEBwYXJhbSBhbGlnbldpdGhGb3JtYXQgYSAzMi1iaXQgaW50ZWdlciByZXByZXNlbnRpbmcgZm9ybWF0dGluZyBmbGFncyB0byBhbGlnbiB3aXRoLlxuICAgKi9cbiAgZm9ybWF0VGV4dChmb3JtYXRUeXBlLCBhbGlnbldpdGhGb3JtYXQgPSBudWxsKSB7XG4gICAgaWYgKHRoaXMuaXNDb2xsYXBzZWQoKSkge1xuICAgICAgdGhpcy50b2dnbGVGb3JtYXQoZm9ybWF0VHlwZSk7XG4gICAgICAvLyBXaGVuIGNoYW5naW5nIGZvcm1hdCwgd2Ugc2hvdWxkIHN0b3AgY29tcG9zaXRpb25cbiAgICAgICRzZXRDb21wb3NpdGlvbktleShudWxsKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0ZWROb2RlcyA9IHRoaXMuZ2V0Tm9kZXMoKTtcbiAgICBjb25zdCBzZWxlY3RlZFRleHROb2RlcyA9IFtdO1xuICAgIGZvciAoY29uc3Qgc2VsZWN0ZWROb2RlIG9mIHNlbGVjdGVkTm9kZXMpIHtcbiAgICAgIGlmICgkaXNUZXh0Tm9kZShzZWxlY3RlZE5vZGUpKSB7XG4gICAgICAgIHNlbGVjdGVkVGV4dE5vZGVzLnB1c2goc2VsZWN0ZWROb2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgYXBwbHlGb3JtYXRUb0VsZW1lbnRzID0gYWxpZ25XaXRoID0+IHtcbiAgICAgIHNlbGVjdGVkTm9kZXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgaWYgKCRpc0VsZW1lbnROb2RlKG5vZGUpKSB7XG4gICAgICAgICAgY29uc3QgbmV3Rm9ybWF0ID0gbm9kZS5nZXRGb3JtYXRGbGFncyhmb3JtYXRUeXBlLCBhbGlnbldpdGgpO1xuICAgICAgICAgIG5vZGUuc2V0VGV4dEZvcm1hdChuZXdGb3JtYXQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHNlbGVjdGVkVGV4dE5vZGVzTGVuZ3RoID0gc2VsZWN0ZWRUZXh0Tm9kZXMubGVuZ3RoO1xuICAgIGlmIChzZWxlY3RlZFRleHROb2Rlc0xlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy50b2dnbGVGb3JtYXQoZm9ybWF0VHlwZSk7XG4gICAgICAvLyBXaGVuIGNoYW5naW5nIGZvcm1hdCwgd2Ugc2hvdWxkIHN0b3AgY29tcG9zaXRpb25cbiAgICAgICRzZXRDb21wb3NpdGlvbktleShudWxsKTtcbiAgICAgIGFwcGx5Rm9ybWF0VG9FbGVtZW50cyhhbGlnbldpdGhGb3JtYXQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhbmNob3IgPSB0aGlzLmFuY2hvcjtcbiAgICBjb25zdCBmb2N1cyA9IHRoaXMuZm9jdXM7XG4gICAgY29uc3QgaXNCYWNrd2FyZCA9IHRoaXMuaXNCYWNrd2FyZCgpO1xuICAgIGNvbnN0IHN0YXJ0UG9pbnQgPSBpc0JhY2t3YXJkID8gZm9jdXMgOiBhbmNob3I7XG4gICAgY29uc3QgZW5kUG9pbnQgPSBpc0JhY2t3YXJkID8gYW5jaG9yIDogZm9jdXM7XG4gICAgbGV0IGZpcnN0SW5kZXggPSAwO1xuICAgIGxldCBmaXJzdE5vZGUgPSBzZWxlY3RlZFRleHROb2Rlc1swXTtcbiAgICBsZXQgc3RhcnRPZmZzZXQgPSBzdGFydFBvaW50LnR5cGUgPT09ICdlbGVtZW50JyA/IDAgOiBzdGFydFBvaW50Lm9mZnNldDtcblxuICAgIC8vIEluIGNhc2Ugc2VsZWN0aW9uIHN0YXJ0ZWQgYXQgdGhlIGVuZCBvZiB0ZXh0IG5vZGUgdXNlIG5leHQgdGV4dCBub2RlXG4gICAgaWYgKHN0YXJ0UG9pbnQudHlwZSA9PT0gJ3RleHQnICYmIHN0YXJ0T2Zmc2V0ID09PSBmaXJzdE5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCkpIHtcbiAgICAgIGZpcnN0SW5kZXggPSAxO1xuICAgICAgZmlyc3ROb2RlID0gc2VsZWN0ZWRUZXh0Tm9kZXNbMV07XG4gICAgICBzdGFydE9mZnNldCA9IDA7XG4gICAgfVxuICAgIGlmIChmaXJzdE5vZGUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBmaXJzdE5leHRGb3JtYXQgPSBmaXJzdE5vZGUuZ2V0Rm9ybWF0RmxhZ3MoZm9ybWF0VHlwZSwgYWxpZ25XaXRoRm9ybWF0KTtcbiAgICBhcHBseUZvcm1hdFRvRWxlbWVudHMoZmlyc3ROZXh0Rm9ybWF0KTtcbiAgICBjb25zdCBsYXN0SW5kZXggPSBzZWxlY3RlZFRleHROb2Rlc0xlbmd0aCAtIDE7XG4gICAgbGV0IGxhc3ROb2RlID0gc2VsZWN0ZWRUZXh0Tm9kZXNbbGFzdEluZGV4XTtcbiAgICBjb25zdCBlbmRPZmZzZXQgPSBlbmRQb2ludC50eXBlID09PSAndGV4dCcgPyBlbmRQb2ludC5vZmZzZXQgOiBsYXN0Tm9kZS5nZXRUZXh0Q29udGVudFNpemUoKTtcblxuICAgIC8vIFNpbmdsZSBub2RlIHNlbGVjdGVkXG4gICAgaWYgKGZpcnN0Tm9kZS5pcyhsYXN0Tm9kZSkpIHtcbiAgICAgIC8vIE5vIGFjdHVhbCB0ZXh0IGlzIHNlbGVjdGVkLCBzbyBkbyBub3RoaW5nLlxuICAgICAgaWYgKHN0YXJ0T2Zmc2V0ID09PSBlbmRPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gVGhlIGVudGlyZSBub2RlIGlzIHNlbGVjdGVkIG9yIGl0IGlzIHRva2VuLCBzbyBqdXN0IGZvcm1hdCBpdFxuICAgICAgaWYgKCRpc1Rva2VuT3JTZWdtZW50ZWQoZmlyc3ROb2RlKSB8fCBzdGFydE9mZnNldCA9PT0gMCAmJiBlbmRPZmZzZXQgPT09IGZpcnN0Tm9kZS5nZXRUZXh0Q29udGVudFNpemUoKSkge1xuICAgICAgICBmaXJzdE5vZGUuc2V0Rm9ybWF0KGZpcnN0TmV4dEZvcm1hdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBOb2RlIGlzIHBhcnRpYWxseSBzZWxlY3RlZCwgc28gc3BsaXQgaXQgaW50byB0d28gbm9kZXNcbiAgICAgICAgLy8gYWRkIHN0eWxlIHRoZSBzZWxlY3RlZCBvbmUuXG4gICAgICAgIGNvbnN0IHNwbGl0Tm9kZXMgPSBmaXJzdE5vZGUuc3BsaXRUZXh0KHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpO1xuICAgICAgICBjb25zdCByZXBsYWNlbWVudCA9IHN0YXJ0T2Zmc2V0ID09PSAwID8gc3BsaXROb2Rlc1swXSA6IHNwbGl0Tm9kZXNbMV07XG4gICAgICAgIHJlcGxhY2VtZW50LnNldEZvcm1hdChmaXJzdE5leHRGb3JtYXQpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBzZWxlY3Rpb24gb25seSBpZiBzdGFydHMvZW5kcyBvbiB0ZXh0IG5vZGVcbiAgICAgICAgaWYgKHN0YXJ0UG9pbnQudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgc3RhcnRQb2ludC5zZXQocmVwbGFjZW1lbnQuX19rZXksIDAsICd0ZXh0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZFBvaW50LnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgIGVuZFBvaW50LnNldChyZXBsYWNlbWVudC5fX2tleSwgZW5kT2Zmc2V0IC0gc3RhcnRPZmZzZXQsICd0ZXh0Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuZm9ybWF0ID0gZmlyc3ROZXh0Rm9ybWF0O1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBNdWx0aXBsZSBub2RlcyBzZWxlY3RlZFxuICAgIC8vIFRoZSBlbnRpcmUgZmlyc3Qgbm9kZSBpc24ndCBzZWxlY3RlZCwgc28gc3BsaXQgaXRcbiAgICBpZiAoc3RhcnRPZmZzZXQgIT09IDAgJiYgISRpc1Rva2VuT3JTZWdtZW50ZWQoZmlyc3ROb2RlKSkge1xuICAgICAgWywgZmlyc3ROb2RlXSA9IGZpcnN0Tm9kZS5zcGxpdFRleHQoc3RhcnRPZmZzZXQpO1xuICAgICAgc3RhcnRPZmZzZXQgPSAwO1xuICAgIH1cbiAgICBmaXJzdE5vZGUuc2V0Rm9ybWF0KGZpcnN0TmV4dEZvcm1hdCk7XG4gICAgY29uc3QgbGFzdE5leHRGb3JtYXQgPSBsYXN0Tm9kZS5nZXRGb3JtYXRGbGFncyhmb3JtYXRUeXBlLCBmaXJzdE5leHRGb3JtYXQpO1xuICAgIC8vIElmIHRoZSBvZmZzZXQgaXMgMCwgaXQgbWVhbnMgbm8gYWN0dWFsIGNoYXJhY3RlcnMgYXJlIHNlbGVjdGVkLFxuICAgIC8vIHNvIHdlIHNraXAgZm9ybWF0dGluZyB0aGUgbGFzdCBub2RlIGFsdG9nZXRoZXIuXG4gICAgaWYgKGVuZE9mZnNldCA+IDApIHtcbiAgICAgIGlmIChlbmRPZmZzZXQgIT09IGxhc3ROb2RlLmdldFRleHRDb250ZW50U2l6ZSgpICYmICEkaXNUb2tlbk9yU2VnbWVudGVkKGxhc3ROb2RlKSkge1xuICAgICAgICBbbGFzdE5vZGVdID0gbGFzdE5vZGUuc3BsaXRUZXh0KGVuZE9mZnNldCk7XG4gICAgICB9XG4gICAgICBsYXN0Tm9kZS5zZXRGb3JtYXQobGFzdE5leHRGb3JtYXQpO1xuICAgIH1cblxuICAgIC8vIFByb2Nlc3MgYWxsIHRleHQgbm9kZXMgaW4gYmV0d2VlblxuICAgIGZvciAobGV0IGkgPSBmaXJzdEluZGV4ICsgMTsgaSA8IGxhc3RJbmRleDsgaSsrKSB7XG4gICAgICBjb25zdCB0ZXh0Tm9kZSA9IHNlbGVjdGVkVGV4dE5vZGVzW2ldO1xuICAgICAgY29uc3QgbmV4dEZvcm1hdCA9IHRleHROb2RlLmdldEZvcm1hdEZsYWdzKGZvcm1hdFR5cGUsIGxhc3ROZXh0Rm9ybWF0KTtcbiAgICAgIHRleHROb2RlLnNldEZvcm1hdChuZXh0Rm9ybWF0KTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgc2VsZWN0aW9uIG9ubHkgaWYgc3RhcnRzL2VuZHMgb24gdGV4dCBub2RlXG4gICAgaWYgKHN0YXJ0UG9pbnQudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICBzdGFydFBvaW50LnNldChmaXJzdE5vZGUuX19rZXksIHN0YXJ0T2Zmc2V0LCAndGV4dCcpO1xuICAgIH1cbiAgICBpZiAoZW5kUG9pbnQudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICBlbmRQb2ludC5zZXQobGFzdE5vZGUuX19rZXksIGVuZE9mZnNldCwgJ3RleHQnKTtcbiAgICB9XG4gICAgdGhpcy5mb3JtYXQgPSBmaXJzdE5leHRGb3JtYXQgfCBsYXN0TmV4dEZvcm1hdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRlbXB0cyB0byBcImludGVsbGlnZW50bHlcIiBpbnNlcnQgYW4gYXJiaXRyYXJ5IGxpc3Qgb2YgTGV4aWNhbCBub2RlcyBpbnRvIHRoZSBFZGl0b3JTdGF0ZSBhdCB0aGVcbiAgICogY3VycmVudCBTZWxlY3Rpb24gYWNjb3JkaW5nIHRvIGEgc2V0IG9mIGhldXJpc3RpY3MgdGhhdCBkZXRlcm1pbmUgaG93IHN1cnJvdW5kaW5nIG5vZGVzXG4gICAqIHNob3VsZCBiZSBjaGFuZ2VkLCByZXBsYWNlZCwgb3IgbW92ZWQgdG8gYWNjb21tb2RhdGUgdGhlIGluY29taW5nIG9uZXMuXG4gICAqXG4gICAqIEBwYXJhbSBub2RlcyAtIHRoZSBub2RlcyB0byBpbnNlcnRcbiAgICovXG4gIGluc2VydE5vZGVzKG5vZGVzKSB7XG4gICAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5hbmNob3Iua2V5ID09PSAncm9vdCcpIHtcbiAgICAgIHRoaXMuaW5zZXJ0UGFyYWdyYXBoKCk7XG4gICAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIFJhbmdlU2VsZWN0aW9uIGFmdGVyIGluc2VydFBhcmFncmFwaGApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGVjdGlvbi5pbnNlcnROb2Rlcyhub2Rlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZpcnN0UG9pbnQgPSB0aGlzLmlzQmFja3dhcmQoKSA/IHRoaXMuZm9jdXMgOiB0aGlzLmFuY2hvcjtcbiAgICBjb25zdCBmaXJzdE5vZGUgPSBmaXJzdFBvaW50LmdldE5vZGUoKTtcbiAgICBjb25zdCBmaXJzdEJsb2NrID0gJGdldEFuY2VzdG9yKGZpcnN0Tm9kZSwgSU5URVJOQUxfJGlzQmxvY2spO1xuICAgIGNvbnN0IGxhc3QgPSBub2Rlc1tub2Rlcy5sZW5ndGggLSAxXTtcblxuICAgIC8vIENBU0UgMTogaW5zZXJ0IGluc2lkZSBhIGNvZGUgYmxvY2tcbiAgICBpZiAoJGlzRWxlbWVudE5vZGUoZmlyc3RCbG9jaykgJiYgJ19fbGFuZ3VhZ2UnIGluIGZpcnN0QmxvY2spIHtcbiAgICAgIGlmICgnX19sYW5ndWFnZScgaW4gbm9kZXNbMF0pIHtcbiAgICAgICAgdGhpcy5pbnNlcnRUZXh0KG5vZGVzWzBdLmdldFRleHRDb250ZW50KCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSAkcmVtb3ZlVGV4dEFuZFNwbGl0QmxvY2sodGhpcyk7XG4gICAgICAgIGZpcnN0QmxvY2suc3BsaWNlKGluZGV4LCAwLCBub2Rlcyk7XG4gICAgICAgIGxhc3Quc2VsZWN0RW5kKCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ0FTRSAyOiBBbGwgZWxlbWVudHMgb2YgdGhlIGFycmF5IGFyZSBpbmxpbmVcbiAgICBjb25zdCBub3RJbmxpbmUgPSBub2RlID0+ICgkaXNFbGVtZW50Tm9kZShub2RlKSB8fCAkaXNEZWNvcmF0b3JOb2RlKG5vZGUpKSAmJiAhbm9kZS5pc0lubGluZSgpO1xuICAgIGlmICghbm9kZXMuc29tZShub3RJbmxpbmUpKSB7XG4gICAgICBpZiAoISRpc0VsZW1lbnROb2RlKGZpcnN0QmxvY2spKSB7XG4gICAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCBub2RlICR7Zmlyc3ROb2RlLmNvbnN0cnVjdG9yLm5hbWV9IG9mIHR5cGUgJHtmaXJzdE5vZGUuZ2V0VHlwZSgpfSB0byBoYXZlIGEgYmxvY2sgRWxlbWVudE5vZGUgYW5jZXN0b3JgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGluZGV4ID0gJHJlbW92ZVRleHRBbmRTcGxpdEJsb2NrKHRoaXMpO1xuICAgICAgZmlyc3RCbG9jay5zcGxpY2UoaW5kZXgsIDAsIG5vZGVzKTtcbiAgICAgIGxhc3Quc2VsZWN0RW5kKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ0FTRSAzOiBBdCBsZWFzdCAxIGVsZW1lbnQgb2YgdGhlIGFycmF5IGlzIG5vdCBpbmxpbmVcbiAgICBjb25zdCBibG9ja3NQYXJlbnQgPSAkd3JhcElubGluZU5vZGVzKG5vZGVzKTtcbiAgICBjb25zdCBub2RlVG9TZWxlY3QgPSBibG9ja3NQYXJlbnQuZ2V0TGFzdERlc2NlbmRhbnQoKTtcbiAgICBjb25zdCBibG9ja3MgPSBibG9ja3NQYXJlbnQuZ2V0Q2hpbGRyZW4oKTtcbiAgICBjb25zdCBpc01lcmdlYWJsZSA9IG5vZGUgPT4gJGlzRWxlbWVudE5vZGUobm9kZSkgJiYgSU5URVJOQUxfJGlzQmxvY2sobm9kZSkgJiYgIW5vZGUuaXNFbXB0eSgpICYmICRpc0VsZW1lbnROb2RlKGZpcnN0QmxvY2spICYmICghZmlyc3RCbG9jay5pc0VtcHR5KCkgfHwgZmlyc3RCbG9jay5jYW5NZXJnZVdoZW5FbXB0eSgpKTtcbiAgICBjb25zdCBzaG91bGRJbnNlcnQgPSAhJGlzRWxlbWVudE5vZGUoZmlyc3RCbG9jaykgfHwgIWZpcnN0QmxvY2suaXNFbXB0eSgpO1xuICAgIGNvbnN0IGluc2VydGVkUGFyYWdyYXBoID0gc2hvdWxkSW5zZXJ0ID8gdGhpcy5pbnNlcnRQYXJhZ3JhcGgoKSA6IG51bGw7XG4gICAgY29uc3QgbGFzdFRvSW5zZXJ0ID0gYmxvY2tzW2Jsb2Nrcy5sZW5ndGggLSAxXTtcbiAgICBsZXQgZmlyc3RUb0luc2VydCA9IGJsb2Nrc1swXTtcbiAgICBpZiAoaXNNZXJnZWFibGUoZmlyc3RUb0luc2VydCkpIHtcbiAgICAgIGlmICghJGlzRWxlbWVudE5vZGUoZmlyc3RCbG9jaykpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIG5vZGUgJHtmaXJzdE5vZGUuY29uc3RydWN0b3IubmFtZX0gb2YgdHlwZSAke2ZpcnN0Tm9kZS5nZXRUeXBlKCl9IHRvIGhhdmUgYSBibG9jayBFbGVtZW50Tm9kZSBhbmNlc3RvcmApO1xuICAgICAgfVxuICAgICAgZmlyc3RCbG9jay5hcHBlbmQoLi4uZmlyc3RUb0luc2VydC5nZXRDaGlsZHJlbigpKTtcbiAgICAgIGZpcnN0VG9JbnNlcnQgPSBibG9ja3NbMV07XG4gICAgfVxuICAgIGlmIChmaXJzdFRvSW5zZXJ0KSB7XG4gICAgICBpZiAoIShmaXJzdEJsb2NrICE9PSBudWxsKSkge1xuICAgICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgbm9kZSAke2ZpcnN0Tm9kZS5jb25zdHJ1Y3Rvci5uYW1lfSBvZiB0eXBlICR7Zmlyc3ROb2RlLmdldFR5cGUoKX0gdG8gaGF2ZSBhIGJsb2NrIGFuY2VzdG9yYCk7XG4gICAgICB9XG4gICAgICBpbnNlcnRSYW5nZUFmdGVyKGZpcnN0QmxvY2ssIGZpcnN0VG9JbnNlcnQpO1xuICAgIH1cbiAgICBjb25zdCBsYXN0SW5zZXJ0ZWRCbG9jayA9ICRnZXRBbmNlc3Rvcihub2RlVG9TZWxlY3QsIElOVEVSTkFMXyRpc0Jsb2NrKTtcbiAgICBpZiAoaW5zZXJ0ZWRQYXJhZ3JhcGggJiYgJGlzRWxlbWVudE5vZGUobGFzdEluc2VydGVkQmxvY2spICYmIChpbnNlcnRlZFBhcmFncmFwaC5jYW5NZXJnZVdoZW5FbXB0eSgpIHx8IElOVEVSTkFMXyRpc0Jsb2NrKGxhc3RUb0luc2VydCkpKSB7XG4gICAgICBsYXN0SW5zZXJ0ZWRCbG9jay5hcHBlbmQoLi4uaW5zZXJ0ZWRQYXJhZ3JhcGguZ2V0Q2hpbGRyZW4oKSk7XG4gICAgICBpbnNlcnRlZFBhcmFncmFwaC5yZW1vdmUoKTtcbiAgICB9XG4gICAgaWYgKCRpc0VsZW1lbnROb2RlKGZpcnN0QmxvY2spICYmIGZpcnN0QmxvY2suaXNFbXB0eSgpKSB7XG4gICAgICBmaXJzdEJsb2NrLnJlbW92ZSgpO1xuICAgIH1cbiAgICBub2RlVG9TZWxlY3Quc2VsZWN0RW5kKCk7XG5cbiAgICAvLyBUbyB1bmRlcnN0YW5kIHRoaXMgdGFrZSBhIGxvb2sgYXQgdGhlIHRlc3QgXCJjYW4gd3JhcCBwb3N0LWxpbmVicmVhayBub2RlcyBpbnRvIG5ldyBlbGVtZW50XCJcbiAgICBjb25zdCBsYXN0Q2hpbGQgPSAkaXNFbGVtZW50Tm9kZShmaXJzdEJsb2NrKSA/IGZpcnN0QmxvY2suZ2V0TGFzdENoaWxkKCkgOiBudWxsO1xuICAgIGlmICgkaXNMaW5lQnJlYWtOb2RlKGxhc3RDaGlsZCkgJiYgbGFzdEluc2VydGVkQmxvY2sgIT09IGZpcnN0QmxvY2spIHtcbiAgICAgIGxhc3RDaGlsZC5yZW1vdmUoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0cyBhIG5ldyBQYXJhZ3JhcGhOb2RlIGludG8gdGhlIEVkaXRvclN0YXRlIGF0IHRoZSBjdXJyZW50IFNlbGVjdGlvblxuICAgKlxuICAgKiBAcmV0dXJucyB0aGUgbmV3bHkgaW5zZXJ0ZWQgbm9kZS5cbiAgICovXG4gIGluc2VydFBhcmFncmFwaCgpIHtcbiAgICBpZiAodGhpcy5hbmNob3Iua2V5ID09PSAncm9vdCcpIHtcbiAgICAgIGNvbnN0IHBhcmFncmFwaCA9ICRjcmVhdGVQYXJhZ3JhcGhOb2RlKCk7XG4gICAgICAkZ2V0Um9vdCgpLnNwbGljZSh0aGlzLmFuY2hvci5vZmZzZXQsIDAsIFtwYXJhZ3JhcGhdKTtcbiAgICAgIHBhcmFncmFwaC5zZWxlY3QoKTtcbiAgICAgIHJldHVybiBwYXJhZ3JhcGg7XG4gICAgfVxuICAgIGNvbnN0IGluZGV4ID0gJHJlbW92ZVRleHRBbmRTcGxpdEJsb2NrKHRoaXMpO1xuICAgIGNvbnN0IGJsb2NrID0gJGdldEFuY2VzdG9yKHRoaXMuYW5jaG9yLmdldE5vZGUoKSwgSU5URVJOQUxfJGlzQmxvY2spO1xuICAgIGlmICghJGlzRWxlbWVudE5vZGUoYmxvY2spKSB7XG4gICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgYW5jZXN0b3IgdG8gYmUgYSBibG9jayBFbGVtZW50Tm9kZWApO1xuICAgIH1cbiAgICBjb25zdCBmaXJzdFRvQXBwZW5kID0gYmxvY2suZ2V0Q2hpbGRBdEluZGV4KGluZGV4KTtcbiAgICBjb25zdCBub2Rlc1RvSW5zZXJ0ID0gZmlyc3RUb0FwcGVuZCA/IFtmaXJzdFRvQXBwZW5kLCAuLi5maXJzdFRvQXBwZW5kLmdldE5leHRTaWJsaW5ncygpXSA6IFtdO1xuICAgIGNvbnN0IG5ld0Jsb2NrID0gYmxvY2suaW5zZXJ0TmV3QWZ0ZXIodGhpcywgZmFsc2UpO1xuICAgIGlmIChuZXdCbG9jaykge1xuICAgICAgbmV3QmxvY2suYXBwZW5kKC4uLm5vZGVzVG9JbnNlcnQpO1xuICAgICAgbmV3QmxvY2suc2VsZWN0U3RhcnQoKTtcbiAgICAgIHJldHVybiBuZXdCbG9jaztcbiAgICB9XG4gICAgLy8gaWYgbmV3QmxvY2sgaXMgbnVsbCwgaXQgbWVhbnMgdGhhdCBibG9jayBpcyBvZiB0eXBlIENvZGVOb2RlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydHMgYSBsb2dpY2FsIGxpbmVicmVhaywgd2hpY2ggbWF5IGJlIGEgbmV3IExpbmVCcmVha05vZGUgb3IgYSBuZXcgUGFyYWdyYXBoTm9kZSwgaW50byB0aGUgRWRpdG9yU3RhdGUgYXQgdGhlXG4gICAqIGN1cnJlbnQgU2VsZWN0aW9uLlxuICAgKi9cbiAgaW5zZXJ0TGluZUJyZWFrKHNlbGVjdFN0YXJ0KSB7XG4gICAgY29uc3QgbGluZUJyZWFrID0gJGNyZWF0ZUxpbmVCcmVha05vZGUoKTtcbiAgICB0aGlzLmluc2VydE5vZGVzKFtsaW5lQnJlYWtdKTtcbiAgICAvLyB0aGlzIGlzIHVzZWQgaW4gTWFjT1Mgd2l0aCB0aGUgY29tbWFuZCAnY3RybC1PJyAob3BlbkxpbmVCcmVhaylcbiAgICBpZiAoc2VsZWN0U3RhcnQpIHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IGxpbmVCcmVhay5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgICBjb25zdCBpbmRleCA9IGxpbmVCcmVhay5nZXRJbmRleFdpdGhpblBhcmVudCgpO1xuICAgICAgcGFyZW50LnNlbGVjdChpbmRleCwgaW5kZXgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRyYWN0cyB0aGUgbm9kZXMgaW4gdGhlIFNlbGVjdGlvbiwgc3BsaXR0aW5nIG5vZGVzIHdoZXJlIG5lY2Vzc2FyeVxuICAgKiB0byBnZXQgb2Zmc2V0LWxldmVsIHByZWNpc2lvbi5cbiAgICpcbiAgICogQHJldHVybnMgVGhlIG5vZGVzIGluIHRoZSBTZWxlY3Rpb25cbiAgICovXG4gIGV4dHJhY3QoKSB7XG4gICAgY29uc3Qgc2VsZWN0ZWROb2RlcyA9IHRoaXMuZ2V0Tm9kZXMoKTtcbiAgICBjb25zdCBzZWxlY3RlZE5vZGVzTGVuZ3RoID0gc2VsZWN0ZWROb2Rlcy5sZW5ndGg7XG4gICAgY29uc3QgbGFzdEluZGV4ID0gc2VsZWN0ZWROb2Rlc0xlbmd0aCAtIDE7XG4gICAgY29uc3QgYW5jaG9yID0gdGhpcy5hbmNob3I7XG4gICAgY29uc3QgZm9jdXMgPSB0aGlzLmZvY3VzO1xuICAgIGxldCBmaXJzdE5vZGUgPSBzZWxlY3RlZE5vZGVzWzBdO1xuICAgIGxldCBsYXN0Tm9kZSA9IHNlbGVjdGVkTm9kZXNbbGFzdEluZGV4XTtcbiAgICBjb25zdCBbYW5jaG9yT2Zmc2V0LCBmb2N1c09mZnNldF0gPSAkZ2V0Q2hhcmFjdGVyT2Zmc2V0cyh0aGlzKTtcbiAgICBpZiAoc2VsZWN0ZWROb2Rlc0xlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH0gZWxzZSBpZiAoc2VsZWN0ZWROb2Rlc0xlbmd0aCA9PT0gMSkge1xuICAgICAgaWYgKCRpc1RleHROb2RlKGZpcnN0Tm9kZSkgJiYgIXRoaXMuaXNDb2xsYXBzZWQoKSkge1xuICAgICAgICBjb25zdCBzdGFydE9mZnNldCA9IGFuY2hvck9mZnNldCA+IGZvY3VzT2Zmc2V0ID8gZm9jdXNPZmZzZXQgOiBhbmNob3JPZmZzZXQ7XG4gICAgICAgIGNvbnN0IGVuZE9mZnNldCA9IGFuY2hvck9mZnNldCA+IGZvY3VzT2Zmc2V0ID8gYW5jaG9yT2Zmc2V0IDogZm9jdXNPZmZzZXQ7XG4gICAgICAgIGNvbnN0IHNwbGl0Tm9kZXMgPSBmaXJzdE5vZGUuc3BsaXRUZXh0KHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpO1xuICAgICAgICBjb25zdCBub2RlID0gc3RhcnRPZmZzZXQgPT09IDAgPyBzcGxpdE5vZGVzWzBdIDogc3BsaXROb2Rlc1sxXTtcbiAgICAgICAgcmV0dXJuIG5vZGUgIT0gbnVsbCA/IFtub2RlXSA6IFtdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtmaXJzdE5vZGVdO1xuICAgIH1cbiAgICBjb25zdCBpc0JlZm9yZSA9IGFuY2hvci5pc0JlZm9yZShmb2N1cyk7XG4gICAgaWYgKCRpc1RleHROb2RlKGZpcnN0Tm9kZSkpIHtcbiAgICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gaXNCZWZvcmUgPyBhbmNob3JPZmZzZXQgOiBmb2N1c09mZnNldDtcbiAgICAgIGlmIChzdGFydE9mZnNldCA9PT0gZmlyc3ROb2RlLmdldFRleHRDb250ZW50U2l6ZSgpKSB7XG4gICAgICAgIHNlbGVjdGVkTm9kZXMuc2hpZnQoKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhcnRPZmZzZXQgIT09IDApIHtcbiAgICAgICAgWywgZmlyc3ROb2RlXSA9IGZpcnN0Tm9kZS5zcGxpdFRleHQoc3RhcnRPZmZzZXQpO1xuICAgICAgICBzZWxlY3RlZE5vZGVzWzBdID0gZmlyc3ROb2RlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoJGlzVGV4dE5vZGUobGFzdE5vZGUpKSB7XG4gICAgICBjb25zdCBsYXN0Tm9kZVRleHQgPSBsYXN0Tm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICAgICAgY29uc3QgbGFzdE5vZGVUZXh0TGVuZ3RoID0gbGFzdE5vZGVUZXh0Lmxlbmd0aDtcbiAgICAgIGNvbnN0IGVuZE9mZnNldCA9IGlzQmVmb3JlID8gZm9jdXNPZmZzZXQgOiBhbmNob3JPZmZzZXQ7XG4gICAgICBpZiAoZW5kT2Zmc2V0ID09PSAwKSB7XG4gICAgICAgIHNlbGVjdGVkTm9kZXMucG9wKCk7XG4gICAgICB9IGVsc2UgaWYgKGVuZE9mZnNldCAhPT0gbGFzdE5vZGVUZXh0TGVuZ3RoKSB7XG4gICAgICAgIFtsYXN0Tm9kZV0gPSBsYXN0Tm9kZS5zcGxpdFRleHQoZW5kT2Zmc2V0KTtcbiAgICAgICAgc2VsZWN0ZWROb2Rlc1tsYXN0SW5kZXhdID0gbGFzdE5vZGU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZWxlY3RlZE5vZGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vZGlmaWVzIHRoZSBTZWxlY3Rpb24gYWNjb3JkaW5nIHRvIHRoZSBwYXJhbWV0ZXJzIGFuZCBhIHNldCBvZiBoZXVyaXN0aWNzIHRoYXQgYWNjb3VudCBmb3JcbiAgICogdmFyaW91cyBub2RlIHR5cGVzLiBDYW4gYmUgdXNlZCB0byBzYWZlbHkgbW92ZSBvciBleHRlbmQgc2VsZWN0aW9uIGJ5IG9uZSBsb2dpY2FsIFwidW5pdFwiIHdpdGhvdXRcbiAgICogZGVhbGluZyBleHBsaWNpdGx5IHdpdGggYWxsIHRoZSBwb3NzaWJsZSBub2RlIHR5cGVzLlxuICAgKlxuICAgKiBAcGFyYW0gYWx0ZXIgdGhlIHR5cGUgb2YgbW9kaWZpY2F0aW9uIHRvIHBlcmZvcm1cbiAgICogQHBhcmFtIGlzQmFja3dhcmQgd2hldGhlciBvciBub3Qgc2VsZWN0aW9uIGlzIGJhY2t3YXJkc1xuICAgKiBAcGFyYW0gZ3JhbnVsYXJpdHkgdGhlIGdyYW51bGFyaXR5IGF0IHdoaWNoIHRvIGFwcGx5IHRoZSBtb2RpZmljYXRpb25cbiAgICovXG4gIG1vZGlmeShhbHRlciwgaXNCYWNrd2FyZCwgZ3JhbnVsYXJpdHkpIHtcbiAgICBjb25zdCBmb2N1cyA9IHRoaXMuZm9jdXM7XG4gICAgY29uc3QgYW5jaG9yID0gdGhpcy5hbmNob3I7XG4gICAgY29uc3QgY29sbGFwc2UgPSBhbHRlciA9PT0gJ21vdmUnO1xuXG4gICAgLy8gSGFuZGxlIHRoZSBzZWxlY3Rpb24gbW92ZW1lbnQgYXJvdW5kIGRlY29yYXRvcnMuXG4gICAgY29uc3QgcG9zc2libGVOb2RlID0gJGdldEFkamFjZW50Tm9kZShmb2N1cywgaXNCYWNrd2FyZCk7XG4gICAgaWYgKCRpc0RlY29yYXRvck5vZGUocG9zc2libGVOb2RlKSAmJiAhcG9zc2libGVOb2RlLmlzSXNvbGF0ZWQoKSkge1xuICAgICAgLy8gTWFrZSBpdCBwb3NzaWJsZSB0byBtb3ZlIHNlbGVjdGlvbiBmcm9tIHJhbmdlIHNlbGVjdGlvbiB0b1xuICAgICAgLy8gbm9kZSBzZWxlY3Rpb24gb24gdGhlIG5vZGUuXG4gICAgICBpZiAoY29sbGFwc2UgJiYgcG9zc2libGVOb2RlLmlzS2V5Ym9hcmRTZWxlY3RhYmxlKCkpIHtcbiAgICAgICAgY29uc3Qgbm9kZVNlbGVjdGlvbiA9ICRjcmVhdGVOb2RlU2VsZWN0aW9uKCk7XG4gICAgICAgIG5vZGVTZWxlY3Rpb24uYWRkKHBvc3NpYmxlTm9kZS5fX2tleSk7XG4gICAgICAgICRzZXRTZWxlY3Rpb24obm9kZVNlbGVjdGlvbik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNpYmxpbmcgPSBpc0JhY2t3YXJkID8gcG9zc2libGVOb2RlLmdldFByZXZpb3VzU2libGluZygpIDogcG9zc2libGVOb2RlLmdldE5leHRTaWJsaW5nKCk7XG4gICAgICBpZiAoISRpc1RleHROb2RlKHNpYmxpbmcpKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHBvc3NpYmxlTm9kZS5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgICAgIGxldCBvZmZzZXQ7XG4gICAgICAgIGxldCBlbGVtZW50S2V5O1xuICAgICAgICBpZiAoJGlzRWxlbWVudE5vZGUoc2libGluZykpIHtcbiAgICAgICAgICBlbGVtZW50S2V5ID0gc2libGluZy5fX2tleTtcbiAgICAgICAgICBvZmZzZXQgPSBpc0JhY2t3YXJkID8gc2libGluZy5nZXRDaGlsZHJlblNpemUoKSA6IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2Zmc2V0ID0gcG9zc2libGVOb2RlLmdldEluZGV4V2l0aGluUGFyZW50KCk7XG4gICAgICAgICAgZWxlbWVudEtleSA9IHBhcmVudC5fX2tleTtcbiAgICAgICAgICBpZiAoIWlzQmFja3dhcmQpIHtcbiAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb2N1cy5zZXQoZWxlbWVudEtleSwgb2Zmc2V0LCAnZWxlbWVudCcpO1xuICAgICAgICBpZiAoY29sbGFwc2UpIHtcbiAgICAgICAgICBhbmNob3Iuc2V0KGVsZW1lbnRLZXksIG9mZnNldCwgJ2VsZW1lbnQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBzaWJsaW5nS2V5ID0gc2libGluZy5fX2tleTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gaXNCYWNrd2FyZCA/IHNpYmxpbmcuZ2V0VGV4dENvbnRlbnQoKS5sZW5ndGggOiAwO1xuICAgICAgICBmb2N1cy5zZXQoc2libGluZ0tleSwgb2Zmc2V0LCAndGV4dCcpO1xuICAgICAgICBpZiAoY29sbGFwc2UpIHtcbiAgICAgICAgICBhbmNob3Iuc2V0KHNpYmxpbmdLZXksIG9mZnNldCwgJ3RleHQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGVkaXRvciA9IGdldEFjdGl2ZUVkaXRvcigpO1xuICAgIGNvbnN0IGRvbVNlbGVjdGlvbiA9IGdldERPTVNlbGVjdGlvbihlZGl0b3IuX3dpbmRvdyk7XG4gICAgaWYgKCFkb21TZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYmxvY2tDdXJzb3JFbGVtZW50ID0gZWRpdG9yLl9ibG9ja0N1cnNvckVsZW1lbnQ7XG4gICAgY29uc3Qgcm9vdEVsZW1lbnQgPSBlZGl0b3IuX3Jvb3RFbGVtZW50O1xuICAgIC8vIFJlbW92ZSB0aGUgYmxvY2sgY3Vyc29yIGVsZW1lbnQgaWYgaXQgZXhpc3RzLiBUaGlzIHdpbGwgZW5zdXJlIHNlbGVjdGlvblxuICAgIC8vIHdvcmtzIGFzIGludGVuZGVkLiBJZiB3ZSBsZWF2ZSBpdCBpbiB0aGUgRE9NIGFsbCBzb3J0cyBvZiBzdHJhbmdlIGJ1Z3NcbiAgICAvLyBvY2N1ci4gOi9cbiAgICBpZiAocm9vdEVsZW1lbnQgIT09IG51bGwgJiYgYmxvY2tDdXJzb3JFbGVtZW50ICE9PSBudWxsICYmICRpc0VsZW1lbnROb2RlKHBvc3NpYmxlTm9kZSkgJiYgIXBvc3NpYmxlTm9kZS5pc0lubGluZSgpICYmICFwb3NzaWJsZU5vZGUuY2FuQmVFbXB0eSgpKSB7XG4gICAgICByZW1vdmVET01CbG9ja0N1cnNvckVsZW1lbnQoYmxvY2tDdXJzb3JFbGVtZW50LCBlZGl0b3IsIHJvb3RFbGVtZW50KTtcbiAgICB9XG4gICAgLy8gV2UgdXNlIHRoZSBET00gc2VsZWN0aW9uLm1vZGlmeSBBUEkgaGVyZSB0byBcInRlbGxcIiB1cyB3aGF0IHRoZSBzZWxlY3Rpb25cbiAgICAvLyB3aWxsIGJlLiBXZSB0aGVuIHVzZSBpdCB0byB1cGRhdGUgdGhlIExleGljYWwgc2VsZWN0aW9uIGFjY29yZGluZ2x5LiBUaGlzXG4gICAgLy8gaXMgbXVjaCBtb3JlIHJlbGlhYmxlIHRoYW4gd2FpdGluZyBmb3IgYSBiZWZvcmVpbnB1dCBhbmQgdXNpbmcgdGhlIHJhbmdlc1xuICAgIC8vIGZyb20gZ2V0VGFyZ2V0UmFuZ2VzKCksIGFuZCBpcyBhbHNvIGJldHRlciB0aGFuIHRyeWluZyB0byBkbyBpdCBvdXJzZWx2ZXNcbiAgICAvLyB1c2luZyBJbnRsLlNlZ21lbnRlciBvciBvdGhlciB3b3JrYXJvdW5kcyB0aGF0IHN0cnVnZ2xlIHdpdGggd29yZCBzZWdtZW50c1xuICAgIC8vIGFuZCBsaW5lIHNlZ21lbnRzIChlc3BlY2lhbGx5IHdpdGggd29yZCB3cmFwcGluZyBhbmQgbm9uLVJvbWFuIGxhbmd1YWdlcykuXG4gICAgbW92ZU5hdGl2ZVNlbGVjdGlvbihkb21TZWxlY3Rpb24sIGFsdGVyLCBpc0JhY2t3YXJkID8gJ2JhY2t3YXJkJyA6ICdmb3J3YXJkJywgZ3JhbnVsYXJpdHkpO1xuICAgIC8vIEd1YXJkIGFnYWluc3Qgbm8gcmFuZ2VzXG4gICAgaWYgKGRvbVNlbGVjdGlvbi5yYW5nZUNvdW50ID4gMCkge1xuICAgICAgY29uc3QgcmFuZ2UgPSBkb21TZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKTtcbiAgICAgIC8vIEFwcGx5IHRoZSBET00gc2VsZWN0aW9uIHRvIG91ciBMZXhpY2FsIHNlbGVjdGlvbi5cbiAgICAgIGNvbnN0IGFuY2hvck5vZGUgPSB0aGlzLmFuY2hvci5nZXROb2RlKCk7XG4gICAgICBjb25zdCByb290ID0gJGlzUm9vdE5vZGUoYW5jaG9yTm9kZSkgPyBhbmNob3JOb2RlIDogJGdldE5lYXJlc3RSb290T3JTaGFkb3dSb290KGFuY2hvck5vZGUpO1xuICAgICAgdGhpcy5hcHBseURPTVJhbmdlKHJhbmdlKTtcbiAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgaWYgKCFjb2xsYXBzZSkge1xuICAgICAgICAvLyBWYWxpZGF0ZSBzZWxlY3Rpb247IG1ha2Ugc3VyZSB0aGF0IHRoZSBuZXcgZXh0ZW5kZWQgc2VsZWN0aW9uIHJlc3BlY3RzIHNoYWRvdyByb290c1xuICAgICAgICBjb25zdCBub2RlcyA9IHRoaXMuZ2V0Tm9kZXMoKTtcbiAgICAgICAgY29uc3QgdmFsaWROb2RlcyA9IFtdO1xuICAgICAgICBsZXQgc2hyaW5rU2VsZWN0aW9uID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBuZXh0Tm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgIGlmICgkaGFzQW5jZXN0b3IobmV4dE5vZGUsIHJvb3QpKSB7XG4gICAgICAgICAgICB2YWxpZE5vZGVzLnB1c2gobmV4dE5vZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaHJpbmtTZWxlY3Rpb24gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hyaW5rU2VsZWN0aW9uICYmIHZhbGlkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIC8vIHZhbGlkTm9kZXMgbGVuZ3RoIGNoZWNrIGlzIGEgc2FmZWd1YXJkIGFnYWluc3QgYW4gaW52YWxpZCBzZWxlY3Rpb247IGFzIGdldE5vZGVzKClcbiAgICAgICAgICAvLyB3aWxsIHJldHVybiBhbiBlbXB0eSBhcnJheSBpbiB0aGlzIGNhc2VcbiAgICAgICAgICBpZiAoaXNCYWNrd2FyZCkge1xuICAgICAgICAgICAgY29uc3QgZmlyc3RWYWxpZE5vZGUgPSB2YWxpZE5vZGVzWzBdO1xuICAgICAgICAgICAgaWYgKCRpc0VsZW1lbnROb2RlKGZpcnN0VmFsaWROb2RlKSkge1xuICAgICAgICAgICAgICBmaXJzdFZhbGlkTm9kZS5zZWxlY3RTdGFydCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZmlyc3RWYWxpZE5vZGUuZ2V0UGFyZW50T3JUaHJvdygpLnNlbGVjdFN0YXJ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RWYWxpZE5vZGUgPSB2YWxpZE5vZGVzW3ZhbGlkTm9kZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAoJGlzRWxlbWVudE5vZGUobGFzdFZhbGlkTm9kZSkpIHtcbiAgICAgICAgICAgICAgbGFzdFZhbGlkTm9kZS5zZWxlY3RFbmQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGxhc3RWYWxpZE5vZGUuZ2V0UGFyZW50T3JUaHJvdygpLnNlbGVjdEVuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlY2F1c2UgYSByYW5nZSB3b3JrcyBvbiBzdGFydCBhbmQgZW5kLCB3ZSBtaWdodCBuZWVkIHRvIGZsaXBcbiAgICAgICAgLy8gdGhlIGFuY2hvciBhbmQgZm9jdXMgcG9pbnRzIHRvIG1hdGNoIHdoYXQgdGhlIERPTSBoYXMsIG5vdCB3aGF0XG4gICAgICAgIC8vIHRoZSByYW5nZSBoYXMgc3BlY2lmaWNhbGx5LlxuICAgICAgICBpZiAoZG9tU2VsZWN0aW9uLmFuY2hvck5vZGUgIT09IHJhbmdlLnN0YXJ0Q29udGFpbmVyIHx8IGRvbVNlbGVjdGlvbi5hbmNob3JPZmZzZXQgIT09IHJhbmdlLnN0YXJ0T2Zmc2V0KSB7XG4gICAgICAgICAgJHN3YXBQb2ludHModGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEhlbHBlciBmb3IgaGFuZGxpbmcgZm9yd2FyZCBjaGFyYWN0ZXIgYW5kIHdvcmQgZGVsZXRpb24gdGhhdCBwcmV2ZW50cyBlbGVtZW50IG5vZGVzXG4gICAqIGxpa2UgYSB0YWJsZSwgY29sdW1ucyBsYXlvdXQgYmVpbmcgZGVzdHJveWVkXG4gICAqXG4gICAqIEBwYXJhbSBhbmNob3IgdGhlIGFuY2hvclxuICAgKiBAcGFyYW0gYW5jaG9yTm9kZSB0aGUgYW5jaG9yIG5vZGUgaW4gdGhlIHNlbGVjdGlvblxuICAgKiBAcGFyYW0gaXNCYWNrd2FyZCB3aGV0aGVyIG9yIG5vdCBzZWxlY3Rpb24gaXMgYmFja3dhcmRzXG4gICAqL1xuICBmb3J3YXJkRGVsZXRpb24oYW5jaG9yLCBhbmNob3JOb2RlLCBpc0JhY2t3YXJkKSB7XG4gICAgaWYgKCFpc0JhY2t3YXJkICYmIChcbiAgICAvLyBEZWxldGUgZm9yd2FyZCBoYW5kbGUgY2FzZVxuICAgIGFuY2hvci50eXBlID09PSAnZWxlbWVudCcgJiYgJGlzRWxlbWVudE5vZGUoYW5jaG9yTm9kZSkgJiYgYW5jaG9yLm9mZnNldCA9PT0gYW5jaG9yTm9kZS5nZXRDaGlsZHJlblNpemUoKSB8fCBhbmNob3IudHlwZSA9PT0gJ3RleHQnICYmIGFuY2hvci5vZmZzZXQgPT09IGFuY2hvck5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCkpKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSBhbmNob3JOb2RlLmdldFBhcmVudCgpO1xuICAgICAgY29uc3QgbmV4dFNpYmxpbmcgPSBhbmNob3JOb2RlLmdldE5leHRTaWJsaW5nKCkgfHwgKHBhcmVudCA9PT0gbnVsbCA/IG51bGwgOiBwYXJlbnQuZ2V0TmV4dFNpYmxpbmcoKSk7XG4gICAgICBpZiAoJGlzRWxlbWVudE5vZGUobmV4dFNpYmxpbmcpICYmIG5leHRTaWJsaW5nLmlzU2hhZG93Um9vdCgpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybXMgb25lIGxvZ2ljYWwgY2hhcmFjdGVyIGRlbGV0aW9uIG9wZXJhdGlvbiBvbiB0aGUgRWRpdG9yU3RhdGUgYmFzZWQgb24gdGhlIGN1cnJlbnQgU2VsZWN0aW9uLlxuICAgKiBIYW5kbGVzIGRpZmZlcmVudCBub2RlIHR5cGVzLlxuICAgKlxuICAgKiBAcGFyYW0gaXNCYWNrd2FyZCB3aGV0aGVyIG9yIG5vdCB0aGUgc2VsZWN0aW9uIGlzIGJhY2t3YXJkcy5cbiAgICovXG4gIGRlbGV0ZUNoYXJhY3Rlcihpc0JhY2t3YXJkKSB7XG4gICAgY29uc3Qgd2FzQ29sbGFwc2VkID0gdGhpcy5pc0NvbGxhcHNlZCgpO1xuICAgIGlmICh0aGlzLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgIGNvbnN0IGFuY2hvciA9IHRoaXMuYW5jaG9yO1xuICAgICAgbGV0IGFuY2hvck5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICAgICAgaWYgKHRoaXMuZm9yd2FyZERlbGV0aW9uKGFuY2hvciwgYW5jaG9yTm9kZSwgaXNCYWNrd2FyZCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBIYW5kbGUgdGhlIGRlbGV0aW9uIGFyb3VuZCBkZWNvcmF0b3JzLlxuICAgICAgY29uc3QgZm9jdXMgPSB0aGlzLmZvY3VzO1xuICAgICAgY29uc3QgcG9zc2libGVOb2RlID0gJGdldEFkamFjZW50Tm9kZShmb2N1cywgaXNCYWNrd2FyZCk7XG4gICAgICBpZiAoJGlzRGVjb3JhdG9yTm9kZShwb3NzaWJsZU5vZGUpICYmICFwb3NzaWJsZU5vZGUuaXNJc29sYXRlZCgpKSB7XG4gICAgICAgIC8vIE1ha2UgaXQgcG9zc2libGUgdG8gbW92ZSBzZWxlY3Rpb24gZnJvbSByYW5nZSBzZWxlY3Rpb24gdG9cbiAgICAgICAgLy8gbm9kZSBzZWxlY3Rpb24gb24gdGhlIG5vZGUuXG4gICAgICAgIGlmIChwb3NzaWJsZU5vZGUuaXNLZXlib2FyZFNlbGVjdGFibGUoKSAmJiAkaXNFbGVtZW50Tm9kZShhbmNob3JOb2RlKSAmJiBhbmNob3JOb2RlLmdldENoaWxkcmVuU2l6ZSgpID09PSAwKSB7XG4gICAgICAgICAgYW5jaG9yTm9kZS5yZW1vdmUoKTtcbiAgICAgICAgICBjb25zdCBub2RlU2VsZWN0aW9uID0gJGNyZWF0ZU5vZGVTZWxlY3Rpb24oKTtcbiAgICAgICAgICBub2RlU2VsZWN0aW9uLmFkZChwb3NzaWJsZU5vZGUuX19rZXkpO1xuICAgICAgICAgICRzZXRTZWxlY3Rpb24obm9kZVNlbGVjdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcG9zc2libGVOb2RlLnJlbW92ZSgpO1xuICAgICAgICAgIGNvbnN0IGVkaXRvciA9IGdldEFjdGl2ZUVkaXRvcigpO1xuICAgICAgICAgIGVkaXRvci5kaXNwYXRjaENvbW1hbmQoU0VMRUNUSU9OX0NIQU5HRV9DT01NQU5ELCB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAoIWlzQmFja3dhcmQgJiYgJGlzRWxlbWVudE5vZGUocG9zc2libGVOb2RlKSAmJiAkaXNFbGVtZW50Tm9kZShhbmNob3JOb2RlKSAmJiBhbmNob3JOb2RlLmlzRW1wdHkoKSkge1xuICAgICAgICBhbmNob3JOb2RlLnJlbW92ZSgpO1xuICAgICAgICBwb3NzaWJsZU5vZGUuc2VsZWN0U3RhcnQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5tb2RpZnkoJ2V4dGVuZCcsIGlzQmFja3dhcmQsICdjaGFyYWN0ZXInKTtcbiAgICAgIGlmICghdGhpcy5pc0NvbGxhcHNlZCgpKSB7XG4gICAgICAgIGNvbnN0IGZvY3VzTm9kZSA9IGZvY3VzLnR5cGUgPT09ICd0ZXh0JyA/IGZvY3VzLmdldE5vZGUoKSA6IG51bGw7XG4gICAgICAgIGFuY2hvck5vZGUgPSBhbmNob3IudHlwZSA9PT0gJ3RleHQnID8gYW5jaG9yLmdldE5vZGUoKSA6IG51bGw7XG4gICAgICAgIGlmIChmb2N1c05vZGUgIT09IG51bGwgJiYgZm9jdXNOb2RlLmlzU2VnbWVudGVkKCkpIHtcbiAgICAgICAgICBjb25zdCBvZmZzZXQgPSBmb2N1cy5vZmZzZXQ7XG4gICAgICAgICAgY29uc3QgdGV4dENvbnRlbnRTaXplID0gZm9jdXNOb2RlLmdldFRleHRDb250ZW50U2l6ZSgpO1xuICAgICAgICAgIGlmIChmb2N1c05vZGUuaXMoYW5jaG9yTm9kZSkgfHwgaXNCYWNrd2FyZCAmJiBvZmZzZXQgIT09IHRleHRDb250ZW50U2l6ZSB8fCAhaXNCYWNrd2FyZCAmJiBvZmZzZXQgIT09IDApIHtcbiAgICAgICAgICAgICRyZW1vdmVTZWdtZW50KGZvY3VzTm9kZSwgaXNCYWNrd2FyZCwgb2Zmc2V0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoYW5jaG9yTm9kZSAhPT0gbnVsbCAmJiBhbmNob3JOb2RlLmlzU2VnbWVudGVkKCkpIHtcbiAgICAgICAgICBjb25zdCBvZmZzZXQgPSBhbmNob3Iub2Zmc2V0O1xuICAgICAgICAgIGNvbnN0IHRleHRDb250ZW50U2l6ZSA9IGFuY2hvck5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCk7XG4gICAgICAgICAgaWYgKGFuY2hvck5vZGUuaXMoZm9jdXNOb2RlKSB8fCBpc0JhY2t3YXJkICYmIG9mZnNldCAhPT0gMCB8fCAhaXNCYWNrd2FyZCAmJiBvZmZzZXQgIT09IHRleHRDb250ZW50U2l6ZSkge1xuICAgICAgICAgICAgJHJlbW92ZVNlZ21lbnQoYW5jaG9yTm9kZSwgaXNCYWNrd2FyZCwgb2Zmc2V0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgJHVwZGF0ZUNhcmV0U2VsZWN0aW9uRm9yVW5pY29kZUNoYXJhY3Rlcih0aGlzLCBpc0JhY2t3YXJkKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNCYWNrd2FyZCAmJiBhbmNob3Iub2Zmc2V0ID09PSAwKSB7XG4gICAgICAgIC8vIFNwZWNpYWwgaGFuZGxpbmcgYXJvdW5kIHJpY2ggdGV4dCBub2Rlc1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gYW5jaG9yLnR5cGUgPT09ICdlbGVtZW50JyA/IGFuY2hvci5nZXROb2RlKCkgOiBhbmNob3IuZ2V0Tm9kZSgpLmdldFBhcmVudE9yVGhyb3coKTtcbiAgICAgICAgaWYgKGVsZW1lbnQuY29sbGFwc2VBdFN0YXJ0KHRoaXMpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlVGV4dCgpO1xuICAgIGlmIChpc0JhY2t3YXJkICYmICF3YXNDb2xsYXBzZWQgJiYgdGhpcy5pc0NvbGxhcHNlZCgpICYmIHRoaXMuYW5jaG9yLnR5cGUgPT09ICdlbGVtZW50JyAmJiB0aGlzLmFuY2hvci5vZmZzZXQgPT09IDApIHtcbiAgICAgIGNvbnN0IGFuY2hvck5vZGUgPSB0aGlzLmFuY2hvci5nZXROb2RlKCk7XG4gICAgICBpZiAoYW5jaG9yTm9kZS5pc0VtcHR5KCkgJiYgJGlzUm9vdE5vZGUoYW5jaG9yTm9kZS5nZXRQYXJlbnQoKSkgJiYgYW5jaG9yTm9kZS5nZXRJbmRleFdpdGhpblBhcmVudCgpID09PSAwKSB7XG4gICAgICAgIGFuY2hvck5vZGUuY29sbGFwc2VBdFN0YXJ0KHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtcyBvbmUgbG9naWNhbCBsaW5lIGRlbGV0aW9uIG9wZXJhdGlvbiBvbiB0aGUgRWRpdG9yU3RhdGUgYmFzZWQgb24gdGhlIGN1cnJlbnQgU2VsZWN0aW9uLlxuICAgKiBIYW5kbGVzIGRpZmZlcmVudCBub2RlIHR5cGVzLlxuICAgKlxuICAgKiBAcGFyYW0gaXNCYWNrd2FyZCB3aGV0aGVyIG9yIG5vdCB0aGUgc2VsZWN0aW9uIGlzIGJhY2t3YXJkcy5cbiAgICovXG4gIGRlbGV0ZUxpbmUoaXNCYWNrd2FyZCkge1xuICAgIGlmICh0aGlzLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgIC8vIFNpbmNlIGBkb21TZWxlY3Rpb24ubW9kaWZ5KCdleHRlbmQnLCAuLi4sICdsaW5lYm91bmRhcnknKWAgd29ya3Mgd2VsbCBmb3IgdGV4dCBzZWxlY3Rpb25zXG4gICAgICAvLyBidXQgZG9lc24ndCBwcm9wZXJseSBoYW5kbGUgc2VsZWN0aW9ucyB3aGljaCBlbmQgb24gZWxlbWVudHMsIGEgc3BhY2UgY2hhcmFjdGVyIGlzIGFkZGVkXG4gICAgICAvLyBmb3Igc3VjaCBzZWxlY3Rpb25zIHRyYW5zZm9ybWluZyB0aGVpciBhbmNob3IncyB0eXBlIHRvICd0ZXh0J1xuICAgICAgY29uc3QgYW5jaG9ySXNFbGVtZW50ID0gdGhpcy5hbmNob3IudHlwZSA9PT0gJ2VsZW1lbnQnO1xuICAgICAgaWYgKGFuY2hvcklzRWxlbWVudCkge1xuICAgICAgICB0aGlzLmluc2VydFRleHQoJyAnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubW9kaWZ5KCdleHRlbmQnLCBpc0JhY2t3YXJkLCAnbGluZWJvdW5kYXJ5Jyk7XG5cbiAgICAgIC8vIElmIHRoZSBzZWxlY3Rpb24gc3RhcnRzIGF0IHRoZSBiZWdpbm5pbmcgb2YgYSB0ZXh0IG5vZGUgKG9mZnNldCAwKSxcbiAgICAgIC8vIGV4dGVuZCB0aGUgc2VsZWN0aW9uIGJ5IG9uZSBjaGFyYWN0ZXIgaW4gdGhlIHNwZWNpZmllZCBkaXJlY3Rpb24uXG4gICAgICAvLyBUaGlzIGVuc3VyZXMgdGhhdCB0aGUgcGFyZW50IGVsZW1lbnQgaXMgZGVsZXRlZCBhbG9uZyB3aXRoIGl0cyBjb250ZW50LlxuICAgICAgLy8gT3RoZXJ3aXNlLCBvbmx5IHRoZSB0ZXh0IGNvbnRlbnQgd2lsbCBiZSBkZWxldGVkLCBsZWF2aW5nIGFuIGVtcHR5IHBhcmVudCBub2RlLlxuICAgICAgaWYgKHRoaXMuaXNDb2xsYXBzZWQoKSAmJiB0aGlzLmFuY2hvci5vZmZzZXQgPT09IDApIHtcbiAgICAgICAgdGhpcy5tb2RpZnkoJ2V4dGVuZCcsIGlzQmFja3dhcmQsICdjaGFyYWN0ZXInKTtcbiAgICAgIH1cblxuICAgICAgLy8gQWRqdXN0cyBzZWxlY3Rpb24gdG8gaW5jbHVkZSBhbiBleHRyYSBjaGFyYWN0ZXIgYWRkZWQgZm9yIGVsZW1lbnQgYW5jaG9ycyB0byByZW1vdmUgaXRcbiAgICAgIGlmIChhbmNob3JJc0VsZW1lbnQpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRQb2ludCA9IGlzQmFja3dhcmQgPyB0aGlzLmFuY2hvciA6IHRoaXMuZm9jdXM7XG4gICAgICAgIHN0YXJ0UG9pbnQuc2V0KHN0YXJ0UG9pbnQua2V5LCBzdGFydFBvaW50Lm9mZnNldCArIDEsIHN0YXJ0UG9pbnQudHlwZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlVGV4dCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm1zIG9uZSBsb2dpY2FsIHdvcmQgZGVsZXRpb24gb3BlcmF0aW9uIG9uIHRoZSBFZGl0b3JTdGF0ZSBiYXNlZCBvbiB0aGUgY3VycmVudCBTZWxlY3Rpb24uXG4gICAqIEhhbmRsZXMgZGlmZmVyZW50IG5vZGUgdHlwZXMuXG4gICAqXG4gICAqIEBwYXJhbSBpc0JhY2t3YXJkIHdoZXRoZXIgb3Igbm90IHRoZSBzZWxlY3Rpb24gaXMgYmFja3dhcmRzLlxuICAgKi9cbiAgZGVsZXRlV29yZChpc0JhY2t3YXJkKSB7XG4gICAgaWYgKHRoaXMuaXNDb2xsYXBzZWQoKSkge1xuICAgICAgY29uc3QgYW5jaG9yID0gdGhpcy5hbmNob3I7XG4gICAgICBjb25zdCBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgICAgIGlmICh0aGlzLmZvcndhcmREZWxldGlvbihhbmNob3IsIGFuY2hvck5vZGUsIGlzQmFja3dhcmQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMubW9kaWZ5KCdleHRlbmQnLCBpc0JhY2t3YXJkLCAnd29yZCcpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZVRleHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIFNlbGVjdGlvbiBpcyBcImJhY2t3YXJkc1wiLCBtZWFuaW5nIHRoZSBmb2N1c1xuICAgKiBsb2dpY2FsbHkgcHJlY2VkZXMgdGhlIGFuY2hvciBpbiB0aGUgRWRpdG9yU3RhdGUuXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIFNlbGVjdGlvbiBpcyBiYWNrd2FyZHMsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGlzQmFja3dhcmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9jdXMuaXNCZWZvcmUodGhpcy5hbmNob3IpO1xuICB9XG4gIGdldFN0YXJ0RW5kUG9pbnRzKCkge1xuICAgIHJldHVybiBbdGhpcy5hbmNob3IsIHRoaXMuZm9jdXNdO1xuICB9XG59XG5mdW5jdGlvbiAkaXNOb2RlU2VsZWN0aW9uKHgpIHtcbiAgcmV0dXJuIHggaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uO1xufVxuZnVuY3Rpb24gZ2V0Q2hhcmFjdGVyT2Zmc2V0KHBvaW50KSB7XG4gIGNvbnN0IG9mZnNldCA9IHBvaW50Lm9mZnNldDtcbiAgaWYgKHBvaW50LnR5cGUgPT09ICd0ZXh0Jykge1xuICAgIHJldHVybiBvZmZzZXQ7XG4gIH1cbiAgY29uc3QgcGFyZW50ID0gcG9pbnQuZ2V0Tm9kZSgpO1xuICByZXR1cm4gb2Zmc2V0ID09PSBwYXJlbnQuZ2V0Q2hpbGRyZW5TaXplKCkgPyBwYXJlbnQuZ2V0VGV4dENvbnRlbnQoKS5sZW5ndGggOiAwO1xufVxuZnVuY3Rpb24gJGdldENoYXJhY3Rlck9mZnNldHMoc2VsZWN0aW9uKSB7XG4gIGNvbnN0IGFuY2hvckFuZEZvY3VzID0gc2VsZWN0aW9uLmdldFN0YXJ0RW5kUG9pbnRzKCk7XG4gIGlmIChhbmNob3JBbmRGb2N1cyA9PT0gbnVsbCkge1xuICAgIHJldHVybiBbMCwgMF07XG4gIH1cbiAgY29uc3QgW2FuY2hvciwgZm9jdXNdID0gYW5jaG9yQW5kRm9jdXM7XG4gIGlmIChhbmNob3IudHlwZSA9PT0gJ2VsZW1lbnQnICYmIGZvY3VzLnR5cGUgPT09ICdlbGVtZW50JyAmJiBhbmNob3Iua2V5ID09PSBmb2N1cy5rZXkgJiYgYW5jaG9yLm9mZnNldCA9PT0gZm9jdXMub2Zmc2V0KSB7XG4gICAgcmV0dXJuIFswLCAwXTtcbiAgfVxuICByZXR1cm4gW2dldENoYXJhY3Rlck9mZnNldChhbmNob3IpLCBnZXRDaGFyYWN0ZXJPZmZzZXQoZm9jdXMpXTtcbn1cbmZ1bmN0aW9uICRzd2FwUG9pbnRzKHNlbGVjdGlvbikge1xuICBjb25zdCBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cztcbiAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgY29uc3QgYW5jaG9yS2V5ID0gYW5jaG9yLmtleTtcbiAgY29uc3QgYW5jaG9yT2Zmc2V0ID0gYW5jaG9yLm9mZnNldDtcbiAgY29uc3QgYW5jaG9yVHlwZSA9IGFuY2hvci50eXBlO1xuICAkc2V0UG9pbnRWYWx1ZXMoYW5jaG9yLCBmb2N1cy5rZXksIGZvY3VzLm9mZnNldCwgZm9jdXMudHlwZSk7XG4gICRzZXRQb2ludFZhbHVlcyhmb2N1cywgYW5jaG9yS2V5LCBhbmNob3JPZmZzZXQsIGFuY2hvclR5cGUpO1xuICBzZWxlY3Rpb24uX2NhY2hlZE5vZGVzID0gbnVsbDtcbn1cbmZ1bmN0aW9uIG1vdmVOYXRpdmVTZWxlY3Rpb24oZG9tU2VsZWN0aW9uLCBhbHRlciwgZGlyZWN0aW9uLCBncmFudWxhcml0eSkge1xuICAvLyBTZWxlY3Rpb24ubW9kaWZ5KCkgbWV0aG9kIGFwcGxpZXMgYSBjaGFuZ2UgdG8gdGhlIGN1cnJlbnQgc2VsZWN0aW9uIG9yIGN1cnNvciBwb3NpdGlvbixcbiAgLy8gYnV0IGlzIHN0aWxsIG5vbi1zdGFuZGFyZCBpbiBzb21lIGJyb3dzZXJzLlxuICBkb21TZWxlY3Rpb24ubW9kaWZ5KGFsdGVyLCBkaXJlY3Rpb24sIGdyYW51bGFyaXR5KTtcbn1cbmZ1bmN0aW9uICR1cGRhdGVDYXJldFNlbGVjdGlvbkZvclVuaWNvZGVDaGFyYWN0ZXIoc2VsZWN0aW9uLCBpc0JhY2t3YXJkKSB7XG4gIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICBjb25zdCBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgY29uc3QgZm9jdXNOb2RlID0gZm9jdXMuZ2V0Tm9kZSgpO1xuICBpZiAoYW5jaG9yTm9kZSA9PT0gZm9jdXNOb2RlICYmIGFuY2hvci50eXBlID09PSAndGV4dCcgJiYgZm9jdXMudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgLy8gSGFuZGxpbmcgb2YgbXVsdGlieXRlIGNoYXJhY3RlcnNcbiAgICBjb25zdCBhbmNob3JPZmZzZXQgPSBhbmNob3Iub2Zmc2V0O1xuICAgIGNvbnN0IGZvY3VzT2Zmc2V0ID0gZm9jdXMub2Zmc2V0O1xuICAgIGNvbnN0IGlzQmVmb3JlID0gYW5jaG9yT2Zmc2V0IDwgZm9jdXNPZmZzZXQ7XG4gICAgY29uc3Qgc3RhcnRPZmZzZXQgPSBpc0JlZm9yZSA/IGFuY2hvck9mZnNldCA6IGZvY3VzT2Zmc2V0O1xuICAgIGNvbnN0IGVuZE9mZnNldCA9IGlzQmVmb3JlID8gZm9jdXNPZmZzZXQgOiBhbmNob3JPZmZzZXQ7XG4gICAgY29uc3QgY2hhcmFjdGVyT2Zmc2V0ID0gZW5kT2Zmc2V0IC0gMTtcbiAgICBpZiAoc3RhcnRPZmZzZXQgIT09IGNoYXJhY3Rlck9mZnNldCkge1xuICAgICAgY29uc3QgdGV4dCA9IGFuY2hvck5vZGUuZ2V0VGV4dENvbnRlbnQoKS5zbGljZShzdGFydE9mZnNldCwgZW5kT2Zmc2V0KTtcbiAgICAgIGlmICghZG9lc0NvbnRhaW5HcmFwaGVtZSh0ZXh0KSkge1xuICAgICAgICBpZiAoaXNCYWNrd2FyZCkge1xuICAgICAgICAgIGZvY3VzLm9mZnNldCA9IGNoYXJhY3Rlck9mZnNldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhbmNob3Iub2Zmc2V0ID0gY2hhcmFjdGVyT2Zmc2V0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiAkcmVtb3ZlU2VnbWVudChub2RlLCBpc0JhY2t3YXJkLCBvZmZzZXQpIHtcbiAgY29uc3QgdGV4dE5vZGUgPSBub2RlO1xuICBjb25zdCB0ZXh0Q29udGVudCA9IHRleHROb2RlLmdldFRleHRDb250ZW50KCk7XG4gIGNvbnN0IHNwbGl0ID0gdGV4dENvbnRlbnQuc3BsaXQoLyg/PVxccykvZyk7XG4gIGNvbnN0IHNwbGl0TGVuZ3RoID0gc3BsaXQubGVuZ3RoO1xuICBsZXQgc2VnbWVudE9mZnNldCA9IDA7XG4gIGxldCByZXN0b3JlT2Zmc2V0ID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGxpdExlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdGV4dCA9IHNwbGl0W2ldO1xuICAgIGNvbnN0IGlzTGFzdCA9IGkgPT09IHNwbGl0TGVuZ3RoIC0gMTtcbiAgICByZXN0b3JlT2Zmc2V0ID0gc2VnbWVudE9mZnNldDtcbiAgICBzZWdtZW50T2Zmc2V0ICs9IHRleHQubGVuZ3RoO1xuICAgIGlmIChpc0JhY2t3YXJkICYmIHNlZ21lbnRPZmZzZXQgPT09IG9mZnNldCB8fCBzZWdtZW50T2Zmc2V0ID4gb2Zmc2V0IHx8IGlzTGFzdCkge1xuICAgICAgc3BsaXQuc3BsaWNlKGksIDEpO1xuICAgICAgaWYgKGlzTGFzdCkge1xuICAgICAgICByZXN0b3JlT2Zmc2V0ID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGNvbnN0IG5leHRUZXh0Q29udGVudCA9IHNwbGl0LmpvaW4oJycpLnRyaW0oKTtcbiAgaWYgKG5leHRUZXh0Q29udGVudCA9PT0gJycpIHtcbiAgICB0ZXh0Tm9kZS5yZW1vdmUoKTtcbiAgfSBlbHNlIHtcbiAgICB0ZXh0Tm9kZS5zZXRUZXh0Q29udGVudChuZXh0VGV4dENvbnRlbnQpO1xuICAgIHRleHROb2RlLnNlbGVjdChyZXN0b3JlT2Zmc2V0LCByZXN0b3JlT2Zmc2V0KTtcbiAgfVxufVxuZnVuY3Rpb24gc2hvdWxkUmVzb2x2ZUFuY2VzdG9yKHJlc29sdmVkRWxlbWVudCwgcmVzb2x2ZWRPZmZzZXQsIGxhc3RQb2ludCkge1xuICBjb25zdCBwYXJlbnQgPSByZXNvbHZlZEVsZW1lbnQuZ2V0UGFyZW50KCk7XG4gIHJldHVybiBsYXN0UG9pbnQgPT09IG51bGwgfHwgcGFyZW50ID09PSBudWxsIHx8ICFwYXJlbnQuY2FuQmVFbXB0eSgpIHx8IHBhcmVudCAhPT0gbGFzdFBvaW50LmdldE5vZGUoKTtcbn1cbmZ1bmN0aW9uICRpbnRlcm5hbFJlc29sdmVTZWxlY3Rpb25Qb2ludChkb20sIG9mZnNldCwgbGFzdFBvaW50LCBlZGl0b3IpIHtcbiAgbGV0IHJlc29sdmVkT2Zmc2V0ID0gb2Zmc2V0O1xuICBsZXQgcmVzb2x2ZWROb2RlO1xuICAvLyBJZiB3ZSBoYXZlIHNlbGVjdGlvbiBvbiBhbiBlbGVtZW50LCB3ZSB3aWxsXG4gIC8vIG5lZWQgdG8gZmlndXJlIG91dCAodXNpbmcgdGhlIG9mZnNldCkgd2hhdCB0ZXh0XG4gIC8vIG5vZGUgc2hvdWxkIGJlIHNlbGVjdGVkLlxuXG4gIGlmIChpc0hUTUxFbGVtZW50KGRvbSkpIHtcbiAgICAvLyBSZXNvbHZlIGVsZW1lbnQgdG8gYSBFbGVtZW50Tm9kZSwgb3IgVGV4dE5vZGUsIG9yIG51bGxcbiAgICBsZXQgbW92ZVNlbGVjdGlvblRvRW5kID0gZmFsc2U7XG4gICAgLy8gR2l2ZW4gd2UncmUgbW92aW5nIHNlbGVjdGlvbiB0byBhbm90aGVyIG5vZGUsIHNlbGVjdGlvbiBpc1xuICAgIC8vIGRlZmluaXRlbHkgZGlydHkuXG4gICAgLy8gV2UgdXNlIHRoZSBhbmNob3IgdG8gZmluZCB3aGljaCBjaGlsZCBub2RlIHRvIHNlbGVjdFxuICAgIGNvbnN0IGNoaWxkTm9kZXMgPSBkb20uY2hpbGROb2RlcztcbiAgICBjb25zdCBjaGlsZE5vZGVzTGVuZ3RoID0gY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgY29uc3QgYmxvY2tDdXJzb3JFbGVtZW50ID0gZWRpdG9yLl9ibG9ja0N1cnNvckVsZW1lbnQ7XG4gICAgLy8gSWYgdGhlIGFuY2hvciBpcyB0aGUgc2FtZSBhcyBsZW5ndGgsIHRoZW4gdGhpcyBtZWFucyB3ZVxuICAgIC8vIG5lZWQgdG8gc2VsZWN0IHRoZSB2ZXJ5IGxhc3QgdGV4dCBub2RlLlxuICAgIGlmIChyZXNvbHZlZE9mZnNldCA9PT0gY2hpbGROb2Rlc0xlbmd0aCkge1xuICAgICAgbW92ZVNlbGVjdGlvblRvRW5kID0gdHJ1ZTtcbiAgICAgIHJlc29sdmVkT2Zmc2V0ID0gY2hpbGROb2Rlc0xlbmd0aCAtIDE7XG4gICAgfVxuICAgIGxldCBjaGlsZERPTSA9IGNoaWxkTm9kZXNbcmVzb2x2ZWRPZmZzZXRdO1xuICAgIGxldCBoYXNCbG9ja0N1cnNvciA9IGZhbHNlO1xuICAgIGlmIChjaGlsZERPTSA9PT0gYmxvY2tDdXJzb3JFbGVtZW50KSB7XG4gICAgICBjaGlsZERPTSA9IGNoaWxkTm9kZXNbcmVzb2x2ZWRPZmZzZXQgKyAxXTtcbiAgICAgIGhhc0Jsb2NrQ3Vyc29yID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGJsb2NrQ3Vyc29yRWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgYmxvY2tDdXJzb3JFbGVtZW50UGFyZW50ID0gYmxvY2tDdXJzb3JFbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICBpZiAoZG9tID09PSBibG9ja0N1cnNvckVsZW1lbnRQYXJlbnQpIHtcbiAgICAgICAgY29uc3QgYmxvY2tDdXJzb3JPZmZzZXQgPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJsb2NrQ3Vyc29yRWxlbWVudFBhcmVudC5jaGlsZHJlbiwgYmxvY2tDdXJzb3JFbGVtZW50KTtcbiAgICAgICAgaWYgKG9mZnNldCA+IGJsb2NrQ3Vyc29yT2Zmc2V0KSB7XG4gICAgICAgICAgcmVzb2x2ZWRPZmZzZXQtLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXNvbHZlZE5vZGUgPSAkZ2V0Tm9kZUZyb21ET00oY2hpbGRET00pO1xuICAgIGlmICgkaXNUZXh0Tm9kZShyZXNvbHZlZE5vZGUpKSB7XG4gICAgICByZXNvbHZlZE9mZnNldCA9IGdldFRleHROb2RlT2Zmc2V0KHJlc29sdmVkTm9kZSwgbW92ZVNlbGVjdGlvblRvRW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHJlc29sdmVkRWxlbWVudCA9ICRnZXROb2RlRnJvbURPTShkb20pO1xuICAgICAgLy8gRW5zdXJlIHJlc29sdmVkRWxlbWVudCBpcyBhY3R1YWxseSBhIGVsZW1lbnQuXG4gICAgICBpZiAocmVzb2x2ZWRFbGVtZW50ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKCRpc0VsZW1lbnROb2RlKHJlc29sdmVkRWxlbWVudCkpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudERPTSA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkocmVzb2x2ZWRFbGVtZW50LmdldEtleSgpKTtcbiAgICAgICAgaWYgKCEoZWxlbWVudERPTSAhPT0gbnVsbCkpIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihgJGludGVybmFsUmVzb2x2ZVNlbGVjdGlvblBvaW50OiBub2RlIGluIERPTSBidXQgbm90IGtleVRvRE9NTWFwYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2xvdCA9IHJlc29sdmVkRWxlbWVudC5nZXRET01TbG90KGVsZW1lbnRET00pO1xuICAgICAgICBbcmVzb2x2ZWRFbGVtZW50LCByZXNvbHZlZE9mZnNldF0gPSBzbG90LnJlc29sdmVDaGlsZEluZGV4KHJlc29sdmVkRWxlbWVudCwgZWxlbWVudERPTSwgZG9tLCBvZmZzZXQpO1xuICAgICAgICAvLyBUaGlzIGlzIGp1c3QgYSB0eXBlc2NyaXB0IHdvcmthcm91bmQsIGl0IGlzIHRydWUgYnV0IGxvc3QgZHVlIHRvIG11dGFiaWxpdHlcbiAgICAgICAgaWYgKCEkaXNFbGVtZW50Tm9kZShyZXNvbHZlZEVsZW1lbnQpKSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoYCRpbnRlcm5hbFJlc29sdmVTZWxlY3Rpb25Qb2ludDogcmVzb2x2ZWRFbGVtZW50IGlzIG5vdCBhbiBFbGVtZW50Tm9kZWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtb3ZlU2VsZWN0aW9uVG9FbmQgJiYgcmVzb2x2ZWRPZmZzZXQgPj0gcmVzb2x2ZWRFbGVtZW50LmdldENoaWxkcmVuU2l6ZSgpKSB7XG4gICAgICAgICAgcmVzb2x2ZWRPZmZzZXQgPSBNYXRoLm1heCgwLCByZXNvbHZlZEVsZW1lbnQuZ2V0Q2hpbGRyZW5TaXplKCkgLSAxKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2hpbGQgPSByZXNvbHZlZEVsZW1lbnQuZ2V0Q2hpbGRBdEluZGV4KHJlc29sdmVkT2Zmc2V0KTtcbiAgICAgICAgaWYgKCRpc0VsZW1lbnROb2RlKGNoaWxkKSAmJiBzaG91bGRSZXNvbHZlQW5jZXN0b3IoY2hpbGQsIHJlc29sdmVkT2Zmc2V0LCBsYXN0UG9pbnQpKSB7XG4gICAgICAgICAgY29uc3QgZGVzY2VuZGFudCA9IG1vdmVTZWxlY3Rpb25Ub0VuZCA/IGNoaWxkLmdldExhc3REZXNjZW5kYW50KCkgOiBjaGlsZC5nZXRGaXJzdERlc2NlbmRhbnQoKTtcbiAgICAgICAgICBpZiAoZGVzY2VuZGFudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzb2x2ZWRFbGVtZW50ID0gY2hpbGQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoaWxkID0gZGVzY2VuZGFudDtcbiAgICAgICAgICAgIHJlc29sdmVkRWxlbWVudCA9ICRpc0VsZW1lbnROb2RlKGNoaWxkKSA/IGNoaWxkIDogY2hpbGQuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvbHZlZE9mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCRpc1RleHROb2RlKGNoaWxkKSkge1xuICAgICAgICAgIHJlc29sdmVkTm9kZSA9IGNoaWxkO1xuICAgICAgICAgIHJlc29sdmVkRWxlbWVudCA9IG51bGw7XG4gICAgICAgICAgcmVzb2x2ZWRPZmZzZXQgPSBnZXRUZXh0Tm9kZU9mZnNldChjaGlsZCwgbW92ZVNlbGVjdGlvblRvRW5kKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGlsZCAhPT0gcmVzb2x2ZWRFbGVtZW50ICYmIG1vdmVTZWxlY3Rpb25Ub0VuZCAmJiAhaGFzQmxvY2tDdXJzb3IpIHtcbiAgICAgICAgICBpZiAoISRpc0VsZW1lbnROb2RlKHJlc29sdmVkRWxlbWVudCkpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBpbnZhcmlhbnRgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZWRPZmZzZXQgPSBNYXRoLm1pbihyZXNvbHZlZEVsZW1lbnQuZ2V0Q2hpbGRyZW5TaXplKCksIHJlc29sdmVkT2Zmc2V0ICsgMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gcmVzb2x2ZWRFbGVtZW50LmdldEluZGV4V2l0aGluUGFyZW50KCk7XG4gICAgICAgIC8vIFdoZW4gc2VsZWN0aW5nIGRlY29yYXRvcnMsIHRoZXJlIGNhbiBiZSBzb21lIHNlbGVjdGlvbiBpc3N1ZXMgd2hlbiB1c2luZyByZXNvbHZlZE9mZnNldCxcbiAgICAgICAgLy8gYW5kIGluc3RlYWQgd2Ugc2hvdWxkIGJlIGNoZWNraW5nIGlmIHdlJ3JlIHVzaW5nIHRoZSBvZmZzZXRcbiAgICAgICAgaWYgKG9mZnNldCA9PT0gMCAmJiAkaXNEZWNvcmF0b3JOb2RlKHJlc29sdmVkRWxlbWVudCkgJiYgJGdldE5vZGVGcm9tRE9NKGRvbSkgPT09IHJlc29sdmVkRWxlbWVudCkge1xuICAgICAgICAgIHJlc29sdmVkT2Zmc2V0ID0gaW5kZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZWRPZmZzZXQgPSBpbmRleCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZWRFbGVtZW50ID0gcmVzb2x2ZWRFbGVtZW50LmdldFBhcmVudE9yVGhyb3coKTtcbiAgICAgIH1cbiAgICAgIGlmICgkaXNFbGVtZW50Tm9kZShyZXNvbHZlZEVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiAkY3JlYXRlUG9pbnQocmVzb2x2ZWRFbGVtZW50Ll9fa2V5LCByZXNvbHZlZE9mZnNldCwgJ2VsZW1lbnQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gVGV4dE5vZGUgb3IgbnVsbFxuICAgIHJlc29sdmVkTm9kZSA9ICRnZXROb2RlRnJvbURPTShkb20pO1xuICB9XG4gIGlmICghJGlzVGV4dE5vZGUocmVzb2x2ZWROb2RlKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiAkY3JlYXRlUG9pbnQocmVzb2x2ZWROb2RlLl9fa2V5LCByZXNvbHZlZE9mZnNldCwgJ3RleHQnKTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVTZWxlY3Rpb25Qb2ludE9uQm91bmRhcnkocG9pbnQsIGlzQmFja3dhcmQsIGlzQ29sbGFwc2VkKSB7XG4gIGNvbnN0IG9mZnNldCA9IHBvaW50Lm9mZnNldDtcbiAgY29uc3Qgbm9kZSA9IHBvaW50LmdldE5vZGUoKTtcbiAgaWYgKG9mZnNldCA9PT0gMCkge1xuICAgIGNvbnN0IHByZXZTaWJsaW5nID0gbm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICBjb25zdCBwYXJlbnQgPSBub2RlLmdldFBhcmVudCgpO1xuICAgIGlmICghaXNCYWNrd2FyZCkge1xuICAgICAgaWYgKCRpc0VsZW1lbnROb2RlKHByZXZTaWJsaW5nKSAmJiAhaXNDb2xsYXBzZWQgJiYgcHJldlNpYmxpbmcuaXNJbmxpbmUoKSkge1xuICAgICAgICBwb2ludC5rZXkgPSBwcmV2U2libGluZy5fX2tleTtcbiAgICAgICAgcG9pbnQub2Zmc2V0ID0gcHJldlNpYmxpbmcuZ2V0Q2hpbGRyZW5TaXplKCk7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGludGVudGlvbmFsXG4gICAgICAgIHBvaW50LnR5cGUgPSAnZWxlbWVudCc7XG4gICAgICB9IGVsc2UgaWYgKCRpc1RleHROb2RlKHByZXZTaWJsaW5nKSkge1xuICAgICAgICBwb2ludC5rZXkgPSBwcmV2U2libGluZy5fX2tleTtcbiAgICAgICAgcG9pbnQub2Zmc2V0ID0gcHJldlNpYmxpbmcuZ2V0VGV4dENvbnRlbnQoKS5sZW5ndGg7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgoaXNDb2xsYXBzZWQgfHwgIWlzQmFja3dhcmQpICYmIHByZXZTaWJsaW5nID09PSBudWxsICYmICRpc0VsZW1lbnROb2RlKHBhcmVudCkgJiYgcGFyZW50LmlzSW5saW5lKCkpIHtcbiAgICAgIGNvbnN0IHBhcmVudFNpYmxpbmcgPSBwYXJlbnQuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgICBpZiAoJGlzVGV4dE5vZGUocGFyZW50U2libGluZykpIHtcbiAgICAgICAgcG9pbnQua2V5ID0gcGFyZW50U2libGluZy5fX2tleTtcbiAgICAgICAgcG9pbnQub2Zmc2V0ID0gcGFyZW50U2libGluZy5nZXRUZXh0Q29udGVudCgpLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAob2Zmc2V0ID09PSBub2RlLmdldFRleHRDb250ZW50KCkubGVuZ3RoKSB7XG4gICAgY29uc3QgbmV4dFNpYmxpbmcgPSBub2RlLmdldE5leHRTaWJsaW5nKCk7XG4gICAgY29uc3QgcGFyZW50ID0gbm9kZS5nZXRQYXJlbnQoKTtcbiAgICBpZiAoaXNCYWNrd2FyZCAmJiAkaXNFbGVtZW50Tm9kZShuZXh0U2libGluZykgJiYgbmV4dFNpYmxpbmcuaXNJbmxpbmUoKSkge1xuICAgICAgcG9pbnQua2V5ID0gbmV4dFNpYmxpbmcuX19rZXk7XG4gICAgICBwb2ludC5vZmZzZXQgPSAwO1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW50ZW50aW9uYWxcbiAgICAgIHBvaW50LnR5cGUgPSAnZWxlbWVudCc7XG4gICAgfSBlbHNlIGlmICgoaXNDb2xsYXBzZWQgfHwgaXNCYWNrd2FyZCkgJiYgbmV4dFNpYmxpbmcgPT09IG51bGwgJiYgJGlzRWxlbWVudE5vZGUocGFyZW50KSAmJiBwYXJlbnQuaXNJbmxpbmUoKSAmJiAhcGFyZW50LmNhbkluc2VydFRleHRBZnRlcigpKSB7XG4gICAgICBjb25zdCBwYXJlbnRTaWJsaW5nID0gcGFyZW50LmdldE5leHRTaWJsaW5nKCk7XG4gICAgICBpZiAoJGlzVGV4dE5vZGUocGFyZW50U2libGluZykpIHtcbiAgICAgICAgcG9pbnQua2V5ID0gcGFyZW50U2libGluZy5fX2tleTtcbiAgICAgICAgcG9pbnQub2Zmc2V0ID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uICRub3JtYWxpemVTZWxlY3Rpb25Qb2ludHNGb3JCb3VuZGFyaWVzKGFuY2hvciwgZm9jdXMsIGxhc3RTZWxlY3Rpb24pIHtcbiAgaWYgKGFuY2hvci50eXBlID09PSAndGV4dCcgJiYgZm9jdXMudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgY29uc3QgaXNCYWNrd2FyZCA9IGFuY2hvci5pc0JlZm9yZShmb2N1cyk7XG4gICAgY29uc3QgaXNDb2xsYXBzZWQgPSBhbmNob3IuaXMoZm9jdXMpO1xuXG4gICAgLy8gQXR0ZW1wdCB0byBub3JtYWxpemUgdGhlIG9mZnNldCB0byB0aGUgcHJldmlvdXMgc2libGluZyBpZiB3ZSdyZSBhdCB0aGVcbiAgICAvLyBzdGFydCBvZiBhIHRleHQgbm9kZSBhbmQgdGhlIHNpYmxpbmcgaXMgYSB0ZXh0IG5vZGUgb3IgaW5saW5lIGVsZW1lbnQuXG4gICAgcmVzb2x2ZVNlbGVjdGlvblBvaW50T25Cb3VuZGFyeShhbmNob3IsIGlzQmFja3dhcmQsIGlzQ29sbGFwc2VkKTtcbiAgICByZXNvbHZlU2VsZWN0aW9uUG9pbnRPbkJvdW5kYXJ5KGZvY3VzLCAhaXNCYWNrd2FyZCwgaXNDb2xsYXBzZWQpO1xuICAgIGlmIChpc0NvbGxhcHNlZCkge1xuICAgICAgZm9jdXMua2V5ID0gYW5jaG9yLmtleTtcbiAgICAgIGZvY3VzLm9mZnNldCA9IGFuY2hvci5vZmZzZXQ7XG4gICAgICBmb2N1cy50eXBlID0gYW5jaG9yLnR5cGU7XG4gICAgfVxuICAgIGNvbnN0IGVkaXRvciA9IGdldEFjdGl2ZUVkaXRvcigpO1xuICAgIGlmIChlZGl0b3IuaXNDb21wb3NpbmcoKSAmJiBlZGl0b3IuX2NvbXBvc2l0aW9uS2V5ICE9PSBhbmNob3Iua2V5ICYmICRpc1JhbmdlU2VsZWN0aW9uKGxhc3RTZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCBsYXN0QW5jaG9yID0gbGFzdFNlbGVjdGlvbi5hbmNob3I7XG4gICAgICBjb25zdCBsYXN0Rm9jdXMgPSBsYXN0U2VsZWN0aW9uLmZvY3VzO1xuICAgICAgJHNldFBvaW50VmFsdWVzKGFuY2hvciwgbGFzdEFuY2hvci5rZXksIGxhc3RBbmNob3Iub2Zmc2V0LCBsYXN0QW5jaG9yLnR5cGUpO1xuICAgICAgJHNldFBvaW50VmFsdWVzKGZvY3VzLCBsYXN0Rm9jdXMua2V5LCBsYXN0Rm9jdXMub2Zmc2V0LCBsYXN0Rm9jdXMudHlwZSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiAkaW50ZXJuYWxSZXNvbHZlU2VsZWN0aW9uUG9pbnRzKGFuY2hvckRPTSwgYW5jaG9yT2Zmc2V0LCBmb2N1c0RPTSwgZm9jdXNPZmZzZXQsIGVkaXRvciwgbGFzdFNlbGVjdGlvbikge1xuICBpZiAoYW5jaG9yRE9NID09PSBudWxsIHx8IGZvY3VzRE9NID09PSBudWxsIHx8ICFpc1NlbGVjdGlvbldpdGhpbkVkaXRvcihlZGl0b3IsIGFuY2hvckRPTSwgZm9jdXNET00pKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgcmVzb2x2ZWRBbmNob3JQb2ludCA9ICRpbnRlcm5hbFJlc29sdmVTZWxlY3Rpb25Qb2ludChhbmNob3JET00sIGFuY2hvck9mZnNldCwgJGlzUmFuZ2VTZWxlY3Rpb24obGFzdFNlbGVjdGlvbikgPyBsYXN0U2VsZWN0aW9uLmFuY2hvciA6IG51bGwsIGVkaXRvcik7XG4gIGlmIChyZXNvbHZlZEFuY2hvclBvaW50ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAge1xuICAgICR2YWxpZGF0ZVBvaW50KGVkaXRvciwgJ2FuY2hvcicsIHJlc29sdmVkQW5jaG9yUG9pbnQpO1xuICB9XG4gIGNvbnN0IHJlc29sdmVkRm9jdXNQb2ludCA9ICRpbnRlcm5hbFJlc29sdmVTZWxlY3Rpb25Qb2ludChmb2N1c0RPTSwgZm9jdXNPZmZzZXQsICRpc1JhbmdlU2VsZWN0aW9uKGxhc3RTZWxlY3Rpb24pID8gbGFzdFNlbGVjdGlvbi5mb2N1cyA6IG51bGwsIGVkaXRvcik7XG4gIGlmIChyZXNvbHZlZEZvY3VzUG9pbnQgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB7XG4gICAgJHZhbGlkYXRlUG9pbnQoZWRpdG9yLCAnZm9jdXMnLCByZXNvbHZlZEFuY2hvclBvaW50KTtcbiAgfVxuICBpZiAocmVzb2x2ZWRBbmNob3JQb2ludC50eXBlID09PSAnZWxlbWVudCcgJiYgcmVzb2x2ZWRGb2N1c1BvaW50LnR5cGUgPT09ICdlbGVtZW50Jykge1xuICAgIGNvbnN0IGFuY2hvck5vZGUgPSAkZ2V0Tm9kZUZyb21ET00oYW5jaG9yRE9NKTtcbiAgICBjb25zdCBmb2N1c05vZGUgPSAkZ2V0Tm9kZUZyb21ET00oZm9jdXNET00pO1xuICAgIC8vIEVuc3VyZSBpZiB3ZSdyZSBzZWxlY3RpbmcgdGhlIGNvbnRlbnQgb2YgYSBkZWNvcmF0b3IgdGhhdCB3ZVxuICAgIC8vIHJldHVybiBudWxsIGZvciB0aGlzIHBvaW50LCBhcyBpdCdzIG5vdCBpbiB0aGUgY29udHJvbGxlZCBzY29wZVxuICAgIC8vIG9mIExleGljYWwuXG4gICAgaWYgKCRpc0RlY29yYXRvck5vZGUoYW5jaG9yTm9kZSkgJiYgJGlzRGVjb3JhdG9yTm9kZShmb2N1c05vZGUpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvLyBIYW5kbGUgbm9ybWFsaXphdGlvbiBvZiBzZWxlY3Rpb24gd2hlbiBpdCBpcyBhdCB0aGUgYm91bmRhcmllcy5cbiAgJG5vcm1hbGl6ZVNlbGVjdGlvblBvaW50c0ZvckJvdW5kYXJpZXMocmVzb2x2ZWRBbmNob3JQb2ludCwgcmVzb2x2ZWRGb2N1c1BvaW50LCBsYXN0U2VsZWN0aW9uKTtcbiAgcmV0dXJuIFtyZXNvbHZlZEFuY2hvclBvaW50LCByZXNvbHZlZEZvY3VzUG9pbnRdO1xufVxuZnVuY3Rpb24gJGlzQmxvY2tFbGVtZW50Tm9kZShub2RlKSB7XG4gIHJldHVybiAkaXNFbGVtZW50Tm9kZShub2RlKSAmJiAhbm9kZS5pc0lubGluZSgpO1xufVxuXG4vLyBUaGlzIGlzIHVzZWQgdG8gbWFrZSBhIHNlbGVjdGlvbiB3aGVuIHRoZSBleGlzdGluZ1xuLy8gc2VsZWN0aW9uIGlzIG51bGwsIGkuZS4gZm9yY2luZyBzZWxlY3Rpb24gb24gdGhlIGVkaXRvclxuLy8gd2hlbiBpdCBjdXJyZW50IGV4aXN0cyBvdXRzaWRlIHRoZSBlZGl0b3IuXG5cbmZ1bmN0aW9uICRpbnRlcm5hbE1ha2VSYW5nZVNlbGVjdGlvbihhbmNob3JLZXksIGFuY2hvck9mZnNldCwgZm9jdXNLZXksIGZvY3VzT2Zmc2V0LCBhbmNob3JUeXBlLCBmb2N1c1R5cGUpIHtcbiAgY29uc3QgZWRpdG9yU3RhdGUgPSBnZXRBY3RpdmVFZGl0b3JTdGF0ZSgpO1xuICBjb25zdCBzZWxlY3Rpb24gPSBuZXcgUmFuZ2VTZWxlY3Rpb24oJGNyZWF0ZVBvaW50KGFuY2hvcktleSwgYW5jaG9yT2Zmc2V0LCBhbmNob3JUeXBlKSwgJGNyZWF0ZVBvaW50KGZvY3VzS2V5LCBmb2N1c09mZnNldCwgZm9jdXNUeXBlKSwgMCwgJycpO1xuICBzZWxlY3Rpb24uZGlydHkgPSB0cnVlO1xuICBlZGl0b3JTdGF0ZS5fc2VsZWN0aW9uID0gc2VsZWN0aW9uO1xuICByZXR1cm4gc2VsZWN0aW9uO1xufVxuZnVuY3Rpb24gJGNyZWF0ZVJhbmdlU2VsZWN0aW9uKCkge1xuICBjb25zdCBhbmNob3IgPSAkY3JlYXRlUG9pbnQoJ3Jvb3QnLCAwLCAnZWxlbWVudCcpO1xuICBjb25zdCBmb2N1cyA9ICRjcmVhdGVQb2ludCgncm9vdCcsIDAsICdlbGVtZW50Jyk7XG4gIHJldHVybiBuZXcgUmFuZ2VTZWxlY3Rpb24oYW5jaG9yLCBmb2N1cywgMCwgJycpO1xufVxuZnVuY3Rpb24gJGNyZWF0ZU5vZGVTZWxlY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgTm9kZVNlbGVjdGlvbihuZXcgU2V0KCkpO1xufVxuZnVuY3Rpb24gJGludGVybmFsQ3JlYXRlU2VsZWN0aW9uKGVkaXRvcikge1xuICBjb25zdCBjdXJyZW50RWRpdG9yU3RhdGUgPSBlZGl0b3IuZ2V0RWRpdG9yU3RhdGUoKTtcbiAgY29uc3QgbGFzdFNlbGVjdGlvbiA9IGN1cnJlbnRFZGl0b3JTdGF0ZS5fc2VsZWN0aW9uO1xuICBjb25zdCBkb21TZWxlY3Rpb24gPSBnZXRET01TZWxlY3Rpb24oZWRpdG9yLl93aW5kb3cpO1xuICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24obGFzdFNlbGVjdGlvbikgfHwgbGFzdFNlbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuICRpbnRlcm5hbENyZWF0ZVJhbmdlU2VsZWN0aW9uKGxhc3RTZWxlY3Rpb24sIGRvbVNlbGVjdGlvbiwgZWRpdG9yLCBudWxsKTtcbiAgfVxuICByZXR1cm4gbGFzdFNlbGVjdGlvbi5jbG9uZSgpO1xufVxuZnVuY3Rpb24gJGNyZWF0ZVJhbmdlU2VsZWN0aW9uRnJvbURvbShkb21TZWxlY3Rpb24sIGVkaXRvcikge1xuICByZXR1cm4gJGludGVybmFsQ3JlYXRlUmFuZ2VTZWxlY3Rpb24obnVsbCwgZG9tU2VsZWN0aW9uLCBlZGl0b3IsIG51bGwpO1xufVxuZnVuY3Rpb24gJGludGVybmFsQ3JlYXRlUmFuZ2VTZWxlY3Rpb24obGFzdFNlbGVjdGlvbiwgZG9tU2VsZWN0aW9uLCBlZGl0b3IsIGV2ZW50KSB7XG4gIGNvbnN0IHdpbmRvd09iaiA9IGVkaXRvci5fd2luZG93O1xuICBpZiAod2luZG93T2JqID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLy8gV2hlbiB3ZSBjcmVhdGUgYSBzZWxlY3Rpb24sIHdlIHRyeSB0byB1c2UgdGhlIHByZXZpb3VzXG4gIC8vIHNlbGVjdGlvbiB3aGVyZSBwb3NzaWJsZSwgdW5sZXNzIGFuIGFjdHVhbCB1c2VyIHNlbGVjdGlvblxuICAvLyBjaGFuZ2UgaGFzIG9jY3VycmVkLiBXaGVuIHdlIGRvIG5lZWQgdG8gY3JlYXRlIGEgbmV3IHNlbGVjdGlvblxuICAvLyB3ZSB2YWxpZGF0ZSB3ZSBjYW4gaGF2ZSB0ZXh0IG5vZGVzIGZvciBib3RoIGFuY2hvciBhbmQgZm9jdXNcbiAgLy8gbm9kZXMuIElmIHRoYXQgaG9sZHMgdHJ1ZSwgd2UgdGhlbiByZXR1cm4gdGhhdCBzZWxlY3Rpb25cbiAgLy8gYXMgYSBtdXRhYmxlIG9iamVjdCB0aGF0IHdlIHVzZSBmb3IgdGhlIGVkaXRvciBzdGF0ZSBmb3IgdGhpc1xuICAvLyB1cGRhdGUgY3ljbGUuIElmIGEgc2VsZWN0aW9uIGdldHMgY2hhbmdlZCwgYW5kIHJlcXVpcmVzIGFcbiAgLy8gdXBkYXRlIHRvIG5hdGl2ZSBET00gc2VsZWN0aW9uLCBpdCBnZXRzIG1hcmtlZCBhcyBcImRpcnR5XCIuXG4gIC8vIElmIHRoZSBzZWxlY3Rpb24gY2hhbmdlcywgYnV0IG1hdGNoZXMgd2l0aCB0aGUgZXhpc3RpbmdcbiAgLy8gRE9NIHNlbGVjdGlvbiwgdGhlbiB3ZSBvbmx5IG5lZWQgdG8gc3luYyBpdC4gT3RoZXJ3aXNlLFxuICAvLyB3ZSBnZW5lcmFsbHkgYmFpbCBvdXQgb2YgZG9pbmcgYW4gdXBkYXRlIHRvIHNlbGVjdGlvbiBkdXJpbmdcbiAgLy8gcmVjb25jaWxpYXRpb24gdW5sZXNzIHRoZXJlIGFyZSBkaXJ0eSBub2RlcyB0aGF0IG5lZWRcbiAgLy8gcmVjb25jaWxpbmcuXG5cbiAgY29uc3Qgd2luZG93RXZlbnQgPSBldmVudCB8fCB3aW5kb3dPYmouZXZlbnQ7XG4gIGNvbnN0IGV2ZW50VHlwZSA9IHdpbmRvd0V2ZW50ID8gd2luZG93RXZlbnQudHlwZSA6IHVuZGVmaW5lZDtcbiAgY29uc3QgaXNTZWxlY3Rpb25DaGFuZ2UgPSBldmVudFR5cGUgPT09ICdzZWxlY3Rpb25jaGFuZ2UnO1xuICBjb25zdCB1c2VET01TZWxlY3Rpb24gPSAhZ2V0SXNQcm9jZXNzaW5nTXV0YXRpb25zKCkgJiYgKGlzU2VsZWN0aW9uQ2hhbmdlIHx8IGV2ZW50VHlwZSA9PT0gJ2JlZm9yZWlucHV0JyB8fCBldmVudFR5cGUgPT09ICdjb21wb3NpdGlvbnN0YXJ0JyB8fCBldmVudFR5cGUgPT09ICdjb21wb3NpdGlvbmVuZCcgfHwgZXZlbnRUeXBlID09PSAnY2xpY2snICYmIHdpbmRvd0V2ZW50ICYmIHdpbmRvd0V2ZW50LmRldGFpbCA9PT0gMyB8fCBldmVudFR5cGUgPT09ICdkcm9wJyB8fCBldmVudFR5cGUgPT09IHVuZGVmaW5lZCk7XG4gIGxldCBhbmNob3JET00sIGZvY3VzRE9NLCBhbmNob3JPZmZzZXQsIGZvY3VzT2Zmc2V0O1xuICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKGxhc3RTZWxlY3Rpb24pIHx8IHVzZURPTVNlbGVjdGlvbikge1xuICAgIGlmIChkb21TZWxlY3Rpb24gPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhbmNob3JET00gPSBkb21TZWxlY3Rpb24uYW5jaG9yTm9kZTtcbiAgICBmb2N1c0RPTSA9IGRvbVNlbGVjdGlvbi5mb2N1c05vZGU7XG4gICAgYW5jaG9yT2Zmc2V0ID0gZG9tU2VsZWN0aW9uLmFuY2hvck9mZnNldDtcbiAgICBmb2N1c09mZnNldCA9IGRvbVNlbGVjdGlvbi5mb2N1c09mZnNldDtcbiAgICBpZiAoaXNTZWxlY3Rpb25DaGFuZ2UgJiYgJGlzUmFuZ2VTZWxlY3Rpb24obGFzdFNlbGVjdGlvbikgJiYgIWlzU2VsZWN0aW9uV2l0aGluRWRpdG9yKGVkaXRvciwgYW5jaG9yRE9NLCBmb2N1c0RPTSkpIHtcbiAgICAgIHJldHVybiBsYXN0U2VsZWN0aW9uLmNsb25lKCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBsYXN0U2VsZWN0aW9uLmNsb25lKCk7XG4gIH1cbiAgLy8gTGV0J3MgcmVzb2x2ZSB0aGUgdGV4dCBub2RlcyBmcm9tIHRoZSBvZmZzZXRzIGFuZCBET00gbm9kZXMgd2UgaGF2ZSBmcm9tXG4gIC8vIG5hdGl2ZSBzZWxlY3Rpb24uXG4gIGNvbnN0IHJlc29sdmVkU2VsZWN0aW9uUG9pbnRzID0gJGludGVybmFsUmVzb2x2ZVNlbGVjdGlvblBvaW50cyhhbmNob3JET00sIGFuY2hvck9mZnNldCwgZm9jdXNET00sIGZvY3VzT2Zmc2V0LCBlZGl0b3IsIGxhc3RTZWxlY3Rpb24pO1xuICBpZiAocmVzb2x2ZWRTZWxlY3Rpb25Qb2ludHMgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBbcmVzb2x2ZWRBbmNob3JQb2ludCwgcmVzb2x2ZWRGb2N1c1BvaW50XSA9IHJlc29sdmVkU2VsZWN0aW9uUG9pbnRzO1xuICByZXR1cm4gbmV3IFJhbmdlU2VsZWN0aW9uKHJlc29sdmVkQW5jaG9yUG9pbnQsIHJlc29sdmVkRm9jdXNQb2ludCwgISRpc1JhbmdlU2VsZWN0aW9uKGxhc3RTZWxlY3Rpb24pID8gMCA6IGxhc3RTZWxlY3Rpb24uZm9ybWF0LCAhJGlzUmFuZ2VTZWxlY3Rpb24obGFzdFNlbGVjdGlvbikgPyAnJyA6IGxhc3RTZWxlY3Rpb24uc3R5bGUpO1xufVxuZnVuY3Rpb24gJHZhbGlkYXRlUG9pbnQoZWRpdG9yLCBuYW1lLCBwb2ludCkge1xuICBjb25zdCBub2RlID0gJGdldE5vZGVCeUtleShwb2ludC5rZXkpO1xuICBpZiAoIShub2RlICE9PSB1bmRlZmluZWQpKSB7XG4gICAgdGhyb3cgRXJyb3IoYCR2YWxpZGF0ZVBvaW50OiAke25hbWV9IGtleSAke3BvaW50LmtleX0gbm90IGZvdW5kIGluIGN1cnJlbnQgZWRpdG9yU3RhdGVgKTtcbiAgfVxuICBpZiAocG9pbnQudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgaWYgKCEkaXNUZXh0Tm9kZShub2RlKSkge1xuICAgICAgdGhyb3cgRXJyb3IoYCR2YWxpZGF0ZVBvaW50OiAke25hbWV9IGtleSAke3BvaW50LmtleX0gaXMgbm90IGEgVGV4dE5vZGVgKTtcbiAgICB9XG4gICAgY29uc3Qgc2l6ZSA9IG5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCk7XG4gICAgaWYgKCEocG9pbnQub2Zmc2V0IDw9IHNpemUpKSB7XG4gICAgICB0aHJvdyBFcnJvcihgJHZhbGlkYXRlUG9pbnQ6ICR7bmFtZX0gcG9pbnQub2Zmc2V0ID4gbm9kZS5nZXRUZXh0Q29udGVudFNpemUoKSAoJHtTdHJpbmcocG9pbnQub2Zmc2V0KX0gPiAke1N0cmluZyhzaXplKX0pYCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICghJGlzRWxlbWVudE5vZGUobm9kZSkpIHtcbiAgICAgIHRocm93IEVycm9yKGAkdmFsaWRhdGVQb2ludDogJHtuYW1lfSBrZXkgJHtwb2ludC5rZXl9IGlzIG5vdCBhbiBFbGVtZW50Tm9kZWApO1xuICAgIH1cbiAgICBjb25zdCBzaXplID0gbm9kZS5nZXRDaGlsZHJlblNpemUoKTtcbiAgICBpZiAoIShwb2ludC5vZmZzZXQgPD0gc2l6ZSkpIHtcbiAgICAgIHRocm93IEVycm9yKGAkdmFsaWRhdGVQb2ludDogJHtuYW1lfSBwb2ludC5vZmZzZXQgPiBub2RlLmdldENoaWxkcmVuU2l6ZSgpICgke1N0cmluZyhwb2ludC5vZmZzZXQpfSA+ICR7U3RyaW5nKHNpemUpfSlgKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uICRnZXRTZWxlY3Rpb24oKSB7XG4gIGNvbnN0IGVkaXRvclN0YXRlID0gZ2V0QWN0aXZlRWRpdG9yU3RhdGUoKTtcbiAgcmV0dXJuIGVkaXRvclN0YXRlLl9zZWxlY3Rpb247XG59XG5mdW5jdGlvbiAkZ2V0UHJldmlvdXNTZWxlY3Rpb24oKSB7XG4gIGNvbnN0IGVkaXRvciA9IGdldEFjdGl2ZUVkaXRvcigpO1xuICByZXR1cm4gZWRpdG9yLl9lZGl0b3JTdGF0ZS5fc2VsZWN0aW9uO1xufVxuZnVuY3Rpb24gJHVwZGF0ZUVsZW1lbnRTZWxlY3Rpb25PbkNyZWF0ZURlbGV0ZU5vZGUoc2VsZWN0aW9uLCBwYXJlbnROb2RlLCBub2RlT2Zmc2V0LCB0aW1lcyA9IDEpIHtcbiAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgY29uc3QgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXM7XG4gIGNvbnN0IGFuY2hvck5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICBjb25zdCBmb2N1c05vZGUgPSBmb2N1cy5nZXROb2RlKCk7XG4gIGlmICghcGFyZW50Tm9kZS5pcyhhbmNob3JOb2RlKSAmJiAhcGFyZW50Tm9kZS5pcyhmb2N1c05vZGUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHBhcmVudEtleSA9IHBhcmVudE5vZGUuX19rZXk7XG4gIC8vIFNpbmdsZSBub2RlLiBXZSBzaGlmdCBzZWxlY3Rpb24gYnV0IG5ldmVyIHJlZGltZW5zaW9uIGl0XG4gIGlmIChzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSkge1xuICAgIGNvbnN0IHNlbGVjdGlvbk9mZnNldCA9IGFuY2hvci5vZmZzZXQ7XG4gICAgaWYgKG5vZGVPZmZzZXQgPD0gc2VsZWN0aW9uT2Zmc2V0ICYmIHRpbWVzID4gMCB8fCBub2RlT2Zmc2V0IDwgc2VsZWN0aW9uT2Zmc2V0ICYmIHRpbWVzIDwgMCkge1xuICAgICAgY29uc3QgbmV3U2VsZWN0aW9uT2Zmc2V0ID0gTWF0aC5tYXgoMCwgc2VsZWN0aW9uT2Zmc2V0ICsgdGltZXMpO1xuICAgICAgYW5jaG9yLnNldChwYXJlbnRLZXksIG5ld1NlbGVjdGlvbk9mZnNldCwgJ2VsZW1lbnQnKTtcbiAgICAgIGZvY3VzLnNldChwYXJlbnRLZXksIG5ld1NlbGVjdGlvbk9mZnNldCwgJ2VsZW1lbnQnKTtcbiAgICAgIC8vIFRoZSBuZXcgc2VsZWN0aW9uIG1pZ2h0IHBvaW50IHRvIHRleHQgbm9kZXMsIHRyeSB0byByZXNvbHZlIHRoZW1cbiAgICAgICR1cGRhdGVTZWxlY3Rpb25SZXNvbHZlVGV4dE5vZGVzKHNlbGVjdGlvbik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIE11bHRpcGxlIG5vZGVzIHNlbGVjdGVkLiBXZSBzaGlmdCBvciByZWRpbWVuc2lvbiBzZWxlY3Rpb25cbiAgICBjb25zdCBpc0JhY2t3YXJkID0gc2VsZWN0aW9uLmlzQmFja3dhcmQoKTtcbiAgICBjb25zdCBmaXJzdFBvaW50ID0gaXNCYWNrd2FyZCA/IGZvY3VzIDogYW5jaG9yO1xuICAgIGNvbnN0IGZpcnN0UG9pbnROb2RlID0gZmlyc3RQb2ludC5nZXROb2RlKCk7XG4gICAgY29uc3QgbGFzdFBvaW50ID0gaXNCYWNrd2FyZCA/IGFuY2hvciA6IGZvY3VzO1xuICAgIGNvbnN0IGxhc3RQb2ludE5vZGUgPSBsYXN0UG9pbnQuZ2V0Tm9kZSgpO1xuICAgIGlmIChwYXJlbnROb2RlLmlzKGZpcnN0UG9pbnROb2RlKSkge1xuICAgICAgY29uc3QgZmlyc3RQb2ludE9mZnNldCA9IGZpcnN0UG9pbnQub2Zmc2V0O1xuICAgICAgaWYgKG5vZGVPZmZzZXQgPD0gZmlyc3RQb2ludE9mZnNldCAmJiB0aW1lcyA+IDAgfHwgbm9kZU9mZnNldCA8IGZpcnN0UG9pbnRPZmZzZXQgJiYgdGltZXMgPCAwKSB7XG4gICAgICAgIGZpcnN0UG9pbnQuc2V0KHBhcmVudEtleSwgTWF0aC5tYXgoMCwgZmlyc3RQb2ludE9mZnNldCArIHRpbWVzKSwgJ2VsZW1lbnQnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhcmVudE5vZGUuaXMobGFzdFBvaW50Tm9kZSkpIHtcbiAgICAgIGNvbnN0IGxhc3RQb2ludE9mZnNldCA9IGxhc3RQb2ludC5vZmZzZXQ7XG4gICAgICBpZiAobm9kZU9mZnNldCA8PSBsYXN0UG9pbnRPZmZzZXQgJiYgdGltZXMgPiAwIHx8IG5vZGVPZmZzZXQgPCBsYXN0UG9pbnRPZmZzZXQgJiYgdGltZXMgPCAwKSB7XG4gICAgICAgIGxhc3RQb2ludC5zZXQocGFyZW50S2V5LCBNYXRoLm1heCgwLCBsYXN0UG9pbnRPZmZzZXQgKyB0aW1lcyksICdlbGVtZW50Jyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIFRoZSBuZXcgc2VsZWN0aW9uIG1pZ2h0IHBvaW50IHRvIHRleHQgbm9kZXMsIHRyeSB0byByZXNvbHZlIHRoZW1cbiAgJHVwZGF0ZVNlbGVjdGlvblJlc29sdmVUZXh0Tm9kZXMoc2VsZWN0aW9uKTtcbn1cbmZ1bmN0aW9uICR1cGRhdGVTZWxlY3Rpb25SZXNvbHZlVGV4dE5vZGVzKHNlbGVjdGlvbikge1xuICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICBjb25zdCBhbmNob3JPZmZzZXQgPSBhbmNob3Iub2Zmc2V0O1xuICBjb25zdCBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cztcbiAgY29uc3QgZm9jdXNPZmZzZXQgPSBmb2N1cy5vZmZzZXQ7XG4gIGNvbnN0IGFuY2hvck5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICBjb25zdCBmb2N1c05vZGUgPSBmb2N1cy5nZXROb2RlKCk7XG4gIGlmIChzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSkge1xuICAgIGlmICghJGlzRWxlbWVudE5vZGUoYW5jaG9yTm9kZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2hpbGRTaXplID0gYW5jaG9yTm9kZS5nZXRDaGlsZHJlblNpemUoKTtcbiAgICBjb25zdCBhbmNob3JPZmZzZXRBdEVuZCA9IGFuY2hvck9mZnNldCA+PSBjaGlsZFNpemU7XG4gICAgY29uc3QgY2hpbGQgPSBhbmNob3JPZmZzZXRBdEVuZCA/IGFuY2hvck5vZGUuZ2V0Q2hpbGRBdEluZGV4KGNoaWxkU2l6ZSAtIDEpIDogYW5jaG9yTm9kZS5nZXRDaGlsZEF0SW5kZXgoYW5jaG9yT2Zmc2V0KTtcbiAgICBpZiAoJGlzVGV4dE5vZGUoY2hpbGQpKSB7XG4gICAgICBsZXQgbmV3T2Zmc2V0ID0gMDtcbiAgICAgIGlmIChhbmNob3JPZmZzZXRBdEVuZCkge1xuICAgICAgICBuZXdPZmZzZXQgPSBjaGlsZC5nZXRUZXh0Q29udGVudFNpemUoKTtcbiAgICAgIH1cbiAgICAgIGFuY2hvci5zZXQoY2hpbGQuX19rZXksIG5ld09mZnNldCwgJ3RleHQnKTtcbiAgICAgIGZvY3VzLnNldChjaGlsZC5fX2tleSwgbmV3T2Zmc2V0LCAndGV4dCcpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCRpc0VsZW1lbnROb2RlKGFuY2hvck5vZGUpKSB7XG4gICAgY29uc3QgY2hpbGRTaXplID0gYW5jaG9yTm9kZS5nZXRDaGlsZHJlblNpemUoKTtcbiAgICBjb25zdCBhbmNob3JPZmZzZXRBdEVuZCA9IGFuY2hvck9mZnNldCA+PSBjaGlsZFNpemU7XG4gICAgY29uc3QgY2hpbGQgPSBhbmNob3JPZmZzZXRBdEVuZCA/IGFuY2hvck5vZGUuZ2V0Q2hpbGRBdEluZGV4KGNoaWxkU2l6ZSAtIDEpIDogYW5jaG9yTm9kZS5nZXRDaGlsZEF0SW5kZXgoYW5jaG9yT2Zmc2V0KTtcbiAgICBpZiAoJGlzVGV4dE5vZGUoY2hpbGQpKSB7XG4gICAgICBsZXQgbmV3T2Zmc2V0ID0gMDtcbiAgICAgIGlmIChhbmNob3JPZmZzZXRBdEVuZCkge1xuICAgICAgICBuZXdPZmZzZXQgPSBjaGlsZC5nZXRUZXh0Q29udGVudFNpemUoKTtcbiAgICAgIH1cbiAgICAgIGFuY2hvci5zZXQoY2hpbGQuX19rZXksIG5ld09mZnNldCwgJ3RleHQnKTtcbiAgICB9XG4gIH1cbiAgaWYgKCRpc0VsZW1lbnROb2RlKGZvY3VzTm9kZSkpIHtcbiAgICBjb25zdCBjaGlsZFNpemUgPSBmb2N1c05vZGUuZ2V0Q2hpbGRyZW5TaXplKCk7XG4gICAgY29uc3QgZm9jdXNPZmZzZXRBdEVuZCA9IGZvY3VzT2Zmc2V0ID49IGNoaWxkU2l6ZTtcbiAgICBjb25zdCBjaGlsZCA9IGZvY3VzT2Zmc2V0QXRFbmQgPyBmb2N1c05vZGUuZ2V0Q2hpbGRBdEluZGV4KGNoaWxkU2l6ZSAtIDEpIDogZm9jdXNOb2RlLmdldENoaWxkQXRJbmRleChmb2N1c09mZnNldCk7XG4gICAgaWYgKCRpc1RleHROb2RlKGNoaWxkKSkge1xuICAgICAgbGV0IG5ld09mZnNldCA9IDA7XG4gICAgICBpZiAoZm9jdXNPZmZzZXRBdEVuZCkge1xuICAgICAgICBuZXdPZmZzZXQgPSBjaGlsZC5nZXRUZXh0Q29udGVudFNpemUoKTtcbiAgICAgIH1cbiAgICAgIGZvY3VzLnNldChjaGlsZC5fX2tleSwgbmV3T2Zmc2V0LCAndGV4dCcpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYXBwbHlTZWxlY3Rpb25UcmFuc2Zvcm1zKG5leHRFZGl0b3JTdGF0ZSwgZWRpdG9yKSB7XG4gIGNvbnN0IHByZXZFZGl0b3JTdGF0ZSA9IGVkaXRvci5nZXRFZGl0b3JTdGF0ZSgpO1xuICBjb25zdCBwcmV2U2VsZWN0aW9uID0gcHJldkVkaXRvclN0YXRlLl9zZWxlY3Rpb247XG4gIGNvbnN0IG5leHRTZWxlY3Rpb24gPSBuZXh0RWRpdG9yU3RhdGUuX3NlbGVjdGlvbjtcbiAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKG5leHRTZWxlY3Rpb24pKSB7XG4gICAgY29uc3QgYW5jaG9yID0gbmV4dFNlbGVjdGlvbi5hbmNob3I7XG4gICAgY29uc3QgZm9jdXMgPSBuZXh0U2VsZWN0aW9uLmZvY3VzO1xuICAgIGxldCBhbmNob3JOb2RlO1xuICAgIGlmIChhbmNob3IudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgICAgIGFuY2hvck5vZGUuc2VsZWN0aW9uVHJhbnNmb3JtKHByZXZTZWxlY3Rpb24sIG5leHRTZWxlY3Rpb24pO1xuICAgIH1cbiAgICBpZiAoZm9jdXMudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICBjb25zdCBmb2N1c05vZGUgPSBmb2N1cy5nZXROb2RlKCk7XG4gICAgICBpZiAoYW5jaG9yTm9kZSAhPT0gZm9jdXNOb2RlKSB7XG4gICAgICAgIGZvY3VzTm9kZS5zZWxlY3Rpb25UcmFuc2Zvcm0ocHJldlNlbGVjdGlvbiwgbmV4dFNlbGVjdGlvbik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtb3ZlU2VsZWN0aW9uUG9pbnRUb1NpYmxpbmcocG9pbnQsIG5vZGUsIHBhcmVudCwgcHJldlNpYmxpbmcsIG5leHRTaWJsaW5nKSB7XG4gIGxldCBzaWJsaW5nS2V5ID0gbnVsbDtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIGxldCB0eXBlID0gbnVsbDtcbiAgaWYgKHByZXZTaWJsaW5nICE9PSBudWxsKSB7XG4gICAgc2libGluZ0tleSA9IHByZXZTaWJsaW5nLl9fa2V5O1xuICAgIGlmICgkaXNUZXh0Tm9kZShwcmV2U2libGluZykpIHtcbiAgICAgIG9mZnNldCA9IHByZXZTaWJsaW5nLmdldFRleHRDb250ZW50U2l6ZSgpO1xuICAgICAgdHlwZSA9ICd0ZXh0JztcbiAgICB9IGVsc2UgaWYgKCRpc0VsZW1lbnROb2RlKHByZXZTaWJsaW5nKSkge1xuICAgICAgb2Zmc2V0ID0gcHJldlNpYmxpbmcuZ2V0Q2hpbGRyZW5TaXplKCk7XG4gICAgICB0eXBlID0gJ2VsZW1lbnQnO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAobmV4dFNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgIHNpYmxpbmdLZXkgPSBuZXh0U2libGluZy5fX2tleTtcbiAgICAgIGlmICgkaXNUZXh0Tm9kZShuZXh0U2libGluZykpIHtcbiAgICAgICAgdHlwZSA9ICd0ZXh0JztcbiAgICAgIH0gZWxzZSBpZiAoJGlzRWxlbWVudE5vZGUobmV4dFNpYmxpbmcpKSB7XG4gICAgICAgIHR5cGUgPSAnZWxlbWVudCc7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChzaWJsaW5nS2V5ICE9PSBudWxsICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBwb2ludC5zZXQoc2libGluZ0tleSwgb2Zmc2V0LCB0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICBvZmZzZXQgPSBub2RlLmdldEluZGV4V2l0aGluUGFyZW50KCk7XG4gICAgaWYgKG9mZnNldCA9PT0gLTEpIHtcbiAgICAgIC8vIE1vdmUgc2VsZWN0aW9uIHRvIGVuZCBvZiBwYXJlbnRcbiAgICAgIG9mZnNldCA9IHBhcmVudC5nZXRDaGlsZHJlblNpemUoKTtcbiAgICB9XG4gICAgcG9pbnQuc2V0KHBhcmVudC5fX2tleSwgb2Zmc2V0LCAnZWxlbWVudCcpO1xuICB9XG59XG5mdW5jdGlvbiBhZGp1c3RQb2ludE9mZnNldEZvck1lcmdlZFNpYmxpbmcocG9pbnQsIGlzQmVmb3JlLCBrZXksIHRhcmdldCwgdGV4dExlbmd0aCkge1xuICBpZiAocG9pbnQudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgcG9pbnQua2V5ID0ga2V5O1xuICAgIGlmICghaXNCZWZvcmUpIHtcbiAgICAgIHBvaW50Lm9mZnNldCArPSB0ZXh0TGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIGlmIChwb2ludC5vZmZzZXQgPiB0YXJnZXQuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKSkge1xuICAgIHBvaW50Lm9mZnNldCAtPSAxO1xuICB9XG59XG5mdW5jdGlvbiB1cGRhdGVET01TZWxlY3Rpb24ocHJldlNlbGVjdGlvbiwgbmV4dFNlbGVjdGlvbiwgZWRpdG9yLCBkb21TZWxlY3Rpb24sIHRhZ3MsIHJvb3RFbGVtZW50LCBub2RlQ291bnQpIHtcbiAgY29uc3QgYW5jaG9yRE9NTm9kZSA9IGRvbVNlbGVjdGlvbi5hbmNob3JOb2RlO1xuICBjb25zdCBmb2N1c0RPTU5vZGUgPSBkb21TZWxlY3Rpb24uZm9jdXNOb2RlO1xuICBjb25zdCBhbmNob3JPZmZzZXQgPSBkb21TZWxlY3Rpb24uYW5jaG9yT2Zmc2V0O1xuICBjb25zdCBmb2N1c09mZnNldCA9IGRvbVNlbGVjdGlvbi5mb2N1c09mZnNldDtcbiAgY29uc3QgYWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cbiAgLy8gVE9ETzogbWFrZSB0aGlzIG5vdCBoYXJkLWNvZGVkLCBhbmQgYWRkIGFub3RoZXIgY29uZmlnIG9wdGlvblxuICAvLyB0aGF0IG1ha2VzIHRoaXMgY29uZmlndXJhYmxlLlxuICBpZiAodGFncy5oYXMoJ2NvbGxhYm9yYXRpb24nKSAmJiBhY3RpdmVFbGVtZW50ICE9PSByb290RWxlbWVudCB8fCBhY3RpdmVFbGVtZW50ICE9PSBudWxsICYmIGlzU2VsZWN0aW9uQ2FwdHVyZWRJbkRlY29yYXRvcklucHV0KGFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24obmV4dFNlbGVjdGlvbikpIHtcbiAgICAvLyBXZSBkb24ndCByZW1vdmUgc2VsZWN0aW9uIGlmIHRoZSBwcmV2U2VsZWN0aW9uIGlzIG51bGwgYmVjYXVzZVxuICAgIC8vIG9mIGVkaXRvci5zZXRSb290RWxlbWVudCgpLiBJZiB0aGlzIG9jY3VycyBvbiBpbml0IHdoZW4gdGhlXG4gICAgLy8gZWRpdG9yIGlzIGFscmVhZHkgZm9jdXNlZCwgdGhlbiB0aGlzIGNhbiBjYXVzZSB0aGUgZWRpdG9yIHRvXG4gICAgLy8gbG9zZSBmb2N1cy5cbiAgICBpZiAocHJldlNlbGVjdGlvbiAhPT0gbnVsbCAmJiBpc1NlbGVjdGlvbldpdGhpbkVkaXRvcihlZGl0b3IsIGFuY2hvckRPTU5vZGUsIGZvY3VzRE9NTm9kZSkpIHtcbiAgICAgIGRvbVNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGFuY2hvciA9IG5leHRTZWxlY3Rpb24uYW5jaG9yO1xuICBjb25zdCBmb2N1cyA9IG5leHRTZWxlY3Rpb24uZm9jdXM7XG4gIGNvbnN0IGFuY2hvcktleSA9IGFuY2hvci5rZXk7XG4gIGNvbnN0IGZvY3VzS2V5ID0gZm9jdXMua2V5O1xuICBjb25zdCBhbmNob3JET00gPSBnZXRFbGVtZW50QnlLZXlPclRocm93KGVkaXRvciwgYW5jaG9yS2V5KTtcbiAgY29uc3QgZm9jdXNET00gPSBnZXRFbGVtZW50QnlLZXlPclRocm93KGVkaXRvciwgZm9jdXNLZXkpO1xuICBjb25zdCBuZXh0QW5jaG9yT2Zmc2V0ID0gYW5jaG9yLm9mZnNldDtcbiAgY29uc3QgbmV4dEZvY3VzT2Zmc2V0ID0gZm9jdXMub2Zmc2V0O1xuICBjb25zdCBuZXh0Rm9ybWF0ID0gbmV4dFNlbGVjdGlvbi5mb3JtYXQ7XG4gIGNvbnN0IG5leHRTdHlsZSA9IG5leHRTZWxlY3Rpb24uc3R5bGU7XG4gIGNvbnN0IGlzQ29sbGFwc2VkID0gbmV4dFNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpO1xuICBsZXQgbmV4dEFuY2hvck5vZGUgPSBhbmNob3JET007XG4gIGxldCBuZXh0Rm9jdXNOb2RlID0gZm9jdXNET007XG4gIGxldCBhbmNob3JGb3JtYXRPclN0eWxlQ2hhbmdlZCA9IGZhbHNlO1xuICBpZiAoYW5jaG9yLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgIG5leHRBbmNob3JOb2RlID0gZ2V0RE9NVGV4dE5vZGUoYW5jaG9yRE9NKTtcbiAgICBjb25zdCBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgICBhbmNob3JGb3JtYXRPclN0eWxlQ2hhbmdlZCA9IGFuY2hvck5vZGUuZ2V0Rm9ybWF0KCkgIT09IG5leHRGb3JtYXQgfHwgYW5jaG9yTm9kZS5nZXRTdHlsZSgpICE9PSBuZXh0U3R5bGU7XG4gIH0gZWxzZSBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24ocHJldlNlbGVjdGlvbikgJiYgcHJldlNlbGVjdGlvbi5hbmNob3IudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgYW5jaG9yRm9ybWF0T3JTdHlsZUNoYW5nZWQgPSB0cnVlO1xuICB9XG4gIGlmIChmb2N1cy50eXBlID09PSAndGV4dCcpIHtcbiAgICBuZXh0Rm9jdXNOb2RlID0gZ2V0RE9NVGV4dE5vZGUoZm9jdXNET00pO1xuICB9XG5cbiAgLy8gSWYgd2UgY2FuJ3QgZ2V0IGFuIHVuZGVybHlpbmcgdGV4dCBub2RlIGZvciBzZWxlY3Rpb24sIHRoZW5cbiAgLy8gd2Ugc2hvdWxkIGF2b2lkIHNldHRpbmcgc2VsZWN0aW9uIHRvIHNvbWV0aGluZyBpbmNvcnJlY3QuXG4gIGlmIChuZXh0QW5jaG9yTm9kZSA9PT0gbnVsbCB8fCBuZXh0Rm9jdXNOb2RlID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChpc0NvbGxhcHNlZCAmJiAocHJldlNlbGVjdGlvbiA9PT0gbnVsbCB8fCBhbmNob3JGb3JtYXRPclN0eWxlQ2hhbmdlZCB8fCAkaXNSYW5nZVNlbGVjdGlvbihwcmV2U2VsZWN0aW9uKSAmJiAocHJldlNlbGVjdGlvbi5mb3JtYXQgIT09IG5leHRGb3JtYXQgfHwgcHJldlNlbGVjdGlvbi5zdHlsZSAhPT0gbmV4dFN0eWxlKSkpIHtcbiAgICBtYXJrQ29sbGFwc2VkU2VsZWN0aW9uRm9ybWF0KG5leHRGb3JtYXQsIG5leHRTdHlsZSwgbmV4dEFuY2hvck9mZnNldCwgYW5jaG9yS2V5LCBwZXJmb3JtYW5jZS5ub3coKSk7XG4gIH1cblxuICAvLyBEaWZmIGFnYWluc3QgdGhlIG5hdGl2ZSBET00gc2VsZWN0aW9uIHRvIGVuc3VyZSB3ZSBkb24ndCBkb1xuICAvLyBhbiB1bm5lY2Vzc2FyeSBzZWxlY3Rpb24gdXBkYXRlLiBXZSBhbHNvIHNraXAgdGhpcyBjaGVjayBpZlxuICAvLyB3ZSdyZSBtb3Zpbmcgc2VsZWN0aW9uIHRvIHdpdGhpbiBhbiBlbGVtZW50LCBhcyB0aGlzIGNhblxuICAvLyBzb21ldGltZXMgYmUgcHJvYmxlbWF0aWMgYXJvdW5kIHNjcm9sbGluZy5cbiAgaWYgKGFuY2hvck9mZnNldCA9PT0gbmV4dEFuY2hvck9mZnNldCAmJiBmb2N1c09mZnNldCA9PT0gbmV4dEZvY3VzT2Zmc2V0ICYmIGFuY2hvckRPTU5vZGUgPT09IG5leHRBbmNob3JOb2RlICYmIGZvY3VzRE9NTm9kZSA9PT0gbmV4dEZvY3VzTm9kZSAmJlxuICAvLyBCYWRseSBpbnRlcnByZXRlZCByYW5nZSBzZWxlY3Rpb24gd2hlbiBjb2xsYXBzZWQgLSAjMTQ4MlxuICAhKGRvbVNlbGVjdGlvbi50eXBlID09PSAnUmFuZ2UnICYmIGlzQ29sbGFwc2VkKSkge1xuICAgIC8vIElmIHRoZSByb290IGVsZW1lbnQgZG9lcyBub3QgaGF2ZSBmb2N1cywgZW5zdXJlIGl0IGhhcyBmb2N1c1xuICAgIGlmIChhY3RpdmVFbGVtZW50ID09PSBudWxsIHx8ICFyb290RWxlbWVudC5jb250YWlucyhhY3RpdmVFbGVtZW50KSkge1xuICAgICAgcm9vdEVsZW1lbnQuZm9jdXMoe1xuICAgICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGFuY2hvci50eXBlICE9PSAnZWxlbWVudCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICAvLyBBcHBseSB0aGUgdXBkYXRlZCBzZWxlY3Rpb24gdG8gdGhlIERPTS4gTm90ZTogdGhpcyB3aWxsIHRyaWdnZXJcbiAgLy8gYSBcInNlbGVjdGlvbmNoYW5nZVwiIGV2ZW50LCBhbHRob3VnaCBpdCB3aWxsIGJlIGFzeW5jaHJvbm91cy5cbiAgdHJ5IHtcbiAgICBkb21TZWxlY3Rpb24uc2V0QmFzZUFuZEV4dGVudChuZXh0QW5jaG9yTm9kZSwgbmV4dEFuY2hvck9mZnNldCwgbmV4dEZvY3VzTm9kZSwgbmV4dEZvY3VzT2Zmc2V0KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvLyBJZiB3ZSBlbmNvdW50ZXIgYW4gZXJyb3IsIGNvbnRpbnVlLiBUaGlzIGNhbiBzb21ldGltZXNcbiAgICAvLyBvY2N1ciB3aXRoIEZGIGFuZCB0aGVyZSdzIG5vIGdvb2QgcmVhc29uIGFzIHRvIHdoeSBpdFxuICAgIC8vIHNob3VsZCBoYXBwZW4uXG4gICAge1xuICAgICAgY29uc29sZS53YXJuKGVycm9yKTtcbiAgICB9XG4gIH1cbiAgaWYgKCF0YWdzLmhhcygnc2tpcC1zY3JvbGwtaW50by12aWV3JykgJiYgbmV4dFNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpICYmIHJvb3RFbGVtZW50ICE9PSBudWxsICYmIHJvb3RFbGVtZW50ID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50KSB7XG4gICAgY29uc3Qgc2VsZWN0aW9uVGFyZ2V0ID0gJGlzUmFuZ2VTZWxlY3Rpb24obmV4dFNlbGVjdGlvbikgJiYgbmV4dFNlbGVjdGlvbi5hbmNob3IudHlwZSA9PT0gJ2VsZW1lbnQnID8gbmV4dEFuY2hvck5vZGUuY2hpbGROb2Rlc1tuZXh0QW5jaG9yT2Zmc2V0XSB8fCBudWxsIDogZG9tU2VsZWN0aW9uLnJhbmdlQ291bnQgPiAwID8gZG9tU2VsZWN0aW9uLmdldFJhbmdlQXQoMCkgOiBudWxsO1xuICAgIGlmIChzZWxlY3Rpb25UYXJnZXQgIT09IG51bGwpIHtcbiAgICAgIGxldCBzZWxlY3Rpb25SZWN0O1xuICAgICAgaWYgKHNlbGVjdGlvblRhcmdldCBpbnN0YW5jZW9mIFRleHQpIHtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgICByYW5nZS5zZWxlY3ROb2RlKHNlbGVjdGlvblRhcmdldCk7XG4gICAgICAgIHNlbGVjdGlvblJlY3QgPSByYW5nZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGVjdGlvblJlY3QgPSBzZWxlY3Rpb25UYXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB9XG4gICAgICBzY3JvbGxJbnRvVmlld0lmTmVlZGVkKGVkaXRvciwgc2VsZWN0aW9uUmVjdCwgcm9vdEVsZW1lbnQpO1xuICAgIH1cbiAgfVxuICBtYXJrU2VsZWN0aW9uQ2hhbmdlRnJvbURPTVVwZGF0ZSgpO1xufVxuZnVuY3Rpb24gJGluc2VydE5vZGVzKG5vZGVzKSB7XG4gIGxldCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCkgfHwgJGdldFByZXZpb3VzU2VsZWN0aW9uKCk7XG4gIGlmIChzZWxlY3Rpb24gPT09IG51bGwpIHtcbiAgICBzZWxlY3Rpb24gPSAkZ2V0Um9vdCgpLnNlbGVjdEVuZCgpO1xuICB9XG4gIHNlbGVjdGlvbi5pbnNlcnROb2Rlcyhub2Rlcyk7XG59XG5mdW5jdGlvbiAkZ2V0VGV4dENvbnRlbnQoKSB7XG4gIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgaWYgKHNlbGVjdGlvbiA9PT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICByZXR1cm4gc2VsZWN0aW9uLmdldFRleHRDb250ZW50KCk7XG59XG5mdW5jdGlvbiAkcmVtb3ZlVGV4dEFuZFNwbGl0QmxvY2soc2VsZWN0aW9uKSB7XG4gIGxldCBzZWxlY3Rpb25fID0gc2VsZWN0aW9uO1xuICBpZiAoIXNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpKSB7XG4gICAgc2VsZWN0aW9uXy5yZW1vdmVUZXh0KCk7XG4gIH1cbiAgLy8gQSBuZXcgc2VsZWN0aW9uIGNhbiBvcmlnaW5hdGUgYXMgYSByZXN1bHQgb2Ygbm9kZSByZXBsYWNlbWVudCwgaW4gd2hpY2ggY2FzZSBpcyByZWdpc3RlcmVkIHZpYVxuICAvLyAkc2V0U2VsZWN0aW9uXG4gIGNvbnN0IG5ld1NlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKG5ld1NlbGVjdGlvbikpIHtcbiAgICBzZWxlY3Rpb25fID0gbmV3U2VsZWN0aW9uO1xuICB9XG4gIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uXykpIHtcbiAgICB0aHJvdyBFcnJvcihgVW5leHBlY3RlZCBkaXJ0eSBzZWxlY3Rpb24gdG8gYmUgbnVsbGApO1xuICB9XG4gIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbl8uYW5jaG9yO1xuICBsZXQgbm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gIGxldCBvZmZzZXQgPSBhbmNob3Iub2Zmc2V0O1xuICB3aGlsZSAoIUlOVEVSTkFMXyRpc0Jsb2NrKG5vZGUpKSB7XG4gICAgW25vZGUsIG9mZnNldF0gPSAkc3BsaXROb2RlQXRQb2ludChub2RlLCBvZmZzZXQpO1xuICB9XG4gIHJldHVybiBvZmZzZXQ7XG59XG5mdW5jdGlvbiAkc3BsaXROb2RlQXRQb2ludChub2RlLCBvZmZzZXQpIHtcbiAgY29uc3QgcGFyZW50ID0gbm9kZS5nZXRQYXJlbnQoKTtcbiAgaWYgKCFwYXJlbnQpIHtcbiAgICBjb25zdCBwYXJhZ3JhcGggPSAkY3JlYXRlUGFyYWdyYXBoTm9kZSgpO1xuICAgICRnZXRSb290KCkuYXBwZW5kKHBhcmFncmFwaCk7XG4gICAgcGFyYWdyYXBoLnNlbGVjdCgpO1xuICAgIHJldHVybiBbJGdldFJvb3QoKSwgMF07XG4gIH1cbiAgaWYgKCRpc1RleHROb2RlKG5vZGUpKSB7XG4gICAgY29uc3Qgc3BsaXQgPSBub2RlLnNwbGl0VGV4dChvZmZzZXQpO1xuICAgIGlmIChzcGxpdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBbcGFyZW50LCBub2RlLmdldEluZGV4V2l0aGluUGFyZW50KCldO1xuICAgIH1cbiAgICBjb25zdCB4ID0gb2Zmc2V0ID09PSAwID8gMCA6IDE7XG4gICAgY29uc3QgaW5kZXggPSBzcGxpdFswXS5nZXRJbmRleFdpdGhpblBhcmVudCgpICsgeDtcbiAgICByZXR1cm4gW3BhcmVudCwgaW5kZXhdO1xuICB9XG4gIGlmICghJGlzRWxlbWVudE5vZGUobm9kZSkgfHwgb2Zmc2V0ID09PSAwKSB7XG4gICAgcmV0dXJuIFtwYXJlbnQsIG5vZGUuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKV07XG4gIH1cbiAgY29uc3QgZmlyc3RUb0FwcGVuZCA9IG5vZGUuZ2V0Q2hpbGRBdEluZGV4KG9mZnNldCk7XG4gIGlmIChmaXJzdFRvQXBwZW5kKSB7XG4gICAgY29uc3QgaW5zZXJ0UG9pbnQgPSBuZXcgUmFuZ2VTZWxlY3Rpb24oJGNyZWF0ZVBvaW50KG5vZGUuX19rZXksIG9mZnNldCwgJ2VsZW1lbnQnKSwgJGNyZWF0ZVBvaW50KG5vZGUuX19rZXksIG9mZnNldCwgJ2VsZW1lbnQnKSwgMCwgJycpO1xuICAgIGNvbnN0IG5ld0VsZW1lbnQgPSBub2RlLmluc2VydE5ld0FmdGVyKGluc2VydFBvaW50KTtcbiAgICBpZiAobmV3RWxlbWVudCkge1xuICAgICAgbmV3RWxlbWVudC5hcHBlbmQoZmlyc3RUb0FwcGVuZCwgLi4uZmlyc3RUb0FwcGVuZC5nZXROZXh0U2libGluZ3MoKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBbcGFyZW50LCBub2RlLmdldEluZGV4V2l0aGluUGFyZW50KCkgKyAxXTtcbn1cbmZ1bmN0aW9uICR3cmFwSW5saW5lTm9kZXMobm9kZXMpIHtcbiAgLy8gV2UgdGVtcG9yYXJpbHkgaW5zZXJ0IHRoZSB0b3BMZXZlbE5vZGVzIGludG8gYW4gYXJiaXRyYXJ5IEVsZW1lbnROb2RlLFxuICAvLyBzaW5jZSBpbnNlcnRBZnRlciBkb2VzIG5vdCB3b3JrIG9uIG5vZGVzIHRoYXQgaGF2ZSBubyBwYXJlbnQgKFRPLURPOiBmaXggdGhhdCkuXG4gIGNvbnN0IHZpcnR1YWxSb290ID0gJGNyZWF0ZVBhcmFncmFwaE5vZGUoKTtcbiAgbGV0IGN1cnJlbnRCbG9jayA9IG51bGw7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgY29uc3QgaXNMaW5lQnJlYWtOb2RlID0gJGlzTGluZUJyZWFrTm9kZShub2RlKTtcbiAgICBpZiAoaXNMaW5lQnJlYWtOb2RlIHx8ICRpc0RlY29yYXRvck5vZGUobm9kZSkgJiYgbm9kZS5pc0lubGluZSgpIHx8ICRpc0VsZW1lbnROb2RlKG5vZGUpICYmIG5vZGUuaXNJbmxpbmUoKSB8fCAkaXNUZXh0Tm9kZShub2RlKSB8fCBub2RlLmlzUGFyZW50UmVxdWlyZWQoKSkge1xuICAgICAgaWYgKGN1cnJlbnRCbG9jayA9PT0gbnVsbCkge1xuICAgICAgICBjdXJyZW50QmxvY2sgPSBub2RlLmNyZWF0ZVBhcmVudEVsZW1lbnROb2RlKCk7XG4gICAgICAgIHZpcnR1YWxSb290LmFwcGVuZChjdXJyZW50QmxvY2spO1xuICAgICAgICAvLyBJbiB0aGUgY2FzZSBvZiBMaW5lQnJlYWtOb2RlLCB3ZSBqdXN0IG5lZWQgdG9cbiAgICAgICAgLy8gYWRkIGFuIGVtcHR5IFBhcmFncmFwaE5vZGUgdG8gdGhlIHRvcExldmVsQmxvY2tzLlxuICAgICAgICBpZiAoaXNMaW5lQnJlYWtOb2RlKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50QmxvY2sgIT09IG51bGwpIHtcbiAgICAgICAgY3VycmVudEJsb2NrLmFwcGVuZChub2RlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmlydHVhbFJvb3QuYXBwZW5kKG5vZGUpO1xuICAgICAgY3VycmVudEJsb2NrID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZpcnR1YWxSb290O1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmxldCBhY3RpdmVFZGl0b3JTdGF0ZSA9IG51bGw7XG5sZXQgYWN0aXZlRWRpdG9yID0gbnVsbDtcbmxldCBpc1JlYWRPbmx5TW9kZSA9IGZhbHNlO1xubGV0IGlzQXR0ZW1wdGluZ1RvUmVjb3ZlckZyb21SZWNvbmNpbGVyRXJyb3IgPSBmYWxzZTtcbmxldCBpbmZpbml0ZVRyYW5zZm9ybUNvdW50ID0gMDtcbmNvbnN0IG9ic2VydmVyT3B0aW9ucyA9IHtcbiAgY2hhcmFjdGVyRGF0YTogdHJ1ZSxcbiAgY2hpbGRMaXN0OiB0cnVlLFxuICBzdWJ0cmVlOiB0cnVlXG59O1xuZnVuY3Rpb24gaXNDdXJyZW50bHlSZWFkT25seU1vZGUoKSB7XG4gIHJldHVybiBpc1JlYWRPbmx5TW9kZSB8fCBhY3RpdmVFZGl0b3JTdGF0ZSAhPT0gbnVsbCAmJiBhY3RpdmVFZGl0b3JTdGF0ZS5fcmVhZE9ubHk7XG59XG5mdW5jdGlvbiBlcnJvck9uUmVhZE9ubHkoKSB7XG4gIGlmIChpc1JlYWRPbmx5TW9kZSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGBDYW5ub3QgdXNlIG1ldGhvZCBpbiByZWFkLW9ubHkgbW9kZS5gKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGVycm9yT25JbmZpbml0ZVRyYW5zZm9ybXMoKSB7XG4gIGlmIChpbmZpbml0ZVRyYW5zZm9ybUNvdW50ID4gOTkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgT25lIG9yIG1vcmUgdHJhbnNmb3JtcyBhcmUgZW5kbGVzc2x5IHRyaWdnZXJpbmcgYWRkaXRpb25hbCB0cmFuc2Zvcm1zLiBNYXkgaGF2ZSBlbmNvdW50ZXJlZCBpbmZpbml0ZSByZWN1cnNpb24gY2F1c2VkIGJ5IHRyYW5zZm9ybXMgdGhhdCBoYXZlIHRoZWlyIHByZWNvbmRpdGlvbnMgdG9vIGxvc2UgYW5kL29yIGNvbmZsaWN0IHdpdGggZWFjaCBvdGhlci5gKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEFjdGl2ZUVkaXRvclN0YXRlKCkge1xuICBpZiAoYWN0aXZlRWRpdG9yU3RhdGUgPT09IG51bGwpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgVW5hYmxlIHRvIGZpbmQgYW4gYWN0aXZlIGVkaXRvciBzdGF0ZS4gU3RhdGUgaGVscGVycyBvciBub2RlIG1ldGhvZHMgY2FuIG9ubHkgYmUgdXNlZCBzeW5jaHJvbm91c2x5IGR1cmluZyB0aGUgY2FsbGJhY2sgb2YgZWRpdG9yLnVwZGF0ZSgpLCBlZGl0b3IucmVhZCgpLCBvciBlZGl0b3JTdGF0ZS5yZWFkKCkuJHtjb2xsZWN0QnVpbGRJbmZvcm1hdGlvbigpfWApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYWN0aXZlRWRpdG9yU3RhdGU7XG59XG5mdW5jdGlvbiBnZXRBY3RpdmVFZGl0b3IoKSB7XG4gIGlmIChhY3RpdmVFZGl0b3IgPT09IG51bGwpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgVW5hYmxlIHRvIGZpbmQgYW4gYWN0aXZlIGVkaXRvci4gVGhpcyBtZXRob2QgY2FuIG9ubHkgYmUgdXNlZCBzeW5jaHJvbm91c2x5IGR1cmluZyB0aGUgY2FsbGJhY2sgb2YgZWRpdG9yLnVwZGF0ZSgpIG9yIGVkaXRvci5yZWFkKCkuJHtjb2xsZWN0QnVpbGRJbmZvcm1hdGlvbigpfWApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYWN0aXZlRWRpdG9yO1xufVxuZnVuY3Rpb24gY29sbGVjdEJ1aWxkSW5mb3JtYXRpb24oKSB7XG4gIGxldCBjb21wYXRpYmxlRWRpdG9ycyA9IDA7XG4gIGNvbnN0IGluY29tcGF0aWJsZUVkaXRvcnMgPSBuZXcgU2V0KCk7XG4gIGNvbnN0IHRoaXNWZXJzaW9uID0gTGV4aWNhbEVkaXRvci52ZXJzaW9uO1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2YgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2NvbnRlbnRlZGl0YWJsZV0nKSkge1xuICAgICAgY29uc3QgZWRpdG9yID0gZ2V0RWRpdG9yUHJvcGVydHlGcm9tRE9NTm9kZShub2RlKTtcbiAgICAgIGlmIChpc0xleGljYWxFZGl0b3IoZWRpdG9yKSkge1xuICAgICAgICBjb21wYXRpYmxlRWRpdG9ycysrO1xuICAgICAgfSBlbHNlIGlmIChlZGl0b3IpIHtcbiAgICAgICAgbGV0IHZlcnNpb24gPSBTdHJpbmcoZWRpdG9yLmNvbnN0cnVjdG9yLnZlcnNpb24gfHwgJzwwLjE3LjEnKTtcbiAgICAgICAgaWYgKHZlcnNpb24gPT09IHRoaXNWZXJzaW9uKSB7XG4gICAgICAgICAgdmVyc2lvbiArPSAnIChzZXBhcmF0ZWx5IGJ1aWx0LCBsaWtlbHkgYSBidW5kbGVyIGNvbmZpZ3VyYXRpb24gaXNzdWUpJztcbiAgICAgICAgfVxuICAgICAgICBpbmNvbXBhdGlibGVFZGl0b3JzLmFkZCh2ZXJzaW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbGV0IG91dHB1dCA9IGAgRGV0ZWN0ZWQgb24gdGhlIHBhZ2U6ICR7Y29tcGF0aWJsZUVkaXRvcnN9IGNvbXBhdGlibGUgZWRpdG9yKHMpIHdpdGggdmVyc2lvbiAke3RoaXNWZXJzaW9ufWA7XG4gIGlmIChpbmNvbXBhdGlibGVFZGl0b3JzLnNpemUpIHtcbiAgICBvdXRwdXQgKz0gYCBhbmQgaW5jb21wYXRpYmxlIGVkaXRvcnMgd2l0aCB2ZXJzaW9ucyAke0FycmF5LmZyb20oaW5jb21wYXRpYmxlRWRpdG9ycykuam9pbignLCAnKX1gO1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59XG5mdW5jdGlvbiBpbnRlcm5hbEdldEFjdGl2ZUVkaXRvcigpIHtcbiAgcmV0dXJuIGFjdGl2ZUVkaXRvcjtcbn1cbmZ1bmN0aW9uIGludGVybmFsR2V0QWN0aXZlRWRpdG9yU3RhdGUoKSB7XG4gIHJldHVybiBhY3RpdmVFZGl0b3JTdGF0ZTtcbn1cbmZ1bmN0aW9uICRhcHBseVRyYW5zZm9ybXMoZWRpdG9yLCBub2RlLCB0cmFuc2Zvcm1zQ2FjaGUpIHtcbiAgY29uc3QgdHlwZSA9IG5vZGUuX190eXBlO1xuICBjb25zdCByZWdpc3RlcmVkTm9kZSA9IGdldFJlZ2lzdGVyZWROb2RlT3JUaHJvdyhlZGl0b3IsIHR5cGUpO1xuICBsZXQgdHJhbnNmb3Jtc0FyciA9IHRyYW5zZm9ybXNDYWNoZS5nZXQodHlwZSk7XG4gIGlmICh0cmFuc2Zvcm1zQXJyID09PSB1bmRlZmluZWQpIHtcbiAgICB0cmFuc2Zvcm1zQXJyID0gQXJyYXkuZnJvbShyZWdpc3RlcmVkTm9kZS50cmFuc2Zvcm1zKTtcbiAgICB0cmFuc2Zvcm1zQ2FjaGUuc2V0KHR5cGUsIHRyYW5zZm9ybXNBcnIpO1xuICB9XG4gIGNvbnN0IHRyYW5zZm9ybXNBcnJMZW5ndGggPSB0cmFuc2Zvcm1zQXJyLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFuc2Zvcm1zQXJyTGVuZ3RoOyBpKyspIHtcbiAgICB0cmFuc2Zvcm1zQXJyW2ldKG5vZGUpO1xuICAgIGlmICghbm9kZS5pc0F0dGFjaGVkKCkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gJGlzTm9kZVZhbGlkRm9yVHJhbnNmb3JtKG5vZGUsIGNvbXBvc2l0aW9uS2V5KSB7XG4gIHJldHVybiBub2RlICE9PSB1bmRlZmluZWQgJiZcbiAgLy8gV2UgZG9uJ3Qgd2FudCB0byB0cmFuc2Zvcm0gbm9kZXMgYmVpbmcgY29tcG9zZWRcbiAgbm9kZS5fX2tleSAhPT0gY29tcG9zaXRpb25LZXkgJiYgbm9kZS5pc0F0dGFjaGVkKCk7XG59XG5mdW5jdGlvbiAkbm9ybWFsaXplQWxsRGlydHlUZXh0Tm9kZXMoZWRpdG9yU3RhdGUsIGVkaXRvcikge1xuICBjb25zdCBkaXJ0eUxlYXZlcyA9IGVkaXRvci5fZGlydHlMZWF2ZXM7XG4gIGNvbnN0IG5vZGVNYXAgPSBlZGl0b3JTdGF0ZS5fbm9kZU1hcDtcbiAgZm9yIChjb25zdCBub2RlS2V5IG9mIGRpcnR5TGVhdmVzKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVNYXAuZ2V0KG5vZGVLZXkpO1xuICAgIGlmICgkaXNUZXh0Tm9kZShub2RlKSAmJiBub2RlLmlzQXR0YWNoZWQoKSAmJiBub2RlLmlzU2ltcGxlVGV4dCgpICYmICFub2RlLmlzVW5tZXJnZWFibGUoKSkge1xuICAgICAgJG5vcm1hbGl6ZVRleHROb2RlKG5vZGUpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYWRkVGFncyhlZGl0b3IsIHRhZ3MpIHtcbiAgaWYgKCF0YWdzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHVwZGF0ZVRhZ3MgPSBlZGl0b3IuX3VwZGF0ZVRhZ3M7XG4gIGxldCB0YWdzXyA9IHRhZ3M7XG4gIGlmICghQXJyYXkuaXNBcnJheSh0YWdzKSkge1xuICAgIHRhZ3NfID0gW3RhZ3NdO1xuICB9XG4gIGZvciAoY29uc3QgdGFnIG9mIHRhZ3NfKSB7XG4gICAgdXBkYXRlVGFncy5hZGQodGFnKTtcbiAgfVxufVxuXG4vKipcbiAqIFRyYW5zZm9ybSBoZXVyaXN0aWM6XG4gKiAxLiBXZSB0cmFuc2Zvcm0gbGVhdmVzIGZpcnN0LiBJZiB0cmFuc2Zvcm1zIGdlbmVyYXRlIGFkZGl0aW9uYWwgZGlydHkgbm9kZXMgd2UgcmVwZWF0IHN0ZXAgMS5cbiAqIFRoZSByZWFzb25pbmcgYmVoaW5kIHRoaXMgaXMgdGhhdCBtYXJraW5nIGEgbGVhZiBhcyBkaXJ0eSBtYXJrcyBhbGwgaXRzIHBhcmVudCBlbGVtZW50cyBhcyBkaXJ0eSB0b28uXG4gKiAyLiBXZSB0cmFuc2Zvcm0gZWxlbWVudHMuIElmIGVsZW1lbnQgdHJhbnNmb3JtcyBnZW5lcmF0ZSBhZGRpdGlvbmFsIGRpcnR5IG5vZGVzIHdlIHJlcGVhdCBzdGVwIDEuXG4gKiBJZiBlbGVtZW50IHRyYW5zZm9ybXMgb25seSBnZW5lcmF0ZSBhZGRpdGlvbmFsIGRpcnR5IGVsZW1lbnRzIHdlIG9ubHkgcmVwZWF0IHN0ZXAgMi5cbiAqXG4gKiBOb3RlIHRoYXQgdG8ga2VlcCB0cmFjayBvZiBuZXdseSBkaXJ0eSBub2RlcyBhbmQgc3VidHJlZXMgd2UgbGV2ZXJhZ2UgdGhlIGVkaXRvci5fZGlydHlOb2RlcyBhbmRcbiAqIGVkaXRvci5fc3VidHJlZXMgd2hpY2ggd2UgcmVzZXQgaW4gZXZlcnkgbG9vcC5cbiAqL1xuZnVuY3Rpb24gJGFwcGx5QWxsVHJhbnNmb3JtcyhlZGl0b3JTdGF0ZSwgZWRpdG9yKSB7XG4gIGNvbnN0IGRpcnR5TGVhdmVzID0gZWRpdG9yLl9kaXJ0eUxlYXZlcztcbiAgY29uc3QgZGlydHlFbGVtZW50cyA9IGVkaXRvci5fZGlydHlFbGVtZW50cztcbiAgY29uc3Qgbm9kZU1hcCA9IGVkaXRvclN0YXRlLl9ub2RlTWFwO1xuICBjb25zdCBjb21wb3NpdGlvbktleSA9ICRnZXRDb21wb3NpdGlvbktleSgpO1xuICBjb25zdCB0cmFuc2Zvcm1zQ2FjaGUgPSBuZXcgTWFwKCk7XG4gIGxldCB1bnRyYW5zZm9ybWVkRGlydHlMZWF2ZXMgPSBkaXJ0eUxlYXZlcztcbiAgbGV0IHVudHJhbnNmb3JtZWREaXJ0eUxlYXZlc0xlbmd0aCA9IHVudHJhbnNmb3JtZWREaXJ0eUxlYXZlcy5zaXplO1xuICBsZXQgdW50cmFuc2Zvcm1lZERpcnR5RWxlbWVudHMgPSBkaXJ0eUVsZW1lbnRzO1xuICBsZXQgdW50cmFuc2Zvcm1lZERpcnR5RWxlbWVudHNMZW5ndGggPSB1bnRyYW5zZm9ybWVkRGlydHlFbGVtZW50cy5zaXplO1xuICB3aGlsZSAodW50cmFuc2Zvcm1lZERpcnR5TGVhdmVzTGVuZ3RoID4gMCB8fCB1bnRyYW5zZm9ybWVkRGlydHlFbGVtZW50c0xlbmd0aCA+IDApIHtcbiAgICBpZiAodW50cmFuc2Zvcm1lZERpcnR5TGVhdmVzTGVuZ3RoID4gMCkge1xuICAgICAgLy8gV2UgbGV2ZXJhZ2UgZWRpdG9yLl9kaXJ0eUxlYXZlcyB0byB0cmFjayB0aGUgbmV3IGRpcnR5IGxlYXZlcyBhZnRlciB0aGUgdHJhbnNmb3Jtc1xuICAgICAgZWRpdG9yLl9kaXJ0eUxlYXZlcyA9IG5ldyBTZXQoKTtcbiAgICAgIGZvciAoY29uc3Qgbm9kZUtleSBvZiB1bnRyYW5zZm9ybWVkRGlydHlMZWF2ZXMpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVNYXAuZ2V0KG5vZGVLZXkpO1xuICAgICAgICBpZiAoJGlzVGV4dE5vZGUobm9kZSkgJiYgbm9kZS5pc0F0dGFjaGVkKCkgJiYgbm9kZS5pc1NpbXBsZVRleHQoKSAmJiAhbm9kZS5pc1VubWVyZ2VhYmxlKCkpIHtcbiAgICAgICAgICAkbm9ybWFsaXplVGV4dE5vZGUobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgIT09IHVuZGVmaW5lZCAmJiAkaXNOb2RlVmFsaWRGb3JUcmFuc2Zvcm0obm9kZSwgY29tcG9zaXRpb25LZXkpKSB7XG4gICAgICAgICAgJGFwcGx5VHJhbnNmb3JtcyhlZGl0b3IsIG5vZGUsIHRyYW5zZm9ybXNDYWNoZSk7XG4gICAgICAgIH1cbiAgICAgICAgZGlydHlMZWF2ZXMuYWRkKG5vZGVLZXkpO1xuICAgICAgfVxuICAgICAgdW50cmFuc2Zvcm1lZERpcnR5TGVhdmVzID0gZWRpdG9yLl9kaXJ0eUxlYXZlcztcbiAgICAgIHVudHJhbnNmb3JtZWREaXJ0eUxlYXZlc0xlbmd0aCA9IHVudHJhbnNmb3JtZWREaXJ0eUxlYXZlcy5zaXplO1xuXG4gICAgICAvLyBXZSB3YW50IHRvIHByaW9yaXRpemUgbm9kZSB0cmFuc2Zvcm1zIG92ZXIgZWxlbWVudCB0cmFuc2Zvcm1zXG4gICAgICBpZiAodW50cmFuc2Zvcm1lZERpcnR5TGVhdmVzTGVuZ3RoID4gMCkge1xuICAgICAgICBpbmZpbml0ZVRyYW5zZm9ybUNvdW50Kys7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFsbCBkaXJ0eSBsZWF2ZXMgaGF2ZSBiZWVuIHByb2Nlc3NlZC4gTGV0J3MgZG8gZWxlbWVudHMhXG4gICAgLy8gV2UgaGF2ZSBwcmV2aW91c2x5IHByb2Nlc3NlZCBkaXJ0eSBsZWF2ZXMsIHNvIGxldCdzIHJlc3RhcnQgdGhlIGVkaXRvciBsZWF2ZXMgU2V0IHRvIHRyYWNrXG4gICAgLy8gbmV3IG9uZXMgY2F1c2VkIGJ5IGVsZW1lbnQgdHJhbnNmb3Jtc1xuICAgIGVkaXRvci5fZGlydHlMZWF2ZXMgPSBuZXcgU2V0KCk7XG4gICAgZWRpdG9yLl9kaXJ0eUVsZW1lbnRzID0gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3QgY3VycmVudFVudHJhbnNmb3JtZWREaXJ0eUVsZW1lbnQgb2YgdW50cmFuc2Zvcm1lZERpcnR5RWxlbWVudHMpIHtcbiAgICAgIGNvbnN0IG5vZGVLZXkgPSBjdXJyZW50VW50cmFuc2Zvcm1lZERpcnR5RWxlbWVudFswXTtcbiAgICAgIGNvbnN0IGludGVudGlvbmFsbHlNYXJrZWRBc0RpcnR5ID0gY3VycmVudFVudHJhbnNmb3JtZWREaXJ0eUVsZW1lbnRbMV07XG4gICAgICBpZiAobm9kZUtleSAhPT0gJ3Jvb3QnICYmICFpbnRlbnRpb25hbGx5TWFya2VkQXNEaXJ0eSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5vZGUgPSBub2RlTWFwLmdldChub2RlS2V5KTtcbiAgICAgIGlmIChub2RlICE9PSB1bmRlZmluZWQgJiYgJGlzTm9kZVZhbGlkRm9yVHJhbnNmb3JtKG5vZGUsIGNvbXBvc2l0aW9uS2V5KSkge1xuICAgICAgICAkYXBwbHlUcmFuc2Zvcm1zKGVkaXRvciwgbm9kZSwgdHJhbnNmb3Jtc0NhY2hlKTtcbiAgICAgIH1cbiAgICAgIGRpcnR5RWxlbWVudHMuc2V0KG5vZGVLZXksIGludGVudGlvbmFsbHlNYXJrZWRBc0RpcnR5KTtcbiAgICB9XG4gICAgdW50cmFuc2Zvcm1lZERpcnR5TGVhdmVzID0gZWRpdG9yLl9kaXJ0eUxlYXZlcztcbiAgICB1bnRyYW5zZm9ybWVkRGlydHlMZWF2ZXNMZW5ndGggPSB1bnRyYW5zZm9ybWVkRGlydHlMZWF2ZXMuc2l6ZTtcbiAgICB1bnRyYW5zZm9ybWVkRGlydHlFbGVtZW50cyA9IGVkaXRvci5fZGlydHlFbGVtZW50cztcbiAgICB1bnRyYW5zZm9ybWVkRGlydHlFbGVtZW50c0xlbmd0aCA9IHVudHJhbnNmb3JtZWREaXJ0eUVsZW1lbnRzLnNpemU7XG4gICAgaW5maW5pdGVUcmFuc2Zvcm1Db3VudCsrO1xuICB9XG4gIGVkaXRvci5fZGlydHlMZWF2ZXMgPSBkaXJ0eUxlYXZlcztcbiAgZWRpdG9yLl9kaXJ0eUVsZW1lbnRzID0gZGlydHlFbGVtZW50cztcbn1cbmZ1bmN0aW9uICRwYXJzZVNlcmlhbGl6ZWROb2RlKHNlcmlhbGl6ZWROb2RlKSB7XG4gIGNvbnN0IGludGVybmFsU2VyaWFsaXplZE5vZGUgPSBzZXJpYWxpemVkTm9kZTtcbiAgcmV0dXJuICRwYXJzZVNlcmlhbGl6ZWROb2RlSW1wbChpbnRlcm5hbFNlcmlhbGl6ZWROb2RlLCBnZXRBY3RpdmVFZGl0b3IoKS5fbm9kZXMpO1xufVxuZnVuY3Rpb24gJHBhcnNlU2VyaWFsaXplZE5vZGVJbXBsKHNlcmlhbGl6ZWROb2RlLCByZWdpc3RlcmVkTm9kZXMpIHtcbiAgY29uc3QgdHlwZSA9IHNlcmlhbGl6ZWROb2RlLnR5cGU7XG4gIGNvbnN0IHJlZ2lzdGVyZWROb2RlID0gcmVnaXN0ZXJlZE5vZGVzLmdldCh0eXBlKTtcbiAgaWYgKHJlZ2lzdGVyZWROb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgcGFyc2VFZGl0b3JTdGF0ZTogdHlwZSBcIiR7dHlwZX1cIiArIG5vdCBmb3VuZGApO1xuICAgIH1cbiAgfVxuICBjb25zdCBub2RlQ2xhc3MgPSByZWdpc3RlcmVkTm9kZS5rbGFzcztcbiAgaWYgKHNlcmlhbGl6ZWROb2RlLnR5cGUgIT09IG5vZGVDbGFzcy5nZXRUeXBlKCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgTGV4aWNhbE5vZGU6IE5vZGUgJHtub2RlQ2xhc3MubmFtZX0gZG9lcyBub3QgaW1wbGVtZW50IC5pbXBvcnRKU09OKCkuYCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IG5vZGUgPSBub2RlQ2xhc3MuaW1wb3J0SlNPTihzZXJpYWxpemVkTm9kZSk7XG4gIGNvbnN0IGNoaWxkcmVuID0gc2VyaWFsaXplZE5vZGUuY2hpbGRyZW47XG4gIGlmICgkaXNFbGVtZW50Tm9kZShub2RlKSAmJiBBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWRKU09OQ2hpbGROb2RlID0gY2hpbGRyZW5baV07XG4gICAgICBjb25zdCBjaGlsZE5vZGUgPSAkcGFyc2VTZXJpYWxpemVkTm9kZUltcGwoc2VyaWFsaXplZEpTT05DaGlsZE5vZGUsIHJlZ2lzdGVyZWROb2Rlcyk7XG4gICAgICBub2RlLmFwcGVuZChjaGlsZE5vZGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHBhcnNlRWRpdG9yU3RhdGUoc2VyaWFsaXplZEVkaXRvclN0YXRlLCBlZGl0b3IsIHVwZGF0ZUZuKSB7XG4gIGNvbnN0IGVkaXRvclN0YXRlID0gY3JlYXRlRW1wdHlFZGl0b3JTdGF0ZSgpO1xuICBjb25zdCBwcmV2aW91c0FjdGl2ZUVkaXRvclN0YXRlID0gYWN0aXZlRWRpdG9yU3RhdGU7XG4gIGNvbnN0IHByZXZpb3VzUmVhZE9ubHlNb2RlID0gaXNSZWFkT25seU1vZGU7XG4gIGNvbnN0IHByZXZpb3VzQWN0aXZlRWRpdG9yID0gYWN0aXZlRWRpdG9yO1xuICBjb25zdCBwcmV2aW91c0RpcnR5RWxlbWVudHMgPSBlZGl0b3IuX2RpcnR5RWxlbWVudHM7XG4gIGNvbnN0IHByZXZpb3VzRGlydHlMZWF2ZXMgPSBlZGl0b3IuX2RpcnR5TGVhdmVzO1xuICBjb25zdCBwcmV2aW91c0Nsb25lTm90TmVlZGVkID0gZWRpdG9yLl9jbG9uZU5vdE5lZWRlZDtcbiAgY29uc3QgcHJldmlvdXNEaXJ0eVR5cGUgPSBlZGl0b3IuX2RpcnR5VHlwZTtcbiAgZWRpdG9yLl9kaXJ0eUVsZW1lbnRzID0gbmV3IE1hcCgpO1xuICBlZGl0b3IuX2RpcnR5TGVhdmVzID0gbmV3IFNldCgpO1xuICBlZGl0b3IuX2Nsb25lTm90TmVlZGVkID0gbmV3IFNldCgpO1xuICBlZGl0b3IuX2RpcnR5VHlwZSA9IDA7XG4gIGFjdGl2ZUVkaXRvclN0YXRlID0gZWRpdG9yU3RhdGU7XG4gIGlzUmVhZE9ubHlNb2RlID0gZmFsc2U7XG4gIGFjdGl2ZUVkaXRvciA9IGVkaXRvcjtcbiAgdHJ5IHtcbiAgICBjb25zdCByZWdpc3RlcmVkTm9kZXMgPSBlZGl0b3IuX25vZGVzO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWROb2RlID0gc2VyaWFsaXplZEVkaXRvclN0YXRlLnJvb3Q7XG4gICAgJHBhcnNlU2VyaWFsaXplZE5vZGVJbXBsKHNlcmlhbGl6ZWROb2RlLCByZWdpc3RlcmVkTm9kZXMpO1xuICAgIGlmICh1cGRhdGVGbikge1xuICAgICAgdXBkYXRlRm4oKTtcbiAgICB9XG5cbiAgICAvLyBNYWtlIHRoZSBlZGl0b3JTdGF0ZSBpbW11dGFibGVcbiAgICBlZGl0b3JTdGF0ZS5fcmVhZE9ubHkgPSB0cnVlO1xuICAgIHtcbiAgICAgIGhhbmRsZURFVk9ubHlQZW5kaW5nVXBkYXRlR3VhcmFudGVlcyhlZGl0b3JTdGF0ZSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICBlZGl0b3IuX29uRXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICBlZGl0b3IuX2RpcnR5RWxlbWVudHMgPSBwcmV2aW91c0RpcnR5RWxlbWVudHM7XG4gICAgZWRpdG9yLl9kaXJ0eUxlYXZlcyA9IHByZXZpb3VzRGlydHlMZWF2ZXM7XG4gICAgZWRpdG9yLl9jbG9uZU5vdE5lZWRlZCA9IHByZXZpb3VzQ2xvbmVOb3ROZWVkZWQ7XG4gICAgZWRpdG9yLl9kaXJ0eVR5cGUgPSBwcmV2aW91c0RpcnR5VHlwZTtcbiAgICBhY3RpdmVFZGl0b3JTdGF0ZSA9IHByZXZpb3VzQWN0aXZlRWRpdG9yU3RhdGU7XG4gICAgaXNSZWFkT25seU1vZGUgPSBwcmV2aW91c1JlYWRPbmx5TW9kZTtcbiAgICBhY3RpdmVFZGl0b3IgPSBwcmV2aW91c0FjdGl2ZUVkaXRvcjtcbiAgfVxuICByZXR1cm4gZWRpdG9yU3RhdGU7XG59XG5cbi8vIFRoaXMgdGVjaG5pY2FsbHkgaXNuJ3QgYW4gdXBkYXRlIGJ1dCBnaXZlbiB3ZSBuZWVkXG4vLyBleHBvc3VyZSB0byB0aGUgbW9kdWxlJ3MgYWN0aXZlIGJpbmRpbmdzLCB3ZSBoYXZlIHRoaXNcbi8vIGZ1bmN0aW9uIGhlcmVcblxuZnVuY3Rpb24gcmVhZEVkaXRvclN0YXRlKGVkaXRvciwgZWRpdG9yU3RhdGUsIGNhbGxiYWNrRm4pIHtcbiAgY29uc3QgcHJldmlvdXNBY3RpdmVFZGl0b3JTdGF0ZSA9IGFjdGl2ZUVkaXRvclN0YXRlO1xuICBjb25zdCBwcmV2aW91c1JlYWRPbmx5TW9kZSA9IGlzUmVhZE9ubHlNb2RlO1xuICBjb25zdCBwcmV2aW91c0FjdGl2ZUVkaXRvciA9IGFjdGl2ZUVkaXRvcjtcbiAgYWN0aXZlRWRpdG9yU3RhdGUgPSBlZGl0b3JTdGF0ZTtcbiAgaXNSZWFkT25seU1vZGUgPSB0cnVlO1xuICBhY3RpdmVFZGl0b3IgPSBlZGl0b3I7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrRm4oKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBhY3RpdmVFZGl0b3JTdGF0ZSA9IHByZXZpb3VzQWN0aXZlRWRpdG9yU3RhdGU7XG4gICAgaXNSZWFkT25seU1vZGUgPSBwcmV2aW91c1JlYWRPbmx5TW9kZTtcbiAgICBhY3RpdmVFZGl0b3IgPSBwcmV2aW91c0FjdGl2ZUVkaXRvcjtcbiAgfVxufVxuZnVuY3Rpb24gaGFuZGxlREVWT25seVBlbmRpbmdVcGRhdGVHdWFyYW50ZWVzKHBlbmRpbmdFZGl0b3JTdGF0ZSkge1xuICAvLyBHaXZlbiB3ZSBjYW4ndCBPYmplY3QuZnJlZXplIHRoZSBub2RlTWFwIGFzIGl0J3MgYSBNYXAsXG4gIC8vIHdlIGluc3RlYWQgcmVwbGFjZSBpdHMgc2V0LCBjbGVhciBhbmQgZGVsZXRlIG1ldGhvZHMuXG4gIGNvbnN0IG5vZGVNYXAgPSBwZW5kaW5nRWRpdG9yU3RhdGUuX25vZGVNYXA7XG4gIG5vZGVNYXAuc2V0ID0gKCkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNhbGwgc2V0KCkgb24gYSBmcm96ZW4gTGV4aWNhbCBub2RlIG1hcCcpO1xuICB9O1xuICBub2RlTWFwLmNsZWFyID0gKCkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNhbGwgY2xlYXIoKSBvbiBhIGZyb3plbiBMZXhpY2FsIG5vZGUgbWFwJyk7XG4gIH07XG4gIG5vZGVNYXAuZGVsZXRlID0gKCkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNhbGwgZGVsZXRlKCkgb24gYSBmcm96ZW4gTGV4aWNhbCBub2RlIG1hcCcpO1xuICB9O1xufVxuZnVuY3Rpb24gJGNvbW1pdFBlbmRpbmdVcGRhdGVzKGVkaXRvciwgcmVjb3ZlcnlFZGl0b3JTdGF0ZSkge1xuICBjb25zdCBwZW5kaW5nRWRpdG9yU3RhdGUgPSBlZGl0b3IuX3BlbmRpbmdFZGl0b3JTdGF0ZTtcbiAgY29uc3Qgcm9vdEVsZW1lbnQgPSBlZGl0b3IuX3Jvb3RFbGVtZW50O1xuICBjb25zdCBzaG91bGRTa2lwRE9NID0gZWRpdG9yLl9oZWFkbGVzcyB8fCByb290RWxlbWVudCA9PT0gbnVsbDtcbiAgaWYgKHBlbmRpbmdFZGl0b3JTdGF0ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vID09PT09PVxuICAvLyBSZWNvbmNpbGlhdGlvbiBoYXMgc3RhcnRlZC5cbiAgLy8gPT09PT09XG5cbiAgY29uc3QgY3VycmVudEVkaXRvclN0YXRlID0gZWRpdG9yLl9lZGl0b3JTdGF0ZTtcbiAgY29uc3QgY3VycmVudFNlbGVjdGlvbiA9IGN1cnJlbnRFZGl0b3JTdGF0ZS5fc2VsZWN0aW9uO1xuICBjb25zdCBwZW5kaW5nU2VsZWN0aW9uID0gcGVuZGluZ0VkaXRvclN0YXRlLl9zZWxlY3Rpb247XG4gIGNvbnN0IG5lZWRzVXBkYXRlID0gZWRpdG9yLl9kaXJ0eVR5cGUgIT09IE5PX0RJUlRZX05PREVTO1xuICBjb25zdCBwcmV2aW91c0FjdGl2ZUVkaXRvclN0YXRlID0gYWN0aXZlRWRpdG9yU3RhdGU7XG4gIGNvbnN0IHByZXZpb3VzUmVhZE9ubHlNb2RlID0gaXNSZWFkT25seU1vZGU7XG4gIGNvbnN0IHByZXZpb3VzQWN0aXZlRWRpdG9yID0gYWN0aXZlRWRpdG9yO1xuICBjb25zdCBwcmV2aW91c2x5VXBkYXRpbmcgPSBlZGl0b3IuX3VwZGF0aW5nO1xuICBjb25zdCBvYnNlcnZlciA9IGVkaXRvci5fb2JzZXJ2ZXI7XG4gIGxldCBtdXRhdGVkTm9kZXMgPSBudWxsO1xuICBlZGl0b3IuX3BlbmRpbmdFZGl0b3JTdGF0ZSA9IG51bGw7XG4gIGVkaXRvci5fZWRpdG9yU3RhdGUgPSBwZW5kaW5nRWRpdG9yU3RhdGU7XG4gIGlmICghc2hvdWxkU2tpcERPTSAmJiBuZWVkc1VwZGF0ZSAmJiBvYnNlcnZlciAhPT0gbnVsbCkge1xuICAgIGFjdGl2ZUVkaXRvciA9IGVkaXRvcjtcbiAgICBhY3RpdmVFZGl0b3JTdGF0ZSA9IHBlbmRpbmdFZGl0b3JTdGF0ZTtcbiAgICBpc1JlYWRPbmx5TW9kZSA9IGZhbHNlO1xuICAgIC8vIFdlIGRvbid0IHdhbnQgdXBkYXRlcyB0byBzeW5jIGJsb2NrIHRoZSByZWNvbmNpbGlhdGlvbi5cbiAgICBlZGl0b3IuX3VwZGF0aW5nID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGlydHlUeXBlID0gZWRpdG9yLl9kaXJ0eVR5cGU7XG4gICAgICBjb25zdCBkaXJ0eUVsZW1lbnRzID0gZWRpdG9yLl9kaXJ0eUVsZW1lbnRzO1xuICAgICAgY29uc3QgZGlydHlMZWF2ZXMgPSBlZGl0b3IuX2RpcnR5TGVhdmVzO1xuICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgbXV0YXRlZE5vZGVzID0gJHJlY29uY2lsZVJvb3QoY3VycmVudEVkaXRvclN0YXRlLCBwZW5kaW5nRWRpdG9yU3RhdGUsIGVkaXRvciwgZGlydHlUeXBlLCBkaXJ0eUVsZW1lbnRzLCBkaXJ0eUxlYXZlcyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIFJlcG9ydCBlcnJvcnNcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIGVkaXRvci5fb25FcnJvcihlcnJvcik7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlc2V0IGVkaXRvciBhbmQgcmVzdG9yZSBpbmNvbWluZyBlZGl0b3Igc3RhdGUgdG8gdGhlIERPTVxuICAgICAgaWYgKCFpc0F0dGVtcHRpbmdUb1JlY292ZXJGcm9tUmVjb25jaWxlckVycm9yKSB7XG4gICAgICAgIHJlc2V0RWRpdG9yKGVkaXRvciwgbnVsbCwgcm9vdEVsZW1lbnQsIHBlbmRpbmdFZGl0b3JTdGF0ZSk7XG4gICAgICAgIGluaXRNdXRhdGlvbk9ic2VydmVyKGVkaXRvcik7XG4gICAgICAgIGVkaXRvci5fZGlydHlUeXBlID0gRlVMTF9SRUNPTkNJTEU7XG4gICAgICAgIGlzQXR0ZW1wdGluZ1RvUmVjb3ZlckZyb21SZWNvbmNpbGVyRXJyb3IgPSB0cnVlO1xuICAgICAgICAkY29tbWl0UGVuZGluZ1VwZGF0ZXMoZWRpdG9yLCBjdXJyZW50RWRpdG9yU3RhdGUpO1xuICAgICAgICBpc0F0dGVtcHRpbmdUb1JlY292ZXJGcm9tUmVjb25jaWxlckVycm9yID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUbyBhdm9pZCBhIHBvc3NpYmxlIHNpdHVhdGlvbiBvZiBpbmZpbml0ZSBsb29wcywgbGV0cyB0aHJvd1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShyb290RWxlbWVudCwgb2JzZXJ2ZXJPcHRpb25zKTtcbiAgICAgIGVkaXRvci5fdXBkYXRpbmcgPSBwcmV2aW91c2x5VXBkYXRpbmc7XG4gICAgICBhY3RpdmVFZGl0b3JTdGF0ZSA9IHByZXZpb3VzQWN0aXZlRWRpdG9yU3RhdGU7XG4gICAgICBpc1JlYWRPbmx5TW9kZSA9IHByZXZpb3VzUmVhZE9ubHlNb2RlO1xuICAgICAgYWN0aXZlRWRpdG9yID0gcHJldmlvdXNBY3RpdmVFZGl0b3I7XG4gICAgfVxuICB9XG4gIGlmICghcGVuZGluZ0VkaXRvclN0YXRlLl9yZWFkT25seSkge1xuICAgIHBlbmRpbmdFZGl0b3JTdGF0ZS5fcmVhZE9ubHkgPSB0cnVlO1xuICAgIHtcbiAgICAgIGhhbmRsZURFVk9ubHlQZW5kaW5nVXBkYXRlR3VhcmFudGVlcyhwZW5kaW5nRWRpdG9yU3RhdGUpO1xuICAgICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHBlbmRpbmdTZWxlY3Rpb24pKSB7XG4gICAgICAgIE9iamVjdC5mcmVlemUocGVuZGluZ1NlbGVjdGlvbi5hbmNob3IpO1xuICAgICAgICBPYmplY3QuZnJlZXplKHBlbmRpbmdTZWxlY3Rpb24uZm9jdXMpO1xuICAgICAgfVxuICAgICAgT2JqZWN0LmZyZWV6ZShwZW5kaW5nU2VsZWN0aW9uKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZGlydHlMZWF2ZXMgPSBlZGl0b3IuX2RpcnR5TGVhdmVzO1xuICBjb25zdCBkaXJ0eUVsZW1lbnRzID0gZWRpdG9yLl9kaXJ0eUVsZW1lbnRzO1xuICBjb25zdCBub3JtYWxpemVkTm9kZXMgPSBlZGl0b3IuX25vcm1hbGl6ZWROb2RlcztcbiAgY29uc3QgdGFncyA9IGVkaXRvci5fdXBkYXRlVGFncztcbiAgY29uc3QgZGVmZXJyZWQgPSBlZGl0b3IuX2RlZmVycmVkO1xuICBpZiAobmVlZHNVcGRhdGUpIHtcbiAgICBlZGl0b3IuX2RpcnR5VHlwZSA9IE5PX0RJUlRZX05PREVTO1xuICAgIGVkaXRvci5fY2xvbmVOb3ROZWVkZWQuY2xlYXIoKTtcbiAgICBlZGl0b3IuX2RpcnR5TGVhdmVzID0gbmV3IFNldCgpO1xuICAgIGVkaXRvci5fZGlydHlFbGVtZW50cyA9IG5ldyBNYXAoKTtcbiAgICBlZGl0b3IuX25vcm1hbGl6ZWROb2RlcyA9IG5ldyBTZXQoKTtcbiAgICBlZGl0b3IuX3VwZGF0ZVRhZ3MgPSBuZXcgU2V0KCk7XG4gIH1cbiAgJGdhcmJhZ2VDb2xsZWN0RGV0YWNoZWREZWNvcmF0b3JzKGVkaXRvciwgcGVuZGluZ0VkaXRvclN0YXRlKTtcblxuICAvLyA9PT09PT1cbiAgLy8gUmVjb25jaWxpYXRpb24gaGFzIGZpbmlzaGVkLiBOb3cgdXBkYXRlIHNlbGVjdGlvbiBhbmQgdHJpZ2dlciBsaXN0ZW5lcnMuXG4gIC8vID09PT09PVxuXG4gIGNvbnN0IGRvbVNlbGVjdGlvbiA9IHNob3VsZFNraXBET00gPyBudWxsIDogZ2V0RE9NU2VsZWN0aW9uKGVkaXRvci5fd2luZG93KTtcblxuICAvLyBBdHRlbXB0IHRvIHVwZGF0ZSB0aGUgRE9NIHNlbGVjdGlvbiwgaW5jbHVkaW5nIGZvY3VzaW5nIG9mIHRoZSByb290IGVsZW1lbnQsXG4gIC8vIGFuZCBzY3JvbGwgaW50byB2aWV3IGlmIG5lZWRlZC5cbiAgaWYgKGVkaXRvci5fZWRpdGFibGUgJiZcbiAgLy8gZG9tU2VsZWN0aW9uIHdpbGwgYmUgbnVsbCBpbiBoZWFkbGVzc1xuICBkb21TZWxlY3Rpb24gIT09IG51bGwgJiYgKG5lZWRzVXBkYXRlIHx8IHBlbmRpbmdTZWxlY3Rpb24gPT09IG51bGwgfHwgcGVuZGluZ1NlbGVjdGlvbi5kaXJ0eSkgJiYgcm9vdEVsZW1lbnQgIT09IG51bGwgJiYgIXRhZ3MuaGFzKCdza2lwLWRvbS1zZWxlY3Rpb24nKSkge1xuICAgIGFjdGl2ZUVkaXRvciA9IGVkaXRvcjtcbiAgICBhY3RpdmVFZGl0b3JTdGF0ZSA9IHBlbmRpbmdFZGl0b3JTdGF0ZTtcbiAgICB0cnkge1xuICAgICAgaWYgKG9ic2VydmVyICE9PSBudWxsKSB7XG4gICAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgIH1cbiAgICAgIGlmIChuZWVkc1VwZGF0ZSB8fCBwZW5kaW5nU2VsZWN0aW9uID09PSBudWxsIHx8IHBlbmRpbmdTZWxlY3Rpb24uZGlydHkpIHtcbiAgICAgICAgY29uc3QgYmxvY2tDdXJzb3JFbGVtZW50ID0gZWRpdG9yLl9ibG9ja0N1cnNvckVsZW1lbnQ7XG4gICAgICAgIGlmIChibG9ja0N1cnNvckVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgICByZW1vdmVET01CbG9ja0N1cnNvckVsZW1lbnQoYmxvY2tDdXJzb3JFbGVtZW50LCBlZGl0b3IsIHJvb3RFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVET01TZWxlY3Rpb24oY3VycmVudFNlbGVjdGlvbiwgcGVuZGluZ1NlbGVjdGlvbiwgZWRpdG9yLCBkb21TZWxlY3Rpb24sIHRhZ3MsIHJvb3RFbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZURPTUJsb2NrQ3Vyc29yRWxlbWVudChlZGl0b3IsIHJvb3RFbGVtZW50LCBwZW5kaW5nU2VsZWN0aW9uKTtcbiAgICAgIGlmIChvYnNlcnZlciAhPT0gbnVsbCkge1xuICAgICAgICBvYnNlcnZlci5vYnNlcnZlKHJvb3RFbGVtZW50LCBvYnNlcnZlck9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBhY3RpdmVFZGl0b3IgPSBwcmV2aW91c0FjdGl2ZUVkaXRvcjtcbiAgICAgIGFjdGl2ZUVkaXRvclN0YXRlID0gcHJldmlvdXNBY3RpdmVFZGl0b3JTdGF0ZTtcbiAgICB9XG4gIH1cbiAgaWYgKG11dGF0ZWROb2RlcyAhPT0gbnVsbCkge1xuICAgIHRyaWdnZXJNdXRhdGlvbkxpc3RlbmVycyhlZGl0b3IsIG11dGF0ZWROb2RlcywgdGFncywgZGlydHlMZWF2ZXMsIGN1cnJlbnRFZGl0b3JTdGF0ZSk7XG4gIH1cbiAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihwZW5kaW5nU2VsZWN0aW9uKSAmJiBwZW5kaW5nU2VsZWN0aW9uICE9PSBudWxsICYmIChjdXJyZW50U2VsZWN0aW9uID09PSBudWxsIHx8ICFjdXJyZW50U2VsZWN0aW9uLmlzKHBlbmRpbmdTZWxlY3Rpb24pKSkge1xuICAgIGVkaXRvci5kaXNwYXRjaENvbW1hbmQoU0VMRUNUSU9OX0NIQU5HRV9DT01NQU5ELCB1bmRlZmluZWQpO1xuICB9XG4gIC8qKlxuICAgKiBDYXB0dXJlIHBlbmRpbmdEZWNvcmF0b3JzIGFmdGVyIGdhcmJhZ2UgY29sbGVjdGluZyBkZXRhY2hlZCBkZWNvcmF0b3JzXG4gICAqL1xuICBjb25zdCBwZW5kaW5nRGVjb3JhdG9ycyA9IGVkaXRvci5fcGVuZGluZ0RlY29yYXRvcnM7XG4gIGlmIChwZW5kaW5nRGVjb3JhdG9ycyAhPT0gbnVsbCkge1xuICAgIGVkaXRvci5fZGVjb3JhdG9ycyA9IHBlbmRpbmdEZWNvcmF0b3JzO1xuICAgIGVkaXRvci5fcGVuZGluZ0RlY29yYXRvcnMgPSBudWxsO1xuICAgIHRyaWdnZXJMaXN0ZW5lcnMoJ2RlY29yYXRvcicsIGVkaXRvciwgdHJ1ZSwgcGVuZGluZ0RlY29yYXRvcnMpO1xuICB9XG5cbiAgLy8gSWYgcmVjb25jaWxlciBmYWlscywgd2UgcmVzZXQgd2hvbGUgZWRpdG9yIChzbyBjdXJyZW50IGVkaXRvciBzdGF0ZSBiZWNvbWVzIGVtcHR5KVxuICAvLyBhbmQgYXR0ZW1wdCB0byByZS1yZW5kZXIgcGVuZGluZ0VkaXRvclN0YXRlLiBJZiB0aGF0IGdvZXMgdGhyb3VnaCB3ZSB0cmlnZ2VyXG4gIC8vIGxpc3RlbmVycywgYnV0IGluc3RlYWQgdXNlIHJlY292ZXJFZGl0b3JTdGF0ZSB3aGljaCBpcyBjdXJyZW50IGVkaXRvciBzdGF0ZSBiZWZvcmUgcmVzZXRcbiAgLy8gVGhpcyBzcGVjaWZpY2FsbHkgaW1wb3J0YW50IGZvciBjb2xsYWIgdGhhdCByZWxpZXMgb24gcHJldkVkaXRvclN0YXRlIGZyb20gdXBkYXRlXG4gIC8vIGxpc3RlbmVyIHRvIGNhbGN1bGF0ZSBkZWx0YSBvZiBjaGFuZ2VkIG5vZGVzL3Byb3BlcnRpZXNcbiAgdHJpZ2dlclRleHRDb250ZW50TGlzdGVuZXJzKGVkaXRvciwgcmVjb3ZlcnlFZGl0b3JTdGF0ZSB8fCBjdXJyZW50RWRpdG9yU3RhdGUsIHBlbmRpbmdFZGl0b3JTdGF0ZSk7XG4gIHRyaWdnZXJMaXN0ZW5lcnMoJ3VwZGF0ZScsIGVkaXRvciwgdHJ1ZSwge1xuICAgIGRpcnR5RWxlbWVudHMsXG4gICAgZGlydHlMZWF2ZXMsXG4gICAgZWRpdG9yU3RhdGU6IHBlbmRpbmdFZGl0b3JTdGF0ZSxcbiAgICBub3JtYWxpemVkTm9kZXMsXG4gICAgcHJldkVkaXRvclN0YXRlOiByZWNvdmVyeUVkaXRvclN0YXRlIHx8IGN1cnJlbnRFZGl0b3JTdGF0ZSxcbiAgICB0YWdzXG4gIH0pO1xuICB0cmlnZ2VyRGVmZXJyZWRVcGRhdGVDYWxsYmFja3MoZWRpdG9yLCBkZWZlcnJlZCk7XG4gICR0cmlnZ2VyRW5xdWV1ZWRVcGRhdGVzKGVkaXRvcik7XG59XG5mdW5jdGlvbiB0cmlnZ2VyVGV4dENvbnRlbnRMaXN0ZW5lcnMoZWRpdG9yLCBjdXJyZW50RWRpdG9yU3RhdGUsIHBlbmRpbmdFZGl0b3JTdGF0ZSkge1xuICBjb25zdCBjdXJyZW50VGV4dENvbnRlbnQgPSBnZXRFZGl0b3JTdGF0ZVRleHRDb250ZW50KGN1cnJlbnRFZGl0b3JTdGF0ZSk7XG4gIGNvbnN0IGxhdGVzdFRleHRDb250ZW50ID0gZ2V0RWRpdG9yU3RhdGVUZXh0Q29udGVudChwZW5kaW5nRWRpdG9yU3RhdGUpO1xuICBpZiAoY3VycmVudFRleHRDb250ZW50ICE9PSBsYXRlc3RUZXh0Q29udGVudCkge1xuICAgIHRyaWdnZXJMaXN0ZW5lcnMoJ3RleHRjb250ZW50JywgZWRpdG9yLCB0cnVlLCBsYXRlc3RUZXh0Q29udGVudCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHRyaWdnZXJNdXRhdGlvbkxpc3RlbmVycyhlZGl0b3IsIG11dGF0ZWROb2RlcywgdXBkYXRlVGFncywgZGlydHlMZWF2ZXMsIHByZXZFZGl0b3JTdGF0ZSkge1xuICBjb25zdCBsaXN0ZW5lcnMgPSBBcnJheS5mcm9tKGVkaXRvci5fbGlzdGVuZXJzLm11dGF0aW9uKTtcbiAgY29uc3QgbGlzdGVuZXJzTGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0ZW5lcnNMZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IFtsaXN0ZW5lciwga2xhc3NdID0gbGlzdGVuZXJzW2ldO1xuICAgIGNvbnN0IG11dGF0ZWROb2Rlc0J5VHlwZSA9IG11dGF0ZWROb2Rlcy5nZXQoa2xhc3MpO1xuICAgIGlmIChtdXRhdGVkTm9kZXNCeVR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbGlzdGVuZXIobXV0YXRlZE5vZGVzQnlUeXBlLCB7XG4gICAgICAgIGRpcnR5TGVhdmVzLFxuICAgICAgICBwcmV2RWRpdG9yU3RhdGUsXG4gICAgICAgIHVwZGF0ZVRhZ3NcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdHJpZ2dlckxpc3RlbmVycyh0eXBlLCBlZGl0b3IsIGlzQ3VycmVudGx5RW5xdWV1aW5nVXBkYXRlcywgLi4ucGF5bG9hZCkge1xuICBjb25zdCBwcmV2aW91c2x5VXBkYXRpbmcgPSBlZGl0b3IuX3VwZGF0aW5nO1xuICBlZGl0b3IuX3VwZGF0aW5nID0gaXNDdXJyZW50bHlFbnF1ZXVpbmdVcGRhdGVzO1xuICB0cnkge1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IEFycmF5LmZyb20oZWRpdG9yLl9saXN0ZW5lcnNbdHlwZV0pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkobnVsbCwgcGF5bG9hZCk7XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIGVkaXRvci5fdXBkYXRpbmcgPSBwcmV2aW91c2x5VXBkYXRpbmc7XG4gIH1cbn1cbmZ1bmN0aW9uIHRyaWdnZXJDb21tYW5kTGlzdGVuZXJzKGVkaXRvciwgdHlwZSwgcGF5bG9hZCkge1xuICBpZiAoZWRpdG9yLl91cGRhdGluZyA9PT0gZmFsc2UgfHwgYWN0aXZlRWRpdG9yICE9PSBlZGl0b3IpIHtcbiAgICBsZXQgcmV0dXJuVmFsID0gZmFsc2U7XG4gICAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICByZXR1cm5WYWwgPSB0cmlnZ2VyQ29tbWFuZExpc3RlbmVycyhlZGl0b3IsIHR5cGUsIHBheWxvYWQpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXR1cm5WYWw7XG4gIH1cbiAgY29uc3QgZWRpdG9ycyA9IGdldEVkaXRvcnNUb1Byb3BhZ2F0ZShlZGl0b3IpO1xuICBmb3IgKGxldCBpID0gNDsgaSA+PSAwOyBpLS0pIHtcbiAgICBmb3IgKGxldCBlID0gMDsgZSA8IGVkaXRvcnMubGVuZ3RoOyBlKyspIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRFZGl0b3IgPSBlZGl0b3JzW2VdO1xuICAgICAgY29uc3QgY29tbWFuZExpc3RlbmVycyA9IGN1cnJlbnRFZGl0b3IuX2NvbW1hbmRzO1xuICAgICAgY29uc3QgbGlzdGVuZXJJblByaW9yaXR5T3JkZXIgPSBjb21tYW5kTGlzdGVuZXJzLmdldCh0eXBlKTtcbiAgICAgIGlmIChsaXN0ZW5lckluUHJpb3JpdHlPcmRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVyc1NldCA9IGxpc3RlbmVySW5Qcmlvcml0eU9yZGVyW2ldO1xuICAgICAgICBpZiAobGlzdGVuZXJzU2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSBBcnJheS5mcm9tKGxpc3RlbmVyc1NldCk7XG4gICAgICAgICAgY29uc3QgbGlzdGVuZXJzTGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxpc3RlbmVyc0xlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAobGlzdGVuZXJzW2pdKHBheWxvYWQsIGVkaXRvcikgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uICR0cmlnZ2VyRW5xdWV1ZWRVcGRhdGVzKGVkaXRvcikge1xuICBjb25zdCBxdWV1ZWRVcGRhdGVzID0gZWRpdG9yLl91cGRhdGVzO1xuICBpZiAocXVldWVkVXBkYXRlcy5sZW5ndGggIT09IDApIHtcbiAgICBjb25zdCBxdWV1ZWRVcGRhdGUgPSBxdWV1ZWRVcGRhdGVzLnNoaWZ0KCk7XG4gICAgaWYgKHF1ZXVlZFVwZGF0ZSkge1xuICAgICAgY29uc3QgW3VwZGF0ZUZuLCBvcHRpb25zXSA9IHF1ZXVlZFVwZGF0ZTtcbiAgICAgICRiZWdpblVwZGF0ZShlZGl0b3IsIHVwZGF0ZUZuLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHRyaWdnZXJEZWZlcnJlZFVwZGF0ZUNhbGxiYWNrcyhlZGl0b3IsIGRlZmVycmVkKSB7XG4gIGVkaXRvci5fZGVmZXJyZWQgPSBbXTtcbiAgaWYgKGRlZmVycmVkLmxlbmd0aCAhPT0gMCkge1xuICAgIGNvbnN0IHByZXZpb3VzbHlVcGRhdGluZyA9IGVkaXRvci5fdXBkYXRpbmc7XG4gICAgZWRpdG9yLl91cGRhdGluZyA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVmZXJyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGVmZXJyZWRbaV0oKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgZWRpdG9yLl91cGRhdGluZyA9IHByZXZpb3VzbHlVcGRhdGluZztcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHByb2Nlc3NOZXN0ZWRVcGRhdGVzKGVkaXRvciwgaW5pdGlhbFNraXBUcmFuc2Zvcm1zKSB7XG4gIGNvbnN0IHF1ZXVlZFVwZGF0ZXMgPSBlZGl0b3IuX3VwZGF0ZXM7XG4gIGxldCBza2lwVHJhbnNmb3JtcyA9IGluaXRpYWxTa2lwVHJhbnNmb3JtcyB8fCBmYWxzZTtcblxuICAvLyBVcGRhdGVzIG1pZ2h0IGdyb3cgYXMgd2UgcHJvY2VzcyB0aGVtLCB3ZSBzbyB3ZSdsbCBuZWVkXG4gIC8vIHRvIGhhbmRsZSBlYWNoIHVwZGF0ZSBhcyB3ZSBnbyB1bnRpbCB0aGUgdXBkYXRlcyBhcnJheSBpc1xuICAvLyBlbXB0eS5cbiAgd2hpbGUgKHF1ZXVlZFVwZGF0ZXMubGVuZ3RoICE9PSAwKSB7XG4gICAgY29uc3QgcXVldWVkVXBkYXRlID0gcXVldWVkVXBkYXRlcy5zaGlmdCgpO1xuICAgIGlmIChxdWV1ZWRVcGRhdGUpIHtcbiAgICAgIGNvbnN0IFtuZXh0VXBkYXRlRm4sIG9wdGlvbnNdID0gcXVldWVkVXBkYXRlO1xuICAgICAgbGV0IG9uVXBkYXRlO1xuICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvblVwZGF0ZSA9IG9wdGlvbnMub25VcGRhdGU7XG4gICAgICAgIGlmIChvcHRpb25zLnNraXBUcmFuc2Zvcm1zKSB7XG4gICAgICAgICAgc2tpcFRyYW5zZm9ybXMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmRpc2NyZXRlKSB7XG4gICAgICAgICAgY29uc3QgcGVuZGluZ0VkaXRvclN0YXRlID0gZWRpdG9yLl9wZW5kaW5nRWRpdG9yU3RhdGU7XG4gICAgICAgICAgaWYgKCEocGVuZGluZ0VkaXRvclN0YXRlICE9PSBudWxsKSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYFVuZXhwZWN0ZWQgZW1wdHkgcGVuZGluZyBlZGl0b3Igc3RhdGUgb24gZGlzY3JldGUgbmVzdGVkIHVwZGF0ZWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwZW5kaW5nRWRpdG9yU3RhdGUuX2ZsdXNoU3luYyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uVXBkYXRlKSB7XG4gICAgICAgICAgZWRpdG9yLl9kZWZlcnJlZC5wdXNoKG9uVXBkYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRUYWdzKGVkaXRvciwgb3B0aW9ucy50YWcpO1xuICAgICAgfVxuICAgICAgbmV4dFVwZGF0ZUZuKCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBza2lwVHJhbnNmb3Jtcztcbn1cbmZ1bmN0aW9uICRiZWdpblVwZGF0ZShlZGl0b3IsIHVwZGF0ZUZuLCBvcHRpb25zKSB7XG4gIGNvbnN0IHVwZGF0ZVRhZ3MgPSBlZGl0b3IuX3VwZGF0ZVRhZ3M7XG4gIGxldCBvblVwZGF0ZTtcbiAgbGV0IHNraXBUcmFuc2Zvcm1zID0gZmFsc2U7XG4gIGxldCBkaXNjcmV0ZSA9IGZhbHNlO1xuICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgb25VcGRhdGUgPSBvcHRpb25zLm9uVXBkYXRlO1xuICAgIGFkZFRhZ3MoZWRpdG9yLCBvcHRpb25zLnRhZyk7XG4gICAgc2tpcFRyYW5zZm9ybXMgPSBvcHRpb25zLnNraXBUcmFuc2Zvcm1zIHx8IGZhbHNlO1xuICAgIGRpc2NyZXRlID0gb3B0aW9ucy5kaXNjcmV0ZSB8fCBmYWxzZTtcbiAgfVxuICBpZiAob25VcGRhdGUpIHtcbiAgICBlZGl0b3IuX2RlZmVycmVkLnB1c2gob25VcGRhdGUpO1xuICB9XG4gIGNvbnN0IGN1cnJlbnRFZGl0b3JTdGF0ZSA9IGVkaXRvci5fZWRpdG9yU3RhdGU7XG4gIGxldCBwZW5kaW5nRWRpdG9yU3RhdGUgPSBlZGl0b3IuX3BlbmRpbmdFZGl0b3JTdGF0ZTtcbiAgbGV0IGVkaXRvclN0YXRlV2FzQ2xvbmVkID0gZmFsc2U7XG4gIGlmIChwZW5kaW5nRWRpdG9yU3RhdGUgPT09IG51bGwgfHwgcGVuZGluZ0VkaXRvclN0YXRlLl9yZWFkT25seSkge1xuICAgIHBlbmRpbmdFZGl0b3JTdGF0ZSA9IGVkaXRvci5fcGVuZGluZ0VkaXRvclN0YXRlID0gY2xvbmVFZGl0b3JTdGF0ZShwZW5kaW5nRWRpdG9yU3RhdGUgfHwgY3VycmVudEVkaXRvclN0YXRlKTtcbiAgICBlZGl0b3JTdGF0ZVdhc0Nsb25lZCA9IHRydWU7XG4gIH1cbiAgcGVuZGluZ0VkaXRvclN0YXRlLl9mbHVzaFN5bmMgPSBkaXNjcmV0ZTtcbiAgY29uc3QgcHJldmlvdXNBY3RpdmVFZGl0b3JTdGF0ZSA9IGFjdGl2ZUVkaXRvclN0YXRlO1xuICBjb25zdCBwcmV2aW91c1JlYWRPbmx5TW9kZSA9IGlzUmVhZE9ubHlNb2RlO1xuICBjb25zdCBwcmV2aW91c0FjdGl2ZUVkaXRvciA9IGFjdGl2ZUVkaXRvcjtcbiAgY29uc3QgcHJldmlvdXNseVVwZGF0aW5nID0gZWRpdG9yLl91cGRhdGluZztcbiAgYWN0aXZlRWRpdG9yU3RhdGUgPSBwZW5kaW5nRWRpdG9yU3RhdGU7XG4gIGlzUmVhZE9ubHlNb2RlID0gZmFsc2U7XG4gIGVkaXRvci5fdXBkYXRpbmcgPSB0cnVlO1xuICBhY3RpdmVFZGl0b3IgPSBlZGl0b3I7XG4gIHRyeSB7XG4gICAgaWYgKGVkaXRvclN0YXRlV2FzQ2xvbmVkKSB7XG4gICAgICBpZiAoZWRpdG9yLl9oZWFkbGVzcykge1xuICAgICAgICBpZiAoY3VycmVudEVkaXRvclN0YXRlLl9zZWxlY3Rpb24gIT09IG51bGwpIHtcbiAgICAgICAgICBwZW5kaW5nRWRpdG9yU3RhdGUuX3NlbGVjdGlvbiA9IGN1cnJlbnRFZGl0b3JTdGF0ZS5fc2VsZWN0aW9uLmNsb25lKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlbmRpbmdFZGl0b3JTdGF0ZS5fc2VsZWN0aW9uID0gJGludGVybmFsQ3JlYXRlU2VsZWN0aW9uKGVkaXRvcik7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0aW5nQ29tcG9zaXRpb25LZXkgPSBlZGl0b3IuX2NvbXBvc2l0aW9uS2V5O1xuICAgIHVwZGF0ZUZuKCk7XG4gICAgc2tpcFRyYW5zZm9ybXMgPSBwcm9jZXNzTmVzdGVkVXBkYXRlcyhlZGl0b3IsIHNraXBUcmFuc2Zvcm1zKTtcbiAgICBhcHBseVNlbGVjdGlvblRyYW5zZm9ybXMocGVuZGluZ0VkaXRvclN0YXRlLCBlZGl0b3IpO1xuICAgIGlmIChlZGl0b3IuX2RpcnR5VHlwZSAhPT0gTk9fRElSVFlfTk9ERVMpIHtcbiAgICAgIGlmIChza2lwVHJhbnNmb3Jtcykge1xuICAgICAgICAkbm9ybWFsaXplQWxsRGlydHlUZXh0Tm9kZXMocGVuZGluZ0VkaXRvclN0YXRlLCBlZGl0b3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJGFwcGx5QWxsVHJhbnNmb3JtcyhwZW5kaW5nRWRpdG9yU3RhdGUsIGVkaXRvcik7XG4gICAgICB9XG4gICAgICBwcm9jZXNzTmVzdGVkVXBkYXRlcyhlZGl0b3IpO1xuICAgICAgJGdhcmJhZ2VDb2xsZWN0RGV0YWNoZWROb2RlcyhjdXJyZW50RWRpdG9yU3RhdGUsIHBlbmRpbmdFZGl0b3JTdGF0ZSwgZWRpdG9yLl9kaXJ0eUxlYXZlcywgZWRpdG9yLl9kaXJ0eUVsZW1lbnRzKTtcbiAgICB9XG4gICAgY29uc3QgZW5kaW5nQ29tcG9zaXRpb25LZXkgPSBlZGl0b3IuX2NvbXBvc2l0aW9uS2V5O1xuICAgIGlmIChzdGFydGluZ0NvbXBvc2l0aW9uS2V5ICE9PSBlbmRpbmdDb21wb3NpdGlvbktleSkge1xuICAgICAgcGVuZGluZ0VkaXRvclN0YXRlLl9mbHVzaFN5bmMgPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBwZW5kaW5nU2VsZWN0aW9uID0gcGVuZGluZ0VkaXRvclN0YXRlLl9zZWxlY3Rpb247XG4gICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHBlbmRpbmdTZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCBwZW5kaW5nTm9kZU1hcCA9IHBlbmRpbmdFZGl0b3JTdGF0ZS5fbm9kZU1hcDtcbiAgICAgIGNvbnN0IGFuY2hvcktleSA9IHBlbmRpbmdTZWxlY3Rpb24uYW5jaG9yLmtleTtcbiAgICAgIGNvbnN0IGZvY3VzS2V5ID0gcGVuZGluZ1NlbGVjdGlvbi5mb2N1cy5rZXk7XG4gICAgICBpZiAocGVuZGluZ05vZGVNYXAuZ2V0KGFuY2hvcktleSkgPT09IHVuZGVmaW5lZCB8fCBwZW5kaW5nTm9kZU1hcC5nZXQoZm9jdXNLZXkpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IEVycm9yKGB1cGRhdGVFZGl0b3I6IHNlbGVjdGlvbiBoYXMgYmVlbiBsb3N0IGJlY2F1c2UgdGhlIHByZXZpb3VzbHkgc2VsZWN0ZWQgbm9kZXMgaGF2ZSBiZWVuIHJlbW92ZWQgYW5kIHNlbGVjdGlvbiB3YXNuJ3QgbW92ZWQgdG8gYW5vdGhlciBub2RlLiBFbnN1cmUgc2VsZWN0aW9uIGNoYW5nZXMgYWZ0ZXIgcmVtb3ZpbmcvcmVwbGFjaW5nIGEgc2VsZWN0ZWQgbm9kZS5gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoJGlzTm9kZVNlbGVjdGlvbihwZW5kaW5nU2VsZWN0aW9uKSkge1xuICAgICAgLy8gVE9ETzogd2Ugc2hvdWxkIGFsc28gdmFsaWRhdGUgbm9kZSBzZWxlY3Rpb24/XG4gICAgICBpZiAocGVuZGluZ1NlbGVjdGlvbi5fbm9kZXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICBwZW5kaW5nRWRpdG9yU3RhdGUuX3NlbGVjdGlvbiA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8vIFJlcG9ydCBlcnJvcnNcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgZWRpdG9yLl9vbkVycm9yKGVycm9yKTtcbiAgICB9XG5cbiAgICAvLyBSZXN0b3JlIGV4aXN0aW5nIGVkaXRvciBzdGF0ZSB0byB0aGUgRE9NXG4gICAgZWRpdG9yLl9wZW5kaW5nRWRpdG9yU3RhdGUgPSBjdXJyZW50RWRpdG9yU3RhdGU7XG4gICAgZWRpdG9yLl9kaXJ0eVR5cGUgPSBGVUxMX1JFQ09OQ0lMRTtcbiAgICBlZGl0b3IuX2Nsb25lTm90TmVlZGVkLmNsZWFyKCk7XG4gICAgZWRpdG9yLl9kaXJ0eUxlYXZlcyA9IG5ldyBTZXQoKTtcbiAgICBlZGl0b3IuX2RpcnR5RWxlbWVudHMuY2xlYXIoKTtcbiAgICAkY29tbWl0UGVuZGluZ1VwZGF0ZXMoZWRpdG9yKTtcbiAgICByZXR1cm47XG4gIH0gZmluYWxseSB7XG4gICAgYWN0aXZlRWRpdG9yU3RhdGUgPSBwcmV2aW91c0FjdGl2ZUVkaXRvclN0YXRlO1xuICAgIGlzUmVhZE9ubHlNb2RlID0gcHJldmlvdXNSZWFkT25seU1vZGU7XG4gICAgYWN0aXZlRWRpdG9yID0gcHJldmlvdXNBY3RpdmVFZGl0b3I7XG4gICAgZWRpdG9yLl91cGRhdGluZyA9IHByZXZpb3VzbHlVcGRhdGluZztcbiAgICBpbmZpbml0ZVRyYW5zZm9ybUNvdW50ID0gMDtcbiAgfVxuICBjb25zdCBzaG91bGRVcGRhdGUgPSBlZGl0b3IuX2RpcnR5VHlwZSAhPT0gTk9fRElSVFlfTk9ERVMgfHwgZWRpdG9yLl9kZWZlcnJlZC5sZW5ndGggPiAwIHx8IGVkaXRvclN0YXRlSGFzRGlydHlTZWxlY3Rpb24ocGVuZGluZ0VkaXRvclN0YXRlLCBlZGl0b3IpO1xuICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgaWYgKHBlbmRpbmdFZGl0b3JTdGF0ZS5fZmx1c2hTeW5jKSB7XG4gICAgICBwZW5kaW5nRWRpdG9yU3RhdGUuX2ZsdXNoU3luYyA9IGZhbHNlO1xuICAgICAgJGNvbW1pdFBlbmRpbmdVcGRhdGVzKGVkaXRvcik7XG4gICAgfSBlbHNlIGlmIChlZGl0b3JTdGF0ZVdhc0Nsb25lZCkge1xuICAgICAgc2NoZWR1bGVNaWNyb1Rhc2soKCkgPT4ge1xuICAgICAgICAkY29tbWl0UGVuZGluZ1VwZGF0ZXMoZWRpdG9yKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwZW5kaW5nRWRpdG9yU3RhdGUuX2ZsdXNoU3luYyA9IGZhbHNlO1xuICAgIGlmIChlZGl0b3JTdGF0ZVdhc0Nsb25lZCkge1xuICAgICAgdXBkYXRlVGFncy5jbGVhcigpO1xuICAgICAgZWRpdG9yLl9kZWZlcnJlZCA9IFtdO1xuICAgICAgZWRpdG9yLl9wZW5kaW5nRWRpdG9yU3RhdGUgPSBudWxsO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdXBkYXRlRWRpdG9yKGVkaXRvciwgdXBkYXRlRm4sIG9wdGlvbnMpIHtcbiAgaWYgKGVkaXRvci5fdXBkYXRpbmcpIHtcbiAgICBlZGl0b3IuX3VwZGF0ZXMucHVzaChbdXBkYXRlRm4sIG9wdGlvbnNdKTtcbiAgfSBlbHNlIHtcbiAgICAkYmVnaW5VcGRhdGUoZWRpdG9yLCB1cGRhdGVGbiwgb3B0aW9ucyk7XG4gIH1cbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWRlY2xhcmF0aW9uLW1lcmdpbmdcblxuLyoqXG4gKiBBIHV0aWxpdHkgY2xhc3MgZm9yIG1hbmFnaW5nIHRoZSBET00gY2hpbGRyZW4gb2YgYW4gRWxlbWVudE5vZGVcbiAqL1xuY2xhc3MgRWxlbWVudERPTVNsb3Qge1xuICBjb25zdHJ1Y3RvcigvKiogVGhlIGVsZW1lbnQgcmV0dXJuZWQgYnkgY3JlYXRlRE9NICovXG4gIGVsZW1lbnQsIC8qKiBBbGwgbWFuYWdlZCBjaGlsZHJlbiB3aWxsIGJlIGluc2VydGVkIGJlZm9yZSB0aGlzIG5vZGUsIGlmIGRlZmluZWQgKi9cbiAgYmVmb3JlLCAvKiogQWxsIG1hbmFnZWQgY2hpbGRyZW4gd2lsbCBiZSBpbnNlcnRlZCBhZnRlciB0aGlzIG5vZGUsIGlmIGRlZmluZWQgKi9cbiAgYWZ0ZXIpIHtcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuYmVmb3JlID0gYmVmb3JlIHx8IG51bGw7XG4gICAgdGhpcy5hZnRlciA9IGFmdGVyIHx8IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBhIG5ldyBFbGVtZW50RE9NU2xvdCB3aGVyZSBhbGwgbWFuYWdlZCBjaGlsZHJlbiB3aWxsIGJlIGluc2VydGVkIGJlZm9yZSB0aGlzIG5vZGVcbiAgICovXG4gIHdpdGhCZWZvcmUoYmVmb3JlKSB7XG4gICAgcmV0dXJuIG5ldyBFbGVtZW50RE9NU2xvdCh0aGlzLmVsZW1lbnQsIGJlZm9yZSwgdGhpcy5hZnRlcik7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBhIG5ldyBFbGVtZW50RE9NU2xvdCB3aGVyZSBhbGwgbWFuYWdlZCBjaGlsZHJlbiB3aWxsIGJlIGluc2VydGVkIGFmdGVyIHRoaXMgbm9kZVxuICAgKi9cbiAgd2l0aEFmdGVyKGFmdGVyKSB7XG4gICAgcmV0dXJuIG5ldyBFbGVtZW50RE9NU2xvdCh0aGlzLmVsZW1lbnQsIHRoaXMuYmVmb3JlLCBhZnRlcik7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBhIG5ldyBFbGVtZW50RE9NU2xvdCB3aXRoIGFuIHVwZGF0ZWQgcm9vdCBlbGVtZW50XG4gICAqL1xuICB3aXRoRWxlbWVudChlbGVtZW50KSB7XG4gICAgcmV0dXJuIG5ldyBFbGVtZW50RE9NU2xvdChlbGVtZW50LCB0aGlzLmJlZm9yZSwgdGhpcy5hZnRlcik7XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydCB0aGUgZ2l2ZW4gY2hpbGQgYmVmb3JlIHRoaXMuYmVmb3JlIGFuZCBhbnkgcmVjb25jaWxlciBtYW5hZ2VkIGxpbmUgYnJlYWsgbm9kZSxcbiAgICogb3IgYXBwZW5kIGl0IGlmIHRoaXMuYmVmb3JlIGlzIG5vdCBkZWZpbmVkXG4gICAqL1xuICBpbnNlcnRDaGlsZChkb20pIHtcbiAgICBjb25zdCBiZWZvcmUgPSB0aGlzLmJlZm9yZSB8fCB0aGlzLmdldE1hbmFnZWRMaW5lQnJlYWsoKTtcbiAgICBpZiAoIShiZWZvcmUgPT09IG51bGwgfHwgYmVmb3JlLnBhcmVudEVsZW1lbnQgPT09IHRoaXMuZWxlbWVudCkpIHtcbiAgICAgIHRocm93IEVycm9yKGBFbGVtZW50RE9NU2xvdC5pbnNlcnRDaGlsZDogYmVmb3JlIGlzIG5vdCBpbiBlbGVtZW50YCk7XG4gICAgfVxuICAgIHRoaXMuZWxlbWVudC5pbnNlcnRCZWZvcmUoZG9tLCBiZWZvcmUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIG1hbmFnZWQgY2hpbGQgZnJvbSB0aGlzIGNvbnRhaW5lciwgd2lsbCB0aHJvdyBpZiBpdCB3YXMgbm90IGFscmVhZHkgdGhlcmVcbiAgICovXG4gIHJlbW92ZUNoaWxkKGRvbSkge1xuICAgIGlmICghKGRvbS5wYXJlbnRFbGVtZW50ID09PSB0aGlzLmVsZW1lbnQpKSB7XG4gICAgICB0aHJvdyBFcnJvcihgRWxlbWVudERPTVNsb3QucmVtb3ZlQ2hpbGQ6IGRvbSBpcyBub3QgaW4gZWxlbWVudGApO1xuICAgIH1cbiAgICB0aGlzLmVsZW1lbnQucmVtb3ZlQ2hpbGQoZG9tKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogUmVwbGFjZSBtYW5hZ2VkIGNoaWxkIHByZXZEb20gd2l0aCBkb20uIFdpbGwgdGhyb3cgaWYgcHJldkRvbSBpcyBub3QgYSBjaGlsZFxuICAgKlxuICAgKiBAcGFyYW0gZG9tIFRoZSBuZXcgbm9kZSB0byByZXBsYWNlIHByZXZEb21cbiAgICogQHBhcmFtIHByZXZEb20gdGhlIG5vZGUgdGhhdCB3aWxsIGJlIHJlcGxhY2VkXG4gICAqL1xuICByZXBsYWNlQ2hpbGQoZG9tLCBwcmV2RG9tKSB7XG4gICAgaWYgKCEocHJldkRvbS5wYXJlbnRFbGVtZW50ID09PSB0aGlzLmVsZW1lbnQpKSB7XG4gICAgICB0aHJvdyBFcnJvcihgRWxlbWVudERPTVNsb3QucmVwbGFjZUNoaWxkOiBwcmV2RG9tIGlzIG5vdCBpbiBlbGVtZW50YCk7XG4gICAgfVxuICAgIHRoaXMuZWxlbWVudC5yZXBsYWNlQ2hpbGQoZG9tLCBwcmV2RG9tKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmlyc3QgbWFuYWdlZCBjaGlsZCBvZiB0aGlzIG5vZGUsXG4gICAqIHdoaWNoIHdpbGwgZWl0aGVyIGJlIHRoaXMuYWZ0ZXIubmV4dFNpYmxpbmcgb3IgdGhpcy5lbGVtZW50LmZpcnN0Q2hpbGQsXG4gICAqIGFuZCB3aWxsIG5ldmVyIGJlIHRoaXMuYmVmb3JlIGlmIGl0IGlzIGRlZmluZWQuXG4gICAqL1xuICBnZXRGaXJzdENoaWxkKCkge1xuICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSB0aGlzLmFmdGVyID8gdGhpcy5hZnRlci5uZXh0U2libGluZyA6IHRoaXMuZWxlbWVudC5maXJzdENoaWxkO1xuICAgIHJldHVybiBmaXJzdENoaWxkID09PSB0aGlzLmJlZm9yZSB8fCBmaXJzdENoaWxkID09PSB0aGlzLmdldE1hbmFnZWRMaW5lQnJlYWsoKSA/IG51bGwgOiBmaXJzdENoaWxkO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldE1hbmFnZWRMaW5lQnJlYWsoKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcbiAgICByZXR1cm4gZWxlbWVudC5fX2xleGljYWxMaW5lQnJlYWsgfHwgbnVsbDtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHNldE1hbmFnZWRMaW5lQnJlYWsobGluZUJyZWFrVHlwZSkge1xuICAgIGlmIChsaW5lQnJlYWtUeXBlID09PSBudWxsKSB7XG4gICAgICB0aGlzLnJlbW92ZU1hbmFnZWRMaW5lQnJlYWsoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgd2Via2l0SGFjayA9IGxpbmVCcmVha1R5cGUgPT09ICdkZWNvcmF0b3InICYmIChJU19JT1MgfHwgSVNfU0FGQVJJKTtcbiAgICAgIHRoaXMuaW5zZXJ0TWFuYWdlZExpbmVCcmVhayh3ZWJraXRIYWNrKTtcbiAgICB9XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHJlbW92ZU1hbmFnZWRMaW5lQnJlYWsoKSB7XG4gICAgY29uc3QgYnIgPSB0aGlzLmdldE1hbmFnZWRMaW5lQnJlYWsoKTtcbiAgICBpZiAoYnIpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG4gICAgICBjb25zdCBzaWJsaW5nID0gYnIubm9kZU5hbWUgPT09ICdJTUcnID8gYnIubmV4dFNpYmxpbmcgOiBudWxsO1xuICAgICAgaWYgKHNpYmxpbmcpIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVDaGlsZChzaWJsaW5nKTtcbiAgICAgIH1cbiAgICAgIGVsZW1lbnQucmVtb3ZlQ2hpbGQoYnIpO1xuICAgICAgZWxlbWVudC5fX2xleGljYWxMaW5lQnJlYWsgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgaW5zZXJ0TWFuYWdlZExpbmVCcmVhayh3ZWJraXRIYWNrKSB7XG4gICAgY29uc3QgcHJldkJyZWFrID0gdGhpcy5nZXRNYW5hZ2VkTGluZUJyZWFrKCk7XG4gICAgaWYgKHByZXZCcmVhaykge1xuICAgICAgaWYgKHdlYmtpdEhhY2sgPT09IChwcmV2QnJlYWsubm9kZU5hbWUgPT09ICdJTUcnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnJlbW92ZU1hbmFnZWRMaW5lQnJlYWsoKTtcbiAgICB9XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcbiAgICBjb25zdCBiZWZvcmUgPSB0aGlzLmJlZm9yZTtcbiAgICBjb25zdCBiciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2JyJyk7XG4gICAgZWxlbWVudC5pbnNlcnRCZWZvcmUoYnIsIGJlZm9yZSk7XG4gICAgaWYgKHdlYmtpdEhhY2spIHtcbiAgICAgIGNvbnN0IGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICAgICAgaW1nLnNldEF0dHJpYnV0ZSgnZGF0YS1sZXhpY2FsLWxpbmVicmVhaycsICd0cnVlJyk7XG4gICAgICBpbWcuc3R5bGUuY3NzVGV4dCA9ICdkaXNwbGF5OiBpbmxpbmUgIWltcG9ydGFudDsgYm9yZGVyOiAwcHggIWltcG9ydGFudDsgbWFyZ2luOiAwcHggIWltcG9ydGFudDsnO1xuICAgICAgaW1nLmFsdCA9ICcnO1xuICAgICAgZWxlbWVudC5pbnNlcnRCZWZvcmUoaW1nLCBicik7XG4gICAgICBlbGVtZW50Ll9fbGV4aWNhbExpbmVCcmVhayA9IGltZztcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5fX2xleGljYWxMaW5lQnJlYWsgPSBicjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqXG4gICAqIFJldHVybnMgdGhlIG9mZnNldCBvZiB0aGUgZmlyc3QgY2hpbGRcbiAgICovXG4gIGdldEZpcnN0Q2hpbGRPZmZzZXQoKSB7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAobGV0IG5vZGUgPSB0aGlzLmFmdGVyOyBub2RlICE9PSBudWxsOyBub2RlID0gbm9kZS5wcmV2aW91c1NpYmxpbmcpIHtcbiAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIGk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICByZXNvbHZlQ2hpbGRJbmRleChlbGVtZW50LCBlbGVtZW50RE9NLCBpbml0aWFsRE9NLCBpbml0aWFsT2Zmc2V0KSB7XG4gICAgaWYgKGluaXRpYWxET00gPT09IHRoaXMuZWxlbWVudCkge1xuICAgICAgY29uc3QgZmlyc3RDaGlsZE9mZnNldCA9IHRoaXMuZ2V0Rmlyc3RDaGlsZE9mZnNldCgpO1xuICAgICAgcmV0dXJuIFtlbGVtZW50LCBNYXRoLm1pbihmaXJzdENoaWxkT2Zmc2V0ICsgZWxlbWVudC5nZXRDaGlsZHJlblNpemUoKSwgTWF0aC5tYXgoZmlyc3RDaGlsZE9mZnNldCwgaW5pdGlhbE9mZnNldCkpXTtcbiAgICB9XG4gICAgLy8gVGhlIHJlc29sdmVkIG9mZnNldCBtdXN0IGJlIGJlZm9yZSBvciBhZnRlciB0aGUgY2hpbGRyZW5cbiAgICBjb25zdCBpbml0aWFsUGF0aCA9IGluZGV4UGF0aChlbGVtZW50RE9NLCBpbml0aWFsRE9NKTtcbiAgICBpbml0aWFsUGF0aC5wdXNoKGluaXRpYWxPZmZzZXQpO1xuICAgIGNvbnN0IGVsZW1lbnRQYXRoID0gaW5kZXhQYXRoKGVsZW1lbnRET00sIHRoaXMuZWxlbWVudCk7XG4gICAgbGV0IG9mZnNldCA9IGVsZW1lbnQuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnRQYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB0YXJnZXQgPSBpbml0aWFsUGF0aFtpXTtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IGVsZW1lbnRQYXRoW2ldO1xuICAgICAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkIHx8IHRhcmdldCA8IHNvdXJjZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAodGFyZ2V0ID4gc291cmNlKSB7XG4gICAgICAgIG9mZnNldCArPSAxO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtlbGVtZW50LmdldFBhcmVudE9yVGhyb3coKSwgb2Zmc2V0XTtcbiAgfVxufVxuZnVuY3Rpb24gaW5kZXhQYXRoKHJvb3QsIGNoaWxkKSB7XG4gIGNvbnN0IHBhdGggPSBbXTtcbiAgbGV0IG5vZGUgPSBjaGlsZDtcbiAgZm9yICg7IG5vZGUgIT09IHJvb3QgJiYgbm9kZSAhPT0gbnVsbDsgbm9kZSA9IGNoaWxkLnBhcmVudE5vZGUpIHtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChsZXQgc2libGluZyA9IG5vZGUucHJldmlvdXNTaWJsaW5nOyBzaWJsaW5nICE9PSBudWxsOyBzaWJsaW5nID0gbm9kZS5wcmV2aW91c1NpYmxpbmcpIHtcbiAgICAgIGkrKztcbiAgICB9XG4gICAgcGF0aC5wdXNoKGkpO1xuICB9XG4gIGlmICghKG5vZGUgPT09IHJvb3QpKSB7XG4gICAgdGhyb3cgRXJyb3IoYGluZGV4UGF0aDogcm9vdCBpcyBub3QgYSBwYXJlbnQgb2YgY2hpbGRgKTtcbiAgfVxuICByZXR1cm4gcGF0aC5yZXZlcnNlKCk7XG59XG5cbi8qKiBAbm9Jbmhlcml0RG9jICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1kZWNsYXJhdGlvbi1tZXJnaW5nXG5jbGFzcyBFbGVtZW50Tm9kZSBleHRlbmRzIExleGljYWxOb2RlIHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgY29uc3RydWN0b3Ioa2V5KSB7XG4gICAgc3VwZXIoa2V5KTtcbiAgICB0aGlzLl9fZmlyc3QgPSBudWxsO1xuICAgIHRoaXMuX19sYXN0ID0gbnVsbDtcbiAgICB0aGlzLl9fc2l6ZSA9IDA7XG4gICAgdGhpcy5fX2Zvcm1hdCA9IDA7XG4gICAgdGhpcy5fX3N0eWxlID0gJyc7XG4gICAgdGhpcy5fX2luZGVudCA9IDA7XG4gICAgdGhpcy5fX2RpciA9IG51bGw7XG4gICAgdGhpcy5fX3RleHRGb3JtYXQgPSAwO1xuICAgIHRoaXMuX190ZXh0U3R5bGUgPSAnJztcbiAgfVxuICBhZnRlckNsb25lRnJvbShwcmV2Tm9kZSkge1xuICAgIHN1cGVyLmFmdGVyQ2xvbmVGcm9tKHByZXZOb2RlKTtcbiAgICB0aGlzLl9fZmlyc3QgPSBwcmV2Tm9kZS5fX2ZpcnN0O1xuICAgIHRoaXMuX19sYXN0ID0gcHJldk5vZGUuX19sYXN0O1xuICAgIHRoaXMuX19zaXplID0gcHJldk5vZGUuX19zaXplO1xuICAgIHRoaXMuX19pbmRlbnQgPSBwcmV2Tm9kZS5fX2luZGVudDtcbiAgICB0aGlzLl9fZm9ybWF0ID0gcHJldk5vZGUuX19mb3JtYXQ7XG4gICAgdGhpcy5fX3N0eWxlID0gcHJldk5vZGUuX19zdHlsZTtcbiAgICB0aGlzLl9fZGlyID0gcHJldk5vZGUuX19kaXI7XG4gICAgdGhpcy5fX3RleHRGb3JtYXQgPSBwcmV2Tm9kZS5fX3RleHRGb3JtYXQ7XG4gICAgdGhpcy5fX3RleHRTdHlsZSA9IHByZXZOb2RlLl9fdGV4dFN0eWxlO1xuICB9XG4gIGdldEZvcm1hdCgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICByZXR1cm4gc2VsZi5fX2Zvcm1hdDtcbiAgfVxuICBnZXRGb3JtYXRUeXBlKCkge1xuICAgIGNvbnN0IGZvcm1hdCA9IHRoaXMuZ2V0Rm9ybWF0KCk7XG4gICAgcmV0dXJuIEVMRU1FTlRfRk9STUFUX1RPX1RZUEVbZm9ybWF0XSB8fCAnJztcbiAgfVxuICBnZXRTdHlsZSgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICByZXR1cm4gc2VsZi5fX3N0eWxlO1xuICB9XG4gIGdldEluZGVudCgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICByZXR1cm4gc2VsZi5fX2luZGVudDtcbiAgfVxuICBnZXRDaGlsZHJlbigpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IFtdO1xuICAgIGxldCBjaGlsZCA9IHRoaXMuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICBjaGlsZCA9IGNoaWxkLmdldE5leHRTaWJsaW5nKCk7XG4gICAgfVxuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuICBnZXRDaGlsZHJlbktleXMoKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBbXTtcbiAgICBsZXQgY2hpbGQgPSB0aGlzLmdldEZpcnN0Q2hpbGQoKTtcbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIGNoaWxkcmVuLnB1c2goY2hpbGQuX19rZXkpO1xuICAgICAgY2hpbGQgPSBjaGlsZC5nZXROZXh0U2libGluZygpO1xuICAgIH1cbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgZ2V0Q2hpbGRyZW5TaXplKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIHJldHVybiBzZWxmLl9fc2l6ZTtcbiAgfVxuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLmdldENoaWxkcmVuU2l6ZSgpID09PSAwO1xuICB9XG4gIGlzRGlydHkoKSB7XG4gICAgY29uc3QgZWRpdG9yID0gZ2V0QWN0aXZlRWRpdG9yKCk7XG4gICAgY29uc3QgZGlydHlFbGVtZW50cyA9IGVkaXRvci5fZGlydHlFbGVtZW50cztcbiAgICByZXR1cm4gZGlydHlFbGVtZW50cyAhPT0gbnVsbCAmJiBkaXJ0eUVsZW1lbnRzLmhhcyh0aGlzLl9fa2V5KTtcbiAgfVxuICBpc0xhc3RDaGlsZCgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICBjb25zdCBwYXJlbnRMYXN0Q2hpbGQgPSB0aGlzLmdldFBhcmVudE9yVGhyb3coKS5nZXRMYXN0Q2hpbGQoKTtcbiAgICByZXR1cm4gcGFyZW50TGFzdENoaWxkICE9PSBudWxsICYmIHBhcmVudExhc3RDaGlsZC5pcyhzZWxmKTtcbiAgfVxuICBnZXRBbGxUZXh0Tm9kZXMoKSB7XG4gICAgY29uc3QgdGV4dE5vZGVzID0gW107XG4gICAgbGV0IGNoaWxkID0gdGhpcy5nZXRGaXJzdENoaWxkKCk7XG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICBpZiAoJGlzVGV4dE5vZGUoY2hpbGQpKSB7XG4gICAgICAgIHRleHROb2Rlcy5wdXNoKGNoaWxkKTtcbiAgICAgIH1cbiAgICAgIGlmICgkaXNFbGVtZW50Tm9kZShjaGlsZCkpIHtcbiAgICAgICAgY29uc3Qgc3ViQ2hpbGRyZW5Ob2RlcyA9IGNoaWxkLmdldEFsbFRleHROb2RlcygpO1xuICAgICAgICB0ZXh0Tm9kZXMucHVzaCguLi5zdWJDaGlsZHJlbk5vZGVzKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkID0gY2hpbGQuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRleHROb2RlcztcbiAgfVxuICBnZXRGaXJzdERlc2NlbmRhbnQoKSB7XG4gICAgbGV0IG5vZGUgPSB0aGlzLmdldEZpcnN0Q2hpbGQoKTtcbiAgICB3aGlsZSAoJGlzRWxlbWVudE5vZGUobm9kZSkpIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gbm9kZS5nZXRGaXJzdENoaWxkKCk7XG4gICAgICBpZiAoY2hpbGQgPT09IG51bGwpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBub2RlID0gY2hpbGQ7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9XG4gIGdldExhc3REZXNjZW5kYW50KCkge1xuICAgIGxldCBub2RlID0gdGhpcy5nZXRMYXN0Q2hpbGQoKTtcbiAgICB3aGlsZSAoJGlzRWxlbWVudE5vZGUobm9kZSkpIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gbm9kZS5nZXRMYXN0Q2hpbGQoKTtcbiAgICAgIGlmIChjaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBjaGlsZDtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgZ2V0RGVzY2VuZGFudEJ5SW5kZXgoaW5kZXgpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuZ2V0Q2hpbGRyZW4oKTtcbiAgICBjb25zdCBjaGlsZHJlbkxlbmd0aCA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAvLyBGb3Igbm9uLWVtcHR5IGVsZW1lbnQgbm9kZXMsIHdlIHJlc29sdmUgaXRzIGRlc2NlbmRhbnRcbiAgICAvLyAoZWl0aGVyIGEgbGVhZiBub2RlIG9yIHRoZSBib3R0b20tbW9zdCBlbGVtZW50KVxuICAgIGlmIChpbmRleCA+PSBjaGlsZHJlbkxlbmd0aCkge1xuICAgICAgY29uc3QgcmVzb2x2ZWROb2RlID0gY2hpbGRyZW5bY2hpbGRyZW5MZW5ndGggLSAxXTtcbiAgICAgIHJldHVybiAkaXNFbGVtZW50Tm9kZShyZXNvbHZlZE5vZGUpICYmIHJlc29sdmVkTm9kZS5nZXRMYXN0RGVzY2VuZGFudCgpIHx8IHJlc29sdmVkTm9kZSB8fCBudWxsO1xuICAgIH1cbiAgICBjb25zdCByZXNvbHZlZE5vZGUgPSBjaGlsZHJlbltpbmRleF07XG4gICAgcmV0dXJuICRpc0VsZW1lbnROb2RlKHJlc29sdmVkTm9kZSkgJiYgcmVzb2x2ZWROb2RlLmdldEZpcnN0RGVzY2VuZGFudCgpIHx8IHJlc29sdmVkTm9kZSB8fCBudWxsO1xuICB9XG4gIGdldEZpcnN0Q2hpbGQoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0TGF0ZXN0KCk7XG4gICAgY29uc3QgZmlyc3RLZXkgPSBzZWxmLl9fZmlyc3Q7XG4gICAgcmV0dXJuIGZpcnN0S2V5ID09PSBudWxsID8gbnVsbCA6ICRnZXROb2RlQnlLZXkoZmlyc3RLZXkpO1xuICB9XG4gIGdldEZpcnN0Q2hpbGRPclRocm93KCkge1xuICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSB0aGlzLmdldEZpcnN0Q2hpbGQoKTtcbiAgICBpZiAoZmlyc3RDaGlsZCA9PT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgbm9kZSAke3RoaXMuX19rZXl9IHRvIGhhdmUgYSBmaXJzdCBjaGlsZC5gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZpcnN0Q2hpbGQ7XG4gIH1cbiAgZ2V0TGFzdENoaWxkKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIGNvbnN0IGxhc3RLZXkgPSBzZWxmLl9fbGFzdDtcbiAgICByZXR1cm4gbGFzdEtleSA9PT0gbnVsbCA/IG51bGwgOiAkZ2V0Tm9kZUJ5S2V5KGxhc3RLZXkpO1xuICB9XG4gIGdldExhc3RDaGlsZE9yVGhyb3coKSB7XG4gICAgY29uc3QgbGFzdENoaWxkID0gdGhpcy5nZXRMYXN0Q2hpbGQoKTtcbiAgICBpZiAobGFzdENoaWxkID09PSBudWxsKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCBub2RlICR7dGhpcy5fX2tleX0gdG8gaGF2ZSBhIGxhc3QgY2hpbGQuYCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsYXN0Q2hpbGQ7XG4gIH1cbiAgZ2V0Q2hpbGRBdEluZGV4KGluZGV4KSB7XG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMuZ2V0Q2hpbGRyZW5TaXplKCk7XG4gICAgbGV0IG5vZGU7XG4gICAgbGV0IGk7XG4gICAgaWYgKGluZGV4IDwgc2l6ZSAvIDIpIHtcbiAgICAgIG5vZGUgPSB0aGlzLmdldEZpcnN0Q2hpbGQoKTtcbiAgICAgIGkgPSAwO1xuICAgICAgd2hpbGUgKG5vZGUgIT09IG51bGwgJiYgaSA8PSBpbmRleCkge1xuICAgICAgICBpZiAoaSA9PT0gaW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5nZXROZXh0U2libGluZygpO1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbm9kZSA9IHRoaXMuZ2V0TGFzdENoaWxkKCk7XG4gICAgaSA9IHNpemUgLSAxO1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsICYmIGkgPj0gaW5kZXgpIHtcbiAgICAgIGlmIChpID09PSBpbmRleCkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlLmdldFByZXZpb3VzU2libGluZygpO1xuICAgICAgaS0tO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBnZXRUZXh0Q29udGVudCgpIHtcbiAgICBsZXQgdGV4dENvbnRlbnQgPSAnJztcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuZ2V0Q2hpbGRyZW4oKTtcbiAgICBjb25zdCBjaGlsZHJlbkxlbmd0aCA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICB0ZXh0Q29udGVudCArPSBjaGlsZC5nZXRUZXh0Q29udGVudCgpO1xuICAgICAgaWYgKCRpc0VsZW1lbnROb2RlKGNoaWxkKSAmJiBpICE9PSBjaGlsZHJlbkxlbmd0aCAtIDEgJiYgIWNoaWxkLmlzSW5saW5lKCkpIHtcbiAgICAgICAgdGV4dENvbnRlbnQgKz0gRE9VQkxFX0xJTkVfQlJFQUs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0ZXh0Q29udGVudDtcbiAgfVxuICBnZXRUZXh0Q29udGVudFNpemUoKSB7XG4gICAgbGV0IHRleHRDb250ZW50U2l6ZSA9IDA7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmdldENoaWxkcmVuKCk7XG4gICAgY29uc3QgY2hpbGRyZW5MZW5ndGggPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgdGV4dENvbnRlbnRTaXplICs9IGNoaWxkLmdldFRleHRDb250ZW50U2l6ZSgpO1xuICAgICAgaWYgKCRpc0VsZW1lbnROb2RlKGNoaWxkKSAmJiBpICE9PSBjaGlsZHJlbkxlbmd0aCAtIDEgJiYgIWNoaWxkLmlzSW5saW5lKCkpIHtcbiAgICAgICAgdGV4dENvbnRlbnRTaXplICs9IERPVUJMRV9MSU5FX0JSRUFLLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRleHRDb250ZW50U2l6ZTtcbiAgfVxuICBnZXREaXJlY3Rpb24oKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0TGF0ZXN0KCk7XG4gICAgcmV0dXJuIHNlbGYuX19kaXI7XG4gIH1cbiAgZ2V0VGV4dEZvcm1hdCgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICByZXR1cm4gc2VsZi5fX3RleHRGb3JtYXQ7XG4gIH1cbiAgaGFzRm9ybWF0KHR5cGUpIHtcbiAgICBpZiAodHlwZSAhPT0gJycpIHtcbiAgICAgIGNvbnN0IGZvcm1hdEZsYWcgPSBFTEVNRU5UX1RZUEVfVE9fRk9STUFUW3R5cGVdO1xuICAgICAgcmV0dXJuICh0aGlzLmdldEZvcm1hdCgpICYgZm9ybWF0RmxhZykgIT09IDA7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBoYXNUZXh0Rm9ybWF0KHR5cGUpIHtcbiAgICBjb25zdCBmb3JtYXRGbGFnID0gVEVYVF9UWVBFX1RPX0ZPUk1BVFt0eXBlXTtcbiAgICByZXR1cm4gKHRoaXMuZ2V0VGV4dEZvcm1hdCgpICYgZm9ybWF0RmxhZykgIT09IDA7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZvcm1hdCBmbGFncyBhcHBsaWVkIHRvIHRoZSBub2RlIGFzIGEgMzItYml0IGludGVnZXIuXG4gICAqXG4gICAqIEByZXR1cm5zIGEgbnVtYmVyIHJlcHJlc2VudGluZyB0aGUgVGV4dEZvcm1hdFR5cGVzIGFwcGxpZWQgdG8gdGhlIG5vZGUuXG4gICAqL1xuICBnZXRGb3JtYXRGbGFncyh0eXBlLCBhbGlnbldpdGhGb3JtYXQpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICBjb25zdCBmb3JtYXQgPSBzZWxmLl9fdGV4dEZvcm1hdDtcbiAgICByZXR1cm4gdG9nZ2xlVGV4dEZvcm1hdFR5cGUoZm9ybWF0LCB0eXBlLCBhbGlnbldpdGhGb3JtYXQpO1xuICB9XG4gIGdldFRleHRTdHlsZSgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICByZXR1cm4gc2VsZi5fX3RleHRTdHlsZTtcbiAgfVxuXG4gIC8vIE11dGF0b3JzXG5cbiAgc2VsZWN0KF9hbmNob3JPZmZzZXQsIF9mb2N1c09mZnNldCkge1xuICAgIGVycm9yT25SZWFkT25seSgpO1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBsZXQgYW5jaG9yT2Zmc2V0ID0gX2FuY2hvck9mZnNldDtcbiAgICBsZXQgZm9jdXNPZmZzZXQgPSBfZm9jdXNPZmZzZXQ7XG4gICAgY29uc3QgY2hpbGRyZW5Db3VudCA9IHRoaXMuZ2V0Q2hpbGRyZW5TaXplKCk7XG4gICAgaWYgKCF0aGlzLmNhbkJlRW1wdHkoKSkge1xuICAgICAgaWYgKF9hbmNob3JPZmZzZXQgPT09IDAgJiYgX2ZvY3VzT2Zmc2V0ID09PSAwKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSB0aGlzLmdldEZpcnN0Q2hpbGQoKTtcbiAgICAgICAgaWYgKCRpc1RleHROb2RlKGZpcnN0Q2hpbGQpIHx8ICRpc0VsZW1lbnROb2RlKGZpcnN0Q2hpbGQpKSB7XG4gICAgICAgICAgcmV0dXJuIGZpcnN0Q2hpbGQuc2VsZWN0KDAsIDApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKChfYW5jaG9yT2Zmc2V0ID09PSB1bmRlZmluZWQgfHwgX2FuY2hvck9mZnNldCA9PT0gY2hpbGRyZW5Db3VudCkgJiYgKF9mb2N1c09mZnNldCA9PT0gdW5kZWZpbmVkIHx8IF9mb2N1c09mZnNldCA9PT0gY2hpbGRyZW5Db3VudCkpIHtcbiAgICAgICAgY29uc3QgbGFzdENoaWxkID0gdGhpcy5nZXRMYXN0Q2hpbGQoKTtcbiAgICAgICAgaWYgKCRpc1RleHROb2RlKGxhc3RDaGlsZCkgfHwgJGlzRWxlbWVudE5vZGUobGFzdENoaWxkKSkge1xuICAgICAgICAgIHJldHVybiBsYXN0Q2hpbGQuc2VsZWN0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFuY2hvck9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBhbmNob3JPZmZzZXQgPSBjaGlsZHJlbkNvdW50O1xuICAgIH1cbiAgICBpZiAoZm9jdXNPZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZm9jdXNPZmZzZXQgPSBjaGlsZHJlbkNvdW50O1xuICAgIH1cbiAgICBjb25zdCBrZXkgPSB0aGlzLl9fa2V5O1xuICAgIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuICRpbnRlcm5hbE1ha2VSYW5nZVNlbGVjdGlvbihrZXksIGFuY2hvck9mZnNldCwga2V5LCBmb2N1c09mZnNldCwgJ2VsZW1lbnQnLCAnZWxlbWVudCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxlY3Rpb24uYW5jaG9yLnNldChrZXksIGFuY2hvck9mZnNldCwgJ2VsZW1lbnQnKTtcbiAgICAgIHNlbGVjdGlvbi5mb2N1cy5zZXQoa2V5LCBmb2N1c09mZnNldCwgJ2VsZW1lbnQnKTtcbiAgICAgIHNlbGVjdGlvbi5kaXJ0eSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBzZWxlY3Rpb247XG4gIH1cbiAgc2VsZWN0U3RhcnQoKSB7XG4gICAgY29uc3QgZmlyc3ROb2RlID0gdGhpcy5nZXRGaXJzdERlc2NlbmRhbnQoKTtcbiAgICByZXR1cm4gZmlyc3ROb2RlID8gZmlyc3ROb2RlLnNlbGVjdFN0YXJ0KCkgOiB0aGlzLnNlbGVjdCgpO1xuICB9XG4gIHNlbGVjdEVuZCgpIHtcbiAgICBjb25zdCBsYXN0Tm9kZSA9IHRoaXMuZ2V0TGFzdERlc2NlbmRhbnQoKTtcbiAgICByZXR1cm4gbGFzdE5vZGUgPyBsYXN0Tm9kZS5zZWxlY3RFbmQoKSA6IHRoaXMuc2VsZWN0KCk7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgY29uc3Qgd3JpdGFibGVTZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5nZXRDaGlsZHJlbigpO1xuICAgIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4gY2hpbGQucmVtb3ZlKCkpO1xuICAgIHJldHVybiB3cml0YWJsZVNlbGY7XG4gIH1cbiAgYXBwZW5kKC4uLm5vZGVzVG9BcHBlbmQpIHtcbiAgICByZXR1cm4gdGhpcy5zcGxpY2UodGhpcy5nZXRDaGlsZHJlblNpemUoKSwgMCwgbm9kZXNUb0FwcGVuZCk7XG4gIH1cbiAgc2V0RGlyZWN0aW9uKGRpcmVjdGlvbikge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgc2VsZi5fX2RpciA9IGRpcmVjdGlvbjtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICBzZXRGb3JtYXQodHlwZSkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgc2VsZi5fX2Zvcm1hdCA9IHR5cGUgIT09ICcnID8gRUxFTUVOVF9UWVBFX1RPX0ZPUk1BVFt0eXBlXSA6IDA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2V0U3R5bGUoc3R5bGUpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX19zdHlsZSA9IHN0eWxlIHx8ICcnO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNldFRleHRGb3JtYXQodHlwZSkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgc2VsZi5fX3RleHRGb3JtYXQgPSB0eXBlO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIHNldFRleHRTdHlsZShzdHlsZSkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgc2VsZi5fX3RleHRTdHlsZSA9IHN0eWxlO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIHNldEluZGVudChpbmRlbnRMZXZlbCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgc2VsZi5fX2luZGVudCA9IGluZGVudExldmVsO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNwbGljZShzdGFydCwgZGVsZXRlQ291bnQsIG5vZGVzVG9JbnNlcnQpIHtcbiAgICBjb25zdCBub2Rlc1RvSW5zZXJ0TGVuZ3RoID0gbm9kZXNUb0luc2VydC5sZW5ndGg7XG4gICAgY29uc3Qgb2xkU2l6ZSA9IHRoaXMuZ2V0Q2hpbGRyZW5TaXplKCk7XG4gICAgY29uc3Qgd3JpdGFibGVTZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIGlmICghKHN0YXJ0ICsgZGVsZXRlQ291bnQgPD0gb2xkU2l6ZSkpIHtcbiAgICAgIHRocm93IEVycm9yKGBFbGVtZW50Tm9kZS5zcGxpY2U6IHN0YXJ0ICsgZGVsZXRlQ291bnQgPiBvbGRTaXplICgke1N0cmluZyhzdGFydCl9ICsgJHtTdHJpbmcoZGVsZXRlQ291bnQpfSA+ICR7U3RyaW5nKG9sZFNpemUpfSlgKTtcbiAgICB9XG4gICAgY29uc3Qgd3JpdGFibGVTZWxmS2V5ID0gd3JpdGFibGVTZWxmLl9fa2V5O1xuICAgIGNvbnN0IG5vZGVzVG9JbnNlcnRLZXlzID0gW107XG4gICAgY29uc3Qgbm9kZXNUb1JlbW92ZUtleXMgPSBbXTtcbiAgICBjb25zdCBub2RlQWZ0ZXJSYW5nZSA9IHRoaXMuZ2V0Q2hpbGRBdEluZGV4KHN0YXJ0ICsgZGVsZXRlQ291bnQpO1xuICAgIGxldCBub2RlQmVmb3JlUmFuZ2UgPSBudWxsO1xuICAgIGxldCBuZXdTaXplID0gb2xkU2l6ZSAtIGRlbGV0ZUNvdW50ICsgbm9kZXNUb0luc2VydExlbmd0aDtcbiAgICBpZiAoc3RhcnQgIT09IDApIHtcbiAgICAgIGlmIChzdGFydCA9PT0gb2xkU2l6ZSkge1xuICAgICAgICBub2RlQmVmb3JlUmFuZ2UgPSB0aGlzLmdldExhc3RDaGlsZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuZ2V0Q2hpbGRBdEluZGV4KHN0YXJ0KTtcbiAgICAgICAgaWYgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICBub2RlQmVmb3JlUmFuZ2UgPSBub2RlLmdldFByZXZpb3VzU2libGluZygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkZWxldGVDb3VudCA+IDApIHtcbiAgICAgIGxldCBub2RlVG9EZWxldGUgPSBub2RlQmVmb3JlUmFuZ2UgPT09IG51bGwgPyB0aGlzLmdldEZpcnN0Q2hpbGQoKSA6IG5vZGVCZWZvcmVSYW5nZS5nZXROZXh0U2libGluZygpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWxldGVDb3VudDsgaSsrKSB7XG4gICAgICAgIGlmIChub2RlVG9EZWxldGUgPT09IG51bGwpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgc3BsaWNlOiBzaWJsaW5nIG5vdCBmb3VuZGApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXh0U2libGluZyA9IG5vZGVUb0RlbGV0ZS5nZXROZXh0U2libGluZygpO1xuICAgICAgICBjb25zdCBub2RlS2V5VG9EZWxldGUgPSBub2RlVG9EZWxldGUuX19rZXk7XG4gICAgICAgIGNvbnN0IHdyaXRhYmxlTm9kZVRvRGVsZXRlID0gbm9kZVRvRGVsZXRlLmdldFdyaXRhYmxlKCk7XG4gICAgICAgIHJlbW92ZUZyb21QYXJlbnQod3JpdGFibGVOb2RlVG9EZWxldGUpO1xuICAgICAgICBub2Rlc1RvUmVtb3ZlS2V5cy5wdXNoKG5vZGVLZXlUb0RlbGV0ZSk7XG4gICAgICAgIG5vZGVUb0RlbGV0ZSA9IG5leHRTaWJsaW5nO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgcHJldk5vZGUgPSBub2RlQmVmb3JlUmFuZ2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlc1RvSW5zZXJ0TGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG5vZGVUb0luc2VydCA9IG5vZGVzVG9JbnNlcnRbaV07XG4gICAgICBpZiAocHJldk5vZGUgIT09IG51bGwgJiYgbm9kZVRvSW5zZXJ0LmlzKHByZXZOb2RlKSkge1xuICAgICAgICBub2RlQmVmb3JlUmFuZ2UgPSBwcmV2Tm9kZSA9IHByZXZOb2RlLmdldFByZXZpb3VzU2libGluZygpO1xuICAgICAgfVxuICAgICAgY29uc3Qgd3JpdGFibGVOb2RlVG9JbnNlcnQgPSBub2RlVG9JbnNlcnQuZ2V0V3JpdGFibGUoKTtcbiAgICAgIGlmICh3cml0YWJsZU5vZGVUb0luc2VydC5fX3BhcmVudCA9PT0gd3JpdGFibGVTZWxmS2V5KSB7XG4gICAgICAgIG5ld1NpemUtLTtcbiAgICAgIH1cbiAgICAgIHJlbW92ZUZyb21QYXJlbnQod3JpdGFibGVOb2RlVG9JbnNlcnQpO1xuICAgICAgY29uc3Qgbm9kZUtleVRvSW5zZXJ0ID0gbm9kZVRvSW5zZXJ0Ll9fa2V5O1xuICAgICAgaWYgKHByZXZOb2RlID09PSBudWxsKSB7XG4gICAgICAgIHdyaXRhYmxlU2VsZi5fX2ZpcnN0ID0gbm9kZUtleVRvSW5zZXJ0O1xuICAgICAgICB3cml0YWJsZU5vZGVUb0luc2VydC5fX3ByZXYgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgd3JpdGFibGVQcmV2Tm9kZSA9IHByZXZOb2RlLmdldFdyaXRhYmxlKCk7XG4gICAgICAgIHdyaXRhYmxlUHJldk5vZGUuX19uZXh0ID0gbm9kZUtleVRvSW5zZXJ0O1xuICAgICAgICB3cml0YWJsZU5vZGVUb0luc2VydC5fX3ByZXYgPSB3cml0YWJsZVByZXZOb2RlLl9fa2V5O1xuICAgICAgfVxuICAgICAgaWYgKG5vZGVUb0luc2VydC5fX2tleSA9PT0gd3JpdGFibGVTZWxmS2V5KSB7XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihgYXBwZW5kOiBhdHRlbXB0aW5nIHRvIGFwcGVuZCBzZWxmYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFNldCBjaGlsZCBwYXJlbnQgdG8gc2VsZlxuICAgICAgd3JpdGFibGVOb2RlVG9JbnNlcnQuX19wYXJlbnQgPSB3cml0YWJsZVNlbGZLZXk7XG4gICAgICBub2Rlc1RvSW5zZXJ0S2V5cy5wdXNoKG5vZGVLZXlUb0luc2VydCk7XG4gICAgICBwcmV2Tm9kZSA9IG5vZGVUb0luc2VydDtcbiAgICB9XG4gICAgaWYgKHN0YXJ0ICsgZGVsZXRlQ291bnQgPT09IG9sZFNpemUpIHtcbiAgICAgIGlmIChwcmV2Tm9kZSAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCB3cml0YWJsZVByZXZOb2RlID0gcHJldk5vZGUuZ2V0V3JpdGFibGUoKTtcbiAgICAgICAgd3JpdGFibGVQcmV2Tm9kZS5fX25leHQgPSBudWxsO1xuICAgICAgICB3cml0YWJsZVNlbGYuX19sYXN0ID0gcHJldk5vZGUuX19rZXk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlQWZ0ZXJSYW5nZSAhPT0gbnVsbCkge1xuICAgICAgY29uc3Qgd3JpdGFibGVOb2RlQWZ0ZXJSYW5nZSA9IG5vZGVBZnRlclJhbmdlLmdldFdyaXRhYmxlKCk7XG4gICAgICBpZiAocHJldk5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3Qgd3JpdGFibGVQcmV2Tm9kZSA9IHByZXZOb2RlLmdldFdyaXRhYmxlKCk7XG4gICAgICAgIHdyaXRhYmxlTm9kZUFmdGVyUmFuZ2UuX19wcmV2ID0gcHJldk5vZGUuX19rZXk7XG4gICAgICAgIHdyaXRhYmxlUHJldk5vZGUuX19uZXh0ID0gbm9kZUFmdGVyUmFuZ2UuX19rZXk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3cml0YWJsZU5vZGVBZnRlclJhbmdlLl9fcHJldiA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHdyaXRhYmxlU2VsZi5fX3NpemUgPSBuZXdTaXplO1xuXG4gICAgLy8gSW4gY2FzZSBvZiBkZWxldGlvbiB3ZSBuZWVkIHRvIGFkanVzdCBzZWxlY3Rpb24sIHVubGluayByZW1vdmVkIG5vZGVzXG4gICAgLy8gYW5kIGNsZWFuIHVwIG5vZGUgaXRzZWxmIGlmIGl0IGJlY29tZXMgZW1wdHkuIE5vbmUgb2YgdGhlc2UgbmVlZGVkXG4gICAgLy8gZm9yIGluc2VydGlvbi1vbmx5IGNhc2VzXG4gICAgaWYgKG5vZGVzVG9SZW1vdmVLZXlzLmxlbmd0aCkge1xuICAgICAgLy8gQWRqdXN0aW5nIHNlbGVjdGlvbiwgaW4gY2FzZSBub2RlIHRoYXQgd2FzIGFuY2hvci9mb2N1cyB3aWxsIGJlIGRlbGV0ZWRcbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICAgIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICAgIGNvbnN0IG5vZGVzVG9SZW1vdmVLZXlTZXQgPSBuZXcgU2V0KG5vZGVzVG9SZW1vdmVLZXlzKTtcbiAgICAgICAgY29uc3Qgbm9kZXNUb0luc2VydEtleVNldCA9IG5ldyBTZXQobm9kZXNUb0luc2VydEtleXMpO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgIGZvY3VzXG4gICAgICAgIH0gPSBzZWxlY3Rpb247XG4gICAgICAgIGlmIChpc1BvaW50UmVtb3ZlZChhbmNob3IsIG5vZGVzVG9SZW1vdmVLZXlTZXQsIG5vZGVzVG9JbnNlcnRLZXlTZXQpKSB7XG4gICAgICAgICAgbW92ZVNlbGVjdGlvblBvaW50VG9TaWJsaW5nKGFuY2hvciwgYW5jaG9yLmdldE5vZGUoKSwgdGhpcywgbm9kZUJlZm9yZVJhbmdlLCBub2RlQWZ0ZXJSYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUG9pbnRSZW1vdmVkKGZvY3VzLCBub2Rlc1RvUmVtb3ZlS2V5U2V0LCBub2Rlc1RvSW5zZXJ0S2V5U2V0KSkge1xuICAgICAgICAgIG1vdmVTZWxlY3Rpb25Qb2ludFRvU2libGluZyhmb2N1cywgZm9jdXMuZ2V0Tm9kZSgpLCB0aGlzLCBub2RlQmVmb3JlUmFuZ2UsIG5vZGVBZnRlclJhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDbGVhbnVwIGlmIG5vZGUgY2FuJ3QgYmUgZW1wdHlcbiAgICAgICAgaWYgKG5ld1NpemUgPT09IDAgJiYgIXRoaXMuY2FuQmVFbXB0eSgpICYmICEkaXNSb290T3JTaGFkb3dSb290KHRoaXMpKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gd3JpdGFibGVTZWxmO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICpcbiAgICogQW4gZXhwZXJpbWVudGFsIEFQSSB0aGF0IGFuIEVsZW1lbnROb2RlIGNhbiBvdmVycmlkZSB0byBjb250cm9sIHdoZXJlIGl0c1xuICAgKiBjaGlsZHJlbiBhcmUgaW5zZXJ0ZWQgaW50byB0aGUgRE9NLCB0aGlzIGlzIHVzZWZ1bCB0byBhZGQgYSB3cmFwcGluZyBub2RlXG4gICAqIG9yIGFjY2Vzc29yeSBub2RlcyBiZWZvcmUgb3IgYWZ0ZXIgdGhlIGNoaWxkcmVuLiBUaGUgcm9vdCBvZiB0aGUgbm9kZSByZXR1cm5lZFxuICAgKiBieSBjcmVhdGVET00gbXVzdCBzdGlsbCBiZSBleGFjdGx5IG9uZSBIVE1MRWxlbWVudC5cbiAgICovXG4gIGdldERPTVNsb3QoZWxlbWVudCkge1xuICAgIHJldHVybiBuZXcgRWxlbWVudERPTVNsb3QoZWxlbWVudCk7XG4gIH1cbiAgZXhwb3J0RE9NKGVkaXRvcikge1xuICAgIGNvbnN0IHtcbiAgICAgIGVsZW1lbnRcbiAgICB9ID0gc3VwZXIuZXhwb3J0RE9NKGVkaXRvcik7XG4gICAgaWYgKGlzSFRNTEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICAgIGNvbnN0IGluZGVudCA9IHRoaXMuZ2V0SW5kZW50KCk7XG4gICAgICBpZiAoaW5kZW50ID4gMCkge1xuICAgICAgICAvLyBwYWRkaW5nLWlubGluZS1zdGFydCBpcyBub3Qgd2lkZWx5IHN1cHBvcnRlZCBpbiBlbWFpbCBIVE1MXG4gICAgICAgIC8vIChzZWUgaHR0cHM6Ly93d3cuY2FuaWVtYWlsLmNvbS9mZWF0dXJlcy9jc3MtcGFkZGluZy1pbmxpbmUtc3RhcnQtZW5kLyksXG4gICAgICAgIC8vIElmIHlvdSB3YW50IHRvIHVzZSBIVE1MIG91dHB1dCBmb3IgZW1haWwsIGNvbnNpZGVyIG92ZXJyaWRpbmcgdGhlIHNlcmlhbGl6YXRpb25cbiAgICAgICAgLy8gdG8gdXNlIGBwYWRkaW5nLXJpZ2h0YCBpbiBSVEwgbGFuZ3VhZ2VzLCBgcGFkZGluZy1sZWZ0YCBpbiBgTFRSYCBsYW5ndWFnZXMsIG9yXG4gICAgICAgIC8vIGB0ZXh0LWluZGVudGAgaWYgeW91IGFyZSBvayB3aXRoIGZpcnN0LWxpbmUgaW5kZW50cy5cbiAgICAgICAgLy8gV2UgcmVjb21tZW5kIGtlZXBpbmcgbXVsdGlwbGVzIG9mIDQwcHggdG8gbWFpbnRhaW4gY29uc2lzdGVuY3kgd2l0aCBsaXN0LWl0ZW1zXG4gICAgICAgIC8vIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2xleGljYWwvcHVsbC80MDI1KVxuICAgICAgICBlbGVtZW50LnN0eWxlLnBhZGRpbmdJbmxpbmVTdGFydCA9IGAke2luZGVudCAqIDQwfXB4YDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGVsZW1lbnRcbiAgICB9O1xuICB9XG4gIC8vIEpTT04gc2VyaWFsaXphdGlvblxuICBleHBvcnRKU09OKCkge1xuICAgIGNvbnN0IGpzb24gPSB7XG4gICAgICBjaGlsZHJlbjogW10sXG4gICAgICBkaXJlY3Rpb246IHRoaXMuZ2V0RGlyZWN0aW9uKCksXG4gICAgICBmb3JtYXQ6IHRoaXMuZ2V0Rm9ybWF0VHlwZSgpLFxuICAgICAgaW5kZW50OiB0aGlzLmdldEluZGVudCgpLFxuICAgICAgLy8gQXMgYW4gZXhjZXB0aW9uIGhlcmUgd2UgaW52b2tlIHN1cGVyIGF0IHRoZSBlbmQgZm9yIGhpc3RvcmljYWwgcmVhc29ucy5cbiAgICAgIC8vIE5hbWVseSwgdG8gcHJlc2VydmUgdGhlIG9yZGVyIG9mIHRoZSBwcm9wZXJ0aWVzIGFuZCBub3QgdG8gYnJlYWsgdGhlIHRlc3RzXG4gICAgICAvLyB0aGF0IHVzZSB0aGUgc2VyaWFsaXplZCBzdHJpbmcgcmVwcmVzZW50YXRpb24uXG4gICAgICAuLi5zdXBlci5leHBvcnRKU09OKClcbiAgICB9O1xuICAgIGNvbnN0IHRleHRGb3JtYXQgPSB0aGlzLmdldFRleHRGb3JtYXQoKTtcbiAgICBjb25zdCB0ZXh0U3R5bGUgPSB0aGlzLmdldFRleHRTdHlsZSgpO1xuICAgIGlmICh0ZXh0Rm9ybWF0ICE9PSAwKSB7XG4gICAgICBqc29uLnRleHRGb3JtYXQgPSB0ZXh0Rm9ybWF0O1xuICAgIH1cbiAgICBpZiAodGV4dFN0eWxlICE9PSAnJykge1xuICAgICAganNvbi50ZXh0U3R5bGUgPSB0ZXh0U3R5bGU7XG4gICAgfVxuICAgIHJldHVybiBqc29uO1xuICB9XG4gIHVwZGF0ZUZyb21KU09OKHNlcmlhbGl6ZWROb2RlKSB7XG4gICAgcmV0dXJuIHN1cGVyLnVwZGF0ZUZyb21KU09OKHNlcmlhbGl6ZWROb2RlKS5zZXRGb3JtYXQoc2VyaWFsaXplZE5vZGUuZm9ybWF0KS5zZXRJbmRlbnQoc2VyaWFsaXplZE5vZGUuaW5kZW50KS5zZXREaXJlY3Rpb24oc2VyaWFsaXplZE5vZGUuZGlyZWN0aW9uKS5zZXRUZXh0Rm9ybWF0KHNlcmlhbGl6ZWROb2RlLnRleHRGb3JtYXQgfHwgMCkuc2V0VGV4dFN0eWxlKHNlcmlhbGl6ZWROb2RlLnRleHRTdHlsZSB8fCAnJyk7XG4gIH1cbiAgLy8gVGhlc2UgYXJlIGludGVuZGVkIHRvIGJlIGV4dGVuZHMgZm9yIHNwZWNpZmljIGVsZW1lbnQgaGV1cmlzdGljcy5cbiAgaW5zZXJ0TmV3QWZ0ZXIoc2VsZWN0aW9uLCByZXN0b3JlU2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY2FuSW5kZW50KCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qXG4gICAqIFRoaXMgbWV0aG9kIGNvbnRyb2xzIHRoZSBiZWhhdmlvciBvZiBhIHRoZSBub2RlIGR1cmluZyBiYWNrd2FyZHNcbiAgICogZGVsZXRpb24gKGkuZS4sIGJhY2tzcGFjZSkgd2hlbiBzZWxlY3Rpb24gaXMgYXQgdGhlIGJlZ2lubmluZyBvZlxuICAgKiB0aGUgbm9kZSAob2Zmc2V0IDApXG4gICAqL1xuICBjb2xsYXBzZUF0U3RhcnQoc2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGV4Y2x1ZGVGcm9tQ29weShkZXN0aW5hdGlvbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKiogQGRlcHJlY2F0ZWQgQGludGVybmFsICovXG4gIGNhblJlcGxhY2VXaXRoKHJlcGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqIEBkZXByZWNhdGVkIEBpbnRlcm5hbCAqL1xuICBjYW5JbnNlcnRBZnRlcihub2RlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY2FuQmVFbXB0eSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjYW5JbnNlcnRUZXh0QmVmb3JlKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNhbkluc2VydFRleHRBZnRlcigpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpc0lubGluZSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gQSBzaGFkb3cgcm9vdCBpcyBhIE5vZGUgdGhhdCBiZWhhdmVzIGxpa2UgUm9vdE5vZGUuIFRoZSBzaGFkb3cgcm9vdCAoYW5kIFJvb3ROb2RlKSBtYXJrIHRoZVxuICAvLyBlbmQgb2YgdGhlIGhpZXJjaGFyY2h5LCBtb3N0IGltcGxlbWVudGF0aW9ucyBzaG91bGQgdHJlYXQgaXQgYXMgdGhlcmUncyBub3RoaW5nICh1cHdhcmRzKVxuICAvLyBiZXlvbmQgdGhpcyBwb2ludC4gRm9yIGV4YW1wbGUsIG5vZGUuZ2V0VG9wTGV2ZWxFbGVtZW50KCksIHdoZW4gcGVyZm9ybWVkIGluc2lkZSBhIFRhYmxlQ2VsbE5vZGVcbiAgLy8gd2lsbCByZXR1cm4gdGhlIGltbWVkaWF0ZSBmaXJzdCBjaGlsZCB1bmRlcm5lYXRoIFRhYmxlQ2VsbE5vZGUgaW5zdGVhZCBvZiBSb290Tm9kZS5cbiAgaXNTaGFkb3dSb290KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKiogQGRlcHJlY2F0ZWQgQGludGVybmFsICovXG4gIGNhbk1lcmdlV2l0aChub2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGV4dHJhY3RXaXRoQ2hpbGQoY2hpbGQsIHNlbGVjdGlvbiwgZGVzdGluYXRpb24pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoaXMgbm9kZSwgd2hlbiBlbXB0eSwgY2FuIG1lcmdlIHdpdGggYSBmaXJzdCBibG9ja1xuICAgKiBvZiBub2RlcyBiZWluZyBpbnNlcnRlZC5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgc3BlY2lmaWNhbGx5IGNhbGxlZCBpbiB7QGxpbmsgUmFuZ2VTZWxlY3Rpb24uaW5zZXJ0Tm9kZXN9XG4gICAqIHRvIGRldGVybWluZSBtZXJnaW5nIGJlaGF2aW9yIGR1cmluZyBub2RlcyBpbnNlcnRpb24uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIEluIGEgTGlzdEl0ZW1Ob2RlIG9yIFF1b3RlTm9kZSBpbXBsZW1lbnRhdGlvbjpcbiAgICogY2FuTWVyZ2VXaGVuRW1wdHkoKTogdHJ1ZSB7XG4gICAqICByZXR1cm4gdHJ1ZTtcbiAgICogfVxuICAgKi9cbiAgY2FuTWVyZ2VXaGVuRW1wdHkoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICByZWNvbmNpbGVPYnNlcnZlZE11dGF0aW9uKGRvbSwgZWRpdG9yKSB7XG4gICAgY29uc3Qgc2xvdCA9IHRoaXMuZ2V0RE9NU2xvdChkb20pO1xuICAgIGxldCBjdXJyZW50RE9NID0gc2xvdC5nZXRGaXJzdENoaWxkKCk7XG4gICAgZm9yIChsZXQgY3VycmVudE5vZGUgPSB0aGlzLmdldEZpcnN0Q2hpbGQoKTsgY3VycmVudE5vZGU7IGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUuZ2V0TmV4dFNpYmxpbmcoKSkge1xuICAgICAgY29uc3QgY29ycmVjdERPTSA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkoY3VycmVudE5vZGUuZ2V0S2V5KCkpO1xuICAgICAgaWYgKGNvcnJlY3RET00gPT09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudERPTSA9PSBudWxsKSB7XG4gICAgICAgIHNsb3QuaW5zZXJ0Q2hpbGQoY29ycmVjdERPTSk7XG4gICAgICAgIGN1cnJlbnRET00gPSBjb3JyZWN0RE9NO1xuICAgICAgfSBlbHNlIGlmIChjdXJyZW50RE9NICE9PSBjb3JyZWN0RE9NKSB7XG4gICAgICAgIHNsb3QucmVwbGFjZUNoaWxkKGNvcnJlY3RET00sIGN1cnJlbnRET00pO1xuICAgICAgfVxuICAgICAgY3VycmVudERPTSA9IGN1cnJlbnRET00ubmV4dFNpYmxpbmc7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiAkaXNFbGVtZW50Tm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgRWxlbWVudE5vZGU7XG59XG5mdW5jdGlvbiBpc1BvaW50UmVtb3ZlZChwb2ludCwgbm9kZXNUb1JlbW92ZUtleVNldCwgbm9kZXNUb0luc2VydEtleVNldCkge1xuICBsZXQgbm9kZSA9IHBvaW50LmdldE5vZGUoKTtcbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBjb25zdCBub2RlS2V5ID0gbm9kZS5fX2tleTtcbiAgICBpZiAobm9kZXNUb1JlbW92ZUtleVNldC5oYXMobm9kZUtleSkgJiYgIW5vZGVzVG9JbnNlcnRLZXlTZXQuaGFzKG5vZGVLZXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbm9kZSA9IG5vZGUuZ2V0UGFyZW50KCk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuXG4vKiogQG5vSW5oZXJpdERvYyAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtZGVjbGFyYXRpb24tbWVyZ2luZ1xuY2xhc3MgRGVjb3JhdG9yTm9kZSBleHRlbmRzIExleGljYWxOb2RlIHtcbiAgLyoqXG4gICAqIFRoZSByZXR1cm5lZCB2YWx1ZSBpcyBhZGRlZCB0byB0aGUgTGV4aWNhbEVkaXRvci5fZGVjb3JhdG9yc1xuICAgKi9cbiAgZGVjb3JhdGUoZWRpdG9yLCBjb25maWcpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgZGVjb3JhdGU6IGJhc2UgbWV0aG9kIG5vdCBleHRlbmRlZGApO1xuICAgIH1cbiAgfVxuICBpc0lzb2xhdGVkKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpc0lubGluZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpc0tleWJvYXJkU2VsZWN0YWJsZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuZnVuY3Rpb24gJGlzRGVjb3JhdG9yTm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgRGVjb3JhdG9yTm9kZTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4vKiogQG5vSW5oZXJpdERvYyAqL1xuY2xhc3MgUm9vdE5vZGUgZXh0ZW5kcyBFbGVtZW50Tm9kZSB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICBzdGF0aWMgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gJ3Jvb3QnO1xuICB9XG4gIHN0YXRpYyBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IFJvb3ROb2RlKCk7XG4gIH1cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoJ3Jvb3QnKTtcbiAgICB0aGlzLl9fY2FjaGVkVGV4dCA9IG51bGw7XG4gIH1cbiAgZ2V0VG9wTGV2ZWxFbGVtZW50T3JUaHJvdygpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgZ2V0VG9wTGV2ZWxFbGVtZW50T3JUaHJvdzogcm9vdCBub2RlcyBhcmUgbm90IHRvcCBsZXZlbCBlbGVtZW50c2ApO1xuICAgIH1cbiAgfVxuICBnZXRUZXh0Q29udGVudCgpIHtcbiAgICBjb25zdCBjYWNoZWRUZXh0ID0gdGhpcy5fX2NhY2hlZFRleHQ7XG4gICAgaWYgKGlzQ3VycmVudGx5UmVhZE9ubHlNb2RlKCkgfHwgZ2V0QWN0aXZlRWRpdG9yKCkuX2RpcnR5VHlwZSA9PT0gTk9fRElSVFlfTk9ERVMpIHtcbiAgICAgIGlmIChjYWNoZWRUZXh0ICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBjYWNoZWRUZXh0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuZ2V0VGV4dENvbnRlbnQoKTtcbiAgfVxuICByZW1vdmUoKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYHJlbW92ZTogY2Fubm90IGJlIGNhbGxlZCBvbiByb290IG5vZGVzYCk7XG4gICAgfVxuICB9XG4gIHJlcGxhY2Uobm9kZSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGByZXBsYWNlOiBjYW5ub3QgYmUgY2FsbGVkIG9uIHJvb3Qgbm9kZXNgKTtcbiAgICB9XG4gIH1cbiAgaW5zZXJ0QmVmb3JlKG5vZGVUb0luc2VydCkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGBpbnNlcnRCZWZvcmU6IGNhbm5vdCBiZSBjYWxsZWQgb24gcm9vdCBub2Rlc2ApO1xuICAgIH1cbiAgfVxuICBpbnNlcnRBZnRlcihub2RlVG9JbnNlcnQpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgaW5zZXJ0QWZ0ZXI6IGNhbm5vdCBiZSBjYWxsZWQgb24gcm9vdCBub2Rlc2ApO1xuICAgIH1cbiAgfVxuXG4gIC8vIFZpZXdcblxuICB1cGRhdGVET00ocHJldk5vZGUsIGRvbSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIE11dGF0ZVxuXG4gIGFwcGVuZCguLi5ub2Rlc1RvQXBwZW5kKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlc1RvQXBwZW5kLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBub2RlID0gbm9kZXNUb0FwcGVuZFtpXTtcbiAgICAgIGlmICghJGlzRWxlbWVudE5vZGUobm9kZSkgJiYgISRpc0RlY29yYXRvck5vZGUobm9kZSkpIHtcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IEVycm9yKGByb290Tm9kZS5hcHBlbmQ6IE9ubHkgZWxlbWVudCBvciBkZWNvcmF0b3Igbm9kZXMgY2FuIGJlIGFwcGVuZGVkIHRvIHRoZSByb290IG5vZGVgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuYXBwZW5kKC4uLm5vZGVzVG9BcHBlbmQpO1xuICB9XG4gIHN0YXRpYyBpbXBvcnRKU09OKHNlcmlhbGl6ZWROb2RlKSB7XG4gICAgLy8gV2UgZG9uJ3QgY3JlYXRlIGEgcm9vdCwgYW5kIGluc3RlYWQgdXNlIHRoZSBleGlzdGluZyByb290LlxuICAgIHJldHVybiAkZ2V0Um9vdCgpLnVwZGF0ZUZyb21KU09OKHNlcmlhbGl6ZWROb2RlKTtcbiAgfVxuICBjb2xsYXBzZUF0U3RhcnQoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbmZ1bmN0aW9uICRjcmVhdGVSb290Tm9kZSgpIHtcbiAgcmV0dXJuIG5ldyBSb290Tm9kZSgpO1xufVxuZnVuY3Rpb24gJGlzUm9vdE5vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIFJvb3ROb2RlO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uIGVkaXRvclN0YXRlSGFzRGlydHlTZWxlY3Rpb24oZWRpdG9yU3RhdGUsIGVkaXRvcikge1xuICBjb25zdCBjdXJyZW50U2VsZWN0aW9uID0gZWRpdG9yLmdldEVkaXRvclN0YXRlKCkuX3NlbGVjdGlvbjtcbiAgY29uc3QgcGVuZGluZ1NlbGVjdGlvbiA9IGVkaXRvclN0YXRlLl9zZWxlY3Rpb247XG5cbiAgLy8gQ2hlY2sgaWYgd2UgbmVlZCB0byB1cGRhdGUgYmVjYXVzZSBvZiBjaGFuZ2VzIGluIHNlbGVjdGlvblxuICBpZiAocGVuZGluZ1NlbGVjdGlvbiAhPT0gbnVsbCkge1xuICAgIGlmIChwZW5kaW5nU2VsZWN0aW9uLmRpcnR5IHx8ICFwZW5kaW5nU2VsZWN0aW9uLmlzKGN1cnJlbnRTZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoY3VycmVudFNlbGVjdGlvbiAhPT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNsb25lRWRpdG9yU3RhdGUoY3VycmVudCkge1xuICByZXR1cm4gbmV3IEVkaXRvclN0YXRlKG5ldyBNYXAoY3VycmVudC5fbm9kZU1hcCkpO1xufVxuZnVuY3Rpb24gY3JlYXRlRW1wdHlFZGl0b3JTdGF0ZSgpIHtcbiAgcmV0dXJuIG5ldyBFZGl0b3JTdGF0ZShuZXcgTWFwKFtbJ3Jvb3QnLCAkY3JlYXRlUm9vdE5vZGUoKV1dKSk7XG59XG5mdW5jdGlvbiBleHBvcnROb2RlVG9KU09OKG5vZGUpIHtcbiAgY29uc3Qgc2VyaWFsaXplZE5vZGUgPSBub2RlLmV4cG9ydEpTT04oKTtcbiAgY29uc3Qgbm9kZUNsYXNzID0gbm9kZS5jb25zdHJ1Y3RvcjtcbiAgaWYgKHNlcmlhbGl6ZWROb2RlLnR5cGUgIT09IG5vZGVDbGFzcy5nZXRUeXBlKCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgTGV4aWNhbE5vZGU6IE5vZGUgJHtub2RlQ2xhc3MubmFtZX0gZG9lcyBub3QgbWF0Y2ggdGhlIHNlcmlhbGl6ZWQgdHlwZS4gQ2hlY2sgaWYgLmV4cG9ydEpTT04oKSBpcyBpbXBsZW1lbnRlZCBhbmQgaXQgaXMgcmV0dXJuaW5nIHRoZSBjb3JyZWN0IHR5cGUuYCk7XG4gICAgfVxuICB9XG4gIGlmICgkaXNFbGVtZW50Tm9kZShub2RlKSkge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRDaGlsZHJlbiA9IHNlcmlhbGl6ZWROb2RlLmNoaWxkcmVuO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShzZXJpYWxpemVkQ2hpbGRyZW4pKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKGBMZXhpY2FsTm9kZTogTm9kZSAke25vZGVDbGFzcy5uYW1lfSBpcyBhbiBlbGVtZW50IGJ1dCAuZXhwb3J0SlNPTigpIGRvZXMgbm90IGhhdmUgYSBjaGlsZHJlbiBhcnJheS5gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmdldENoaWxkcmVuKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWRDaGlsZE5vZGUgPSBleHBvcnROb2RlVG9KU09OKGNoaWxkKTtcbiAgICAgIHNlcmlhbGl6ZWRDaGlsZHJlbi5wdXNoKHNlcmlhbGl6ZWRDaGlsZE5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgcmV0dXJuIHNlcmlhbGl6ZWROb2RlO1xufVxuY2xhc3MgRWRpdG9yU3RhdGUge1xuICBjb25zdHJ1Y3Rvcihub2RlTWFwLCBzZWxlY3Rpb24pIHtcbiAgICB0aGlzLl9ub2RlTWFwID0gbm9kZU1hcDtcbiAgICB0aGlzLl9zZWxlY3Rpb24gPSBzZWxlY3Rpb24gfHwgbnVsbDtcbiAgICB0aGlzLl9mbHVzaFN5bmMgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkT25seSA9IGZhbHNlO1xuICB9XG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25vZGVNYXAuc2l6ZSA9PT0gMSAmJiB0aGlzLl9zZWxlY3Rpb24gPT09IG51bGw7XG4gIH1cbiAgcmVhZChjYWxsYmFja0ZuLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHJlYWRFZGl0b3JTdGF0ZShvcHRpb25zICYmIG9wdGlvbnMuZWRpdG9yIHx8IG51bGwsIHRoaXMsIGNhbGxiYWNrRm4pO1xuICB9XG4gIGNsb25lKHNlbGVjdGlvbikge1xuICAgIGNvbnN0IGVkaXRvclN0YXRlID0gbmV3IEVkaXRvclN0YXRlKHRoaXMuX25vZGVNYXAsIHNlbGVjdGlvbiA9PT0gdW5kZWZpbmVkID8gdGhpcy5fc2VsZWN0aW9uIDogc2VsZWN0aW9uKTtcbiAgICBlZGl0b3JTdGF0ZS5fcmVhZE9ubHkgPSB0cnVlO1xuICAgIHJldHVybiBlZGl0b3JTdGF0ZTtcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHJlYWRFZGl0b3JTdGF0ZShudWxsLCB0aGlzLCAoKSA9PiAoe1xuICAgICAgcm9vdDogZXhwb3J0Tm9kZVRvSlNPTigkZ2V0Um9vdCgpKVxuICAgIH0pKTtcbiAgfVxufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cblxuLy8gVE9ETzogQ2xlYW51cCBBcnRpZmljaWFsTm9kZV9fRE9fTk9UX1VTRSAjNTk2NlxuY2xhc3MgQXJ0aWZpY2lhbE5vZGVfX0RPX05PVF9VU0UgZXh0ZW5kcyBFbGVtZW50Tm9kZSB7XG4gIHN0YXRpYyBnZXRUeXBlKCkge1xuICAgIHJldHVybiAnYXJ0aWZpY2lhbCc7XG4gIH1cbiAgY3JlYXRlRE9NKGNvbmZpZykge1xuICAgIC8vIHRoaXMgaXNudCBzdXBwb3NlZCB0byBiZSB1c2VkIGFuZCBpcyBub3QgdXNlZCBhbnl3aGVyZSBidXQgZGVmaW5pbmcgaXQgdG8gYXBwZWFzZSB0aGUgQVBJXG4gICAgY29uc3QgZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgcmV0dXJuIGRvbTtcbiAgfVxufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8qKiBAbm9Jbmhlcml0RG9jICovXG5jbGFzcyBQYXJhZ3JhcGhOb2RlIGV4dGVuZHMgRWxlbWVudE5vZGUge1xuICBzdGF0aWMgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gJ3BhcmFncmFwaCc7XG4gIH1cbiAgc3RhdGljIGNsb25lKG5vZGUpIHtcbiAgICByZXR1cm4gbmV3IFBhcmFncmFwaE5vZGUobm9kZS5fX2tleSk7XG4gIH1cblxuICAvLyBWaWV3XG5cbiAgY3JlYXRlRE9NKGNvbmZpZykge1xuICAgIGNvbnN0IGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKTtcbiAgICBjb25zdCBjbGFzc05hbWVzID0gZ2V0Q2FjaGVkQ2xhc3NOYW1lQXJyYXkoY29uZmlnLnRoZW1lLCAncGFyYWdyYXBoJyk7XG4gICAgaWYgKGNsYXNzTmFtZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgZG9tQ2xhc3NMaXN0ID0gZG9tLmNsYXNzTGlzdDtcbiAgICAgIGRvbUNsYXNzTGlzdC5hZGQoLi4uY2xhc3NOYW1lcyk7XG4gICAgfVxuICAgIHJldHVybiBkb207XG4gIH1cbiAgdXBkYXRlRE9NKHByZXZOb2RlLCBkb20sIGNvbmZpZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGF0aWMgaW1wb3J0RE9NKCkge1xuICAgIHJldHVybiB7XG4gICAgICBwOiBub2RlID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246ICRjb252ZXJ0UGFyYWdyYXBoRWxlbWVudCxcbiAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxuICBleHBvcnRET00oZWRpdG9yKSB7XG4gICAgY29uc3Qge1xuICAgICAgZWxlbWVudFxuICAgIH0gPSBzdXBlci5leHBvcnRET00oZWRpdG9yKTtcbiAgICBpZiAoaXNIVE1MRWxlbWVudChlbGVtZW50KSkge1xuICAgICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICAgIGVsZW1lbnQuYXBwZW5kKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2JyJykpO1xuICAgICAgfVxuICAgICAgY29uc3QgZm9ybWF0VHlwZSA9IHRoaXMuZ2V0Rm9ybWF0VHlwZSgpO1xuICAgICAgZWxlbWVudC5zdHlsZS50ZXh0QWxpZ24gPSBmb3JtYXRUeXBlO1xuICAgICAgY29uc3QgZGlyZWN0aW9uID0gdGhpcy5nZXREaXJlY3Rpb24oKTtcbiAgICAgIGlmIChkaXJlY3Rpb24pIHtcbiAgICAgICAgZWxlbWVudC5kaXIgPSBkaXJlY3Rpb247XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBlbGVtZW50XG4gICAgfTtcbiAgfVxuICBzdGF0aWMgaW1wb3J0SlNPTihzZXJpYWxpemVkTm9kZSkge1xuICAgIHJldHVybiAkY3JlYXRlUGFyYWdyYXBoTm9kZSgpLnVwZGF0ZUZyb21KU09OKHNlcmlhbGl6ZWROb2RlKTtcbiAgfVxuICBleHBvcnRKU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdXBlci5leHBvcnRKU09OKCksXG4gICAgICAvLyBUaGVzZSBhcmUgaW5jbHVkZWQgZXhwbGljaXRseSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICAgIHRleHRGb3JtYXQ6IHRoaXMuZ2V0VGV4dEZvcm1hdCgpLFxuICAgICAgdGV4dFN0eWxlOiB0aGlzLmdldFRleHRTdHlsZSgpXG4gICAgfTtcbiAgfVxuXG4gIC8vIE11dGF0aW9uXG5cbiAgaW5zZXJ0TmV3QWZ0ZXIocmFuZ2VTZWxlY3Rpb24sIHJlc3RvcmVTZWxlY3Rpb24pIHtcbiAgICBjb25zdCBuZXdFbGVtZW50ID0gJGNyZWF0ZVBhcmFncmFwaE5vZGUoKTtcbiAgICBuZXdFbGVtZW50LnNldFRleHRGb3JtYXQocmFuZ2VTZWxlY3Rpb24uZm9ybWF0KTtcbiAgICBuZXdFbGVtZW50LnNldFRleHRTdHlsZShyYW5nZVNlbGVjdGlvbi5zdHlsZSk7XG4gICAgY29uc3QgZGlyZWN0aW9uID0gdGhpcy5nZXREaXJlY3Rpb24oKTtcbiAgICBuZXdFbGVtZW50LnNldERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgIG5ld0VsZW1lbnQuc2V0Rm9ybWF0KHRoaXMuZ2V0Rm9ybWF0VHlwZSgpKTtcbiAgICBuZXdFbGVtZW50LnNldFN0eWxlKHRoaXMuZ2V0VGV4dFN0eWxlKCkpO1xuICAgIHRoaXMuaW5zZXJ0QWZ0ZXIobmV3RWxlbWVudCwgcmVzdG9yZVNlbGVjdGlvbik7XG4gICAgcmV0dXJuIG5ld0VsZW1lbnQ7XG4gIH1cbiAgY29sbGFwc2VBdFN0YXJ0KCkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5nZXRDaGlsZHJlbigpO1xuICAgIC8vIElmIHdlIGhhdmUgYW4gZW1wdHkgKHRyaW1tZWQpIGZpcnN0IHBhcmFncmFwaCBhbmQgdHJ5IGFuZCByZW1vdmUgaXQsXG4gICAgLy8gZGVsZXRlIHRoZSBwYXJhZ3JhcGggYXMgbG9uZyBhcyB3ZSBoYXZlIGFub3RoZXIgc2libGluZyB0byBnbyB0b1xuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDAgfHwgJGlzVGV4dE5vZGUoY2hpbGRyZW5bMF0pICYmIGNoaWxkcmVuWzBdLmdldFRleHRDb250ZW50KCkudHJpbSgpID09PSAnJykge1xuICAgICAgY29uc3QgbmV4dFNpYmxpbmcgPSB0aGlzLmdldE5leHRTaWJsaW5nKCk7XG4gICAgICBpZiAobmV4dFNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5zZWxlY3ROZXh0KCk7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgcHJldlNpYmxpbmcgPSB0aGlzLmdldFByZXZpb3VzU2libGluZygpO1xuICAgICAgaWYgKHByZXZTaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0UHJldmlvdXMoKTtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gJGNvbnZlcnRQYXJhZ3JhcGhFbGVtZW50KGVsZW1lbnQpIHtcbiAgY29uc3Qgbm9kZSA9ICRjcmVhdGVQYXJhZ3JhcGhOb2RlKCk7XG4gIGlmIChlbGVtZW50LnN0eWxlKSB7XG4gICAgbm9kZS5zZXRGb3JtYXQoZWxlbWVudC5zdHlsZS50ZXh0QWxpZ24pO1xuICAgIHNldE5vZGVJbmRlbnRGcm9tRE9NKGVsZW1lbnQsIG5vZGUpO1xuICB9XG4gIHJldHVybiB7XG4gICAgbm9kZVxuICB9O1xufVxuZnVuY3Rpb24gJGNyZWF0ZVBhcmFncmFwaE5vZGUoKSB7XG4gIHJldHVybiAkYXBwbHlOb2RlUmVwbGFjZW1lbnQobmV3IFBhcmFncmFwaE5vZGUoKSk7XG59XG5mdW5jdGlvbiAkaXNQYXJhZ3JhcGhOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBQYXJhZ3JhcGhOb2RlO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8zODQxXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuXG5jb25zdCBERUZBVUxUX1NLSVBfSU5JVElBTElaQVRJT04gPSBmYWxzZTtcbmNvbnN0IENPTU1BTkRfUFJJT1JJVFlfRURJVE9SID0gMDtcbmNvbnN0IENPTU1BTkRfUFJJT1JJVFlfTE9XID0gMTtcbmNvbnN0IENPTU1BTkRfUFJJT1JJVFlfTk9STUFMID0gMjtcbmNvbnN0IENPTU1BTkRfUFJJT1JJVFlfSElHSCA9IDM7XG5jb25zdCBDT01NQU5EX1BSSU9SSVRZX0NSSVRJQ0FMID0gNDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuXG4vKipcbiAqIFR5cGUgaGVscGVyIGZvciBleHRyYWN0aW5nIHRoZSBwYXlsb2FkIHR5cGUgZnJvbSBhIGNvbW1hbmQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBjb25zdCBNWV9DT01NQU5EID0gY3JlYXRlQ29tbWFuZDxTb21lVHlwZT4oKTtcbiAqXG4gKiAvLyAuLi5cbiAqXG4gKiBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKE1ZX0NPTU1BTkQsIHBheWxvYWQgPT4ge1xuICogICAvLyBUeXBlIG9mIGBwYXlsb2FkYCBpcyBpbmZlcnJlZCBoZXJlLiBCdXQgbGV0cyBzYXkgd2Ugd2FudCB0byBleHRyYWN0IGEgZnVuY3Rpb24gdG8gZGVsZWdhdGUgdG9cbiAqICAgJGhhbmRsZU15Q29tbWFuZChlZGl0b3IsIHBheWxvYWQpO1xuICogICByZXR1cm4gdHJ1ZTtcbiAqIH0pO1xuICpcbiAqIGZ1bmN0aW9uICRoYW5kbGVNeUNvbW1hbmQoZWRpdG9yOiBMZXhpY2FsRWRpdG9yLCBwYXlsb2FkOiBDb21tYW5kUGF5bG9hZFR5cGU8dHlwZW9mIE1ZX0NPTU1BTkQ+KSB7XG4gKiAgIC8vIGBwYXlsb2FkYCBpcyBvZiB0eXBlIGBTb21lVHlwZWAsIGV4dHJhY3RlZCBmcm9tIHRoZSBjb21tYW5kLlxuICogfVxuICogYGBgXG4gKi9cblxuZnVuY3Rpb24gcmVzZXRFZGl0b3IoZWRpdG9yLCBwcmV2Um9vdEVsZW1lbnQsIG5leHRSb290RWxlbWVudCwgcGVuZGluZ0VkaXRvclN0YXRlKSB7XG4gIGNvbnN0IGtleU5vZGVNYXAgPSBlZGl0b3IuX2tleVRvRE9NTWFwO1xuICBrZXlOb2RlTWFwLmNsZWFyKCk7XG4gIGVkaXRvci5fZWRpdG9yU3RhdGUgPSBjcmVhdGVFbXB0eUVkaXRvclN0YXRlKCk7XG4gIGVkaXRvci5fcGVuZGluZ0VkaXRvclN0YXRlID0gcGVuZGluZ0VkaXRvclN0YXRlO1xuICBlZGl0b3IuX2NvbXBvc2l0aW9uS2V5ID0gbnVsbDtcbiAgZWRpdG9yLl9kaXJ0eVR5cGUgPSBOT19ESVJUWV9OT0RFUztcbiAgZWRpdG9yLl9jbG9uZU5vdE5lZWRlZC5jbGVhcigpO1xuICBlZGl0b3IuX2RpcnR5TGVhdmVzID0gbmV3IFNldCgpO1xuICBlZGl0b3IuX2RpcnR5RWxlbWVudHMuY2xlYXIoKTtcbiAgZWRpdG9yLl9ub3JtYWxpemVkTm9kZXMgPSBuZXcgU2V0KCk7XG4gIGVkaXRvci5fdXBkYXRlVGFncyA9IG5ldyBTZXQoKTtcbiAgZWRpdG9yLl91cGRhdGVzID0gW107XG4gIGVkaXRvci5fYmxvY2tDdXJzb3JFbGVtZW50ID0gbnVsbDtcbiAgY29uc3Qgb2JzZXJ2ZXIgPSBlZGl0b3IuX29ic2VydmVyO1xuICBpZiAob2JzZXJ2ZXIgIT09IG51bGwpIHtcbiAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgZWRpdG9yLl9vYnNlcnZlciA9IG51bGw7XG4gIH1cblxuICAvLyBSZW1vdmUgYWxsIHRoZSBET00gbm9kZXMgZnJvbSB0aGUgcm9vdCBlbGVtZW50XG4gIGlmIChwcmV2Um9vdEVsZW1lbnQgIT09IG51bGwpIHtcbiAgICBwcmV2Um9vdEVsZW1lbnQudGV4dENvbnRlbnQgPSAnJztcbiAgfVxuICBpZiAobmV4dFJvb3RFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgbmV4dFJvb3RFbGVtZW50LnRleHRDb250ZW50ID0gJyc7XG4gICAga2V5Tm9kZU1hcC5zZXQoJ3Jvb3QnLCBuZXh0Um9vdEVsZW1lbnQpO1xuICB9XG59XG5mdW5jdGlvbiBpbml0aWFsaXplQ29udmVyc2lvbkNhY2hlKG5vZGVzLCBhZGRpdGlvbmFsQ29udmVyc2lvbnMpIHtcbiAgY29uc3QgY29udmVyc2lvbkNhY2hlID0gbmV3IE1hcCgpO1xuICBjb25zdCBoYW5kbGVkQ29udmVyc2lvbnMgPSBuZXcgU2V0KCk7XG4gIGNvbnN0IGFkZENvbnZlcnNpb25zVG9DYWNoZSA9IG1hcCA9PiB7XG4gICAgT2JqZWN0LmtleXMobWFwKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBsZXQgY3VycmVudENhY2hlID0gY29udmVyc2lvbkNhY2hlLmdldChrZXkpO1xuICAgICAgaWYgKGN1cnJlbnRDYWNoZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGN1cnJlbnRDYWNoZSA9IFtdO1xuICAgICAgICBjb252ZXJzaW9uQ2FjaGUuc2V0KGtleSwgY3VycmVudENhY2hlKTtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnRDYWNoZS5wdXNoKG1hcFtrZXldKTtcbiAgICB9KTtcbiAgfTtcbiAgbm9kZXMuZm9yRWFjaChub2RlID0+IHtcbiAgICBjb25zdCBpbXBvcnRET00gPSBub2RlLmtsYXNzLmltcG9ydERPTTtcbiAgICBpZiAoaW1wb3J0RE9NID09IG51bGwgfHwgaGFuZGxlZENvbnZlcnNpb25zLmhhcyhpbXBvcnRET00pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGhhbmRsZWRDb252ZXJzaW9ucy5hZGQoaW1wb3J0RE9NKTtcbiAgICBjb25zdCBtYXAgPSBpbXBvcnRET00uY2FsbChub2RlLmtsYXNzKTtcbiAgICBpZiAobWFwICE9PSBudWxsKSB7XG4gICAgICBhZGRDb252ZXJzaW9uc1RvQ2FjaGUobWFwKTtcbiAgICB9XG4gIH0pO1xuICBpZiAoYWRkaXRpb25hbENvbnZlcnNpb25zKSB7XG4gICAgYWRkQ29udmVyc2lvbnNUb0NhY2hlKGFkZGl0aW9uYWxDb252ZXJzaW9ucyk7XG4gIH1cbiAgcmV0dXJuIGNvbnZlcnNpb25DYWNoZTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IExleGljYWxFZGl0b3IgYXR0YWNoZWQgdG8gYSBzaW5nbGUgY29udGVudEVkaXRhYmxlIChwcm92aWRlZCBpbiB0aGUgY29uZmlnKS4gVGhpcyBpc1xuICogdGhlIGxvd2VzdC1sZXZlbCBpbml0aWFsaXphdGlvbiBBUEkgZm9yIGEgTGV4aWNhbEVkaXRvci4gSWYgeW91J3JlIHVzaW5nIFJlYWN0IG9yIGFub3RoZXIgZnJhbWV3b3JrLFxuICogY29uc2lkZXIgdXNpbmcgdGhlIGFwcHJvcHJpYXRlIGFic3RyYWN0aW9ucywgc3VjaCBhcyBMZXhpY2FsQ29tcG9zZXJcbiAqIEBwYXJhbSBlZGl0b3JDb25maWcgLSB0aGUgZWRpdG9yIGNvbmZpZ3VyYXRpb24uXG4gKiBAcmV0dXJucyBhIExleGljYWxFZGl0b3IgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRWRpdG9yKGVkaXRvckNvbmZpZykge1xuICBjb25zdCBjb25maWcgPSBlZGl0b3JDb25maWcgfHwge307XG4gIGNvbnN0IGFjdGl2ZUVkaXRvciA9IGludGVybmFsR2V0QWN0aXZlRWRpdG9yKCk7XG4gIGNvbnN0IHRoZW1lID0gY29uZmlnLnRoZW1lIHx8IHt9O1xuICBjb25zdCBwYXJlbnRFZGl0b3IgPSBlZGl0b3JDb25maWcgPT09IHVuZGVmaW5lZCA/IGFjdGl2ZUVkaXRvciA6IGNvbmZpZy5wYXJlbnRFZGl0b3IgfHwgbnVsbDtcbiAgY29uc3QgZGlzYWJsZUV2ZW50cyA9IGNvbmZpZy5kaXNhYmxlRXZlbnRzIHx8IGZhbHNlO1xuICBjb25zdCBlZGl0b3JTdGF0ZSA9IGNyZWF0ZUVtcHR5RWRpdG9yU3RhdGUoKTtcbiAgY29uc3QgbmFtZXNwYWNlID0gY29uZmlnLm5hbWVzcGFjZSB8fCAocGFyZW50RWRpdG9yICE9PSBudWxsID8gcGFyZW50RWRpdG9yLl9jb25maWcubmFtZXNwYWNlIDogY3JlYXRlVUlEKCkpO1xuICBjb25zdCBpbml0aWFsRWRpdG9yU3RhdGUgPSBjb25maWcuZWRpdG9yU3RhdGU7XG4gIGNvbnN0IG5vZGVzID0gW1Jvb3ROb2RlLCBUZXh0Tm9kZSwgTGluZUJyZWFrTm9kZSwgVGFiTm9kZSwgUGFyYWdyYXBoTm9kZSwgQXJ0aWZpY2lhbE5vZGVfX0RPX05PVF9VU0UsIC4uLihjb25maWcubm9kZXMgfHwgW10pXTtcbiAgY29uc3Qge1xuICAgIG9uRXJyb3IsXG4gICAgaHRtbFxuICB9ID0gY29uZmlnO1xuICBjb25zdCBpc0VkaXRhYmxlID0gY29uZmlnLmVkaXRhYmxlICE9PSB1bmRlZmluZWQgPyBjb25maWcuZWRpdGFibGUgOiB0cnVlO1xuICBsZXQgcmVnaXN0ZXJlZE5vZGVzO1xuICBpZiAoZWRpdG9yQ29uZmlnID09PSB1bmRlZmluZWQgJiYgYWN0aXZlRWRpdG9yICE9PSBudWxsKSB7XG4gICAgcmVnaXN0ZXJlZE5vZGVzID0gYWN0aXZlRWRpdG9yLl9ub2RlcztcbiAgfSBlbHNlIHtcbiAgICByZWdpc3RlcmVkTm9kZXMgPSBuZXcgTWFwKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IGtsYXNzID0gbm9kZXNbaV07XG4gICAgICBsZXQgcmVwbGFjZSA9IG51bGw7XG4gICAgICBsZXQgcmVwbGFjZVdpdGhLbGFzcyA9IG51bGw7XG4gICAgICBpZiAodHlwZW9mIGtsYXNzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBrbGFzcztcbiAgICAgICAga2xhc3MgPSBvcHRpb25zLnJlcGxhY2U7XG4gICAgICAgIHJlcGxhY2UgPSBvcHRpb25zLndpdGg7XG4gICAgICAgIHJlcGxhY2VXaXRoS2xhc3MgPSBvcHRpb25zLndpdGhLbGFzcyB8fCBudWxsO1xuICAgICAgfVxuICAgICAgLy8gRW5zdXJlIGN1c3RvbSBub2RlcyBpbXBsZW1lbnQgcmVxdWlyZWQgbWV0aG9kcyBhbmQgcmVwbGFjZVdpdGhLbGFzcyBpcyBpbnN0YW5jZSBvZiBiYXNlIGtsYXNzLlxuICAgICAge1xuICAgICAgICAvLyBBcnRpZmljaWFsTm9kZV9fRE9fTk9UX1VTRSBjYW4gZ2V0IHJlbmFtZWQsIHNvIHdlIHVzZSB0aGUgdHlwZVxuICAgICAgICBjb25zdCBub2RlVHlwZSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChrbGFzcywgJ2dldFR5cGUnKSAmJiBrbGFzcy5nZXRUeXBlKCk7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBrbGFzcy5uYW1lO1xuICAgICAgICBpZiAocmVwbGFjZVdpdGhLbGFzcykge1xuICAgICAgICAgIGlmICghKHJlcGxhY2VXaXRoS2xhc3MucHJvdG90eXBlIGluc3RhbmNlb2Yga2xhc3MpKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgJHtyZXBsYWNlV2l0aEtsYXNzLm5hbWV9IGRvZXNuJ3QgZXh0ZW5kIHRoZSAke25hbWV9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lICE9PSAnUm9vdE5vZGUnICYmIG5vZGVUeXBlICE9PSAncm9vdCcgJiYgbm9kZVR5cGUgIT09ICdhcnRpZmljaWFsJykge1xuICAgICAgICAgIGNvbnN0IHByb3RvID0ga2xhc3MucHJvdG90eXBlO1xuICAgICAgICAgIFsnZ2V0VHlwZScsICdjbG9uZSddLmZvckVhY2gobWV0aG9kID0+IHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgICAgICAgICAgIGlmICgha2xhc3MuaGFzT3duUHJvcGVydHkobWV0aG9kKSkge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYCR7bmFtZX0gbXVzdCBpbXBsZW1lbnQgc3RhdGljIFwiJHttZXRob2R9XCIgbWV0aG9kYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgICAgICAgICAha2xhc3MuaGFzT3duUHJvcGVydHkoJ2ltcG9ydERPTScpICYmXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgICAgICAgIGtsYXNzLmhhc093blByb3BlcnR5KCdleHBvcnRET00nKSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGAke25hbWV9IHNob3VsZCBpbXBsZW1lbnQgXCJpbXBvcnRET01cIiBpZiB1c2luZyBhIGN1c3RvbSBcImV4cG9ydERPTVwiIG1ldGhvZCB0byBlbnN1cmUgSFRNTCBzZXJpYWxpemF0aW9uIChpbXBvcnRhbnQgZm9yIGNvcHkgJiBwYXN0ZSkgd29ya3MgYXMgZXhwZWN0ZWRgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCRpc0RlY29yYXRvck5vZGUocHJvdG8pKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgICAgICAgICBpZiAoIXByb3RvLmhhc093blByb3BlcnR5KCdkZWNvcmF0ZScpKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihgJHtwcm90by5jb25zdHJ1Y3Rvci5uYW1lfSBtdXN0IGltcGxlbWVudCBcImRlY29yYXRlXCIgbWV0aG9kYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgICAgICAgIWtsYXNzLmhhc093blByb3BlcnR5KCdpbXBvcnRKU09OJykpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgJHtuYW1lfSBzaG91bGQgaW1wbGVtZW50IFwiaW1wb3J0SlNPTlwiIG1ldGhvZCB0byBlbnN1cmUgSlNPTiBhbmQgZGVmYXVsdCBIVE1MIHNlcmlhbGl6YXRpb24gd29ya3MgYXMgZXhwZWN0ZWRgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHR5cGUgPSBrbGFzcy5nZXRUeXBlKCk7XG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSBrbGFzcy50cmFuc2Zvcm0oKTtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybXMgPSBuZXcgU2V0KCk7XG4gICAgICBpZiAodHJhbnNmb3JtICE9PSBudWxsKSB7XG4gICAgICAgIHRyYW5zZm9ybXMuYWRkKHRyYW5zZm9ybSk7XG4gICAgICB9XG4gICAgICByZWdpc3RlcmVkTm9kZXMuc2V0KHR5cGUsIHtcbiAgICAgICAgZXhwb3J0RE9NOiBodG1sICYmIGh0bWwuZXhwb3J0ID8gaHRtbC5leHBvcnQuZ2V0KGtsYXNzKSA6IHVuZGVmaW5lZCxcbiAgICAgICAga2xhc3MsXG4gICAgICAgIHJlcGxhY2UsXG4gICAgICAgIHJlcGxhY2VXaXRoS2xhc3MsXG4gICAgICAgIHRyYW5zZm9ybXNcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBjb25zdCBlZGl0b3IgPSBuZXcgTGV4aWNhbEVkaXRvcihlZGl0b3JTdGF0ZSwgcGFyZW50RWRpdG9yLCByZWdpc3RlcmVkTm9kZXMsIHtcbiAgICBkaXNhYmxlRXZlbnRzLFxuICAgIG5hbWVzcGFjZSxcbiAgICB0aGVtZVxuICB9LCBvbkVycm9yID8gb25FcnJvciA6IGNvbnNvbGUuZXJyb3IsIGluaXRpYWxpemVDb252ZXJzaW9uQ2FjaGUocmVnaXN0ZXJlZE5vZGVzLCBodG1sID8gaHRtbC5pbXBvcnQgOiB1bmRlZmluZWQpLCBpc0VkaXRhYmxlKTtcbiAgaWYgKGluaXRpYWxFZGl0b3JTdGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZWRpdG9yLl9wZW5kaW5nRWRpdG9yU3RhdGUgPSBpbml0aWFsRWRpdG9yU3RhdGU7XG4gICAgZWRpdG9yLl9kaXJ0eVR5cGUgPSBGVUxMX1JFQ09OQ0lMRTtcbiAgfVxuICByZXR1cm4gZWRpdG9yO1xufVxuY2xhc3MgTGV4aWNhbEVkaXRvciB7XG4gIC8qKiBUaGUgdmVyc2lvbiB3aXRoIGJ1aWxkIGlkZW50aWZpZXJzIGZvciB0aGlzIGVkaXRvciAoc2luY2UgMC4xNy4xKSAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBjb25zdHJ1Y3RvcihlZGl0b3JTdGF0ZSwgcGFyZW50RWRpdG9yLCBub2RlcywgY29uZmlnLCBvbkVycm9yLCBodG1sQ29udmVyc2lvbnMsIGVkaXRhYmxlKSB7XG4gICAgdGhpcy5fcGFyZW50RWRpdG9yID0gcGFyZW50RWRpdG9yO1xuICAgIC8vIFRoZSByb290IGVsZW1lbnQgYXNzb2NpYXRlZCB3aXRoIHRoaXMgZWRpdG9yXG4gICAgdGhpcy5fcm9vdEVsZW1lbnQgPSBudWxsO1xuICAgIC8vIFRoZSBjdXJyZW50IGVkaXRvciBzdGF0ZVxuICAgIHRoaXMuX2VkaXRvclN0YXRlID0gZWRpdG9yU3RhdGU7XG4gICAgLy8gSGFuZGxpbmcgb2YgZHJhZnRzIGFuZCB1cGRhdGVzXG4gICAgdGhpcy5fcGVuZGluZ0VkaXRvclN0YXRlID0gbnVsbDtcbiAgICAvLyBVc2VkIHRvIGhlbHAgY28tb3JkaW5hdGUgc2VsZWN0aW9uIGFuZCBldmVudHNcbiAgICB0aGlzLl9jb21wb3NpdGlvbktleSA9IG51bGw7XG4gICAgdGhpcy5fZGVmZXJyZWQgPSBbXTtcbiAgICAvLyBVc2VkIGR1cmluZyByZWNvbmNpbGlhdGlvblxuICAgIHRoaXMuX2tleVRvRE9NTWFwID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuX3VwZGF0ZXMgPSBbXTtcbiAgICB0aGlzLl91cGRhdGluZyA9IGZhbHNlO1xuICAgIC8vIExpc3RlbmVyc1xuICAgIHRoaXMuX2xpc3RlbmVycyA9IHtcbiAgICAgIGRlY29yYXRvcjogbmV3IFNldCgpLFxuICAgICAgZWRpdGFibGU6IG5ldyBTZXQoKSxcbiAgICAgIG11dGF0aW9uOiBuZXcgTWFwKCksXG4gICAgICByb290OiBuZXcgU2V0KCksXG4gICAgICB0ZXh0Y29udGVudDogbmV3IFNldCgpLFxuICAgICAgdXBkYXRlOiBuZXcgU2V0KClcbiAgICB9O1xuICAgIC8vIENvbW1hbmRzXG4gICAgdGhpcy5fY29tbWFuZHMgPSBuZXcgTWFwKCk7XG4gICAgLy8gRWRpdG9yIGNvbmZpZ3VyYXRpb24gZm9yIHRoZW1lL2NvbnRleHQuXG4gICAgdGhpcy5fY29uZmlnID0gY29uZmlnO1xuICAgIC8vIE1hcHBpbmcgb2YgdHlwZXMgdG8gdGhlaXIgbm9kZXNcbiAgICB0aGlzLl9ub2RlcyA9IG5vZGVzO1xuICAgIC8vIFJlYWN0IG5vZGUgZGVjb3JhdG9ycyBmb3IgcG9ydGFsc1xuICAgIHRoaXMuX2RlY29yYXRvcnMgPSB7fTtcbiAgICB0aGlzLl9wZW5kaW5nRGVjb3JhdG9ycyA9IG51bGw7XG4gICAgLy8gVXNlZCB0byBvcHRpbWl6ZSByZWNvbmNpbGlhdGlvblxuICAgIHRoaXMuX2RpcnR5VHlwZSA9IE5PX0RJUlRZX05PREVTO1xuICAgIHRoaXMuX2Nsb25lTm90TmVlZGVkID0gbmV3IFNldCgpO1xuICAgIHRoaXMuX2RpcnR5TGVhdmVzID0gbmV3IFNldCgpO1xuICAgIHRoaXMuX2RpcnR5RWxlbWVudHMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5fbm9ybWFsaXplZE5vZGVzID0gbmV3IFNldCgpO1xuICAgIHRoaXMuX3VwZGF0ZVRhZ3MgPSBuZXcgU2V0KCk7XG4gICAgLy8gSGFuZGxpbmcgb2YgRE9NIG11dGF0aW9uc1xuICAgIHRoaXMuX29ic2VydmVyID0gbnVsbDtcbiAgICAvLyBVc2VkIGZvciBpZGVudGlmeWluZyBvd25pbmcgZWRpdG9yc1xuICAgIHRoaXMuX2tleSA9IGNyZWF0ZVVJRCgpO1xuICAgIHRoaXMuX29uRXJyb3IgPSBvbkVycm9yO1xuICAgIHRoaXMuX2h0bWxDb252ZXJzaW9ucyA9IGh0bWxDb252ZXJzaW9ucztcbiAgICB0aGlzLl9lZGl0YWJsZSA9IGVkaXRhYmxlO1xuICAgIHRoaXMuX2hlYWRsZXNzID0gcGFyZW50RWRpdG9yICE9PSBudWxsICYmIHBhcmVudEVkaXRvci5faGVhZGxlc3M7XG4gICAgdGhpcy5fd2luZG93ID0gbnVsbDtcbiAgICB0aGlzLl9ibG9ja0N1cnNvckVsZW1lbnQgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGVkaXRvciBpcyBjdXJyZW50bHkgaW4gXCJjb21wb3NpdGlvblwiIG1vZGUgZHVlIHRvIHJlY2VpdmluZyBpbnB1dFxuICAgKiB0aHJvdWdoIGFuIElNRSwgb3IgM1AgZXh0ZW5zaW9uLCBmb3IgZXhhbXBsZS4gUmV0dXJucyBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBpc0NvbXBvc2luZygpIHtcbiAgICByZXR1cm4gdGhpcy5fY29tcG9zaXRpb25LZXkgIT0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgbGlzdGVuZXIgZm9yIEVkaXRvciB1cGRhdGUgZXZlbnQuIFdpbGwgdHJpZ2dlciB0aGUgcHJvdmlkZWQgY2FsbGJhY2tcbiAgICogZWFjaCB0aW1lIHRoZSBlZGl0b3IgZ29lcyB0aHJvdWdoIGFuIHVwZGF0ZSAodmlhIHtAbGluayBMZXhpY2FsRWRpdG9yLnVwZGF0ZX0pIHVudGlsIHRoZVxuICAgKiB0ZWFyZG93biBmdW5jdGlvbiBpcyBjYWxsZWQuXG4gICAqXG4gICAqIEByZXR1cm5zIGEgdGVhcmRvd24gZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBjbGVhbnVwIHRoZSBsaXN0ZW5lci5cbiAgICovXG4gIHJlZ2lzdGVyVXBkYXRlTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICBjb25zdCBsaXN0ZW5lclNldE9yTWFwID0gdGhpcy5fbGlzdGVuZXJzLnVwZGF0ZTtcbiAgICBsaXN0ZW5lclNldE9yTWFwLmFkZChsaXN0ZW5lcik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGxpc3RlbmVyU2V0T3JNYXAuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBsaXN0ZW5lciBmb3IgZm9yIHdoZW4gdGhlIGVkaXRvciBjaGFuZ2VzIGJldHdlZW4gZWRpdGFibGUgYW5kIG5vbi1lZGl0YWJsZSBzdGF0ZXMuXG4gICAqIFdpbGwgdHJpZ2dlciB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgZWFjaCB0aW1lIHRoZSBlZGl0b3IgdHJhbnNpdGlvbnMgYmV0d2VlbiB0aGVzZSBzdGF0ZXMgdW50aWwgdGhlXG4gICAqIHRlYXJkb3duIGZ1bmN0aW9uIGlzIGNhbGxlZC5cbiAgICpcbiAgICogQHJldHVybnMgYSB0ZWFyZG93biBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGNsZWFudXAgdGhlIGxpc3RlbmVyLlxuICAgKi9cbiAgcmVnaXN0ZXJFZGl0YWJsZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgY29uc3QgbGlzdGVuZXJTZXRPck1hcCA9IHRoaXMuX2xpc3RlbmVycy5lZGl0YWJsZTtcbiAgICBsaXN0ZW5lclNldE9yTWFwLmFkZChsaXN0ZW5lcik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGxpc3RlbmVyU2V0T3JNYXAuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBsaXN0ZW5lciBmb3Igd2hlbiB0aGUgZWRpdG9yJ3MgZGVjb3JhdG9yIG9iamVjdCBjaGFuZ2VzLiBUaGUgZGVjb3JhdG9yIG9iamVjdCBjb250YWluc1xuICAgKiBhbGwgRGVjb3JhdG9yTm9kZSBrZXlzIC0+IHRoZWlyIGRlY29yYXRlZCB2YWx1ZS4gVGhpcyBpcyBwcmltYXJpbHkgdXNlZCB3aXRoIGV4dGVybmFsIFVJIGZyYW1ld29ya3MuXG4gICAqXG4gICAqIFdpbGwgdHJpZ2dlciB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgZWFjaCB0aW1lIHRoZSBlZGl0b3IgdHJhbnNpdGlvbnMgYmV0d2VlbiB0aGVzZSBzdGF0ZXMgdW50aWwgdGhlXG4gICAqIHRlYXJkb3duIGZ1bmN0aW9uIGlzIGNhbGxlZC5cbiAgICpcbiAgICogQHJldHVybnMgYSB0ZWFyZG93biBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGNsZWFudXAgdGhlIGxpc3RlbmVyLlxuICAgKi9cbiAgcmVnaXN0ZXJEZWNvcmF0b3JMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIGNvbnN0IGxpc3RlbmVyU2V0T3JNYXAgPSB0aGlzLl9saXN0ZW5lcnMuZGVjb3JhdG9yO1xuICAgIGxpc3RlbmVyU2V0T3JNYXAuYWRkKGxpc3RlbmVyKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgbGlzdGVuZXJTZXRPck1hcC5kZWxldGUobGlzdGVuZXIpO1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIGxpc3RlbmVyIGZvciB3aGVuIExleGljYWwgY29tbWl0cyBhbiB1cGRhdGUgdG8gdGhlIERPTSBhbmQgdGhlIHRleHQgY29udGVudCBvZlxuICAgKiB0aGUgZWRpdG9yIGNoYW5nZXMgZnJvbSB0aGUgcHJldmlvdXMgc3RhdGUgb2YgdGhlIGVkaXRvci4gSWYgdGhlIHRleHQgY29udGVudCBpcyB0aGVcbiAgICogc2FtZSBiZXR3ZWVuIHVwZGF0ZXMsIG5vIG5vdGlmaWNhdGlvbnMgdG8gdGhlIGxpc3RlbmVycyB3aWxsIGhhcHBlbi5cbiAgICpcbiAgICogV2lsbCB0cmlnZ2VyIHRoZSBwcm92aWRlZCBjYWxsYmFjayBlYWNoIHRpbWUgdGhlIGVkaXRvciB0cmFuc2l0aW9ucyBiZXR3ZWVuIHRoZXNlIHN0YXRlcyB1bnRpbCB0aGVcbiAgICogdGVhcmRvd24gZnVuY3Rpb24gaXMgY2FsbGVkLlxuICAgKlxuICAgKiBAcmV0dXJucyBhIHRlYXJkb3duIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2xlYW51cCB0aGUgbGlzdGVuZXIuXG4gICAqL1xuICByZWdpc3RlclRleHRDb250ZW50TGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICBjb25zdCBsaXN0ZW5lclNldE9yTWFwID0gdGhpcy5fbGlzdGVuZXJzLnRleHRjb250ZW50O1xuICAgIGxpc3RlbmVyU2V0T3JNYXAuYWRkKGxpc3RlbmVyKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgbGlzdGVuZXJTZXRPck1hcC5kZWxldGUobGlzdGVuZXIpO1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIGxpc3RlbmVyIGZvciB3aGVuIHRoZSBlZGl0b3IncyByb290IERPTSBlbGVtZW50ICh0aGUgY29udGVudCBlZGl0YWJsZVxuICAgKiBMZXhpY2FsIGF0dGFjaGVzIHRvKSBjaGFuZ2VzLiBUaGlzIGlzIHByaW1hcmlseSB1c2VkIHRvIGF0dGFjaCBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIHJvb3RcbiAgICogIGVsZW1lbnQuIFRoZSByb290IGxpc3RlbmVyIGZ1bmN0aW9uIGlzIGV4ZWN1dGVkIGRpcmVjdGx5IHVwb24gcmVnaXN0cmF0aW9uIGFuZCB0aGVuIG9uXG4gICAqIGFueSBzdWJzZXF1ZW50IHVwZGF0ZS5cbiAgICpcbiAgICogV2lsbCB0cmlnZ2VyIHRoZSBwcm92aWRlZCBjYWxsYmFjayBlYWNoIHRpbWUgdGhlIGVkaXRvciB0cmFuc2l0aW9ucyBiZXR3ZWVuIHRoZXNlIHN0YXRlcyB1bnRpbCB0aGVcbiAgICogdGVhcmRvd24gZnVuY3Rpb24gaXMgY2FsbGVkLlxuICAgKlxuICAgKiBAcmV0dXJucyBhIHRlYXJkb3duIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2xlYW51cCB0aGUgbGlzdGVuZXIuXG4gICAqL1xuICByZWdpc3RlclJvb3RMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIGNvbnN0IGxpc3RlbmVyU2V0T3JNYXAgPSB0aGlzLl9saXN0ZW5lcnMucm9vdDtcbiAgICBsaXN0ZW5lcih0aGlzLl9yb290RWxlbWVudCwgbnVsbCk7XG4gICAgbGlzdGVuZXJTZXRPck1hcC5hZGQobGlzdGVuZXIpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBsaXN0ZW5lcihudWxsLCB0aGlzLl9yb290RWxlbWVudCk7XG4gICAgICBsaXN0ZW5lclNldE9yTWFwLmRlbGV0ZShsaXN0ZW5lcik7XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgbGlzdGVuZXIgdGhhdCB3aWxsIHRyaWdnZXIgYW55dGltZSB0aGUgcHJvdmlkZWQgY29tbWFuZFxuICAgKiBpcyBkaXNwYXRjaGVkIHdpdGgge0BsaW5rIExleGljYWxFZGl0b3IuZGlzcGF0Y2h9LCBzdWJqZWN0IHRvIHByaW9yaXR5LlxuICAgKiBMaXN0ZW5lcnMgdGhhdCBydW4gYXQgYSBoaWdoZXIgcHJpb3JpdHkgY2FuIFwiaW50ZXJjZXB0XCIgY29tbWFuZHMgYW5kXG4gICAqIHByZXZlbnQgdGhlbSBmcm9tIHByb3BhZ2F0aW5nIHRvIG90aGVyIGhhbmRsZXJzIGJ5IHJldHVybmluZyB0cnVlLlxuICAgKlxuICAgKiBMaXN0ZW5lcnMgYXJlIGFsd2F5cyBpbnZva2VkIGluIGFuIHtAbGluayBMZXhpY2FsRWRpdG9yLnVwZGF0ZX0gYW5kIGNhblxuICAgKiBjYWxsIGRvbGxhciBmdW5jdGlvbnMuXG4gICAqXG4gICAqIExpc3RlbmVycyByZWdpc3RlcmVkIGF0IHRoZSBzYW1lIHByaW9yaXR5IGxldmVsIHdpbGwgcnVuXG4gICAqIGRldGVybWluaXN0aWNhbGx5IGluIHRoZSBvcmRlciBvZiByZWdpc3RyYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSBjb21tYW5kIC0gdGhlIGNvbW1hbmQgdGhhdCB3aWxsIHRyaWdnZXIgdGhlIGNhbGxiYWNrLlxuICAgKiBAcGFyYW0gbGlzdGVuZXIgLSB0aGUgZnVuY3Rpb24gdGhhdCB3aWxsIGV4ZWN1dGUgd2hlbiB0aGUgY29tbWFuZCBpcyBkaXNwYXRjaGVkLlxuICAgKiBAcGFyYW0gcHJpb3JpdHkgLSB0aGUgcmVsYXRpdmUgcHJpb3JpdHkgb2YgdGhlIGxpc3RlbmVyLiAwIHwgMSB8IDIgfCAzIHwgNFxuICAgKiAgIChvciB7QGxpbmsgQ09NTUFORF9QUklPUklUWV9FRElUT1J9IHxcbiAgICogICAgIHtAbGluayBDT01NQU5EX1BSSU9SSVRZX0xPV30gfFxuICAgKiAgICAge0BsaW5rIENPTU1BTkRfUFJJT1JJVFlfTk9STUFMfSB8XG4gICAqICAgICB7QGxpbmsgQ09NTUFORF9QUklPUklUWV9ISUdIfSB8XG4gICAqICAgICB7QGxpbmsgQ09NTUFORF9QUklPUklUWV9DUklUSUNBTH0pXG4gICAqIEByZXR1cm5zIGEgdGVhcmRvd24gZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBjbGVhbnVwIHRoZSBsaXN0ZW5lci5cbiAgICovXG4gIHJlZ2lzdGVyQ29tbWFuZChjb21tYW5kLCBsaXN0ZW5lciwgcHJpb3JpdHkpIHtcbiAgICBpZiAocHJpb3JpdHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvcihgTGlzdGVuZXIgZm9yIHR5cGUgXCJjb21tYW5kXCIgcmVxdWlyZXMgYSBcInByaW9yaXR5XCIuYCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNvbW1hbmRzTWFwID0gdGhpcy5fY29tbWFuZHM7XG4gICAgaWYgKCFjb21tYW5kc01hcC5oYXMoY29tbWFuZCkpIHtcbiAgICAgIGNvbW1hbmRzTWFwLnNldChjb21tYW5kLCBbbmV3IFNldCgpLCBuZXcgU2V0KCksIG5ldyBTZXQoKSwgbmV3IFNldCgpLCBuZXcgU2V0KCldKTtcbiAgICB9XG4gICAgY29uc3QgbGlzdGVuZXJzSW5Qcmlvcml0eU9yZGVyID0gY29tbWFuZHNNYXAuZ2V0KGNvbW1hbmQpO1xuICAgIGlmIChsaXN0ZW5lcnNJblByaW9yaXR5T3JkZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvcihgcmVnaXN0ZXJDb21tYW5kOiBDb21tYW5kICR7U3RyaW5nKGNvbW1hbmQpfSBub3QgZm91bmQgaW4gY29tbWFuZCBtYXBgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbGlzdGVuZXJzID0gbGlzdGVuZXJzSW5Qcmlvcml0eU9yZGVyW3ByaW9yaXR5XTtcbiAgICBsaXN0ZW5lcnMuYWRkKGxpc3RlbmVyKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgbGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcik7XG4gICAgICBpZiAobGlzdGVuZXJzSW5Qcmlvcml0eU9yZGVyLmV2ZXJ5KGxpc3RlbmVyc1NldCA9PiBsaXN0ZW5lcnNTZXQuc2l6ZSA9PT0gMCkpIHtcbiAgICAgICAgY29tbWFuZHNNYXAuZGVsZXRlKGNvbW1hbmQpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgbGlzdGVuZXIgdGhhdCB3aWxsIHJ1biB3aGVuIGEgTGV4aWNhbCBub2RlIG9mIHRoZSBwcm92aWRlZCBjbGFzcyBpc1xuICAgKiBtdXRhdGVkLiBUaGUgbGlzdGVuZXIgd2lsbCByZWNlaXZlIGEgbGlzdCBvZiBub2RlcyBhbG9uZyB3aXRoIHRoZSB0eXBlIG9mIG11dGF0aW9uXG4gICAqIHRoYXQgd2FzIHBlcmZvcm1lZCBvbiBlYWNoOiBjcmVhdGVkLCBkZXN0cm95ZWQsIG9yIHVwZGF0ZWQuXG4gICAqXG4gICAqIE9uZSBjb21tb24gdXNlIGNhc2UgZm9yIHRoaXMgaXMgdG8gYXR0YWNoIERPTSBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIHVuZGVybHlpbmcgRE9NIG5vZGVzIGFzIExleGljYWwgbm9kZXMgYXJlIGNyZWF0ZWQuXG4gICAqIHtAbGluayBMZXhpY2FsRWRpdG9yLmdldEVsZW1lbnRCeUtleX0gY2FuIGJlIHVzZWQgZm9yIHRoaXMuXG4gICAqXG4gICAqIElmIGFueSBleGlzdGluZyBub2RlcyBhcmUgaW4gdGhlIERPTSwgYW5kIHNraXBJbml0aWFsaXphdGlvbiBpcyBub3QgdHJ1ZSwgdGhlIGxpc3RlbmVyXG4gICAqIHdpbGwgYmUgY2FsbGVkIGltbWVkaWF0ZWx5IHdpdGggYW4gdXBkYXRlVGFnIG9mICdyZWdpc3Rlck11dGF0aW9uTGlzdGVuZXInIHdoZXJlIGFsbFxuICAgKiBub2RlcyBoYXZlIHRoZSAnY3JlYXRlZCcgTm9kZU11dGF0aW9uLiBUaGlzIGNhbiBiZSBjb250cm9sbGVkIHdpdGggdGhlIHNraXBJbml0aWFsaXphdGlvbiBvcHRpb25cbiAgICogKHdob3NlIGRlZmF1bHQgd2FzIHByZXZpb3VzbHkgdHJ1ZSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCAmbHQ7PTAuMTYuMSBidXQgaGFzIGJlZW4gY2hhbmdlZCB0byBmYWxzZSBhcyBvZiAwLjIxLjApLlxuICAgKlxuICAgKiBAcGFyYW0ga2xhc3MgLSBUaGUgY2xhc3Mgb2YgdGhlIG5vZGUgdGhhdCB5b3Ugd2FudCB0byBsaXN0ZW4gdG8gbXV0YXRpb25zIG9uLlxuICAgKiBAcGFyYW0gbGlzdGVuZXIgLSBUaGUgbG9naWMgeW91IHdhbnQgdG8gcnVuIHdoZW4gdGhlIG5vZGUgaXMgbXV0YXRlZC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBzZWUge0BsaW5rIE11dGF0aW9uTGlzdGVuZXJPcHRpb25zfVxuICAgKiBAcmV0dXJucyBhIHRlYXJkb3duIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2xlYW51cCB0aGUgbGlzdGVuZXIuXG4gICAqL1xuICByZWdpc3Rlck11dGF0aW9uTGlzdGVuZXIoa2xhc3MsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gICAgY29uc3Qga2xhc3NUb011dGF0ZSA9IHRoaXMucmVzb2x2ZVJlZ2lzdGVyZWROb2RlQWZ0ZXJSZXBsYWNlbWVudHModGhpcy5nZXRSZWdpc3RlcmVkTm9kZShrbGFzcykpLmtsYXNzO1xuICAgIGNvbnN0IG11dGF0aW9ucyA9IHRoaXMuX2xpc3RlbmVycy5tdXRhdGlvbjtcbiAgICBtdXRhdGlvbnMuc2V0KGxpc3RlbmVyLCBrbGFzc1RvTXV0YXRlKTtcbiAgICBjb25zdCBza2lwSW5pdGlhbGl6YXRpb24gPSBvcHRpb25zICYmIG9wdGlvbnMuc2tpcEluaXRpYWxpemF0aW9uO1xuICAgIGlmICghKHNraXBJbml0aWFsaXphdGlvbiA9PT0gdW5kZWZpbmVkID8gREVGQVVMVF9TS0lQX0lOSVRJQUxJWkFUSU9OIDogc2tpcEluaXRpYWxpemF0aW9uKSkge1xuICAgICAgdGhpcy5pbml0aWFsaXplTXV0YXRpb25MaXN0ZW5lcihsaXN0ZW5lciwga2xhc3NUb011dGF0ZSk7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBtdXRhdGlvbnMuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBnZXRSZWdpc3RlcmVkTm9kZShrbGFzcykge1xuICAgIGNvbnN0IHJlZ2lzdGVyZWROb2RlID0gdGhpcy5fbm9kZXMuZ2V0KGtsYXNzLmdldFR5cGUoKSk7XG4gICAgaWYgKHJlZ2lzdGVyZWROb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYE5vZGUgJHtrbGFzcy5uYW1lfSBoYXMgbm90IGJlZW4gcmVnaXN0ZXJlZC4gRW5zdXJlIG5vZGUgaGFzIGJlZW4gcGFzc2VkIHRvIGNyZWF0ZUVkaXRvci5gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlZ2lzdGVyZWROb2RlO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICByZXNvbHZlUmVnaXN0ZXJlZE5vZGVBZnRlclJlcGxhY2VtZW50cyhyZWdpc3RlcmVkTm9kZSkge1xuICAgIHdoaWxlIChyZWdpc3RlcmVkTm9kZS5yZXBsYWNlV2l0aEtsYXNzKSB7XG4gICAgICByZWdpc3RlcmVkTm9kZSA9IHRoaXMuZ2V0UmVnaXN0ZXJlZE5vZGUocmVnaXN0ZXJlZE5vZGUucmVwbGFjZVdpdGhLbGFzcyk7XG4gICAgfVxuICAgIHJldHVybiByZWdpc3RlcmVkTm9kZTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgaW5pdGlhbGl6ZU11dGF0aW9uTGlzdGVuZXIobGlzdGVuZXIsIGtsYXNzKSB7XG4gICAgY29uc3QgcHJldkVkaXRvclN0YXRlID0gdGhpcy5fZWRpdG9yU3RhdGU7XG4gICAgY29uc3Qgbm9kZU1hcCA9IGdldENhY2hlZFR5cGVUb05vZGVNYXAocHJldkVkaXRvclN0YXRlKS5nZXQoa2xhc3MuZ2V0VHlwZSgpKTtcbiAgICBpZiAoIW5vZGVNYXApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgbm9kZU11dGF0aW9uTWFwID0gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3QgayBvZiBub2RlTWFwLmtleXMoKSkge1xuICAgICAgbm9kZU11dGF0aW9uTWFwLnNldChrLCAnY3JlYXRlZCcpO1xuICAgIH1cbiAgICBpZiAobm9kZU11dGF0aW9uTWFwLnNpemUgPiAwKSB7XG4gICAgICBsaXN0ZW5lcihub2RlTXV0YXRpb25NYXAsIHtcbiAgICAgICAgZGlydHlMZWF2ZXM6IG5ldyBTZXQoKSxcbiAgICAgICAgcHJldkVkaXRvclN0YXRlLFxuICAgICAgICB1cGRhdGVUYWdzOiBuZXcgU2V0KFsncmVnaXN0ZXJNdXRhdGlvbkxpc3RlbmVyJ10pXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHJlZ2lzdGVyTm9kZVRyYW5zZm9ybVRvS2xhc3Moa2xhc3MsIGxpc3RlbmVyKSB7XG4gICAgY29uc3QgcmVnaXN0ZXJlZE5vZGUgPSB0aGlzLmdldFJlZ2lzdGVyZWROb2RlKGtsYXNzKTtcbiAgICByZWdpc3RlcmVkTm9kZS50cmFuc2Zvcm1zLmFkZChsaXN0ZW5lcik7XG4gICAgcmV0dXJuIHJlZ2lzdGVyZWROb2RlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIGxpc3RlbmVyIHRoYXQgd2lsbCBydW4gd2hlbiBhIExleGljYWwgbm9kZSBvZiB0aGUgcHJvdmlkZWQgY2xhc3MgaXNcbiAgICogbWFya2VkIGRpcnR5IGR1cmluZyBhbiB1cGRhdGUuIFRoZSBsaXN0ZW5lciB3aWxsIGNvbnRpbnVlIHRvIHJ1biBhcyBsb25nIGFzIHRoZSBub2RlXG4gICAqIGlzIG1hcmtlZCBkaXJ0eS4gVGhlcmUgYXJlIG5vIGd1YXJhbnRlZXMgYXJvdW5kIHRoZSBvcmRlciBvZiB0cmFuc2Zvcm0gZXhlY3V0aW9uIVxuICAgKlxuICAgKiBXYXRjaCBvdXQgZm9yIGluZmluaXRlIGxvb3BzLiBTZWUgW05vZGUgVHJhbnNmb3Jtc10oaHR0cHM6Ly9sZXhpY2FsLmRldi9kb2NzL2NvbmNlcHRzL3RyYW5zZm9ybXMpXG4gICAqIEBwYXJhbSBrbGFzcyAtIFRoZSBjbGFzcyBvZiB0aGUgbm9kZSB0aGF0IHlvdSB3YW50IHRvIHJ1biB0cmFuc2Zvcm1zIG9uLlxuICAgKiBAcGFyYW0gbGlzdGVuZXIgLSBUaGUgbG9naWMgeW91IHdhbnQgdG8gcnVuIHdoZW4gdGhlIG5vZGUgaXMgdXBkYXRlZC5cbiAgICogQHJldHVybnMgYSB0ZWFyZG93biBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGNsZWFudXAgdGhlIGxpc3RlbmVyLlxuICAgKi9cbiAgcmVnaXN0ZXJOb2RlVHJhbnNmb3JtKGtsYXNzLCBsaXN0ZW5lcikge1xuICAgIGNvbnN0IHJlZ2lzdGVyZWROb2RlID0gdGhpcy5yZWdpc3Rlck5vZGVUcmFuc2Zvcm1Ub0tsYXNzKGtsYXNzLCBsaXN0ZW5lcik7XG4gICAgY29uc3QgcmVnaXN0ZXJlZE5vZGVzID0gW3JlZ2lzdGVyZWROb2RlXTtcbiAgICBjb25zdCByZXBsYWNlV2l0aEtsYXNzID0gcmVnaXN0ZXJlZE5vZGUucmVwbGFjZVdpdGhLbGFzcztcbiAgICBpZiAocmVwbGFjZVdpdGhLbGFzcyAhPSBudWxsKSB7XG4gICAgICBjb25zdCByZWdpc3RlcmVkUmVwbGFjZVdpdGhOb2RlID0gdGhpcy5yZWdpc3Rlck5vZGVUcmFuc2Zvcm1Ub0tsYXNzKHJlcGxhY2VXaXRoS2xhc3MsIGxpc3RlbmVyKTtcbiAgICAgIHJlZ2lzdGVyZWROb2Rlcy5wdXNoKHJlZ2lzdGVyZWRSZXBsYWNlV2l0aE5vZGUpO1xuICAgIH1cbiAgICBtYXJrTm9kZXNXaXRoVHlwZXNBc0RpcnR5KHRoaXMsIHJlZ2lzdGVyZWROb2Rlcy5tYXAobm9kZSA9PiBub2RlLmtsYXNzLmdldFR5cGUoKSkpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICByZWdpc3RlcmVkTm9kZXMuZm9yRWFjaChub2RlID0+IG5vZGUudHJhbnNmb3Jtcy5kZWxldGUobGlzdGVuZXIpKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gYXNzZXJ0IHRoYXQgYSBjZXJ0YWluIG5vZGUgaXMgcmVnaXN0ZXJlZCwgdXN1YWxseSBieSBwbHVnaW5zIHRvIGVuc3VyZSBub2RlcyB0aGF0IHRoZXlcbiAgICogZGVwZW5kIG9uIGhhdmUgYmVlbiByZWdpc3RlcmVkLlxuICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBlZGl0b3IgaGFzIHJlZ2lzdGVyZWQgdGhlIHByb3ZpZGVkIG5vZGUgdHlwZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgaGFzTm9kZShub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuX25vZGVzLmhhcyhub2RlLmdldFR5cGUoKSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCB0byBhc3NlcnQgdGhhdCBjZXJ0YWluIG5vZGVzIGFyZSByZWdpc3RlcmVkLCB1c3VhbGx5IGJ5IHBsdWdpbnMgdG8gZW5zdXJlIG5vZGVzIHRoYXQgdGhleVxuICAgKiBkZXBlbmQgb24gaGF2ZSBiZWVuIHJlZ2lzdGVyZWQuXG4gICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIGVkaXRvciBoYXMgcmVnaXN0ZXJlZCBhbGwgb2YgdGhlIHByb3ZpZGVkIG5vZGUgdHlwZXMsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGhhc05vZGVzKG5vZGVzKSB7XG4gICAgcmV0dXJuIG5vZGVzLmV2ZXJ5KHRoaXMuaGFzTm9kZS5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaGVzIGEgY29tbWFuZCBvZiB0aGUgc3BlY2lmaWVkIHR5cGUgd2l0aCB0aGUgc3BlY2lmaWVkIHBheWxvYWQuXG4gICAqIFRoaXMgdHJpZ2dlcnMgYWxsIGNvbW1hbmQgbGlzdGVuZXJzIChzZXQgYnkge0BsaW5rIExleGljYWxFZGl0b3IucmVnaXN0ZXJDb21tYW5kfSlcbiAgICogZm9yIHRoaXMgdHlwZSwgcGFzc2luZyB0aGVtIHRoZSBwcm92aWRlZCBwYXlsb2FkLiBUaGUgY29tbWFuZCBsaXN0ZW5lcnNcbiAgICogd2lsbCBiZSB0cmlnZ2VyZWQgaW4gYW4gaW1wbGljaXQge0BsaW5rIExleGljYWxFZGl0b3IudXBkYXRlfSwgdW5sZXNzXG4gICAqIHRoaXMgd2FzIGludm9rZWQgZnJvbSBpbnNpZGUgYW4gdXBkYXRlIGluIHdoaWNoIGNhc2UgdGhhdCB1cGRhdGUgY29udGV4dFxuICAgKiB3aWxsIGJlIHJlLXVzZWQgKGFzIGlmIHRoaXMgd2FzIGEgZG9sbGFyIGZ1bmN0aW9uIGl0c2VsZikuXG4gICAqIEBwYXJhbSB0eXBlIC0gdGhlIHR5cGUgb2YgY29tbWFuZCBsaXN0ZW5lcnMgdG8gdHJpZ2dlci5cbiAgICogQHBhcmFtIHBheWxvYWQgLSB0aGUgZGF0YSB0byBwYXNzIGFzIGFuIGFyZ3VtZW50IHRvIHRoZSBjb21tYW5kIGxpc3RlbmVycy5cbiAgICovXG4gIGRpc3BhdGNoQ29tbWFuZCh0eXBlLCBwYXlsb2FkKSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoQ29tbWFuZCh0aGlzLCB0eXBlLCBwYXlsb2FkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGEgbWFwIG9mIGFsbCBkZWNvcmF0b3JzIGluIHRoZSBlZGl0b3IuXG4gICAqIEByZXR1cm5zIEEgbWFwcGluZyBvZiBjYWxsIGRlY29yYXRvciBrZXlzIHRvIHRoZWlyIGRlY29yYXRlZCBjb250ZW50XG4gICAqL1xuICBnZXREZWNvcmF0b3JzKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWNvcmF0b3JzO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEByZXR1cm5zIHRoZSBjdXJyZW50IHJvb3QgZWxlbWVudCBvZiB0aGUgZWRpdG9yLiBJZiB5b3Ugd2FudCB0byByZWdpc3RlclxuICAgKiBhbiBldmVudCBsaXN0ZW5lciwgZG8gaXQgdmlhIHtAbGluayBMZXhpY2FsRWRpdG9yLnJlZ2lzdGVyUm9vdExpc3RlbmVyfSwgc2luY2VcbiAgICogdGhpcyByZWZlcmVuY2UgbWF5IG5vdCBiZSBzdGFibGUuXG4gICAqL1xuICBnZXRSb290RWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcm9vdEVsZW1lbnQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUga2V5IG9mIHRoZSBlZGl0b3JcbiAgICogQHJldHVybnMgVGhlIGVkaXRvciBrZXlcbiAgICovXG4gIGdldEtleSgpIHtcbiAgICByZXR1cm4gdGhpcy5fa2V5O1xuICB9XG5cbiAgLyoqXG4gICAqIEltcGVyYXRpdmVseSBzZXQgdGhlIHJvb3QgY29udGVudGVkaXRhYmxlIGVsZW1lbnQgdGhhdCBMZXhpY2FsIGxpc3RlbnNcbiAgICogZm9yIGV2ZW50cyBvbi5cbiAgICovXG4gIHNldFJvb3RFbGVtZW50KG5leHRSb290RWxlbWVudCkge1xuICAgIGNvbnN0IHByZXZSb290RWxlbWVudCA9IHRoaXMuX3Jvb3RFbGVtZW50O1xuICAgIGlmIChuZXh0Um9vdEVsZW1lbnQgIT09IHByZXZSb290RWxlbWVudCkge1xuICAgICAgY29uc3QgY2xhc3NOYW1lcyA9IGdldENhY2hlZENsYXNzTmFtZUFycmF5KHRoaXMuX2NvbmZpZy50aGVtZSwgJ3Jvb3QnKTtcbiAgICAgIGNvbnN0IHBlbmRpbmdFZGl0b3JTdGF0ZSA9IHRoaXMuX3BlbmRpbmdFZGl0b3JTdGF0ZSB8fCB0aGlzLl9lZGl0b3JTdGF0ZTtcbiAgICAgIHRoaXMuX3Jvb3RFbGVtZW50ID0gbmV4dFJvb3RFbGVtZW50O1xuICAgICAgcmVzZXRFZGl0b3IodGhpcywgcHJldlJvb3RFbGVtZW50LCBuZXh0Um9vdEVsZW1lbnQsIHBlbmRpbmdFZGl0b3JTdGF0ZSk7XG4gICAgICBpZiAocHJldlJvb3RFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IHJlbW92ZSB0aGlzIGZsYWcgb25jZSB3ZSBubyBsb25nZXIgdXNlIFVFdjIgaW50ZXJuYWxseVxuICAgICAgICBpZiAoIXRoaXMuX2NvbmZpZy5kaXNhYmxlRXZlbnRzKSB7XG4gICAgICAgICAgcmVtb3ZlUm9vdEVsZW1lbnRFdmVudHMocHJldlJvb3RFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2xhc3NOYW1lcyAhPSBudWxsKSB7XG4gICAgICAgICAgcHJldlJvb3RFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoLi4uY2xhc3NOYW1lcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChuZXh0Um9vdEVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3Qgd2luZG93T2JqID0gZ2V0RGVmYXVsdFZpZXcobmV4dFJvb3RFbGVtZW50KTtcbiAgICAgICAgY29uc3Qgc3R5bGUgPSBuZXh0Um9vdEVsZW1lbnQuc3R5bGU7XG4gICAgICAgIHN0eWxlLnVzZXJTZWxlY3QgPSAndGV4dCc7XG4gICAgICAgIHN0eWxlLndoaXRlU3BhY2UgPSAncHJlLXdyYXAnO1xuICAgICAgICBzdHlsZS53b3JkQnJlYWsgPSAnYnJlYWstd29yZCc7XG4gICAgICAgIG5leHRSb290RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtbGV4aWNhbC1lZGl0b3InLCAndHJ1ZScpO1xuICAgICAgICB0aGlzLl93aW5kb3cgPSB3aW5kb3dPYmo7XG4gICAgICAgIHRoaXMuX2RpcnR5VHlwZSA9IEZVTExfUkVDT05DSUxFO1xuICAgICAgICBpbml0TXV0YXRpb25PYnNlcnZlcih0aGlzKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlVGFncy5hZGQoJ2hpc3RvcnktbWVyZ2UnKTtcbiAgICAgICAgJGNvbW1pdFBlbmRpbmdVcGRhdGVzKHRoaXMpO1xuXG4gICAgICAgIC8vIFRPRE86IHJlbW92ZSB0aGlzIGZsYWcgb25jZSB3ZSBubyBsb25nZXIgdXNlIFVFdjIgaW50ZXJuYWxseVxuICAgICAgICBpZiAoIXRoaXMuX2NvbmZpZy5kaXNhYmxlRXZlbnRzKSB7XG4gICAgICAgICAgYWRkUm9vdEVsZW1lbnRFdmVudHMobmV4dFJvb3RFbGVtZW50LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2xhc3NOYW1lcyAhPSBudWxsKSB7XG4gICAgICAgICAgbmV4dFJvb3RFbGVtZW50LmNsYXNzTGlzdC5hZGQoLi4uY2xhc3NOYW1lcyk7XG4gICAgICAgIH1cbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IG5leHRSb290RWxlbWVudFBhcmVudCA9IG5leHRSb290RWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgIGlmIChuZXh0Um9vdEVsZW1lbnRQYXJlbnQgIT0gbnVsbCAmJiBbJ2ZsZXgnLCAnaW5saW5lLWZsZXgnXS5pbmNsdWRlcyhnZXRDb21wdXRlZFN0eWxlKG5leHRSb290RWxlbWVudFBhcmVudCkuZGlzcGxheSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgV2hlbiB1c2luZyBcImRpc3BsYXk6IGZsZXhcIiBvciBcImRpc3BsYXk6IGlubGluZS1mbGV4XCIgb24gYW4gZWxlbWVudCBjb250YWluaW5nIGNvbnRlbnQgZWRpdGFibGUsIENocm9tZSBtYXkgaGF2ZSB1bndhbnRlZCBmb2N1c2luZyBiZWhhdmlvciB3aGVuIGNsaWNraW5nIG91dHNpZGUgb2YgaXQuIENvbnNpZGVyIHdyYXBwaW5nIHRoZSBjb250ZW50IGVkaXRhYmxlIHdpdGhpbiBhIG5vbi1mbGV4IGVsZW1lbnQuYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXaGVuIHRoZSBjb250ZW50IGVkaXRhYmxlIGlzIHVubW91bnRlZCB3ZSB3aWxsIHN0aWxsIHRyaWdnZXIgYVxuICAgICAgICAvLyByZWNvbmNpbGlhdGlvbiBzbyB0aGF0IGFueSBwZW5kaW5nIHVwZGF0ZXMgYXJlIGZsdXNoZWQsXG4gICAgICAgIC8vIHRvIG1hdGNoIHRoZSBwcmV2aW91cyBzdGF0ZSBjaGFuZ2Ugd2hlblxuICAgICAgICAvLyBgX2VkaXRvclN0YXRlID0gcGVuZGluZ0VkaXRvclN0YXRlYCB3YXMgdXNlZCwgYnV0IGJ5XG4gICAgICAgIC8vIHVzaW5nIGEgY29tbWl0IHdlIHByZXNlcnZlIHRoZSByZWFkT25seSBpbnZhcmlhbnRcbiAgICAgICAgLy8gZm9yIGVkaXRvci5nZXRFZGl0b3JTdGF0ZSgpLlxuICAgICAgICB0aGlzLl93aW5kb3cgPSBudWxsO1xuICAgICAgICB0aGlzLl91cGRhdGVUYWdzLmFkZCgnaGlzdG9yeS1tZXJnZScpO1xuICAgICAgICAkY29tbWl0UGVuZGluZ1VwZGF0ZXModGhpcyk7XG4gICAgICB9XG4gICAgICB0cmlnZ2VyTGlzdGVuZXJzKCdyb290JywgdGhpcywgZmFsc2UsIG5leHRSb290RWxlbWVudCwgcHJldlJvb3RFbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgdW5kZXJseWluZyBIVE1MRWxlbWVudCBhc3NvY2lhdGVkIHdpdGggdGhlIExleGljYWxOb2RlIGZvciB0aGUgZ2l2ZW4ga2V5LlxuICAgKiBAcmV0dXJucyB0aGUgSFRNTEVsZW1lbnQgcmVuZGVyZWQgYnkgdGhlIExleGljYWxOb2RlIGFzc29jaWF0ZWQgd2l0aCB0aGUga2V5LlxuICAgKiBAcGFyYW0ga2V5IC0gdGhlIGtleSBvZiB0aGUgTGV4aWNhbE5vZGUuXG4gICAqL1xuICBnZXRFbGVtZW50QnlLZXkoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX2tleVRvRE9NTWFwLmdldChrZXkpIHx8IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgYWN0aXZlIGVkaXRvciBzdGF0ZS5cbiAgICogQHJldHVybnMgVGhlIGVkaXRvciBzdGF0ZVxuICAgKi9cbiAgZ2V0RWRpdG9yU3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VkaXRvclN0YXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEltcGVyYXRpdmVseSBzZXQgdGhlIEVkaXRvclN0YXRlLiBUcmlnZ2VycyByZWNvbmNpbGlhdGlvbiBsaWtlIGFuIHVwZGF0ZS5cbiAgICogQHBhcmFtIGVkaXRvclN0YXRlIC0gdGhlIHN0YXRlIHRvIHNldCB0aGUgZWRpdG9yXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gb3B0aW9ucyBmb3IgdGhlIHVwZGF0ZS5cbiAgICovXG4gIHNldEVkaXRvclN0YXRlKGVkaXRvclN0YXRlLCBvcHRpb25zKSB7XG4gICAgaWYgKGVkaXRvclN0YXRlLmlzRW1wdHkoKSkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvcihgc2V0RWRpdG9yU3RhdGU6IHRoZSBlZGl0b3Igc3RhdGUgaXMgZW1wdHkuIEVuc3VyZSB0aGUgZWRpdG9yIHN0YXRlJ3Mgcm9vdCBub2RlIG5ldmVyIGJlY29tZXMgZW1wdHkuYCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRW5zdXJlIHRoYXQgd2UgaGF2ZSBhIHdyaXRhYmxlIEVkaXRvclN0YXRlIHNvIHRoYXQgdHJhbnNmb3JtcyBjYW4gcnVuXG4gICAgLy8gZHVyaW5nIGEgaGlzdG9yaWMgb3BlcmF0aW9uXG4gICAgbGV0IHdyaXRhYmxlRWRpdG9yU3RhdGUgPSBlZGl0b3JTdGF0ZTtcbiAgICBpZiAod3JpdGFibGVFZGl0b3JTdGF0ZS5fcmVhZE9ubHkpIHtcbiAgICAgIHdyaXRhYmxlRWRpdG9yU3RhdGUgPSBjbG9uZUVkaXRvclN0YXRlKGVkaXRvclN0YXRlKTtcbiAgICAgIHdyaXRhYmxlRWRpdG9yU3RhdGUuX3NlbGVjdGlvbiA9IGVkaXRvclN0YXRlLl9zZWxlY3Rpb24gPyBlZGl0b3JTdGF0ZS5fc2VsZWN0aW9uLmNsb25lKCkgOiBudWxsO1xuICAgIH1cbiAgICAkZmx1c2hSb290TXV0YXRpb25zKHRoaXMpO1xuICAgIGNvbnN0IHBlbmRpbmdFZGl0b3JTdGF0ZSA9IHRoaXMuX3BlbmRpbmdFZGl0b3JTdGF0ZTtcbiAgICBjb25zdCB0YWdzID0gdGhpcy5fdXBkYXRlVGFncztcbiAgICBjb25zdCB0YWcgPSBvcHRpb25zICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnRhZyA6IG51bGw7XG4gICAgaWYgKHBlbmRpbmdFZGl0b3JTdGF0ZSAhPT0gbnVsbCAmJiAhcGVuZGluZ0VkaXRvclN0YXRlLmlzRW1wdHkoKSkge1xuICAgICAgaWYgKHRhZyAhPSBudWxsKSB7XG4gICAgICAgIHRhZ3MuYWRkKHRhZyk7XG4gICAgICB9XG4gICAgICAkY29tbWl0UGVuZGluZ1VwZGF0ZXModGhpcyk7XG4gICAgfVxuICAgIHRoaXMuX3BlbmRpbmdFZGl0b3JTdGF0ZSA9IHdyaXRhYmxlRWRpdG9yU3RhdGU7XG4gICAgdGhpcy5fZGlydHlUeXBlID0gRlVMTF9SRUNPTkNJTEU7XG4gICAgdGhpcy5fZGlydHlFbGVtZW50cy5zZXQoJ3Jvb3QnLCBmYWxzZSk7XG4gICAgdGhpcy5fY29tcG9zaXRpb25LZXkgPSBudWxsO1xuICAgIGlmICh0YWcgIT0gbnVsbCkge1xuICAgICAgdGFncy5hZGQodGFnKTtcbiAgICB9XG5cbiAgICAvLyBPbmx5IGNvbW1pdCBwZW5kaW5nIHVwZGF0ZXMgaWYgbm90IGFscmVhZHkgaW4gYW4gZWRpdG9yLnVwZGF0ZVxuICAgIC8vIChlLmcuIGRpc3BhdGNoQ29tbWFuZCkgb3RoZXJ3aXNlIHRoaXMgd2lsbCBjYXVzZSBhIHNlY29uZCBjb21taXRcbiAgICAvLyB3aXRoIGFuIGFscmVhZHkgcmVhZC1vbmx5IHN0YXRlIGFuZCBzZWxlY3Rpb25cbiAgICBpZiAoIXRoaXMuX3VwZGF0aW5nKSB7XG4gICAgICAkY29tbWl0UGVuZGluZ1VwZGF0ZXModGhpcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBhIFNlcmlhbGl6ZWRFZGl0b3JTdGF0ZSAodXN1YWxseSBwcm9kdWNlZCBieSB7QGxpbmsgRWRpdG9yU3RhdGUudG9KU09OfSkgYW5kIHJldHVybnNcbiAgICogYW5kIEVkaXRvclN0YXRlIG9iamVjdCB0aGF0IGNhbiBiZSwgZm9yIGV4YW1wbGUsIHBhc3NlZCB0byB7QGxpbmsgTGV4aWNhbEVkaXRvci5zZXRFZGl0b3JTdGF0ZX0uIFR5cGljYWxseSxcbiAgICogZGVzZXJpYWxpemF0aW9uIGZyb20gSlNPTiBzdG9yZWQgaW4gYSBkYXRhYmFzZSB1c2VzIHRoaXMgbWV0aG9kLlxuICAgKiBAcGFyYW0gbWF5YmVTdHJpbmdpZmllZEVkaXRvclN0YXRlXG4gICAqIEBwYXJhbSB1cGRhdGVGblxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgcGFyc2VFZGl0b3JTdGF0ZShtYXliZVN0cmluZ2lmaWVkRWRpdG9yU3RhdGUsIHVwZGF0ZUZuKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZEVkaXRvclN0YXRlID0gdHlwZW9mIG1heWJlU3RyaW5naWZpZWRFZGl0b3JTdGF0ZSA9PT0gJ3N0cmluZycgPyBKU09OLnBhcnNlKG1heWJlU3RyaW5naWZpZWRFZGl0b3JTdGF0ZSkgOiBtYXliZVN0cmluZ2lmaWVkRWRpdG9yU3RhdGU7XG4gICAgcmV0dXJuIHBhcnNlRWRpdG9yU3RhdGUoc2VyaWFsaXplZEVkaXRvclN0YXRlLCB0aGlzLCB1cGRhdGVGbik7XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZXMgYSByZWFkIG9mIHRoZSBlZGl0b3IncyBzdGF0ZSwgd2l0aCB0aGVcbiAgICogZWRpdG9yIGNvbnRleHQgYXZhaWxhYmxlICh1c2VmdWwgZm9yIGV4cG9ydGluZyBhbmQgcmVhZC1vbmx5IERPTVxuICAgKiBvcGVyYXRpb25zKS4gTXVjaCBsaWtlIHVwZGF0ZSwgYnV0IHByZXZlbnRzIGFueSBtdXRhdGlvbiBvZiB0aGVcbiAgICogZWRpdG9yJ3Mgc3RhdGUuIEFueSBwZW5kaW5nIHVwZGF0ZXMgd2lsbCBiZSBmbHVzaGVkIGltbWVkaWF0ZWx5IGJlZm9yZVxuICAgKiB0aGUgcmVhZC5cbiAgICogQHBhcmFtIGNhbGxiYWNrRm4gLSBBIGZ1bmN0aW9uIHRoYXQgaGFzIGFjY2VzcyB0byByZWFkLW9ubHkgZWRpdG9yIHN0YXRlLlxuICAgKi9cbiAgcmVhZChjYWxsYmFja0ZuKSB7XG4gICAgJGNvbW1pdFBlbmRpbmdVcGRhdGVzKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLmdldEVkaXRvclN0YXRlKCkucmVhZChjYWxsYmFja0ZuLCB7XG4gICAgICBlZGl0b3I6IHRoaXNcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyBhbiB1cGRhdGUgdG8gdGhlIGVkaXRvciBzdGF0ZS4gVGhlIHVwZGF0ZUZuIGNhbGxiYWNrIGlzIHRoZSBPTkxZIHBsYWNlXG4gICAqIHdoZXJlIExleGljYWwgZWRpdG9yIHN0YXRlIGNhbiBiZSBzYWZlbHkgbXV0YXRlZC5cbiAgICogQHBhcmFtIHVwZGF0ZUZuIC0gQSBmdW5jdGlvbiB0aGF0IGhhcyBhY2Nlc3MgdG8gd3JpdGFibGUgZWRpdG9yIHN0YXRlLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEEgYmFnIG9mIG9wdGlvbnMgdG8gY29udHJvbCB0aGUgYmVoYXZpb3Igb2YgdGhlIHVwZGF0ZS5cbiAgICogQHBhcmFtIG9wdGlvbnMub25VcGRhdGUgLSBBIGZ1bmN0aW9uIHRvIHJ1biBvbmNlIHRoZSB1cGRhdGUgaXMgY29tcGxldGUuXG4gICAqIFVzZWZ1bCBmb3Igc3luY2hyb25pemluZyB1cGRhdGVzIGluIHNvbWUgY2FzZXMuXG4gICAqIEBwYXJhbSBvcHRpb25zLnNraXBUcmFuc2Zvcm1zIC0gU2V0dGluZyB0aGlzIHRvIHRydWUgd2lsbCBzdXBwcmVzcyBhbGwgbm9kZVxuICAgKiB0cmFuc2Zvcm1zIGZvciB0aGlzIHVwZGF0ZSBjeWNsZS5cbiAgICogQHBhcmFtIG9wdGlvbnMudGFnIC0gQSB0YWcgdG8gaWRlbnRpZnkgdGhpcyB1cGRhdGUsIGluIGFuIHVwZGF0ZSBsaXN0ZW5lciwgZm9yIGluc3RhbmNlLlxuICAgKiBTb21lIHRhZ3MgYXJlIHJlc2VydmVkIGJ5IHRoZSBjb3JlIGFuZCBjb250cm9sIHVwZGF0ZSBiZWhhdmlvciBpbiBkaWZmZXJlbnQgd2F5cy5cbiAgICogQHBhcmFtIG9wdGlvbnMuZGlzY3JldGUgLSBJZiB0cnVlLCBwcmV2ZW50cyB0aGlzIHVwZGF0ZSBmcm9tIGJlaW5nIGJhdGNoZWQsIGZvcmNpbmcgaXQgdG9cbiAgICogcnVuIHN5bmNocm9ub3VzbHkuXG4gICAqL1xuICB1cGRhdGUodXBkYXRlRm4sIG9wdGlvbnMpIHtcbiAgICB1cGRhdGVFZGl0b3IodGhpcywgdXBkYXRlRm4sIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvY3VzZXMgdGhlIGVkaXRvclxuICAgKiBAcGFyYW0gY2FsbGJhY2tGbiAtIEEgZnVuY3Rpb24gdG8gcnVuIGFmdGVyIHRoZSBlZGl0b3IgaXMgZm9jdXNlZC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBBIGJhZyBvZiBvcHRpb25zXG4gICAqIEBwYXJhbSBvcHRpb25zLmRlZmF1bHRTZWxlY3Rpb24gLSBXaGVyZSB0byBtb3ZlIHNlbGVjdGlvbiB3aGVuIHRoZSBlZGl0b3IgaXNcbiAgICogZm9jdXNlZC4gQ2FuIGJlIHJvb3RTdGFydCwgcm9vdEVuZCwgb3IgdW5kZWZpbmVkLiBEZWZhdWx0cyB0byByb290RW5kLlxuICAgKi9cbiAgZm9jdXMoY2FsbGJhY2tGbiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qgcm9vdEVsZW1lbnQgPSB0aGlzLl9yb290RWxlbWVudDtcbiAgICBpZiAocm9vdEVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgZW5zdXJlcyB0aGF0IGlPUyBkb2VzIG5vdCB0cmlnZ2VyIGNhcHMgbG9jayB1cG9uIGZvY3VzXG4gICAgICByb290RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2F1dG9jYXBpdGFsaXplJywgJ29mZicpO1xuICAgICAgdXBkYXRlRWRpdG9yKHRoaXMsICgpID0+IHtcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgICAgICBjb25zdCByb290ID0gJGdldFJvb3QoKTtcbiAgICAgICAgaWYgKHNlbGVjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIE1hcmtpbmcgdGhlIHNlbGVjdGlvbiBkaXJ0eSB3aWxsIGZvcmNlIHRoZSBzZWxlY3Rpb24gYmFjayB0byBpdFxuICAgICAgICAgIHNlbGVjdGlvbi5kaXJ0eSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAocm9vdC5nZXRDaGlsZHJlblNpemUoKSAhPT0gMCkge1xuICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRTZWxlY3Rpb24gPT09ICdyb290U3RhcnQnKSB7XG4gICAgICAgICAgICByb290LnNlbGVjdFN0YXJ0KCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJvb3Quc2VsZWN0RW5kKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIG9uVXBkYXRlOiAoKSA9PiB7XG4gICAgICAgICAgcm9vdEVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhdXRvY2FwaXRhbGl6ZScpO1xuICAgICAgICAgIGlmIChjYWxsYmFja0ZuKSB7XG4gICAgICAgICAgICBjYWxsYmFja0ZuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0YWc6ICdmb2N1cydcbiAgICAgIH0pO1xuICAgICAgLy8gSW4gdGhlIGNhc2Ugd2hlcmUgb25VcGRhdGUgZG9lc24ndCBmaXJlIChkdWUgdG8gdGhlIGZvY3VzIHVwZGF0ZSBub3RcbiAgICAgIC8vIG9jY3VyaW5nKS5cbiAgICAgIGlmICh0aGlzLl9wZW5kaW5nRWRpdG9yU3RhdGUgPT09IG51bGwpIHtcbiAgICAgICAgcm9vdEVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhdXRvY2FwaXRhbGl6ZScpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGZvY3VzIGZyb20gdGhlIGVkaXRvci5cbiAgICovXG4gIGJsdXIoKSB7XG4gICAgY29uc3Qgcm9vdEVsZW1lbnQgPSB0aGlzLl9yb290RWxlbWVudDtcbiAgICBpZiAocm9vdEVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgIHJvb3RFbGVtZW50LmJsdXIoKTtcbiAgICB9XG4gICAgY29uc3QgZG9tU2VsZWN0aW9uID0gZ2V0RE9NU2VsZWN0aW9uKHRoaXMuX3dpbmRvdyk7XG4gICAgaWYgKGRvbVNlbGVjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgZG9tU2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBlZGl0b3IgaXMgZWRpdGFibGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgZWRpdG9yIGlzIGVkaXRhYmxlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBpc0VkaXRhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl9lZGl0YWJsZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZWRpdGFibGUgcHJvcGVydHkgb2YgdGhlIGVkaXRvci4gV2hlbiBmYWxzZSwgdGhlXG4gICAqIGVkaXRvciB3aWxsIG5vdCBsaXN0ZW4gZm9yIHVzZXIgZXZlbnRzIG9uIHRoZSB1bmRlcmxpbmcgY29udGVudGVkaXRhYmxlLlxuICAgKiBAcGFyYW0gZWRpdGFibGUgLSB0aGUgdmFsdWUgdG8gc2V0IHRoZSBlZGl0YWJsZSBtb2RlIHRvLlxuICAgKi9cbiAgc2V0RWRpdGFibGUoZWRpdGFibGUpIHtcbiAgICBpZiAodGhpcy5fZWRpdGFibGUgIT09IGVkaXRhYmxlKSB7XG4gICAgICB0aGlzLl9lZGl0YWJsZSA9IGVkaXRhYmxlO1xuICAgICAgdHJpZ2dlckxpc3RlbmVycygnZWRpdGFibGUnLCB0aGlzLCB0cnVlLCBlZGl0YWJsZSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgSlNPTi1zZXJpYWxpemFibGUgamF2YXNjcmlwdCBvYmplY3QgTk9UIGEgSlNPTiBzdHJpbmcuXG4gICAqIFlvdSBzdGlsbCBtdXN0IGNhbGwgSlNPTi5zdHJpbmdpZnkgKG9yIHNvbWV0aGluZyBlbHNlKSB0byB0dXJuIHRoZVxuICAgKiBzdGF0ZSBpbnRvIGEgc3RyaW5nIHlvdSBjYW4gdHJhbnNmZXIgb3ZlciB0aGUgd2lyZSBhbmQgc3RvcmUgaW4gYSBkYXRhYmFzZS5cbiAgICpcbiAgICogU2VlIHtAbGluayBMZXhpY2FsTm9kZS5leHBvcnRKU09OfVxuICAgKlxuICAgKiBAcmV0dXJucyBBIEpTT04tc2VyaWFsaXphYmxlIGphdmFzY3JpcHQgb2JqZWN0XG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVkaXRvclN0YXRlOiB0aGlzLl9lZGl0b3JTdGF0ZS50b0pTT04oKVxuICAgIH07XG4gIH1cbn1cbkxleGljYWxFZGl0b3IudmVyc2lvbiA9IFwiMC4yMy4xK2Rldi5lc21cIjtcblxuZXhwb3J0IHsgJGFkZFVwZGF0ZVRhZywgJGFwcGx5Tm9kZVJlcGxhY2VtZW50LCAkY2xvbmVXaXRoUHJvcGVydGllcywgJGNvcHlOb2RlLCAkY3JlYXRlTGluZUJyZWFrTm9kZSwgJGNyZWF0ZU5vZGVTZWxlY3Rpb24sICRjcmVhdGVQYXJhZ3JhcGhOb2RlLCAkY3JlYXRlUG9pbnQsICRjcmVhdGVSYW5nZVNlbGVjdGlvbiwgJGNyZWF0ZVJhbmdlU2VsZWN0aW9uRnJvbURvbSwgJGNyZWF0ZVRhYk5vZGUsICRjcmVhdGVUZXh0Tm9kZSwgJGdldEFkamFjZW50Tm9kZSwgJGdldENoYXJhY3Rlck9mZnNldHMsICRnZXRFZGl0b3IsICRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlLCAkZ2V0TmVhcmVzdFJvb3RPclNoYWRvd1Jvb3QsICRnZXROb2RlQnlLZXksICRnZXROb2RlQnlLZXlPclRocm93LCAkZ2V0UHJldmlvdXNTZWxlY3Rpb24sICRnZXRSb290LCAkZ2V0U2VsZWN0aW9uLCAkZ2V0VGV4dENvbnRlbnQsICRoYXNBbmNlc3RvciwgJGhhc1VwZGF0ZVRhZywgJGluc2VydE5vZGVzLCAkaXNCbG9ja0VsZW1lbnROb2RlLCAkaXNEZWNvcmF0b3JOb2RlLCAkaXNFbGVtZW50Tm9kZSwgJGlzSW5saW5lRWxlbWVudE9yRGVjb3JhdG9yTm9kZSwgJGlzTGVhZk5vZGUsICRpc0xpbmVCcmVha05vZGUsICRpc05vZGVTZWxlY3Rpb24sICRpc1BhcmFncmFwaE5vZGUsICRpc1JhbmdlU2VsZWN0aW9uLCAkaXNSb290Tm9kZSwgJGlzUm9vdE9yU2hhZG93Um9vdCwgJGlzVGFiTm9kZSwgJGlzVGV4dE5vZGUsICRpc1Rva2VuT3JTZWdtZW50ZWQsICRub2Rlc09mVHlwZSwgJG5vcm1hbGl6ZVNlbGVjdGlvbiBhcyAkbm9ybWFsaXplU2VsZWN0aW9uX19FWFBFUklNRU5UQUwsICRvblVwZGF0ZSwgJHBhcnNlU2VyaWFsaXplZE5vZGUsICRzZWxlY3RBbGwsICRzZXRDb21wb3NpdGlvbktleSwgJHNldFNlbGVjdGlvbiwgJHNwbGl0Tm9kZSwgQXJ0aWZpY2lhbE5vZGVfX0RPX05PVF9VU0UsIEJMVVJfQ09NTUFORCwgQ0FOX1JFRE9fQ09NTUFORCwgQ0FOX1VORE9fQ09NTUFORCwgQ0xFQVJfRURJVE9SX0NPTU1BTkQsIENMRUFSX0hJU1RPUllfQ09NTUFORCwgQ0xJQ0tfQ09NTUFORCwgQ09NTUFORF9QUklPUklUWV9DUklUSUNBTCwgQ09NTUFORF9QUklPUklUWV9FRElUT1IsIENPTU1BTkRfUFJJT1JJVFlfSElHSCwgQ09NTUFORF9QUklPUklUWV9MT1csIENPTU1BTkRfUFJJT1JJVFlfTk9STUFMLCBDT05UUk9MTEVEX1RFWFRfSU5TRVJUSU9OX0NPTU1BTkQsIENPUFlfQ09NTUFORCwgQ1VUX0NPTU1BTkQsIERFTEVURV9DSEFSQUNURVJfQ09NTUFORCwgREVMRVRFX0xJTkVfQ09NTUFORCwgREVMRVRFX1dPUkRfQ09NTUFORCwgRFJBR0VORF9DT01NQU5ELCBEUkFHT1ZFUl9DT01NQU5ELCBEUkFHU1RBUlRfQ09NTUFORCwgRFJPUF9DT01NQU5ELCBEZWNvcmF0b3JOb2RlLCBFbGVtZW50Tm9kZSwgRk9DVVNfQ09NTUFORCwgRk9STUFUX0VMRU1FTlRfQ09NTUFORCwgRk9STUFUX1RFWFRfQ09NTUFORCwgSU5ERU5UX0NPTlRFTlRfQ09NTUFORCwgSU5TRVJUX0xJTkVfQlJFQUtfQ09NTUFORCwgSU5TRVJUX1BBUkFHUkFQSF9DT01NQU5ELCBJTlNFUlRfVEFCX0NPTU1BTkQsIElTX0FMTF9GT1JNQVRUSU5HLCBJU19CT0xELCBJU19DT0RFLCBJU19ISUdITElHSFQsIElTX0lUQUxJQywgSVNfU1RSSUtFVEhST1VHSCwgSVNfU1VCU0NSSVBULCBJU19TVVBFUlNDUklQVCwgSVNfVU5ERVJMSU5FLCBLRVlfQVJST1dfRE9XTl9DT01NQU5ELCBLRVlfQVJST1dfTEVGVF9DT01NQU5ELCBLRVlfQVJST1dfUklHSFRfQ09NTUFORCwgS0VZX0FSUk9XX1VQX0NPTU1BTkQsIEtFWV9CQUNLU1BBQ0VfQ09NTUFORCwgS0VZX0RFTEVURV9DT01NQU5ELCBLRVlfRE9XTl9DT01NQU5ELCBLRVlfRU5URVJfQ09NTUFORCwgS0VZX0VTQ0FQRV9DT01NQU5ELCBLRVlfTU9ESUZJRVJfQ09NTUFORCwgS0VZX1NQQUNFX0NPTU1BTkQsIEtFWV9UQUJfQ09NTUFORCwgTGluZUJyZWFrTm9kZSwgTU9WRV9UT19FTkQsIE1PVkVfVE9fU1RBUlQsIE9VVERFTlRfQ09OVEVOVF9DT01NQU5ELCBQQVNURV9DT01NQU5ELCBQYXJhZ3JhcGhOb2RlLCBSRURPX0NPTU1BTkQsIFJFTU9WRV9URVhUX0NPTU1BTkQsIFJvb3ROb2RlLCBTRUxFQ1RJT05fQ0hBTkdFX0NPTU1BTkQsIFNFTEVDVElPTl9JTlNFUlRfQ0xJUEJPQVJEX05PREVTX0NPTU1BTkQsIFNFTEVDVF9BTExfQ09NTUFORCwgVEVYVF9UWVBFX1RPX0ZPUk1BVCwgVGFiTm9kZSwgVGV4dE5vZGUsIFVORE9fQ09NTUFORCwgY3JlYXRlQ29tbWFuZCwgY3JlYXRlRWRpdG9yLCBnZXRET01Pd25lckRvY3VtZW50LCBnZXRET01TZWxlY3Rpb24sIGdldERPTVNlbGVjdGlvbkZyb21UYXJnZXQsIGdldERPTVRleHROb2RlLCBnZXRFZGl0b3JQcm9wZXJ0eUZyb21ET01Ob2RlLCBnZXROZWFyZXN0RWRpdG9yRnJvbURPTU5vZGUsIGlzQmxvY2tEb21Ob2RlLCBpc0N1cnJlbnRseVJlYWRPbmx5TW9kZSwgaXNET01Eb2N1bWVudE5vZGUsIGlzRE9NTm9kZSwgaXNET01UZXh0Tm9kZSwgaXNET01Vbm1hbmFnZWQsIGlzRG9jdW1lbnRGcmFnbWVudCwgaXNIVE1MQW5jaG9yRWxlbWVudCwgaXNIVE1MRWxlbWVudCwgaXNJbmxpbmVEb21Ob2RlLCBpc0xleGljYWxFZGl0b3IsIGlzU2VsZWN0aW9uQ2FwdHVyZWRJbkRlY29yYXRvcklucHV0LCBpc1NlbGVjdGlvbldpdGhpbkVkaXRvciwgcmVzZXRSYW5kb21LZXksIHNldERPTVVubWFuYWdlZCwgc2V0Tm9kZUluZGVudEZyb21ET00gfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lexical/Lexical.dev.mjs\n"));

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["main-app"], () => (__webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Flei%2Fhome%2Funderg%2Ftheatre%2Fy3%2Fsegp%2Fmilkup%2Fsrc%2Fapp%2Fpage.js%22%2C%22ids%22%3A%5B%5D%7D&server=false!")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);