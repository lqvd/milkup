"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@lexical";
exports.ids = ["vendor-chunks/@lexical"];
exports.modules = {

/***/ "(ssr)/./node_modules/@lexical/clipboard/LexicalClipboard.dev.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@lexical/clipboard/LexicalClipboard.dev.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $generateJSONFromSelectedNodes: () => (/* binding */ $generateJSONFromSelectedNodes),\n/* harmony export */   $generateNodesFromSerializedNodes: () => (/* binding */ $generateNodesFromSerializedNodes),\n/* harmony export */   $getClipboardDataFromSelection: () => (/* binding */ $getClipboardDataFromSelection),\n/* harmony export */   $getHtmlContent: () => (/* binding */ $getHtmlContent),\n/* harmony export */   $getLexicalContent: () => (/* binding */ $getLexicalContent),\n/* harmony export */   $insertDataTransferForPlainText: () => (/* binding */ $insertDataTransferForPlainText),\n/* harmony export */   $insertDataTransferForRichText: () => (/* binding */ $insertDataTransferForRichText),\n/* harmony export */   $insertGeneratedNodes: () => (/* binding */ $insertGeneratedNodes),\n/* harmony export */   copyToClipboard: () => (/* binding */ copyToClipboard),\n/* harmony export */   setLexicalClipboardDataTransfer: () => (/* binding */ setLexicalClipboardDataTransfer)\n/* harmony export */ });\n/* harmony import */ var _lexical_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/html */ \"(ssr)/./node_modules/@lexical/html/LexicalHtml.dev.mjs\");\n/* harmony import */ var _lexical_selection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lexical/selection */ \"(ssr)/./node_modules/@lexical/selection/LexicalSelection.dev.mjs\");\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Returns the *currently selected* Lexical content as an HTML string, relying on the\n * logic defined in the exportDOM methods on the LexicalNode classes. Note that\n * this will not return the HTML content of the entire editor (unless all the content is included\n * in the current selection).\n *\n * @param editor - LexicalEditor instance to get HTML content from\n * @param selection - The selection to use (default is $getSelection())\n * @returns a string of HTML content\n */\nfunction $getHtmlContent(editor, selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)()) {\n  if (selection == null) {\n    {\n      throw Error(`Expected valid LexicalSelection`);\n    }\n  }\n\n  // If we haven't selected anything\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return '';\n  }\n  return (0,_lexical_html__WEBPACK_IMPORTED_MODULE_1__.$generateHtmlFromNodes)(editor, selection);\n}\n\n/**\n * Returns the *currently selected* Lexical content as a JSON string, relying on the\n * logic defined in the exportJSON methods on the LexicalNode classes. Note that\n * this will not return the JSON content of the entire editor (unless all the content is included\n * in the current selection).\n *\n * @param editor  - LexicalEditor instance to get the JSON content from\n * @param selection - The selection to use (default is $getSelection())\n * @returns\n */\nfunction $getLexicalContent(editor, selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)()) {\n  if (selection == null) {\n    {\n      throw Error(`Expected valid LexicalSelection`);\n    }\n  }\n\n  // If we haven't selected anything\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return null;\n  }\n  return JSON.stringify($generateJSONFromSelectedNodes(editor, selection));\n}\n\n/**\n * Attempts to insert content of the mime-types text/plain or text/uri-list from\n * the provided DataTransfer object into the editor at the provided selection.\n * text/uri-list is only used if text/plain is not also provided.\n *\n * @param dataTransfer an object conforming to the [DataTransfer interface] (https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface)\n * @param selection the selection to use as the insertion point for the content in the DataTransfer object\n */\nfunction $insertDataTransferForPlainText(dataTransfer, selection) {\n  const text = dataTransfer.getData('text/plain') || dataTransfer.getData('text/uri-list');\n  if (text != null) {\n    selection.insertRawText(text);\n  }\n}\n\n/**\n * Attempts to insert content of the mime-types application/x-lexical-editor, text/html,\n * text/plain, or text/uri-list (in descending order of priority) from the provided DataTransfer\n * object into the editor at the provided selection.\n *\n * @param dataTransfer an object conforming to the [DataTransfer interface] (https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface)\n * @param selection the selection to use as the insertion point for the content in the DataTransfer object\n * @param editor the LexicalEditor the content is being inserted into.\n */\nfunction $insertDataTransferForRichText(dataTransfer, selection, editor) {\n  const lexicalString = dataTransfer.getData('application/x-lexical-editor');\n  if (lexicalString) {\n    try {\n      const payload = JSON.parse(lexicalString);\n      if (payload.namespace === editor._config.namespace && Array.isArray(payload.nodes)) {\n        const nodes = $generateNodesFromSerializedNodes(payload.nodes);\n        return $insertGeneratedNodes(editor, nodes, selection);\n      }\n    } catch (_unused) {\n      // Fail silently.\n    }\n  }\n  const htmlString = dataTransfer.getData('text/html');\n  if (htmlString) {\n    try {\n      const parser = new DOMParser();\n      const dom = parser.parseFromString(trustHTML(htmlString), 'text/html');\n      const nodes = (0,_lexical_html__WEBPACK_IMPORTED_MODULE_1__.$generateNodesFromDOM)(editor, dom);\n      return $insertGeneratedNodes(editor, nodes, selection);\n    } catch (_unused2) {\n      // Fail silently.\n    }\n  }\n\n  // Multi-line plain text in rich text mode pasted as separate paragraphs\n  // instead of single paragraph with linebreaks.\n  // Webkit-specific: Supports read 'text/uri-list' in clipboard.\n  const text = dataTransfer.getData('text/plain') || dataTransfer.getData('text/uri-list');\n  if (text != null) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      const parts = text.split(/(\\r?\\n|\\t)/);\n      if (parts[parts.length - 1] === '') {\n        parts.pop();\n      }\n      for (let i = 0; i < parts.length; i++) {\n        const currentSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(currentSelection)) {\n          const part = parts[i];\n          if (part === '\\n' || part === '\\r\\n') {\n            currentSelection.insertParagraph();\n          } else if (part === '\\t') {\n            currentSelection.insertNodes([(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTabNode)()]);\n          } else {\n            currentSelection.insertText(part);\n          }\n        }\n      }\n    } else {\n      selection.insertRawText(text);\n    }\n  }\n}\nfunction trustHTML(html) {\n  if (window.trustedTypes && window.trustedTypes.createPolicy) {\n    const policy = window.trustedTypes.createPolicy('lexical', {\n      createHTML: input => input\n    });\n    return policy.createHTML(html);\n  }\n  return html;\n}\n\n/**\n * Inserts Lexical nodes into the editor using different strategies depending on\n * some simple selection-based heuristics. If you're looking for a generic way to\n * to insert nodes into the editor at a specific selection point, you probably want\n * {@link lexical.$insertNodes}\n *\n * @param editor LexicalEditor instance to insert the nodes into.\n * @param nodes The nodes to insert.\n * @param selection The selection to insert the nodes into.\n */\nfunction $insertGeneratedNodes(editor, nodes, selection) {\n  if (!editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, {\n    nodes,\n    selection\n  })) {\n    selection.insertNodes(nodes);\n  }\n  return;\n}\nfunction exportNodeToJSON(node) {\n  const serializedNode = node.exportJSON();\n  const nodeClass = node.constructor;\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .exportJSON().`);\n    }\n  }\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node)) {\n    const serializedChildren = serializedNode.children;\n    if (!Array.isArray(serializedChildren)) {\n      {\n        throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);\n      }\n    }\n  }\n  return serializedNode;\n}\nfunction $appendNodesToJSON(editor, selection, currentNode, targetArray = []) {\n  let shouldInclude = selection !== null ? currentNode.isSelected(selection) : true;\n  const shouldExclude = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n  if (selection !== null) {\n    let clone = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$cloneWithProperties)(currentNode);\n    clone = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(clone) && selection !== null ? (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_2__.$sliceSelectedTextNodeContent)(selection, clone) : clone;\n    target = clone;\n  }\n  const children = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(target) ? target.getChildren() : [];\n  const serializedNode = exportNodeToJSON(target);\n\n  // TODO: TextNode calls getTextContent() (NOT node.__text) within its exportJSON method\n  // which uses getLatest() to get the text from the original node with the same key.\n  // This is a deeper issue with the word \"clone\" here, it's still a reference to the\n  // same node as far as the LexicalEditor is concerned since it shares a key.\n  // We need a way to create a clone of a Node in memory with its own key, but\n  // until then this hack will work for the selected text extract use case.\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(target)) {\n    const text = target.__text;\n    // If an uncollapsed selection ends or starts at the end of a line of specialized,\n    // TextNodes, such as code tokens, we will get a 'blank' TextNode here, i.e., one\n    // with text of length 0. We don't want this, it makes a confusing mess. Reset!\n    if (text.length > 0) {\n      serializedNode.text = text;\n    } else {\n      shouldInclude = false;\n    }\n  }\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToJSON(editor, selection, childNode, serializedNode.children);\n    if (!shouldInclude && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection, 'clone')) {\n      shouldInclude = true;\n    }\n  }\n  if (shouldInclude && !shouldExclude) {\n    targetArray.push(serializedNode);\n  } else if (Array.isArray(serializedNode.children)) {\n    for (let i = 0; i < serializedNode.children.length; i++) {\n      const serializedChildNode = serializedNode.children[i];\n      targetArray.push(serializedChildNode);\n    }\n  }\n  return shouldInclude;\n}\n\n// TODO why $ function with Editor instance?\n/**\n * Gets the Lexical JSON of the nodes inside the provided Selection.\n *\n * @param editor LexicalEditor to get the JSON content from.\n * @param selection Selection to get the JSON content from.\n * @returns an object with the editor namespace and a list of serializable nodes as JavaScript objects.\n */\nfunction $generateJSONFromSelectedNodes(editor, selection) {\n  const nodes = [];\n  const root = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)();\n  const topLevelChildren = root.getChildren();\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToJSON(editor, selection, topLevelNode, nodes);\n  }\n  return {\n    namespace: editor._config.namespace,\n    nodes\n  };\n}\n\n/**\n * This method takes an array of objects conforming to the BaseSeralizedNode interface and returns\n * an Array containing instances of the corresponding LexicalNode classes registered on the editor.\n * Normally, you'd get an Array of BaseSerialized nodes from {@link $generateJSONFromSelectedNodes}\n *\n * @param serializedNodes an Array of objects conforming to the BaseSerializedNode interface.\n * @returns an Array of Lexical Node objects.\n */\nfunction $generateNodesFromSerializedNodes(serializedNodes) {\n  const nodes = [];\n  for (let i = 0; i < serializedNodes.length; i++) {\n    const serializedNode = serializedNodes[i];\n    const node = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$parseSerializedNode)(serializedNode);\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(node)) {\n      (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_2__.$addNodeStyle)(node);\n    }\n    nodes.push(node);\n  }\n  return nodes;\n}\nconst EVENT_LATENCY = 50;\nlet clipboardEventTimeout = null;\n\n// TODO custom selection\n// TODO potentially have a node customizable version for plain text\n/**\n * Copies the content of the current selection to the clipboard in\n * text/plain, text/html, and application/x-lexical-editor (Lexical JSON)\n * formats.\n *\n * @param editor the LexicalEditor instance to copy content from\n * @param event the native browser ClipboardEvent to add the content to.\n * @returns\n */\nasync function copyToClipboard(editor, event, data) {\n  if (clipboardEventTimeout !== null) {\n    // Prevent weird race conditions that can happen when this function is run multiple times\n    // synchronously. In the future, we can do better, we can cancel/override the previously running job.\n    return false;\n  }\n  if (event !== null) {\n    return new Promise((resolve, reject) => {\n      editor.update(() => {\n        resolve($copyToClipboardEvent(editor, event, data));\n      });\n    });\n  }\n  const rootElement = editor.getRootElement();\n  const windowDocument = editor._window == null ? window.document : editor._window.document;\n  const domSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.getDOMSelection)(editor._window);\n  if (rootElement === null || domSelection === null) {\n    return false;\n  }\n  const element = windowDocument.createElement('span');\n  element.style.cssText = 'position: fixed; top: -1000px;';\n  element.append(windowDocument.createTextNode('#'));\n  rootElement.append(element);\n  const range = new Range();\n  range.setStart(element, 0);\n  range.setEnd(element, 1);\n  domSelection.removeAllRanges();\n  domSelection.addRange(range);\n  return new Promise((resolve, reject) => {\n    const removeListener = editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.COPY_COMMAND, secondEvent => {\n      if ((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_3__.objectKlassEquals)(secondEvent, ClipboardEvent)) {\n        removeListener();\n        if (clipboardEventTimeout !== null) {\n          window.clearTimeout(clipboardEventTimeout);\n          clipboardEventTimeout = null;\n        }\n        resolve($copyToClipboardEvent(editor, secondEvent, data));\n      }\n      // Block the entire copy flow while we wait for the next ClipboardEvent\n      return true;\n    }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL);\n    // If the above hack execCommand hack works, this timeout code should never fire. Otherwise,\n    // the listener will be quickly freed so that the user can reuse it again\n    clipboardEventTimeout = window.setTimeout(() => {\n      removeListener();\n      clipboardEventTimeout = null;\n      resolve(false);\n    }, EVENT_LATENCY);\n    windowDocument.execCommand('copy');\n    element.remove();\n  });\n}\n\n// TODO shouldn't pass editor (pass namespace directly)\nfunction $copyToClipboardEvent(editor, event, data) {\n  if (data === undefined) {\n    const domSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.getDOMSelection)(editor._window);\n    if (!domSelection) {\n      return false;\n    }\n    const anchorDOM = domSelection.anchorNode;\n    const focusDOM = domSelection.focusNode;\n    if (anchorDOM !== null && focusDOM !== null && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.isSelectionWithinEditor)(editor, anchorDOM, focusDOM)) {\n      return false;\n    }\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (selection === null) {\n      return false;\n    }\n    data = $getClipboardDataFromSelection(selection);\n  }\n  event.preventDefault();\n  const clipboardData = event.clipboardData;\n  if (clipboardData === null) {\n    return false;\n  }\n  setLexicalClipboardDataTransfer(clipboardData, data);\n  return true;\n}\nconst clipboardDataFunctions = [['text/html', $getHtmlContent], ['application/x-lexical-editor', $getLexicalContent]];\n\n/**\n * Serialize the content of the current selection to strings in\n * text/plain, text/html, and application/x-lexical-editor (Lexical JSON)\n * formats (as available).\n *\n * @param selection the selection to serialize (defaults to $getSelection())\n * @returns LexicalClipboardData\n */\nfunction $getClipboardDataFromSelection(selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)()) {\n  const clipboardData = {\n    'text/plain': selection ? selection.getTextContent() : ''\n  };\n  if (selection) {\n    const editor = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getEditor)();\n    for (const [mimeType, $editorFn] of clipboardDataFunctions) {\n      const v = $editorFn(editor, selection);\n      if (v !== null) {\n        clipboardData[mimeType] = v;\n      }\n    }\n  }\n  return clipboardData;\n}\n\n/**\n * Call setData on the given clipboardData for each MIME type present\n * in the given data (from {@link $getClipboardDataFromSelection})\n *\n * @param clipboardData the event.clipboardData to populate from data\n * @param data The lexical data\n */\nfunction setLexicalClipboardDataTransfer(clipboardData, data) {\n  for (const k in data) {\n    const v = data[k];\n    if (v !== undefined) {\n      clipboardData.setData(k, v);\n    }\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvY2xpcGJvYXJkL0xleGljYWxDbGlwYm9hcmQuZGV2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU4RTtBQUNJO0FBQy9CO0FBQ29QOztBQUV2UztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxzREFBYTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSwwREFBaUI7QUFDdkI7QUFDQTtBQUNBLFNBQVMscUVBQXNCO0FBQy9COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHNEQUFhO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLDBEQUFpQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9FQUFxQjtBQUN6QztBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMERBQWlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QyxpQ0FBaUMsc0RBQWE7QUFDOUMsWUFBWSwwREFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLDBDQUEwQyx1REFBYztBQUN4RCxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsNkVBQXdDO0FBQ3RFO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGdCQUFnQjtBQUN2RDtBQUNBO0FBQ0EsTUFBTSx1REFBYztBQUNwQjtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsZ0JBQWdCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVEQUFjO0FBQ3RDO0FBQ0E7QUFDQSxnQkFBZ0IsNkRBQW9CO0FBQ3BDLFlBQVksb0RBQVcsZ0NBQWdDLGlGQUE2QjtBQUNwRjtBQUNBO0FBQ0EsbUJBQW1CLHVEQUFjO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sb0RBQVc7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBLDBCQUEwQix1REFBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLG9CQUFvQixvQ0FBb0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpREFBUTtBQUN2QjtBQUNBLGtCQUFrQiw2QkFBNkI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDRCQUE0QjtBQUM5QztBQUNBLGlCQUFpQiw2REFBb0I7QUFDckMsUUFBUSxvREFBVztBQUNuQixNQUFNLGlFQUFhO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHdEQUFlO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGFBQWE7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxpREFBWTtBQUM5RCxVQUFVLGlFQUFpQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEVBQUUsOERBQXlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix3REFBZTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGdFQUF1QjtBQUMzRTtBQUNBO0FBQ0Esc0JBQXNCLHNEQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxzREFBYTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtREFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixxQ0FBcUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU0UiIsInNvdXJjZXMiOlsiL1VzZXJzL2xlaS9ob21lL3VuZGVyZy90aGVhdHJlL3kzL3NlZ3AvbWlsa3VwL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9jbGlwYm9hcmQvTGV4aWNhbENsaXBib2FyZC5kZXYubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuaW1wb3J0IHsgJGdlbmVyYXRlSHRtbEZyb21Ob2RlcywgJGdlbmVyYXRlTm9kZXNGcm9tRE9NIH0gZnJvbSAnQGxleGljYWwvaHRtbCc7XG5pbXBvcnQgeyAkYWRkTm9kZVN0eWxlLCAkc2xpY2VTZWxlY3RlZFRleHROb2RlQ29udGVudCB9IGZyb20gJ0BsZXhpY2FsL3NlbGVjdGlvbic7XG5pbXBvcnQgeyBvYmplY3RLbGFzc0VxdWFscyB9IGZyb20gJ0BsZXhpY2FsL3V0aWxzJztcbmltcG9ydCB7ICRpc1JhbmdlU2VsZWN0aW9uLCAkZ2V0U2VsZWN0aW9uLCAkY3JlYXRlVGFiTm9kZSwgU0VMRUNUSU9OX0lOU0VSVF9DTElQQk9BUkRfTk9ERVNfQ09NTUFORCwgJGdldFJvb3QsICRwYXJzZVNlcmlhbGl6ZWROb2RlLCAkaXNUZXh0Tm9kZSwgZ2V0RE9NU2VsZWN0aW9uLCBDT1BZX0NPTU1BTkQsIENPTU1BTkRfUFJJT1JJVFlfQ1JJVElDQUwsIGlzU2VsZWN0aW9uV2l0aGluRWRpdG9yLCAkZ2V0RWRpdG9yLCAkaXNFbGVtZW50Tm9kZSwgJGNsb25lV2l0aFByb3BlcnRpZXMgfSBmcm9tICdsZXhpY2FsJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4vKipcbiAqIFJldHVybnMgdGhlICpjdXJyZW50bHkgc2VsZWN0ZWQqIExleGljYWwgY29udGVudCBhcyBhbiBIVE1MIHN0cmluZywgcmVseWluZyBvbiB0aGVcbiAqIGxvZ2ljIGRlZmluZWQgaW4gdGhlIGV4cG9ydERPTSBtZXRob2RzIG9uIHRoZSBMZXhpY2FsTm9kZSBjbGFzc2VzLiBOb3RlIHRoYXRcbiAqIHRoaXMgd2lsbCBub3QgcmV0dXJuIHRoZSBIVE1MIGNvbnRlbnQgb2YgdGhlIGVudGlyZSBlZGl0b3IgKHVubGVzcyBhbGwgdGhlIGNvbnRlbnQgaXMgaW5jbHVkZWRcbiAqIGluIHRoZSBjdXJyZW50IHNlbGVjdGlvbikuXG4gKlxuICogQHBhcmFtIGVkaXRvciAtIExleGljYWxFZGl0b3IgaW5zdGFuY2UgdG8gZ2V0IEhUTUwgY29udGVudCBmcm9tXG4gKiBAcGFyYW0gc2VsZWN0aW9uIC0gVGhlIHNlbGVjdGlvbiB0byB1c2UgKGRlZmF1bHQgaXMgJGdldFNlbGVjdGlvbigpKVxuICogQHJldHVybnMgYSBzdHJpbmcgb2YgSFRNTCBjb250ZW50XG4gKi9cbmZ1bmN0aW9uICRnZXRIdG1sQ29udGVudChlZGl0b3IsIHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKSkge1xuICBpZiAoc2VsZWN0aW9uID09IG51bGwpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgdmFsaWQgTGV4aWNhbFNlbGVjdGlvbmApO1xuICAgIH1cbiAgfVxuXG4gIC8vIElmIHdlIGhhdmVuJ3Qgc2VsZWN0ZWQgYW55dGhpbmdcbiAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgfHwgc2VsZWN0aW9uLmdldE5vZGVzKCkubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHJldHVybiAkZ2VuZXJhdGVIdG1sRnJvbU5vZGVzKGVkaXRvciwgc2VsZWN0aW9uKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSAqY3VycmVudGx5IHNlbGVjdGVkKiBMZXhpY2FsIGNvbnRlbnQgYXMgYSBKU09OIHN0cmluZywgcmVseWluZyBvbiB0aGVcbiAqIGxvZ2ljIGRlZmluZWQgaW4gdGhlIGV4cG9ydEpTT04gbWV0aG9kcyBvbiB0aGUgTGV4aWNhbE5vZGUgY2xhc3Nlcy4gTm90ZSB0aGF0XG4gKiB0aGlzIHdpbGwgbm90IHJldHVybiB0aGUgSlNPTiBjb250ZW50IG9mIHRoZSBlbnRpcmUgZWRpdG9yICh1bmxlc3MgYWxsIHRoZSBjb250ZW50IGlzIGluY2x1ZGVkXG4gKiBpbiB0aGUgY3VycmVudCBzZWxlY3Rpb24pLlxuICpcbiAqIEBwYXJhbSBlZGl0b3IgIC0gTGV4aWNhbEVkaXRvciBpbnN0YW5jZSB0byBnZXQgdGhlIEpTT04gY29udGVudCBmcm9tXG4gKiBAcGFyYW0gc2VsZWN0aW9uIC0gVGhlIHNlbGVjdGlvbiB0byB1c2UgKGRlZmF1bHQgaXMgJGdldFNlbGVjdGlvbigpKVxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gJGdldExleGljYWxDb250ZW50KGVkaXRvciwgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpKSB7XG4gIGlmIChzZWxlY3Rpb24gPT0gbnVsbCkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCB2YWxpZCBMZXhpY2FsU2VsZWN0aW9uYCk7XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgd2UgaGF2ZW4ndCBzZWxlY3RlZCBhbnl0aGluZ1xuICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSAmJiBzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSB8fCBzZWxlY3Rpb24uZ2V0Tm9kZXMoKS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoJGdlbmVyYXRlSlNPTkZyb21TZWxlY3RlZE5vZGVzKGVkaXRvciwgc2VsZWN0aW9uKSk7XG59XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gaW5zZXJ0IGNvbnRlbnQgb2YgdGhlIG1pbWUtdHlwZXMgdGV4dC9wbGFpbiBvciB0ZXh0L3VyaS1saXN0IGZyb21cbiAqIHRoZSBwcm92aWRlZCBEYXRhVHJhbnNmZXIgb2JqZWN0IGludG8gdGhlIGVkaXRvciBhdCB0aGUgcHJvdmlkZWQgc2VsZWN0aW9uLlxuICogdGV4dC91cmktbGlzdCBpcyBvbmx5IHVzZWQgaWYgdGV4dC9wbGFpbiBpcyBub3QgYWxzbyBwcm92aWRlZC5cbiAqXG4gKiBAcGFyYW0gZGF0YVRyYW5zZmVyIGFuIG9iamVjdCBjb25mb3JtaW5nIHRvIHRoZSBbRGF0YVRyYW5zZmVyIGludGVyZmFjZV0gKGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2RuZC5odG1sI3RoZS1kYXRhdHJhbnNmZXItaW50ZXJmYWNlKVxuICogQHBhcmFtIHNlbGVjdGlvbiB0aGUgc2VsZWN0aW9uIHRvIHVzZSBhcyB0aGUgaW5zZXJ0aW9uIHBvaW50IGZvciB0aGUgY29udGVudCBpbiB0aGUgRGF0YVRyYW5zZmVyIG9iamVjdFxuICovXG5mdW5jdGlvbiAkaW5zZXJ0RGF0YVRyYW5zZmVyRm9yUGxhaW5UZXh0KGRhdGFUcmFuc2Zlciwgc2VsZWN0aW9uKSB7XG4gIGNvbnN0IHRleHQgPSBkYXRhVHJhbnNmZXIuZ2V0RGF0YSgndGV4dC9wbGFpbicpIHx8IGRhdGFUcmFuc2Zlci5nZXREYXRhKCd0ZXh0L3VyaS1saXN0Jyk7XG4gIGlmICh0ZXh0ICE9IG51bGwpIHtcbiAgICBzZWxlY3Rpb24uaW5zZXJ0UmF3VGV4dCh0ZXh0KTtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHRzIHRvIGluc2VydCBjb250ZW50IG9mIHRoZSBtaW1lLXR5cGVzIGFwcGxpY2F0aW9uL3gtbGV4aWNhbC1lZGl0b3IsIHRleHQvaHRtbCxcbiAqIHRleHQvcGxhaW4sIG9yIHRleHQvdXJpLWxpc3QgKGluIGRlc2NlbmRpbmcgb3JkZXIgb2YgcHJpb3JpdHkpIGZyb20gdGhlIHByb3ZpZGVkIERhdGFUcmFuc2ZlclxuICogb2JqZWN0IGludG8gdGhlIGVkaXRvciBhdCB0aGUgcHJvdmlkZWQgc2VsZWN0aW9uLlxuICpcbiAqIEBwYXJhbSBkYXRhVHJhbnNmZXIgYW4gb2JqZWN0IGNvbmZvcm1pbmcgdG8gdGhlIFtEYXRhVHJhbnNmZXIgaW50ZXJmYWNlXSAoaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZG5kLmh0bWwjdGhlLWRhdGF0cmFuc2Zlci1pbnRlcmZhY2UpXG4gKiBAcGFyYW0gc2VsZWN0aW9uIHRoZSBzZWxlY3Rpb24gdG8gdXNlIGFzIHRoZSBpbnNlcnRpb24gcG9pbnQgZm9yIHRoZSBjb250ZW50IGluIHRoZSBEYXRhVHJhbnNmZXIgb2JqZWN0XG4gKiBAcGFyYW0gZWRpdG9yIHRoZSBMZXhpY2FsRWRpdG9yIHRoZSBjb250ZW50IGlzIGJlaW5nIGluc2VydGVkIGludG8uXG4gKi9cbmZ1bmN0aW9uICRpbnNlcnREYXRhVHJhbnNmZXJGb3JSaWNoVGV4dChkYXRhVHJhbnNmZXIsIHNlbGVjdGlvbiwgZWRpdG9yKSB7XG4gIGNvbnN0IGxleGljYWxTdHJpbmcgPSBkYXRhVHJhbnNmZXIuZ2V0RGF0YSgnYXBwbGljYXRpb24veC1sZXhpY2FsLWVkaXRvcicpO1xuICBpZiAobGV4aWNhbFN0cmluZykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwYXlsb2FkID0gSlNPTi5wYXJzZShsZXhpY2FsU3RyaW5nKTtcbiAgICAgIGlmIChwYXlsb2FkLm5hbWVzcGFjZSA9PT0gZWRpdG9yLl9jb25maWcubmFtZXNwYWNlICYmIEFycmF5LmlzQXJyYXkocGF5bG9hZC5ub2RlcykpIHtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSAkZ2VuZXJhdGVOb2Rlc0Zyb21TZXJpYWxpemVkTm9kZXMocGF5bG9hZC5ub2Rlcyk7XG4gICAgICAgIHJldHVybiAkaW5zZXJ0R2VuZXJhdGVkTm9kZXMoZWRpdG9yLCBub2Rlcywgc2VsZWN0aW9uKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChfdW51c2VkKSB7XG4gICAgICAvLyBGYWlsIHNpbGVudGx5LlxuICAgIH1cbiAgfVxuICBjb25zdCBodG1sU3RyaW5nID0gZGF0YVRyYW5zZmVyLmdldERhdGEoJ3RleHQvaHRtbCcpO1xuICBpZiAoaHRtbFN0cmluZykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG4gICAgICBjb25zdCBkb20gPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHRydXN0SFRNTChodG1sU3RyaW5nKSwgJ3RleHQvaHRtbCcpO1xuICAgICAgY29uc3Qgbm9kZXMgPSAkZ2VuZXJhdGVOb2Rlc0Zyb21ET00oZWRpdG9yLCBkb20pO1xuICAgICAgcmV0dXJuICRpbnNlcnRHZW5lcmF0ZWROb2RlcyhlZGl0b3IsIG5vZGVzLCBzZWxlY3Rpb24pO1xuICAgIH0gY2F0Y2ggKF91bnVzZWQyKSB7XG4gICAgICAvLyBGYWlsIHNpbGVudGx5LlxuICAgIH1cbiAgfVxuXG4gIC8vIE11bHRpLWxpbmUgcGxhaW4gdGV4dCBpbiByaWNoIHRleHQgbW9kZSBwYXN0ZWQgYXMgc2VwYXJhdGUgcGFyYWdyYXBoc1xuICAvLyBpbnN0ZWFkIG9mIHNpbmdsZSBwYXJhZ3JhcGggd2l0aCBsaW5lYnJlYWtzLlxuICAvLyBXZWJraXQtc3BlY2lmaWM6IFN1cHBvcnRzIHJlYWQgJ3RleHQvdXJpLWxpc3QnIGluIGNsaXBib2FyZC5cbiAgY29uc3QgdGV4dCA9IGRhdGFUcmFuc2Zlci5nZXREYXRhKCd0ZXh0L3BsYWluJykgfHwgZGF0YVRyYW5zZmVyLmdldERhdGEoJ3RleHQvdXJpLWxpc3QnKTtcbiAgaWYgKHRleHQgIT0gbnVsbCkge1xuICAgIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCBwYXJ0cyA9IHRleHQuc3BsaXQoLyhcXHI/XFxufFxcdCkvKTtcbiAgICAgIGlmIChwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXSA9PT0gJycpIHtcbiAgICAgICAgcGFydHMucG9wKCk7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgIGlmICgkaXNSYW5nZVNlbGVjdGlvbihjdXJyZW50U2VsZWN0aW9uKSkge1xuICAgICAgICAgIGNvbnN0IHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgICAgICBpZiAocGFydCA9PT0gJ1xcbicgfHwgcGFydCA9PT0gJ1xcclxcbicpIHtcbiAgICAgICAgICAgIGN1cnJlbnRTZWxlY3Rpb24uaW5zZXJ0UGFyYWdyYXBoKCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChwYXJ0ID09PSAnXFx0Jykge1xuICAgICAgICAgICAgY3VycmVudFNlbGVjdGlvbi5pbnNlcnROb2RlcyhbJGNyZWF0ZVRhYk5vZGUoKV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXJyZW50U2VsZWN0aW9uLmluc2VydFRleHQocGFydCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGVjdGlvbi5pbnNlcnRSYXdUZXh0KHRleHQpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdHJ1c3RIVE1MKGh0bWwpIHtcbiAgaWYgKHdpbmRvdy50cnVzdGVkVHlwZXMgJiYgd2luZG93LnRydXN0ZWRUeXBlcy5jcmVhdGVQb2xpY3kpIHtcbiAgICBjb25zdCBwb2xpY3kgPSB3aW5kb3cudHJ1c3RlZFR5cGVzLmNyZWF0ZVBvbGljeSgnbGV4aWNhbCcsIHtcbiAgICAgIGNyZWF0ZUhUTUw6IGlucHV0ID0+IGlucHV0XG4gICAgfSk7XG4gICAgcmV0dXJuIHBvbGljeS5jcmVhdGVIVE1MKGh0bWwpO1xuICB9XG4gIHJldHVybiBodG1sO1xufVxuXG4vKipcbiAqIEluc2VydHMgTGV4aWNhbCBub2RlcyBpbnRvIHRoZSBlZGl0b3IgdXNpbmcgZGlmZmVyZW50IHN0cmF0ZWdpZXMgZGVwZW5kaW5nIG9uXG4gKiBzb21lIHNpbXBsZSBzZWxlY3Rpb24tYmFzZWQgaGV1cmlzdGljcy4gSWYgeW91J3JlIGxvb2tpbmcgZm9yIGEgZ2VuZXJpYyB3YXkgdG9cbiAqIHRvIGluc2VydCBub2RlcyBpbnRvIHRoZSBlZGl0b3IgYXQgYSBzcGVjaWZpYyBzZWxlY3Rpb24gcG9pbnQsIHlvdSBwcm9iYWJseSB3YW50XG4gKiB7QGxpbmsgbGV4aWNhbC4kaW5zZXJ0Tm9kZXN9XG4gKlxuICogQHBhcmFtIGVkaXRvciBMZXhpY2FsRWRpdG9yIGluc3RhbmNlIHRvIGluc2VydCB0aGUgbm9kZXMgaW50by5cbiAqIEBwYXJhbSBub2RlcyBUaGUgbm9kZXMgdG8gaW5zZXJ0LlxuICogQHBhcmFtIHNlbGVjdGlvbiBUaGUgc2VsZWN0aW9uIHRvIGluc2VydCB0aGUgbm9kZXMgaW50by5cbiAqL1xuZnVuY3Rpb24gJGluc2VydEdlbmVyYXRlZE5vZGVzKGVkaXRvciwgbm9kZXMsIHNlbGVjdGlvbikge1xuICBpZiAoIWVkaXRvci5kaXNwYXRjaENvbW1hbmQoU0VMRUNUSU9OX0lOU0VSVF9DTElQQk9BUkRfTk9ERVNfQ09NTUFORCwge1xuICAgIG5vZGVzLFxuICAgIHNlbGVjdGlvblxuICB9KSkge1xuICAgIHNlbGVjdGlvbi5pbnNlcnROb2Rlcyhub2Rlcyk7XG4gIH1cbiAgcmV0dXJuO1xufVxuZnVuY3Rpb24gZXhwb3J0Tm9kZVRvSlNPTihub2RlKSB7XG4gIGNvbnN0IHNlcmlhbGl6ZWROb2RlID0gbm9kZS5leHBvcnRKU09OKCk7XG4gIGNvbnN0IG5vZGVDbGFzcyA9IG5vZGUuY29uc3RydWN0b3I7XG4gIGlmIChzZXJpYWxpemVkTm9kZS50eXBlICE9PSBub2RlQ2xhc3MuZ2V0VHlwZSgpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYExleGljYWxOb2RlOiBOb2RlICR7bm9kZUNsYXNzLm5hbWV9IGRvZXMgbm90IGltcGxlbWVudCAuZXhwb3J0SlNPTigpLmApO1xuICAgIH1cbiAgfVxuICBpZiAoJGlzRWxlbWVudE5vZGUobm9kZSkpIHtcbiAgICBjb25zdCBzZXJpYWxpemVkQ2hpbGRyZW4gPSBzZXJpYWxpemVkTm9kZS5jaGlsZHJlbjtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2VyaWFsaXplZENoaWxkcmVuKSkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvcihgTGV4aWNhbE5vZGU6IE5vZGUgJHtub2RlQ2xhc3MubmFtZX0gaXMgYW4gZWxlbWVudCBidXQgLmV4cG9ydEpTT04oKSBkb2VzIG5vdCBoYXZlIGEgY2hpbGRyZW4gYXJyYXkuYCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBzZXJpYWxpemVkTm9kZTtcbn1cbmZ1bmN0aW9uICRhcHBlbmROb2Rlc1RvSlNPTihlZGl0b3IsIHNlbGVjdGlvbiwgY3VycmVudE5vZGUsIHRhcmdldEFycmF5ID0gW10pIHtcbiAgbGV0IHNob3VsZEluY2x1ZGUgPSBzZWxlY3Rpb24gIT09IG51bGwgPyBjdXJyZW50Tm9kZS5pc1NlbGVjdGVkKHNlbGVjdGlvbikgOiB0cnVlO1xuICBjb25zdCBzaG91bGRFeGNsdWRlID0gJGlzRWxlbWVudE5vZGUoY3VycmVudE5vZGUpICYmIGN1cnJlbnROb2RlLmV4Y2x1ZGVGcm9tQ29weSgnaHRtbCcpO1xuICBsZXQgdGFyZ2V0ID0gY3VycmVudE5vZGU7XG4gIGlmIChzZWxlY3Rpb24gIT09IG51bGwpIHtcbiAgICBsZXQgY2xvbmUgPSAkY2xvbmVXaXRoUHJvcGVydGllcyhjdXJyZW50Tm9kZSk7XG4gICAgY2xvbmUgPSAkaXNUZXh0Tm9kZShjbG9uZSkgJiYgc2VsZWN0aW9uICE9PSBudWxsID8gJHNsaWNlU2VsZWN0ZWRUZXh0Tm9kZUNvbnRlbnQoc2VsZWN0aW9uLCBjbG9uZSkgOiBjbG9uZTtcbiAgICB0YXJnZXQgPSBjbG9uZTtcbiAgfVxuICBjb25zdCBjaGlsZHJlbiA9ICRpc0VsZW1lbnROb2RlKHRhcmdldCkgPyB0YXJnZXQuZ2V0Q2hpbGRyZW4oKSA6IFtdO1xuICBjb25zdCBzZXJpYWxpemVkTm9kZSA9IGV4cG9ydE5vZGVUb0pTT04odGFyZ2V0KTtcblxuICAvLyBUT0RPOiBUZXh0Tm9kZSBjYWxscyBnZXRUZXh0Q29udGVudCgpIChOT1Qgbm9kZS5fX3RleHQpIHdpdGhpbiBpdHMgZXhwb3J0SlNPTiBtZXRob2RcbiAgLy8gd2hpY2ggdXNlcyBnZXRMYXRlc3QoKSB0byBnZXQgdGhlIHRleHQgZnJvbSB0aGUgb3JpZ2luYWwgbm9kZSB3aXRoIHRoZSBzYW1lIGtleS5cbiAgLy8gVGhpcyBpcyBhIGRlZXBlciBpc3N1ZSB3aXRoIHRoZSB3b3JkIFwiY2xvbmVcIiBoZXJlLCBpdCdzIHN0aWxsIGEgcmVmZXJlbmNlIHRvIHRoZVxuICAvLyBzYW1lIG5vZGUgYXMgZmFyIGFzIHRoZSBMZXhpY2FsRWRpdG9yIGlzIGNvbmNlcm5lZCBzaW5jZSBpdCBzaGFyZXMgYSBrZXkuXG4gIC8vIFdlIG5lZWQgYSB3YXkgdG8gY3JlYXRlIGEgY2xvbmUgb2YgYSBOb2RlIGluIG1lbW9yeSB3aXRoIGl0cyBvd24ga2V5LCBidXRcbiAgLy8gdW50aWwgdGhlbiB0aGlzIGhhY2sgd2lsbCB3b3JrIGZvciB0aGUgc2VsZWN0ZWQgdGV4dCBleHRyYWN0IHVzZSBjYXNlLlxuICBpZiAoJGlzVGV4dE5vZGUodGFyZ2V0KSkge1xuICAgIGNvbnN0IHRleHQgPSB0YXJnZXQuX190ZXh0O1xuICAgIC8vIElmIGFuIHVuY29sbGFwc2VkIHNlbGVjdGlvbiBlbmRzIG9yIHN0YXJ0cyBhdCB0aGUgZW5kIG9mIGEgbGluZSBvZiBzcGVjaWFsaXplZCxcbiAgICAvLyBUZXh0Tm9kZXMsIHN1Y2ggYXMgY29kZSB0b2tlbnMsIHdlIHdpbGwgZ2V0IGEgJ2JsYW5rJyBUZXh0Tm9kZSBoZXJlLCBpLmUuLCBvbmVcbiAgICAvLyB3aXRoIHRleHQgb2YgbGVuZ3RoIDAuIFdlIGRvbid0IHdhbnQgdGhpcywgaXQgbWFrZXMgYSBjb25mdXNpbmcgbWVzcy4gUmVzZXQhXG4gICAgaWYgKHRleHQubGVuZ3RoID4gMCkge1xuICAgICAgc2VyaWFsaXplZE5vZGUudGV4dCA9IHRleHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNob3VsZEluY2x1ZGUgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNoaWxkTm9kZSA9IGNoaWxkcmVuW2ldO1xuICAgIGNvbnN0IHNob3VsZEluY2x1ZGVDaGlsZCA9ICRhcHBlbmROb2Rlc1RvSlNPTihlZGl0b3IsIHNlbGVjdGlvbiwgY2hpbGROb2RlLCBzZXJpYWxpemVkTm9kZS5jaGlsZHJlbik7XG4gICAgaWYgKCFzaG91bGRJbmNsdWRlICYmICRpc0VsZW1lbnROb2RlKGN1cnJlbnROb2RlKSAmJiBzaG91bGRJbmNsdWRlQ2hpbGQgJiYgY3VycmVudE5vZGUuZXh0cmFjdFdpdGhDaGlsZChjaGlsZE5vZGUsIHNlbGVjdGlvbiwgJ2Nsb25lJykpIHtcbiAgICAgIHNob3VsZEluY2x1ZGUgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBpZiAoc2hvdWxkSW5jbHVkZSAmJiAhc2hvdWxkRXhjbHVkZSkge1xuICAgIHRhcmdldEFycmF5LnB1c2goc2VyaWFsaXplZE5vZGUpO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc2VyaWFsaXplZE5vZGUuY2hpbGRyZW4pKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXJpYWxpemVkTm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc2VyaWFsaXplZENoaWxkTm9kZSA9IHNlcmlhbGl6ZWROb2RlLmNoaWxkcmVuW2ldO1xuICAgICAgdGFyZ2V0QXJyYXkucHVzaChzZXJpYWxpemVkQ2hpbGROb2RlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNob3VsZEluY2x1ZGU7XG59XG5cbi8vIFRPRE8gd2h5ICQgZnVuY3Rpb24gd2l0aCBFZGl0b3IgaW5zdGFuY2U/XG4vKipcbiAqIEdldHMgdGhlIExleGljYWwgSlNPTiBvZiB0aGUgbm9kZXMgaW5zaWRlIHRoZSBwcm92aWRlZCBTZWxlY3Rpb24uXG4gKlxuICogQHBhcmFtIGVkaXRvciBMZXhpY2FsRWRpdG9yIHRvIGdldCB0aGUgSlNPTiBjb250ZW50IGZyb20uXG4gKiBAcGFyYW0gc2VsZWN0aW9uIFNlbGVjdGlvbiB0byBnZXQgdGhlIEpTT04gY29udGVudCBmcm9tLlxuICogQHJldHVybnMgYW4gb2JqZWN0IHdpdGggdGhlIGVkaXRvciBuYW1lc3BhY2UgYW5kIGEgbGlzdCBvZiBzZXJpYWxpemFibGUgbm9kZXMgYXMgSmF2YVNjcmlwdCBvYmplY3RzLlxuICovXG5mdW5jdGlvbiAkZ2VuZXJhdGVKU09ORnJvbVNlbGVjdGVkTm9kZXMoZWRpdG9yLCBzZWxlY3Rpb24pIHtcbiAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgY29uc3Qgcm9vdCA9ICRnZXRSb290KCk7XG4gIGNvbnN0IHRvcExldmVsQ2hpbGRyZW4gPSByb290LmdldENoaWxkcmVuKCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdG9wTGV2ZWxDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHRvcExldmVsTm9kZSA9IHRvcExldmVsQ2hpbGRyZW5baV07XG4gICAgJGFwcGVuZE5vZGVzVG9KU09OKGVkaXRvciwgc2VsZWN0aW9uLCB0b3BMZXZlbE5vZGUsIG5vZGVzKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWVzcGFjZTogZWRpdG9yLl9jb25maWcubmFtZXNwYWNlLFxuICAgIG5vZGVzXG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgdGFrZXMgYW4gYXJyYXkgb2Ygb2JqZWN0cyBjb25mb3JtaW5nIHRvIHRoZSBCYXNlU2VyYWxpemVkTm9kZSBpbnRlcmZhY2UgYW5kIHJldHVybnNcbiAqIGFuIEFycmF5IGNvbnRhaW5pbmcgaW5zdGFuY2VzIG9mIHRoZSBjb3JyZXNwb25kaW5nIExleGljYWxOb2RlIGNsYXNzZXMgcmVnaXN0ZXJlZCBvbiB0aGUgZWRpdG9yLlxuICogTm9ybWFsbHksIHlvdSdkIGdldCBhbiBBcnJheSBvZiBCYXNlU2VyaWFsaXplZCBub2RlcyBmcm9tIHtAbGluayAkZ2VuZXJhdGVKU09ORnJvbVNlbGVjdGVkTm9kZXN9XG4gKlxuICogQHBhcmFtIHNlcmlhbGl6ZWROb2RlcyBhbiBBcnJheSBvZiBvYmplY3RzIGNvbmZvcm1pbmcgdG8gdGhlIEJhc2VTZXJpYWxpemVkTm9kZSBpbnRlcmZhY2UuXG4gKiBAcmV0dXJucyBhbiBBcnJheSBvZiBMZXhpY2FsIE5vZGUgb2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gJGdlbmVyYXRlTm9kZXNGcm9tU2VyaWFsaXplZE5vZGVzKHNlcmlhbGl6ZWROb2Rlcykge1xuICBjb25zdCBub2RlcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlcmlhbGl6ZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWROb2RlID0gc2VyaWFsaXplZE5vZGVzW2ldO1xuICAgIGNvbnN0IG5vZGUgPSAkcGFyc2VTZXJpYWxpemVkTm9kZShzZXJpYWxpemVkTm9kZSk7XG4gICAgaWYgKCRpc1RleHROb2RlKG5vZGUpKSB7XG4gICAgICAkYWRkTm9kZVN0eWxlKG5vZGUpO1xuICAgIH1cbiAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICB9XG4gIHJldHVybiBub2Rlcztcbn1cbmNvbnN0IEVWRU5UX0xBVEVOQ1kgPSA1MDtcbmxldCBjbGlwYm9hcmRFdmVudFRpbWVvdXQgPSBudWxsO1xuXG4vLyBUT0RPIGN1c3RvbSBzZWxlY3Rpb25cbi8vIFRPRE8gcG90ZW50aWFsbHkgaGF2ZSBhIG5vZGUgY3VzdG9taXphYmxlIHZlcnNpb24gZm9yIHBsYWluIHRleHRcbi8qKlxuICogQ29waWVzIHRoZSBjb250ZW50IG9mIHRoZSBjdXJyZW50IHNlbGVjdGlvbiB0byB0aGUgY2xpcGJvYXJkIGluXG4gKiB0ZXh0L3BsYWluLCB0ZXh0L2h0bWwsIGFuZCBhcHBsaWNhdGlvbi94LWxleGljYWwtZWRpdG9yIChMZXhpY2FsIEpTT04pXG4gKiBmb3JtYXRzLlxuICpcbiAqIEBwYXJhbSBlZGl0b3IgdGhlIExleGljYWxFZGl0b3IgaW5zdGFuY2UgdG8gY29weSBjb250ZW50IGZyb21cbiAqIEBwYXJhbSBldmVudCB0aGUgbmF0aXZlIGJyb3dzZXIgQ2xpcGJvYXJkRXZlbnQgdG8gYWRkIHRoZSBjb250ZW50IHRvLlxuICogQHJldHVybnNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gY29weVRvQ2xpcGJvYXJkKGVkaXRvciwgZXZlbnQsIGRhdGEpIHtcbiAgaWYgKGNsaXBib2FyZEV2ZW50VGltZW91dCAhPT0gbnVsbCkge1xuICAgIC8vIFByZXZlbnQgd2VpcmQgcmFjZSBjb25kaXRpb25zIHRoYXQgY2FuIGhhcHBlbiB3aGVuIHRoaXMgZnVuY3Rpb24gaXMgcnVuIG11bHRpcGxlIHRpbWVzXG4gICAgLy8gc3luY2hyb25vdXNseS4gSW4gdGhlIGZ1dHVyZSwgd2UgY2FuIGRvIGJldHRlciwgd2UgY2FuIGNhbmNlbC9vdmVycmlkZSB0aGUgcHJldmlvdXNseSBydW5uaW5nIGpvYi5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGV2ZW50ICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgICAgICByZXNvbHZlKCRjb3B5VG9DbGlwYm9hcmRFdmVudChlZGl0b3IsIGV2ZW50LCBkYXRhKSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBjb25zdCByb290RWxlbWVudCA9IGVkaXRvci5nZXRSb290RWxlbWVudCgpO1xuICBjb25zdCB3aW5kb3dEb2N1bWVudCA9IGVkaXRvci5fd2luZG93ID09IG51bGwgPyB3aW5kb3cuZG9jdW1lbnQgOiBlZGl0b3IuX3dpbmRvdy5kb2N1bWVudDtcbiAgY29uc3QgZG9tU2VsZWN0aW9uID0gZ2V0RE9NU2VsZWN0aW9uKGVkaXRvci5fd2luZG93KTtcbiAgaWYgKHJvb3RFbGVtZW50ID09PSBudWxsIHx8IGRvbVNlbGVjdGlvbiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBlbGVtZW50ID0gd2luZG93RG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICBlbGVtZW50LnN0eWxlLmNzc1RleHQgPSAncG9zaXRpb246IGZpeGVkOyB0b3A6IC0xMDAwcHg7JztcbiAgZWxlbWVudC5hcHBlbmQod2luZG93RG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJyMnKSk7XG4gIHJvb3RFbGVtZW50LmFwcGVuZChlbGVtZW50KTtcbiAgY29uc3QgcmFuZ2UgPSBuZXcgUmFuZ2UoKTtcbiAgcmFuZ2Uuc2V0U3RhcnQoZWxlbWVudCwgMCk7XG4gIHJhbmdlLnNldEVuZChlbGVtZW50LCAxKTtcbiAgZG9tU2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuICBkb21TZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHJlbW92ZUxpc3RlbmVyID0gZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChDT1BZX0NPTU1BTkQsIHNlY29uZEV2ZW50ID0+IHtcbiAgICAgIGlmIChvYmplY3RLbGFzc0VxdWFscyhzZWNvbmRFdmVudCwgQ2xpcGJvYXJkRXZlbnQpKSB7XG4gICAgICAgIHJlbW92ZUxpc3RlbmVyKCk7XG4gICAgICAgIGlmIChjbGlwYm9hcmRFdmVudFRpbWVvdXQgIT09IG51bGwpIHtcbiAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KGNsaXBib2FyZEV2ZW50VGltZW91dCk7XG4gICAgICAgICAgY2xpcGJvYXJkRXZlbnRUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKCRjb3B5VG9DbGlwYm9hcmRFdmVudChlZGl0b3IsIHNlY29uZEV2ZW50LCBkYXRhKSk7XG4gICAgICB9XG4gICAgICAvLyBCbG9jayB0aGUgZW50aXJlIGNvcHkgZmxvdyB3aGlsZSB3ZSB3YWl0IGZvciB0aGUgbmV4dCBDbGlwYm9hcmRFdmVudFxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSwgQ09NTUFORF9QUklPUklUWV9DUklUSUNBTCk7XG4gICAgLy8gSWYgdGhlIGFib3ZlIGhhY2sgZXhlY0NvbW1hbmQgaGFjayB3b3JrcywgdGhpcyB0aW1lb3V0IGNvZGUgc2hvdWxkIG5ldmVyIGZpcmUuIE90aGVyd2lzZSxcbiAgICAvLyB0aGUgbGlzdGVuZXIgd2lsbCBiZSBxdWlja2x5IGZyZWVkIHNvIHRoYXQgdGhlIHVzZXIgY2FuIHJldXNlIGl0IGFnYWluXG4gICAgY2xpcGJvYXJkRXZlbnRUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoKTtcbiAgICAgIGNsaXBib2FyZEV2ZW50VGltZW91dCA9IG51bGw7XG4gICAgICByZXNvbHZlKGZhbHNlKTtcbiAgICB9LCBFVkVOVF9MQVRFTkNZKTtcbiAgICB3aW5kb3dEb2N1bWVudC5leGVjQ29tbWFuZCgnY29weScpO1xuICAgIGVsZW1lbnQucmVtb3ZlKCk7XG4gIH0pO1xufVxuXG4vLyBUT0RPIHNob3VsZG4ndCBwYXNzIGVkaXRvciAocGFzcyBuYW1lc3BhY2UgZGlyZWN0bHkpXG5mdW5jdGlvbiAkY29weVRvQ2xpcGJvYXJkRXZlbnQoZWRpdG9yLCBldmVudCwgZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgZG9tU2VsZWN0aW9uID0gZ2V0RE9NU2VsZWN0aW9uKGVkaXRvci5fd2luZG93KTtcbiAgICBpZiAoIWRvbVNlbGVjdGlvbikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBhbmNob3JET00gPSBkb21TZWxlY3Rpb24uYW5jaG9yTm9kZTtcbiAgICBjb25zdCBmb2N1c0RPTSA9IGRvbVNlbGVjdGlvbi5mb2N1c05vZGU7XG4gICAgaWYgKGFuY2hvckRPTSAhPT0gbnVsbCAmJiBmb2N1c0RPTSAhPT0gbnVsbCAmJiAhaXNTZWxlY3Rpb25XaXRoaW5FZGl0b3IoZWRpdG9yLCBhbmNob3JET00sIGZvY3VzRE9NKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKHNlbGVjdGlvbiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBkYXRhID0gJGdldENsaXBib2FyZERhdGFGcm9tU2VsZWN0aW9uKHNlbGVjdGlvbik7XG4gIH1cbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgY29uc3QgY2xpcGJvYXJkRGF0YSA9IGV2ZW50LmNsaXBib2FyZERhdGE7XG4gIGlmIChjbGlwYm9hcmREYXRhID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHNldExleGljYWxDbGlwYm9hcmREYXRhVHJhbnNmZXIoY2xpcGJvYXJkRGF0YSwgZGF0YSk7XG4gIHJldHVybiB0cnVlO1xufVxuY29uc3QgY2xpcGJvYXJkRGF0YUZ1bmN0aW9ucyA9IFtbJ3RleHQvaHRtbCcsICRnZXRIdG1sQ29udGVudF0sIFsnYXBwbGljYXRpb24veC1sZXhpY2FsLWVkaXRvcicsICRnZXRMZXhpY2FsQ29udGVudF1dO1xuXG4vKipcbiAqIFNlcmlhbGl6ZSB0aGUgY29udGVudCBvZiB0aGUgY3VycmVudCBzZWxlY3Rpb24gdG8gc3RyaW5ncyBpblxuICogdGV4dC9wbGFpbiwgdGV4dC9odG1sLCBhbmQgYXBwbGljYXRpb24veC1sZXhpY2FsLWVkaXRvciAoTGV4aWNhbCBKU09OKVxuICogZm9ybWF0cyAoYXMgYXZhaWxhYmxlKS5cbiAqXG4gKiBAcGFyYW0gc2VsZWN0aW9uIHRoZSBzZWxlY3Rpb24gdG8gc2VyaWFsaXplIChkZWZhdWx0cyB0byAkZ2V0U2VsZWN0aW9uKCkpXG4gKiBAcmV0dXJucyBMZXhpY2FsQ2xpcGJvYXJkRGF0YVxuICovXG5mdW5jdGlvbiAkZ2V0Q2xpcGJvYXJkRGF0YUZyb21TZWxlY3Rpb24oc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpKSB7XG4gIGNvbnN0IGNsaXBib2FyZERhdGEgPSB7XG4gICAgJ3RleHQvcGxhaW4nOiBzZWxlY3Rpb24gPyBzZWxlY3Rpb24uZ2V0VGV4dENvbnRlbnQoKSA6ICcnXG4gIH07XG4gIGlmIChzZWxlY3Rpb24pIHtcbiAgICBjb25zdCBlZGl0b3IgPSAkZ2V0RWRpdG9yKCk7XG4gICAgZm9yIChjb25zdCBbbWltZVR5cGUsICRlZGl0b3JGbl0gb2YgY2xpcGJvYXJkRGF0YUZ1bmN0aW9ucykge1xuICAgICAgY29uc3QgdiA9ICRlZGl0b3JGbihlZGl0b3IsIHNlbGVjdGlvbik7XG4gICAgICBpZiAodiAhPT0gbnVsbCkge1xuICAgICAgICBjbGlwYm9hcmREYXRhW21pbWVUeXBlXSA9IHY7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjbGlwYm9hcmREYXRhO1xufVxuXG4vKipcbiAqIENhbGwgc2V0RGF0YSBvbiB0aGUgZ2l2ZW4gY2xpcGJvYXJkRGF0YSBmb3IgZWFjaCBNSU1FIHR5cGUgcHJlc2VudFxuICogaW4gdGhlIGdpdmVuIGRhdGEgKGZyb20ge0BsaW5rICRnZXRDbGlwYm9hcmREYXRhRnJvbVNlbGVjdGlvbn0pXG4gKlxuICogQHBhcmFtIGNsaXBib2FyZERhdGEgdGhlIGV2ZW50LmNsaXBib2FyZERhdGEgdG8gcG9wdWxhdGUgZnJvbSBkYXRhXG4gKiBAcGFyYW0gZGF0YSBUaGUgbGV4aWNhbCBkYXRhXG4gKi9cbmZ1bmN0aW9uIHNldExleGljYWxDbGlwYm9hcmREYXRhVHJhbnNmZXIoY2xpcGJvYXJkRGF0YSwgZGF0YSkge1xuICBmb3IgKGNvbnN0IGsgaW4gZGF0YSkge1xuICAgIGNvbnN0IHYgPSBkYXRhW2tdO1xuICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNsaXBib2FyZERhdGEuc2V0RGF0YShrLCB2KTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHsgJGdlbmVyYXRlSlNPTkZyb21TZWxlY3RlZE5vZGVzLCAkZ2VuZXJhdGVOb2Rlc0Zyb21TZXJpYWxpemVkTm9kZXMsICRnZXRDbGlwYm9hcmREYXRhRnJvbVNlbGVjdGlvbiwgJGdldEh0bWxDb250ZW50LCAkZ2V0TGV4aWNhbENvbnRlbnQsICRpbnNlcnREYXRhVHJhbnNmZXJGb3JQbGFpblRleHQsICRpbnNlcnREYXRhVHJhbnNmZXJGb3JSaWNoVGV4dCwgJGluc2VydEdlbmVyYXRlZE5vZGVzLCBjb3B5VG9DbGlwYm9hcmQsIHNldExleGljYWxDbGlwYm9hcmREYXRhVHJhbnNmZXIgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/clipboard/LexicalClipboard.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/dragon/LexicalDragon.dev.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@lexical/dragon/LexicalDragon.dev.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   registerDragonSupport: () => (/* binding */ registerDragonSupport)\n/* harmony export */ });\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction registerDragonSupport(editor) {\n  const origin = window.location.origin;\n  const handler = event => {\n    if (event.origin !== origin) {\n      return;\n    }\n    const rootElement = editor.getRootElement();\n    if (document.activeElement !== rootElement) {\n      return;\n    }\n    const data = event.data;\n    if (typeof data === 'string') {\n      let parsedData;\n      try {\n        parsedData = JSON.parse(data);\n      } catch (e) {\n        return;\n      }\n      if (parsedData && parsedData.protocol === 'nuanria_messaging' && parsedData.type === 'request') {\n        const payload = parsedData.payload;\n        if (payload && payload.functionId === 'makeChanges') {\n          const args = payload.args;\n          if (args) {\n            const [elementStart, elementLength, text, selStart, selLength, formatCommand] = args;\n            editor.update(() => {\n              const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n              if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n                const anchor = selection.anchor;\n                let anchorNode = anchor.getNode();\n                let setSelStart = 0;\n                let setSelEnd = 0;\n                if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(anchorNode)) {\n                  // set initial selection\n                  if (elementStart >= 0 && elementLength >= 0) {\n                    setSelStart = elementStart;\n                    setSelEnd = elementStart + elementLength;\n                    // If the offset is more than the end, make it the end\n                    selection.setTextNodeRange(anchorNode, setSelStart, anchorNode, setSelEnd);\n                  }\n                }\n                if (setSelStart !== setSelEnd || text !== '') {\n                  selection.insertRawText(text);\n                  anchorNode = anchor.getNode();\n                }\n                if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(anchorNode)) {\n                  // set final selection\n                  setSelStart = selStart;\n                  setSelEnd = selStart + selLength;\n                  const anchorNodeTextLength = anchorNode.getTextContentSize();\n                  // If the offset is more than the end, make it the end\n                  setSelStart = setSelStart > anchorNodeTextLength ? anchorNodeTextLength : setSelStart;\n                  setSelEnd = setSelEnd > anchorNodeTextLength ? anchorNodeTextLength : setSelEnd;\n                  selection.setTextNodeRange(anchorNode, setSelStart, anchorNode, setSelEnd);\n                }\n\n                // block the chrome extension from handling this event\n                event.stopImmediatePropagation();\n              }\n            });\n          }\n        }\n      }\n    }\n  };\n  window.addEventListener('message', handler, true);\n  return () => {\n    window.removeEventListener('message', handler, true);\n  };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvZHJhZ29uL0xleGljYWxEcmFnb24uZGV2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV3RTs7QUFFeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxzREFBYTtBQUM3QyxrQkFBa0IsMERBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9EQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvREFBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVpQyIsInNvdXJjZXMiOlsiL1VzZXJzL2xlaS9ob21lL3VuZGVyZy90aGVhdHJlL3kzL3NlZ3AvbWlsa3VwL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9kcmFnb24vTGV4aWNhbERyYWdvbi5kZXYubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuaW1wb3J0IHsgJGdldFNlbGVjdGlvbiwgJGlzUmFuZ2VTZWxlY3Rpb24sICRpc1RleHROb2RlIH0gZnJvbSAnbGV4aWNhbCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gcmVnaXN0ZXJEcmFnb25TdXBwb3J0KGVkaXRvcikge1xuICBjb25zdCBvcmlnaW4gPSB3aW5kb3cubG9jYXRpb24ub3JpZ2luO1xuICBjb25zdCBoYW5kbGVyID0gZXZlbnQgPT4ge1xuICAgIGlmIChldmVudC5vcmlnaW4gIT09IG9yaWdpbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByb290RWxlbWVudCA9IGVkaXRvci5nZXRSb290RWxlbWVudCgpO1xuICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSByb290RWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gZXZlbnQuZGF0YTtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICBsZXQgcGFyc2VkRGF0YTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHBhcnNlZERhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAocGFyc2VkRGF0YSAmJiBwYXJzZWREYXRhLnByb3RvY29sID09PSAnbnVhbnJpYV9tZXNzYWdpbmcnICYmIHBhcnNlZERhdGEudHlwZSA9PT0gJ3JlcXVlc3QnKSB7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSBwYXJzZWREYXRhLnBheWxvYWQ7XG4gICAgICAgIGlmIChwYXlsb2FkICYmIHBheWxvYWQuZnVuY3Rpb25JZCA9PT0gJ21ha2VDaGFuZ2VzJykge1xuICAgICAgICAgIGNvbnN0IGFyZ3MgPSBwYXlsb2FkLmFyZ3M7XG4gICAgICAgICAgaWYgKGFyZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IFtlbGVtZW50U3RhcnQsIGVsZW1lbnRMZW5ndGgsIHRleHQsIHNlbFN0YXJ0LCBzZWxMZW5ndGgsIGZvcm1hdENvbW1hbmRdID0gYXJncztcbiAgICAgICAgICAgIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICAgIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgICAgICAgICAgICAgICBsZXQgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gICAgICAgICAgICAgICAgbGV0IHNldFNlbFN0YXJ0ID0gMDtcbiAgICAgICAgICAgICAgICBsZXQgc2V0U2VsRW5kID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoJGlzVGV4dE5vZGUoYW5jaG9yTm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgIC8vIHNldCBpbml0aWFsIHNlbGVjdGlvblxuICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRTdGFydCA+PSAwICYmIGVsZW1lbnRMZW5ndGggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzZXRTZWxTdGFydCA9IGVsZW1lbnRTdGFydDtcbiAgICAgICAgICAgICAgICAgICAgc2V0U2VsRW5kID0gZWxlbWVudFN0YXJ0ICsgZWxlbWVudExlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIG9mZnNldCBpcyBtb3JlIHRoYW4gdGhlIGVuZCwgbWFrZSBpdCB0aGUgZW5kXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5zZXRUZXh0Tm9kZVJhbmdlKGFuY2hvck5vZGUsIHNldFNlbFN0YXJ0LCBhbmNob3JOb2RlLCBzZXRTZWxFbmQpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2V0U2VsU3RhcnQgIT09IHNldFNlbEVuZCB8fCB0ZXh0ICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uLmluc2VydFJhd1RleHQodGV4dCk7XG4gICAgICAgICAgICAgICAgICBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCRpc1RleHROb2RlKGFuY2hvck5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAvLyBzZXQgZmluYWwgc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgICBzZXRTZWxTdGFydCA9IHNlbFN0YXJ0O1xuICAgICAgICAgICAgICAgICAgc2V0U2VsRW5kID0gc2VsU3RhcnQgKyBzZWxMZW5ndGg7XG4gICAgICAgICAgICAgICAgICBjb25zdCBhbmNob3JOb2RlVGV4dExlbmd0aCA9IGFuY2hvck5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCk7XG4gICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgb2Zmc2V0IGlzIG1vcmUgdGhhbiB0aGUgZW5kLCBtYWtlIGl0IHRoZSBlbmRcbiAgICAgICAgICAgICAgICAgIHNldFNlbFN0YXJ0ID0gc2V0U2VsU3RhcnQgPiBhbmNob3JOb2RlVGV4dExlbmd0aCA/IGFuY2hvck5vZGVUZXh0TGVuZ3RoIDogc2V0U2VsU3RhcnQ7XG4gICAgICAgICAgICAgICAgICBzZXRTZWxFbmQgPSBzZXRTZWxFbmQgPiBhbmNob3JOb2RlVGV4dExlbmd0aCA/IGFuY2hvck5vZGVUZXh0TGVuZ3RoIDogc2V0U2VsRW5kO1xuICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uLnNldFRleHROb2RlUmFuZ2UoYW5jaG9yTm9kZSwgc2V0U2VsU3RhcnQsIGFuY2hvck5vZGUsIHNldFNlbEVuZCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gYmxvY2sgdGhlIGNocm9tZSBleHRlbnNpb24gZnJvbSBoYW5kbGluZyB0aGlzIGV2ZW50XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBoYW5kbGVyLCB0cnVlKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGhhbmRsZXIsIHRydWUpO1xuICB9O1xufVxuXG5leHBvcnQgeyByZWdpc3RlckRyYWdvblN1cHBvcnQgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/dragon/LexicalDragon.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/history/LexicalHistory.dev.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@lexical/history/LexicalHistory.dev.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createEmptyHistoryState: () => (/* binding */ createEmptyHistoryState),\n/* harmony export */   registerHistory: () => (/* binding */ registerHistory)\n/* harmony export */ });\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst HISTORY_MERGE = 0;\nconst HISTORY_PUSH = 1;\nconst DISCARD_HISTORY_CANDIDATE = 2;\nconst OTHER = 0;\nconst COMPOSING_CHARACTER = 1;\nconst INSERT_CHARACTER_AFTER_SELECTION = 2;\nconst DELETE_CHARACTER_BEFORE_SELECTION = 3;\nconst DELETE_CHARACTER_AFTER_SELECTION = 4;\nfunction getDirtyNodes(editorState, dirtyLeaves, dirtyElements) {\n  const nodeMap = editorState._nodeMap;\n  const nodes = [];\n  for (const dirtyLeafKey of dirtyLeaves) {\n    const dirtyLeaf = nodeMap.get(dirtyLeafKey);\n    if (dirtyLeaf !== undefined) {\n      nodes.push(dirtyLeaf);\n    }\n  }\n  for (const [dirtyElementKey, intentionallyMarkedAsDirty] of dirtyElements) {\n    if (!intentionallyMarkedAsDirty) {\n      continue;\n    }\n    const dirtyElement = nodeMap.get(dirtyElementKey);\n    if (dirtyElement !== undefined && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootNode)(dirtyElement)) {\n      nodes.push(dirtyElement);\n    }\n  }\n  return nodes;\n}\nfunction getChangeType(prevEditorState, nextEditorState, dirtyLeavesSet, dirtyElementsSet, isComposing) {\n  if (prevEditorState === null || dirtyLeavesSet.size === 0 && dirtyElementsSet.size === 0 && !isComposing) {\n    return OTHER;\n  }\n  const nextSelection = nextEditorState._selection;\n  const prevSelection = prevEditorState._selection;\n  if (isComposing) {\n    return COMPOSING_CHARACTER;\n  }\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(nextSelection) || !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(prevSelection) || !prevSelection.isCollapsed() || !nextSelection.isCollapsed()) {\n    return OTHER;\n  }\n  const dirtyNodes = getDirtyNodes(nextEditorState, dirtyLeavesSet, dirtyElementsSet);\n  if (dirtyNodes.length === 0) {\n    return OTHER;\n  }\n\n  // Catching the case when inserting new text node into an element (e.g. first char in paragraph/list),\n  // or after existing node.\n  if (dirtyNodes.length > 1) {\n    const nextNodeMap = nextEditorState._nodeMap;\n    const nextAnchorNode = nextNodeMap.get(nextSelection.anchor.key);\n    const prevAnchorNode = nextNodeMap.get(prevSelection.anchor.key);\n    if (nextAnchorNode && prevAnchorNode && !prevEditorState._nodeMap.has(nextAnchorNode.__key) && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(nextAnchorNode) && nextAnchorNode.__text.length === 1 && nextSelection.anchor.offset === 1) {\n      return INSERT_CHARACTER_AFTER_SELECTION;\n    }\n    return OTHER;\n  }\n  const nextDirtyNode = dirtyNodes[0];\n  const prevDirtyNode = prevEditorState._nodeMap.get(nextDirtyNode.__key);\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(prevDirtyNode) || !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(nextDirtyNode) || prevDirtyNode.__mode !== nextDirtyNode.__mode) {\n    return OTHER;\n  }\n  const prevText = prevDirtyNode.__text;\n  const nextText = nextDirtyNode.__text;\n  if (prevText === nextText) {\n    return OTHER;\n  }\n  const nextAnchor = nextSelection.anchor;\n  const prevAnchor = prevSelection.anchor;\n  if (nextAnchor.key !== prevAnchor.key || nextAnchor.type !== 'text') {\n    return OTHER;\n  }\n  const nextAnchorOffset = nextAnchor.offset;\n  const prevAnchorOffset = prevAnchor.offset;\n  const textDiff = nextText.length - prevText.length;\n  if (textDiff === 1 && prevAnchorOffset === nextAnchorOffset - 1) {\n    return INSERT_CHARACTER_AFTER_SELECTION;\n  }\n  if (textDiff === -1 && prevAnchorOffset === nextAnchorOffset + 1) {\n    return DELETE_CHARACTER_BEFORE_SELECTION;\n  }\n  if (textDiff === -1 && prevAnchorOffset === nextAnchorOffset) {\n    return DELETE_CHARACTER_AFTER_SELECTION;\n  }\n  return OTHER;\n}\nfunction isTextNodeUnchanged(key, prevEditorState, nextEditorState) {\n  const prevNode = prevEditorState._nodeMap.get(key);\n  const nextNode = nextEditorState._nodeMap.get(key);\n  const prevSelection = prevEditorState._selection;\n  const nextSelection = nextEditorState._selection;\n  const isDeletingLine = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(prevSelection) && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(nextSelection) && prevSelection.anchor.type === 'element' && prevSelection.focus.type === 'element' && nextSelection.anchor.type === 'text' && nextSelection.focus.type === 'text';\n  if (!isDeletingLine && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(prevNode) && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(nextNode) && prevNode.__parent === nextNode.__parent) {\n    // This has the assumption that object key order won't change if the\n    // content did not change, which should normally be safe given\n    // the manner in which nodes and exportJSON are typically implemented.\n    return JSON.stringify(prevEditorState.read(() => prevNode.exportJSON())) === JSON.stringify(nextEditorState.read(() => nextNode.exportJSON()));\n  }\n  return false;\n}\nfunction createMergeActionGetter(editor, delay) {\n  let prevChangeTime = Date.now();\n  let prevChangeType = OTHER;\n  return (prevEditorState, nextEditorState, currentHistoryEntry, dirtyLeaves, dirtyElements, tags) => {\n    const changeTime = Date.now();\n\n    // If applying changes from history stack there's no need\n    // to run history logic again, as history entries already calculated\n    if (tags.has('historic')) {\n      prevChangeType = OTHER;\n      prevChangeTime = changeTime;\n      return DISCARD_HISTORY_CANDIDATE;\n    }\n    const changeType = getChangeType(prevEditorState, nextEditorState, dirtyLeaves, dirtyElements, editor.isComposing());\n    const mergeAction = (() => {\n      const isSameEditor = currentHistoryEntry === null || currentHistoryEntry.editor === editor;\n      const shouldPushHistory = tags.has('history-push');\n      const shouldMergeHistory = !shouldPushHistory && isSameEditor && tags.has('history-merge');\n      if (shouldMergeHistory) {\n        return HISTORY_MERGE;\n      }\n      if (prevEditorState === null) {\n        return HISTORY_PUSH;\n      }\n      const selection = nextEditorState._selection;\n      const hasDirtyNodes = dirtyLeaves.size > 0 || dirtyElements.size > 0;\n      if (!hasDirtyNodes) {\n        if (selection !== null) {\n          return HISTORY_MERGE;\n        }\n        return DISCARD_HISTORY_CANDIDATE;\n      }\n      if (shouldPushHistory === false && changeType !== OTHER && changeType === prevChangeType && changeTime < prevChangeTime + delay && isSameEditor) {\n        return HISTORY_MERGE;\n      }\n\n      // A single node might have been marked as dirty, but not have changed\n      // due to some node transform reverting the change.\n      if (dirtyLeaves.size === 1) {\n        const dirtyLeafKey = Array.from(dirtyLeaves)[0];\n        if (isTextNodeUnchanged(dirtyLeafKey, prevEditorState, nextEditorState)) {\n          return HISTORY_MERGE;\n        }\n      }\n      return HISTORY_PUSH;\n    })();\n    prevChangeTime = changeTime;\n    prevChangeType = changeType;\n    return mergeAction;\n  };\n}\nfunction redo(editor, historyState) {\n  const redoStack = historyState.redoStack;\n  const undoStack = historyState.undoStack;\n  if (redoStack.length !== 0) {\n    const current = historyState.current;\n    if (current !== null) {\n      undoStack.push(current);\n      editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CAN_UNDO_COMMAND, true);\n    }\n    const historyStateEntry = redoStack.pop();\n    if (redoStack.length === 0) {\n      editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CAN_REDO_COMMAND, false);\n    }\n    historyState.current = historyStateEntry || null;\n    if (historyStateEntry) {\n      historyStateEntry.editor.setEditorState(historyStateEntry.editorState, {\n        tag: 'historic'\n      });\n    }\n  }\n}\nfunction undo(editor, historyState) {\n  const redoStack = historyState.redoStack;\n  const undoStack = historyState.undoStack;\n  const undoStackLength = undoStack.length;\n  if (undoStackLength !== 0) {\n    const current = historyState.current;\n    const historyStateEntry = undoStack.pop();\n    if (current !== null) {\n      redoStack.push(current);\n      editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CAN_REDO_COMMAND, true);\n    }\n    if (undoStack.length === 0) {\n      editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CAN_UNDO_COMMAND, false);\n    }\n    historyState.current = historyStateEntry || null;\n    if (historyStateEntry) {\n      historyStateEntry.editor.setEditorState(historyStateEntry.editorState, {\n        tag: 'historic'\n      });\n    }\n  }\n}\nfunction clearHistory(historyState) {\n  historyState.undoStack = [];\n  historyState.redoStack = [];\n  historyState.current = null;\n}\n\n/**\n * Registers necessary listeners to manage undo/redo history stack and related editor commands.\n * It returns `unregister` callback that cleans up all listeners and should be called on editor unmount.\n * @param editor - The lexical editor.\n * @param historyState - The history state, containing the current state and the undo/redo stack.\n * @param delay - The time (in milliseconds) the editor should delay generating a new history stack,\n * instead of merging the current changes with the current stack.\n * @returns The listeners cleanup callback function.\n */\nfunction registerHistory(editor, historyState, delay) {\n  const getMergeAction = createMergeActionGetter(editor, delay);\n  const applyChange = ({\n    editorState,\n    prevEditorState,\n    dirtyLeaves,\n    dirtyElements,\n    tags\n  }) => {\n    const current = historyState.current;\n    const redoStack = historyState.redoStack;\n    const undoStack = historyState.undoStack;\n    const currentEditorState = current === null ? null : current.editorState;\n    if (current !== null && editorState === currentEditorState) {\n      return;\n    }\n    const mergeAction = getMergeAction(prevEditorState, editorState, current, dirtyLeaves, dirtyElements, tags);\n    if (mergeAction === HISTORY_PUSH) {\n      if (redoStack.length !== 0) {\n        historyState.redoStack = [];\n        editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CAN_REDO_COMMAND, false);\n      }\n      if (current !== null) {\n        undoStack.push({\n          ...current\n        });\n        editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CAN_UNDO_COMMAND, true);\n      }\n    } else if (mergeAction === DISCARD_HISTORY_CANDIDATE) {\n      return;\n    }\n\n    // Else we merge\n    historyState.current = {\n      editor,\n      editorState\n    };\n  };\n  const unregister = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.mergeRegister)(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.UNDO_COMMAND, () => {\n    undo(editor, historyState);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.REDO_COMMAND, () => {\n    redo(editor, historyState);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CLEAR_EDITOR_COMMAND, () => {\n    clearHistory(historyState);\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CLEAR_HISTORY_COMMAND, () => {\n    clearHistory(historyState);\n    editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CAN_REDO_COMMAND, false);\n    editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CAN_UNDO_COMMAND, false);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerUpdateListener(applyChange));\n  return unregister;\n}\n\n/**\n * Creates an empty history state.\n * @returns - The empty history state, as an object.\n */\nfunction createEmptyHistoryState() {\n  return {\n    current: null,\n    redoStack: [],\n    undoStack: []\n  };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvaGlzdG9yeS9MZXhpY2FsSGlzdG9yeS5kZXYubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFK0M7QUFDNko7O0FBRTVNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLG9EQUFXO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLDBEQUFpQixvQkFBb0IsMERBQWlCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUcsb0RBQVc7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxvREFBVyxvQkFBb0Isb0RBQVc7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsMERBQWlCLG1CQUFtQiwwREFBaUI7QUFDOUUseUJBQXlCLG9EQUFXLGNBQWMsb0RBQVc7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixxREFBZ0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHFEQUFnQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixxREFBZ0I7QUFDN0M7QUFDQTtBQUNBLDZCQUE2QixxREFBZ0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixxREFBZ0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsK0JBQStCLHFEQUFnQjtBQUMvQztBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw2REFBYSx3QkFBd0IsaURBQVk7QUFDdEU7QUFDQTtBQUNBLEdBQUcsRUFBRSw0REFBdUIsMEJBQTBCLGlEQUFZO0FBQ2xFO0FBQ0E7QUFDQSxHQUFHLEVBQUUsNERBQXVCLDBCQUEwQix5REFBb0I7QUFDMUU7QUFDQTtBQUNBLEdBQUcsRUFBRSw0REFBdUIsMEJBQTBCLDBEQUFxQjtBQUMzRTtBQUNBLDJCQUEyQixxREFBZ0I7QUFDM0MsMkJBQTJCLHFEQUFnQjtBQUMzQztBQUNBLEdBQUcsRUFBRSw0REFBdUI7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVvRCIsInNvdXJjZXMiOlsiL1VzZXJzL2xlaS9ob21lL3VuZGVyZy90aGVhdHJlL3kzL3NlZ3AvbWlsa3VwL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9oaXN0b3J5L0xleGljYWxIaXN0b3J5LmRldi5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5pbXBvcnQgeyBtZXJnZVJlZ2lzdGVyIH0gZnJvbSAnQGxleGljYWwvdXRpbHMnO1xuaW1wb3J0IHsgVU5ET19DT01NQU5ELCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiwgUkVET19DT01NQU5ELCBDTEVBUl9FRElUT1JfQ09NTUFORCwgQ0xFQVJfSElTVE9SWV9DT01NQU5ELCBDQU5fUkVET19DT01NQU5ELCBDQU5fVU5ET19DT01NQU5ELCAkaXNSYW5nZVNlbGVjdGlvbiwgJGlzVGV4dE5vZGUsICRpc1Jvb3ROb2RlIH0gZnJvbSAnbGV4aWNhbCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuY29uc3QgSElTVE9SWV9NRVJHRSA9IDA7XG5jb25zdCBISVNUT1JZX1BVU0ggPSAxO1xuY29uc3QgRElTQ0FSRF9ISVNUT1JZX0NBTkRJREFURSA9IDI7XG5jb25zdCBPVEhFUiA9IDA7XG5jb25zdCBDT01QT1NJTkdfQ0hBUkFDVEVSID0gMTtcbmNvbnN0IElOU0VSVF9DSEFSQUNURVJfQUZURVJfU0VMRUNUSU9OID0gMjtcbmNvbnN0IERFTEVURV9DSEFSQUNURVJfQkVGT1JFX1NFTEVDVElPTiA9IDM7XG5jb25zdCBERUxFVEVfQ0hBUkFDVEVSX0FGVEVSX1NFTEVDVElPTiA9IDQ7XG5mdW5jdGlvbiBnZXREaXJ0eU5vZGVzKGVkaXRvclN0YXRlLCBkaXJ0eUxlYXZlcywgZGlydHlFbGVtZW50cykge1xuICBjb25zdCBub2RlTWFwID0gZWRpdG9yU3RhdGUuX25vZGVNYXA7XG4gIGNvbnN0IG5vZGVzID0gW107XG4gIGZvciAoY29uc3QgZGlydHlMZWFmS2V5IG9mIGRpcnR5TGVhdmVzKSB7XG4gICAgY29uc3QgZGlydHlMZWFmID0gbm9kZU1hcC5nZXQoZGlydHlMZWFmS2V5KTtcbiAgICBpZiAoZGlydHlMZWFmICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG5vZGVzLnB1c2goZGlydHlMZWFmKTtcbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBbZGlydHlFbGVtZW50S2V5LCBpbnRlbnRpb25hbGx5TWFya2VkQXNEaXJ0eV0gb2YgZGlydHlFbGVtZW50cykge1xuICAgIGlmICghaW50ZW50aW9uYWxseU1hcmtlZEFzRGlydHkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBkaXJ0eUVsZW1lbnQgPSBub2RlTWFwLmdldChkaXJ0eUVsZW1lbnRLZXkpO1xuICAgIGlmIChkaXJ0eUVsZW1lbnQgIT09IHVuZGVmaW5lZCAmJiAhJGlzUm9vdE5vZGUoZGlydHlFbGVtZW50KSkge1xuICAgICAgbm9kZXMucHVzaChkaXJ0eUVsZW1lbnQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbm9kZXM7XG59XG5mdW5jdGlvbiBnZXRDaGFuZ2VUeXBlKHByZXZFZGl0b3JTdGF0ZSwgbmV4dEVkaXRvclN0YXRlLCBkaXJ0eUxlYXZlc1NldCwgZGlydHlFbGVtZW50c1NldCwgaXNDb21wb3NpbmcpIHtcbiAgaWYgKHByZXZFZGl0b3JTdGF0ZSA9PT0gbnVsbCB8fCBkaXJ0eUxlYXZlc1NldC5zaXplID09PSAwICYmIGRpcnR5RWxlbWVudHNTZXQuc2l6ZSA9PT0gMCAmJiAhaXNDb21wb3NpbmcpIHtcbiAgICByZXR1cm4gT1RIRVI7XG4gIH1cbiAgY29uc3QgbmV4dFNlbGVjdGlvbiA9IG5leHRFZGl0b3JTdGF0ZS5fc2VsZWN0aW9uO1xuICBjb25zdCBwcmV2U2VsZWN0aW9uID0gcHJldkVkaXRvclN0YXRlLl9zZWxlY3Rpb247XG4gIGlmIChpc0NvbXBvc2luZykge1xuICAgIHJldHVybiBDT01QT1NJTkdfQ0hBUkFDVEVSO1xuICB9XG4gIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24obmV4dFNlbGVjdGlvbikgfHwgISRpc1JhbmdlU2VsZWN0aW9uKHByZXZTZWxlY3Rpb24pIHx8ICFwcmV2U2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgfHwgIW5leHRTZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSkge1xuICAgIHJldHVybiBPVEhFUjtcbiAgfVxuICBjb25zdCBkaXJ0eU5vZGVzID0gZ2V0RGlydHlOb2RlcyhuZXh0RWRpdG9yU3RhdGUsIGRpcnR5TGVhdmVzU2V0LCBkaXJ0eUVsZW1lbnRzU2V0KTtcbiAgaWYgKGRpcnR5Tm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIE9USEVSO1xuICB9XG5cbiAgLy8gQ2F0Y2hpbmcgdGhlIGNhc2Ugd2hlbiBpbnNlcnRpbmcgbmV3IHRleHQgbm9kZSBpbnRvIGFuIGVsZW1lbnQgKGUuZy4gZmlyc3QgY2hhciBpbiBwYXJhZ3JhcGgvbGlzdCksXG4gIC8vIG9yIGFmdGVyIGV4aXN0aW5nIG5vZGUuXG4gIGlmIChkaXJ0eU5vZGVzLmxlbmd0aCA+IDEpIHtcbiAgICBjb25zdCBuZXh0Tm9kZU1hcCA9IG5leHRFZGl0b3JTdGF0ZS5fbm9kZU1hcDtcbiAgICBjb25zdCBuZXh0QW5jaG9yTm9kZSA9IG5leHROb2RlTWFwLmdldChuZXh0U2VsZWN0aW9uLmFuY2hvci5rZXkpO1xuICAgIGNvbnN0IHByZXZBbmNob3JOb2RlID0gbmV4dE5vZGVNYXAuZ2V0KHByZXZTZWxlY3Rpb24uYW5jaG9yLmtleSk7XG4gICAgaWYgKG5leHRBbmNob3JOb2RlICYmIHByZXZBbmNob3JOb2RlICYmICFwcmV2RWRpdG9yU3RhdGUuX25vZGVNYXAuaGFzKG5leHRBbmNob3JOb2RlLl9fa2V5KSAmJiAkaXNUZXh0Tm9kZShuZXh0QW5jaG9yTm9kZSkgJiYgbmV4dEFuY2hvck5vZGUuX190ZXh0Lmxlbmd0aCA9PT0gMSAmJiBuZXh0U2VsZWN0aW9uLmFuY2hvci5vZmZzZXQgPT09IDEpIHtcbiAgICAgIHJldHVybiBJTlNFUlRfQ0hBUkFDVEVSX0FGVEVSX1NFTEVDVElPTjtcbiAgICB9XG4gICAgcmV0dXJuIE9USEVSO1xuICB9XG4gIGNvbnN0IG5leHREaXJ0eU5vZGUgPSBkaXJ0eU5vZGVzWzBdO1xuICBjb25zdCBwcmV2RGlydHlOb2RlID0gcHJldkVkaXRvclN0YXRlLl9ub2RlTWFwLmdldChuZXh0RGlydHlOb2RlLl9fa2V5KTtcbiAgaWYgKCEkaXNUZXh0Tm9kZShwcmV2RGlydHlOb2RlKSB8fCAhJGlzVGV4dE5vZGUobmV4dERpcnR5Tm9kZSkgfHwgcHJldkRpcnR5Tm9kZS5fX21vZGUgIT09IG5leHREaXJ0eU5vZGUuX19tb2RlKSB7XG4gICAgcmV0dXJuIE9USEVSO1xuICB9XG4gIGNvbnN0IHByZXZUZXh0ID0gcHJldkRpcnR5Tm9kZS5fX3RleHQ7XG4gIGNvbnN0IG5leHRUZXh0ID0gbmV4dERpcnR5Tm9kZS5fX3RleHQ7XG4gIGlmIChwcmV2VGV4dCA9PT0gbmV4dFRleHQpIHtcbiAgICByZXR1cm4gT1RIRVI7XG4gIH1cbiAgY29uc3QgbmV4dEFuY2hvciA9IG5leHRTZWxlY3Rpb24uYW5jaG9yO1xuICBjb25zdCBwcmV2QW5jaG9yID0gcHJldlNlbGVjdGlvbi5hbmNob3I7XG4gIGlmIChuZXh0QW5jaG9yLmtleSAhPT0gcHJldkFuY2hvci5rZXkgfHwgbmV4dEFuY2hvci50eXBlICE9PSAndGV4dCcpIHtcbiAgICByZXR1cm4gT1RIRVI7XG4gIH1cbiAgY29uc3QgbmV4dEFuY2hvck9mZnNldCA9IG5leHRBbmNob3Iub2Zmc2V0O1xuICBjb25zdCBwcmV2QW5jaG9yT2Zmc2V0ID0gcHJldkFuY2hvci5vZmZzZXQ7XG4gIGNvbnN0IHRleHREaWZmID0gbmV4dFRleHQubGVuZ3RoIC0gcHJldlRleHQubGVuZ3RoO1xuICBpZiAodGV4dERpZmYgPT09IDEgJiYgcHJldkFuY2hvck9mZnNldCA9PT0gbmV4dEFuY2hvck9mZnNldCAtIDEpIHtcbiAgICByZXR1cm4gSU5TRVJUX0NIQVJBQ1RFUl9BRlRFUl9TRUxFQ1RJT047XG4gIH1cbiAgaWYgKHRleHREaWZmID09PSAtMSAmJiBwcmV2QW5jaG9yT2Zmc2V0ID09PSBuZXh0QW5jaG9yT2Zmc2V0ICsgMSkge1xuICAgIHJldHVybiBERUxFVEVfQ0hBUkFDVEVSX0JFRk9SRV9TRUxFQ1RJT047XG4gIH1cbiAgaWYgKHRleHREaWZmID09PSAtMSAmJiBwcmV2QW5jaG9yT2Zmc2V0ID09PSBuZXh0QW5jaG9yT2Zmc2V0KSB7XG4gICAgcmV0dXJuIERFTEVURV9DSEFSQUNURVJfQUZURVJfU0VMRUNUSU9OO1xuICB9XG4gIHJldHVybiBPVEhFUjtcbn1cbmZ1bmN0aW9uIGlzVGV4dE5vZGVVbmNoYW5nZWQoa2V5LCBwcmV2RWRpdG9yU3RhdGUsIG5leHRFZGl0b3JTdGF0ZSkge1xuICBjb25zdCBwcmV2Tm9kZSA9IHByZXZFZGl0b3JTdGF0ZS5fbm9kZU1hcC5nZXQoa2V5KTtcbiAgY29uc3QgbmV4dE5vZGUgPSBuZXh0RWRpdG9yU3RhdGUuX25vZGVNYXAuZ2V0KGtleSk7XG4gIGNvbnN0IHByZXZTZWxlY3Rpb24gPSBwcmV2RWRpdG9yU3RhdGUuX3NlbGVjdGlvbjtcbiAgY29uc3QgbmV4dFNlbGVjdGlvbiA9IG5leHRFZGl0b3JTdGF0ZS5fc2VsZWN0aW9uO1xuICBjb25zdCBpc0RlbGV0aW5nTGluZSA9ICRpc1JhbmdlU2VsZWN0aW9uKHByZXZTZWxlY3Rpb24pICYmICRpc1JhbmdlU2VsZWN0aW9uKG5leHRTZWxlY3Rpb24pICYmIHByZXZTZWxlY3Rpb24uYW5jaG9yLnR5cGUgPT09ICdlbGVtZW50JyAmJiBwcmV2U2VsZWN0aW9uLmZvY3VzLnR5cGUgPT09ICdlbGVtZW50JyAmJiBuZXh0U2VsZWN0aW9uLmFuY2hvci50eXBlID09PSAndGV4dCcgJiYgbmV4dFNlbGVjdGlvbi5mb2N1cy50eXBlID09PSAndGV4dCc7XG4gIGlmICghaXNEZWxldGluZ0xpbmUgJiYgJGlzVGV4dE5vZGUocHJldk5vZGUpICYmICRpc1RleHROb2RlKG5leHROb2RlKSAmJiBwcmV2Tm9kZS5fX3BhcmVudCA9PT0gbmV4dE5vZGUuX19wYXJlbnQpIHtcbiAgICAvLyBUaGlzIGhhcyB0aGUgYXNzdW1wdGlvbiB0aGF0IG9iamVjdCBrZXkgb3JkZXIgd29uJ3QgY2hhbmdlIGlmIHRoZVxuICAgIC8vIGNvbnRlbnQgZGlkIG5vdCBjaGFuZ2UsIHdoaWNoIHNob3VsZCBub3JtYWxseSBiZSBzYWZlIGdpdmVuXG4gICAgLy8gdGhlIG1hbm5lciBpbiB3aGljaCBub2RlcyBhbmQgZXhwb3J0SlNPTiBhcmUgdHlwaWNhbGx5IGltcGxlbWVudGVkLlxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShwcmV2RWRpdG9yU3RhdGUucmVhZCgoKSA9PiBwcmV2Tm9kZS5leHBvcnRKU09OKCkpKSA9PT0gSlNPTi5zdHJpbmdpZnkobmV4dEVkaXRvclN0YXRlLnJlYWQoKCkgPT4gbmV4dE5vZGUuZXhwb3J0SlNPTigpKSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY3JlYXRlTWVyZ2VBY3Rpb25HZXR0ZXIoZWRpdG9yLCBkZWxheSkge1xuICBsZXQgcHJldkNoYW5nZVRpbWUgPSBEYXRlLm5vdygpO1xuICBsZXQgcHJldkNoYW5nZVR5cGUgPSBPVEhFUjtcbiAgcmV0dXJuIChwcmV2RWRpdG9yU3RhdGUsIG5leHRFZGl0b3JTdGF0ZSwgY3VycmVudEhpc3RvcnlFbnRyeSwgZGlydHlMZWF2ZXMsIGRpcnR5RWxlbWVudHMsIHRhZ3MpID0+IHtcbiAgICBjb25zdCBjaGFuZ2VUaW1lID0gRGF0ZS5ub3coKTtcblxuICAgIC8vIElmIGFwcGx5aW5nIGNoYW5nZXMgZnJvbSBoaXN0b3J5IHN0YWNrIHRoZXJlJ3Mgbm8gbmVlZFxuICAgIC8vIHRvIHJ1biBoaXN0b3J5IGxvZ2ljIGFnYWluLCBhcyBoaXN0b3J5IGVudHJpZXMgYWxyZWFkeSBjYWxjdWxhdGVkXG4gICAgaWYgKHRhZ3MuaGFzKCdoaXN0b3JpYycpKSB7XG4gICAgICBwcmV2Q2hhbmdlVHlwZSA9IE9USEVSO1xuICAgICAgcHJldkNoYW5nZVRpbWUgPSBjaGFuZ2VUaW1lO1xuICAgICAgcmV0dXJuIERJU0NBUkRfSElTVE9SWV9DQU5ESURBVEU7XG4gICAgfVxuICAgIGNvbnN0IGNoYW5nZVR5cGUgPSBnZXRDaGFuZ2VUeXBlKHByZXZFZGl0b3JTdGF0ZSwgbmV4dEVkaXRvclN0YXRlLCBkaXJ0eUxlYXZlcywgZGlydHlFbGVtZW50cywgZWRpdG9yLmlzQ29tcG9zaW5nKCkpO1xuICAgIGNvbnN0IG1lcmdlQWN0aW9uID0gKCgpID0+IHtcbiAgICAgIGNvbnN0IGlzU2FtZUVkaXRvciA9IGN1cnJlbnRIaXN0b3J5RW50cnkgPT09IG51bGwgfHwgY3VycmVudEhpc3RvcnlFbnRyeS5lZGl0b3IgPT09IGVkaXRvcjtcbiAgICAgIGNvbnN0IHNob3VsZFB1c2hIaXN0b3J5ID0gdGFncy5oYXMoJ2hpc3RvcnktcHVzaCcpO1xuICAgICAgY29uc3Qgc2hvdWxkTWVyZ2VIaXN0b3J5ID0gIXNob3VsZFB1c2hIaXN0b3J5ICYmIGlzU2FtZUVkaXRvciAmJiB0YWdzLmhhcygnaGlzdG9yeS1tZXJnZScpO1xuICAgICAgaWYgKHNob3VsZE1lcmdlSGlzdG9yeSkge1xuICAgICAgICByZXR1cm4gSElTVE9SWV9NRVJHRTtcbiAgICAgIH1cbiAgICAgIGlmIChwcmV2RWRpdG9yU3RhdGUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIEhJU1RPUllfUFVTSDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IG5leHRFZGl0b3JTdGF0ZS5fc2VsZWN0aW9uO1xuICAgICAgY29uc3QgaGFzRGlydHlOb2RlcyA9IGRpcnR5TGVhdmVzLnNpemUgPiAwIHx8IGRpcnR5RWxlbWVudHMuc2l6ZSA+IDA7XG4gICAgICBpZiAoIWhhc0RpcnR5Tm9kZXMpIHtcbiAgICAgICAgaWYgKHNlbGVjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBISVNUT1JZX01FUkdFO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBESVNDQVJEX0hJU1RPUllfQ0FORElEQVRFO1xuICAgICAgfVxuICAgICAgaWYgKHNob3VsZFB1c2hIaXN0b3J5ID09PSBmYWxzZSAmJiBjaGFuZ2VUeXBlICE9PSBPVEhFUiAmJiBjaGFuZ2VUeXBlID09PSBwcmV2Q2hhbmdlVHlwZSAmJiBjaGFuZ2VUaW1lIDwgcHJldkNoYW5nZVRpbWUgKyBkZWxheSAmJiBpc1NhbWVFZGl0b3IpIHtcbiAgICAgICAgcmV0dXJuIEhJU1RPUllfTUVSR0U7XG4gICAgICB9XG5cbiAgICAgIC8vIEEgc2luZ2xlIG5vZGUgbWlnaHQgaGF2ZSBiZWVuIG1hcmtlZCBhcyBkaXJ0eSwgYnV0IG5vdCBoYXZlIGNoYW5nZWRcbiAgICAgIC8vIGR1ZSB0byBzb21lIG5vZGUgdHJhbnNmb3JtIHJldmVydGluZyB0aGUgY2hhbmdlLlxuICAgICAgaWYgKGRpcnR5TGVhdmVzLnNpemUgPT09IDEpIHtcbiAgICAgICAgY29uc3QgZGlydHlMZWFmS2V5ID0gQXJyYXkuZnJvbShkaXJ0eUxlYXZlcylbMF07XG4gICAgICAgIGlmIChpc1RleHROb2RlVW5jaGFuZ2VkKGRpcnR5TGVhZktleSwgcHJldkVkaXRvclN0YXRlLCBuZXh0RWRpdG9yU3RhdGUpKSB7XG4gICAgICAgICAgcmV0dXJuIEhJU1RPUllfTUVSR0U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBISVNUT1JZX1BVU0g7XG4gICAgfSkoKTtcbiAgICBwcmV2Q2hhbmdlVGltZSA9IGNoYW5nZVRpbWU7XG4gICAgcHJldkNoYW5nZVR5cGUgPSBjaGFuZ2VUeXBlO1xuICAgIHJldHVybiBtZXJnZUFjdGlvbjtcbiAgfTtcbn1cbmZ1bmN0aW9uIHJlZG8oZWRpdG9yLCBoaXN0b3J5U3RhdGUpIHtcbiAgY29uc3QgcmVkb1N0YWNrID0gaGlzdG9yeVN0YXRlLnJlZG9TdGFjaztcbiAgY29uc3QgdW5kb1N0YWNrID0gaGlzdG9yeVN0YXRlLnVuZG9TdGFjaztcbiAgaWYgKHJlZG9TdGFjay5sZW5ndGggIT09IDApIHtcbiAgICBjb25zdCBjdXJyZW50ID0gaGlzdG9yeVN0YXRlLmN1cnJlbnQ7XG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIHVuZG9TdGFjay5wdXNoKGN1cnJlbnQpO1xuICAgICAgZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChDQU5fVU5ET19DT01NQU5ELCB0cnVlKTtcbiAgICB9XG4gICAgY29uc3QgaGlzdG9yeVN0YXRlRW50cnkgPSByZWRvU3RhY2sucG9wKCk7XG4gICAgaWYgKHJlZG9TdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgIGVkaXRvci5kaXNwYXRjaENvbW1hbmQoQ0FOX1JFRE9fQ09NTUFORCwgZmFsc2UpO1xuICAgIH1cbiAgICBoaXN0b3J5U3RhdGUuY3VycmVudCA9IGhpc3RvcnlTdGF0ZUVudHJ5IHx8IG51bGw7XG4gICAgaWYgKGhpc3RvcnlTdGF0ZUVudHJ5KSB7XG4gICAgICBoaXN0b3J5U3RhdGVFbnRyeS5lZGl0b3Iuc2V0RWRpdG9yU3RhdGUoaGlzdG9yeVN0YXRlRW50cnkuZWRpdG9yU3RhdGUsIHtcbiAgICAgICAgdGFnOiAnaGlzdG9yaWMnXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHVuZG8oZWRpdG9yLCBoaXN0b3J5U3RhdGUpIHtcbiAgY29uc3QgcmVkb1N0YWNrID0gaGlzdG9yeVN0YXRlLnJlZG9TdGFjaztcbiAgY29uc3QgdW5kb1N0YWNrID0gaGlzdG9yeVN0YXRlLnVuZG9TdGFjaztcbiAgY29uc3QgdW5kb1N0YWNrTGVuZ3RoID0gdW5kb1N0YWNrLmxlbmd0aDtcbiAgaWYgKHVuZG9TdGFja0xlbmd0aCAhPT0gMCkge1xuICAgIGNvbnN0IGN1cnJlbnQgPSBoaXN0b3J5U3RhdGUuY3VycmVudDtcbiAgICBjb25zdCBoaXN0b3J5U3RhdGVFbnRyeSA9IHVuZG9TdGFjay5wb3AoKTtcbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgcmVkb1N0YWNrLnB1c2goY3VycmVudCk7XG4gICAgICBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKENBTl9SRURPX0NPTU1BTkQsIHRydWUpO1xuICAgIH1cbiAgICBpZiAodW5kb1N0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChDQU5fVU5ET19DT01NQU5ELCBmYWxzZSk7XG4gICAgfVxuICAgIGhpc3RvcnlTdGF0ZS5jdXJyZW50ID0gaGlzdG9yeVN0YXRlRW50cnkgfHwgbnVsbDtcbiAgICBpZiAoaGlzdG9yeVN0YXRlRW50cnkpIHtcbiAgICAgIGhpc3RvcnlTdGF0ZUVudHJ5LmVkaXRvci5zZXRFZGl0b3JTdGF0ZShoaXN0b3J5U3RhdGVFbnRyeS5lZGl0b3JTdGF0ZSwge1xuICAgICAgICB0YWc6ICdoaXN0b3JpYydcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY2xlYXJIaXN0b3J5KGhpc3RvcnlTdGF0ZSkge1xuICBoaXN0b3J5U3RhdGUudW5kb1N0YWNrID0gW107XG4gIGhpc3RvcnlTdGF0ZS5yZWRvU3RhY2sgPSBbXTtcbiAgaGlzdG9yeVN0YXRlLmN1cnJlbnQgPSBudWxsO1xufVxuXG4vKipcbiAqIFJlZ2lzdGVycyBuZWNlc3NhcnkgbGlzdGVuZXJzIHRvIG1hbmFnZSB1bmRvL3JlZG8gaGlzdG9yeSBzdGFjayBhbmQgcmVsYXRlZCBlZGl0b3IgY29tbWFuZHMuXG4gKiBJdCByZXR1cm5zIGB1bnJlZ2lzdGVyYCBjYWxsYmFjayB0aGF0IGNsZWFucyB1cCBhbGwgbGlzdGVuZXJzIGFuZCBzaG91bGQgYmUgY2FsbGVkIG9uIGVkaXRvciB1bm1vdW50LlxuICogQHBhcmFtIGVkaXRvciAtIFRoZSBsZXhpY2FsIGVkaXRvci5cbiAqIEBwYXJhbSBoaXN0b3J5U3RhdGUgLSBUaGUgaGlzdG9yeSBzdGF0ZSwgY29udGFpbmluZyB0aGUgY3VycmVudCBzdGF0ZSBhbmQgdGhlIHVuZG8vcmVkbyBzdGFjay5cbiAqIEBwYXJhbSBkZWxheSAtIFRoZSB0aW1lIChpbiBtaWxsaXNlY29uZHMpIHRoZSBlZGl0b3Igc2hvdWxkIGRlbGF5IGdlbmVyYXRpbmcgYSBuZXcgaGlzdG9yeSBzdGFjayxcbiAqIGluc3RlYWQgb2YgbWVyZ2luZyB0aGUgY3VycmVudCBjaGFuZ2VzIHdpdGggdGhlIGN1cnJlbnQgc3RhY2suXG4gKiBAcmV0dXJucyBUaGUgbGlzdGVuZXJzIGNsZWFudXAgY2FsbGJhY2sgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVySGlzdG9yeShlZGl0b3IsIGhpc3RvcnlTdGF0ZSwgZGVsYXkpIHtcbiAgY29uc3QgZ2V0TWVyZ2VBY3Rpb24gPSBjcmVhdGVNZXJnZUFjdGlvbkdldHRlcihlZGl0b3IsIGRlbGF5KTtcbiAgY29uc3QgYXBwbHlDaGFuZ2UgPSAoe1xuICAgIGVkaXRvclN0YXRlLFxuICAgIHByZXZFZGl0b3JTdGF0ZSxcbiAgICBkaXJ0eUxlYXZlcyxcbiAgICBkaXJ0eUVsZW1lbnRzLFxuICAgIHRhZ3NcbiAgfSkgPT4ge1xuICAgIGNvbnN0IGN1cnJlbnQgPSBoaXN0b3J5U3RhdGUuY3VycmVudDtcbiAgICBjb25zdCByZWRvU3RhY2sgPSBoaXN0b3J5U3RhdGUucmVkb1N0YWNrO1xuICAgIGNvbnN0IHVuZG9TdGFjayA9IGhpc3RvcnlTdGF0ZS51bmRvU3RhY2s7XG4gICAgY29uc3QgY3VycmVudEVkaXRvclN0YXRlID0gY3VycmVudCA9PT0gbnVsbCA/IG51bGwgOiBjdXJyZW50LmVkaXRvclN0YXRlO1xuICAgIGlmIChjdXJyZW50ICE9PSBudWxsICYmIGVkaXRvclN0YXRlID09PSBjdXJyZW50RWRpdG9yU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbWVyZ2VBY3Rpb24gPSBnZXRNZXJnZUFjdGlvbihwcmV2RWRpdG9yU3RhdGUsIGVkaXRvclN0YXRlLCBjdXJyZW50LCBkaXJ0eUxlYXZlcywgZGlydHlFbGVtZW50cywgdGFncyk7XG4gICAgaWYgKG1lcmdlQWN0aW9uID09PSBISVNUT1JZX1BVU0gpIHtcbiAgICAgIGlmIChyZWRvU3RhY2subGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIGhpc3RvcnlTdGF0ZS5yZWRvU3RhY2sgPSBbXTtcbiAgICAgICAgZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChDQU5fUkVET19DT01NQU5ELCBmYWxzZSk7XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICB1bmRvU3RhY2sucHVzaCh7XG4gICAgICAgICAgLi4uY3VycmVudFxuICAgICAgICB9KTtcbiAgICAgICAgZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChDQU5fVU5ET19DT01NQU5ELCB0cnVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1lcmdlQWN0aW9uID09PSBESVNDQVJEX0hJU1RPUllfQ0FORElEQVRFKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRWxzZSB3ZSBtZXJnZVxuICAgIGhpc3RvcnlTdGF0ZS5jdXJyZW50ID0ge1xuICAgICAgZWRpdG9yLFxuICAgICAgZWRpdG9yU3RhdGVcbiAgICB9O1xuICB9O1xuICBjb25zdCB1bnJlZ2lzdGVyID0gbWVyZ2VSZWdpc3RlcihlZGl0b3IucmVnaXN0ZXJDb21tYW5kKFVORE9fQ09NTUFORCwgKCkgPT4ge1xuICAgIHVuZG8oZWRpdG9yLCBoaXN0b3J5U3RhdGUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoUkVET19DT01NQU5ELCAoKSA9PiB7XG4gICAgcmVkbyhlZGl0b3IsIGhpc3RvcnlTdGF0ZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChDTEVBUl9FRElUT1JfQ09NTUFORCwgKCkgPT4ge1xuICAgIGNsZWFySGlzdG9yeShoaXN0b3J5U3RhdGUpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKENMRUFSX0hJU1RPUllfQ09NTUFORCwgKCkgPT4ge1xuICAgIGNsZWFySGlzdG9yeShoaXN0b3J5U3RhdGUpO1xuICAgIGVkaXRvci5kaXNwYXRjaENvbW1hbmQoQ0FOX1JFRE9fQ09NTUFORCwgZmFsc2UpO1xuICAgIGVkaXRvci5kaXNwYXRjaENvbW1hbmQoQ0FOX1VORE9fQ09NTUFORCwgZmFsc2UpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlclVwZGF0ZUxpc3RlbmVyKGFwcGx5Q2hhbmdlKSk7XG4gIHJldHVybiB1bnJlZ2lzdGVyO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gZW1wdHkgaGlzdG9yeSBzdGF0ZS5cbiAqIEByZXR1cm5zIC0gVGhlIGVtcHR5IGhpc3Rvcnkgc3RhdGUsIGFzIGFuIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRW1wdHlIaXN0b3J5U3RhdGUoKSB7XG4gIHJldHVybiB7XG4gICAgY3VycmVudDogbnVsbCxcbiAgICByZWRvU3RhY2s6IFtdLFxuICAgIHVuZG9TdGFjazogW11cbiAgfTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlRW1wdHlIaXN0b3J5U3RhdGUsIHJlZ2lzdGVySGlzdG9yeSB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/history/LexicalHistory.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/html/LexicalHtml.dev.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@lexical/html/LexicalHtml.dev.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $generateHtmlFromNodes: () => (/* binding */ $generateHtmlFromNodes),\n/* harmony export */   $generateNodesFromDOM: () => (/* binding */ $generateNodesFromDOM)\n/* harmony export */ });\n/* harmony import */ var _lexical_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/selection */ \"(ssr)/./node_modules/@lexical/selection/LexicalSelection.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n/**\n * How you parse your html string to get a document is left up to you. In the browser you can use the native\n * DOMParser API to generate a document (see clipboard.ts), but to use in a headless environment you can use JSDom\n * or an equivalent library and pass in the document here.\n */\nfunction $generateNodesFromDOM(editor, dom) {\n  const elements = dom.body ? dom.body.childNodes : [];\n  let lexicalNodes = [];\n  const allArtificialNodes = [];\n  for (let i = 0; i < elements.length; i++) {\n    const element = elements[i];\n    if (!IGNORE_TAGS.has(element.nodeName)) {\n      const lexicalNode = $createNodesFromDOM(element, editor, allArtificialNodes, false);\n      if (lexicalNode !== null) {\n        lexicalNodes = lexicalNodes.concat(lexicalNode);\n      }\n    }\n  }\n  $unwrapArtificalNodes(allArtificialNodes);\n  return lexicalNodes;\n}\nfunction $generateHtmlFromNodes(editor, selection) {\n  if (typeof document === 'undefined' || typeof window === 'undefined' && typeof global.window === 'undefined') {\n    throw new Error('To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.');\n  }\n  const container = document.createElement('div');\n  const root = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)();\n  const topLevelChildren = root.getChildren();\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToHTML(editor, topLevelNode, container, selection);\n  }\n  return container.innerHTML;\n}\nfunction $appendNodesToHTML(editor, currentNode, parentElement, selection = null) {\n  let shouldInclude = selection !== null ? currentNode.isSelected(selection) : true;\n  const shouldExclude = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n  if (selection !== null) {\n    let clone = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$cloneWithProperties)(currentNode);\n    clone = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(clone) && selection !== null ? (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_1__.$sliceSelectedTextNodeContent)(selection, clone) : clone;\n    target = clone;\n  }\n  const children = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(target) ? target.getChildren() : [];\n  const registeredNode = editor._nodes.get(target.getType());\n  let exportOutput;\n\n  // Use HTMLConfig overrides, if available.\n  if (registeredNode && registeredNode.exportDOM !== undefined) {\n    exportOutput = registeredNode.exportDOM(editor, target);\n  } else {\n    exportOutput = target.exportDOM(editor);\n  }\n  const {\n    element,\n    after\n  } = exportOutput;\n  if (!element) {\n    return false;\n  }\n  const fragment = document.createDocumentFragment();\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToHTML(editor, childNode, fragment, selection);\n    if (!shouldInclude && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection, 'html')) {\n      shouldInclude = true;\n    }\n  }\n  if (shouldInclude && !shouldExclude) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.isDocumentFragment)(element)) {\n      element.append(fragment);\n    }\n    parentElement.append(element);\n    if (after) {\n      const newElement = after.call(target, element);\n      if (newElement) {\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.isDocumentFragment)(element)) {\n          element.replaceChildren(newElement);\n        } else {\n          element.replaceWith(newElement);\n        }\n      }\n    }\n  } else {\n    parentElement.append(fragment);\n  }\n  return shouldInclude;\n}\nfunction getConversionFunction(domNode, editor) {\n  const {\n    nodeName\n  } = domNode;\n  const cachedConversions = editor._htmlConversions.get(nodeName.toLowerCase());\n  let currentConversion = null;\n  if (cachedConversions !== undefined) {\n    for (const cachedConversion of cachedConversions) {\n      const domConversion = cachedConversion(domNode);\n      if (domConversion !== null && (currentConversion === null ||\n      // Given equal priority, prefer the last registered importer\n      // which is typically an application custom node or HTMLConfig['import']\n      (currentConversion.priority || 0) <= (domConversion.priority || 0))) {\n        currentConversion = domConversion;\n      }\n    }\n  }\n  return currentConversion !== null ? currentConversion.conversion : null;\n}\nconst IGNORE_TAGS = new Set(['STYLE', 'SCRIPT']);\nfunction $createNodesFromDOM(node, editor, allArtificialNodes, hasBlockAncestorLexicalNode, forChildMap = new Map(), parentLexicalNode) {\n  let lexicalNodes = [];\n  if (IGNORE_TAGS.has(node.nodeName)) {\n    return lexicalNodes;\n  }\n  let currentLexicalNode = null;\n  const transformFunction = getConversionFunction(node, editor);\n  const transformOutput = transformFunction ? transformFunction(node) : null;\n  let postTransform = null;\n  if (transformOutput !== null) {\n    postTransform = transformOutput.after;\n    const transformNodes = transformOutput.node;\n    currentLexicalNode = Array.isArray(transformNodes) ? transformNodes[transformNodes.length - 1] : transformNodes;\n    if (currentLexicalNode !== null) {\n      for (const [, forChildFunction] of forChildMap) {\n        currentLexicalNode = forChildFunction(currentLexicalNode, parentLexicalNode);\n        if (!currentLexicalNode) {\n          break;\n        }\n      }\n      if (currentLexicalNode) {\n        lexicalNodes.push(...(Array.isArray(transformNodes) ? transformNodes : [currentLexicalNode]));\n      }\n    }\n    if (transformOutput.forChild != null) {\n      forChildMap.set(node.nodeName, transformOutput.forChild);\n    }\n  }\n\n  // If the DOM node doesn't have a transformer, we don't know what\n  // to do with it but we still need to process any childNodes.\n  const children = node.childNodes;\n  let childLexicalNodes = [];\n  const hasBlockAncestorLexicalNodeForChildren = currentLexicalNode != null && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(currentLexicalNode) ? false : currentLexicalNode != null && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isBlockElementNode)(currentLexicalNode) || hasBlockAncestorLexicalNode;\n  for (let i = 0; i < children.length; i++) {\n    childLexicalNodes.push(...$createNodesFromDOM(children[i], editor, allArtificialNodes, hasBlockAncestorLexicalNodeForChildren, new Map(forChildMap), currentLexicalNode));\n  }\n  if (postTransform != null) {\n    childLexicalNodes = postTransform(childLexicalNodes);\n  }\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.isBlockDomNode)(node)) {\n    if (!hasBlockAncestorLexicalNodeForChildren) {\n      childLexicalNodes = wrapContinuousInlines(node, childLexicalNodes, lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode);\n    } else {\n      childLexicalNodes = wrapContinuousInlines(node, childLexicalNodes, () => {\n        const artificialNode = new lexical__WEBPACK_IMPORTED_MODULE_0__.ArtificialNode__DO_NOT_USE();\n        allArtificialNodes.push(artificialNode);\n        return artificialNode;\n      });\n    }\n  }\n  if (currentLexicalNode == null) {\n    if (childLexicalNodes.length > 0) {\n      // If it hasn't been converted to a LexicalNode, we hoist its children\n      // up to the same level as it.\n      lexicalNodes = lexicalNodes.concat(childLexicalNodes);\n    } else {\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.isBlockDomNode)(node) && isDomNodeBetweenTwoInlineNodes(node)) {\n        // Empty block dom node that hasnt been converted, we replace it with a linebreak if its between inline nodes\n        lexicalNodes = lexicalNodes.concat((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createLineBreakNode)());\n      }\n    }\n  } else {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentLexicalNode)) {\n      // If the current node is a ElementNode after conversion,\n      // we can append all the children to it.\n      currentLexicalNode.append(...childLexicalNodes);\n    }\n  }\n  return lexicalNodes;\n}\nfunction wrapContinuousInlines(domNode, nodes, createWrapperFn) {\n  const textAlign = domNode.style.textAlign;\n  const out = [];\n  let continuousInlines = [];\n  // wrap contiguous inline child nodes in para\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isBlockElementNode)(node)) {\n      if (textAlign && !node.getFormat()) {\n        node.setFormat(textAlign);\n      }\n      out.push(node);\n    } else {\n      continuousInlines.push(node);\n      if (i === nodes.length - 1 || i < nodes.length - 1 && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isBlockElementNode)(nodes[i + 1])) {\n        const wrapper = createWrapperFn();\n        wrapper.setFormat(textAlign);\n        wrapper.append(...continuousInlines);\n        out.push(wrapper);\n        continuousInlines = [];\n      }\n    }\n  }\n  return out;\n}\nfunction $unwrapArtificalNodes(allArtificialNodes) {\n  for (const node of allArtificialNodes) {\n    if (node.getNextSibling() instanceof lexical__WEBPACK_IMPORTED_MODULE_0__.ArtificialNode__DO_NOT_USE) {\n      node.insertAfter((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createLineBreakNode)());\n    }\n  }\n  // Replace artificial node with it's children\n  for (const node of allArtificialNodes) {\n    const children = node.getChildren();\n    for (const child of children) {\n      node.insertBefore(child);\n    }\n    node.remove();\n  }\n}\nfunction isDomNodeBetweenTwoInlineNodes(node) {\n  if (node.nextSibling == null || node.previousSibling == null) {\n    return false;\n  }\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.isInlineDomNode)(node.nextSibling) && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.isInlineDomNode)(node.previousSibling);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvaHRtbC9MZXhpY2FsSHRtbC5kZXYubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFbUU7QUFDSjtBQUM4Szs7QUFFN087QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlEQUFRO0FBQ3ZCO0FBQ0Esa0JBQWtCLDZCQUE2QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1REFBYztBQUN0QztBQUNBO0FBQ0EsZ0JBQWdCLDZEQUFvQjtBQUNwQyxZQUFZLG9EQUFXLGdDQUFnQyxpRkFBNkI7QUFDcEY7QUFDQTtBQUNBLG1CQUFtQix1REFBYztBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0EsMEJBQTBCLHVEQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzREFBYSxhQUFhLDJEQUFrQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDJEQUFrQjtBQUM5QjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLDREQUFtQiw2REFBNkQsNERBQW1CO0FBQ2xMLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sdURBQWM7QUFDcEI7QUFDQSx5RUFBeUUseURBQW9CO0FBQzdGLE1BQU07QUFDTjtBQUNBLG1DQUFtQywrREFBMEI7QUFDN0Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixVQUFVLHVEQUFjO0FBQ3hCO0FBQ0EsMkNBQTJDLDZEQUFvQjtBQUMvRDtBQUNBO0FBQ0EsSUFBSTtBQUNKLFFBQVEsdURBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBLFFBQVEsNERBQW1CO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsNERBQTRELDREQUFtQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsK0RBQTBCO0FBQ25FLHVCQUF1Qiw2REFBb0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx3REFBZSxzQkFBc0Isd0RBQWU7QUFDN0Q7O0FBRXlEIiwic291cmNlcyI6WyIvVXNlcnMvbGVpL2hvbWUvdW5kZXJnL3RoZWF0cmUveTMvc2VncC9taWxrdXAvbm9kZV9tb2R1bGVzL0BsZXhpY2FsL2h0bWwvTGV4aWNhbEh0bWwuZGV2Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmltcG9ydCB7ICRzbGljZVNlbGVjdGVkVGV4dE5vZGVDb250ZW50IH0gZnJvbSAnQGxleGljYWwvc2VsZWN0aW9uJztcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQsIGlzQmxvY2tEb21Ob2RlIH0gZnJvbSAnQGxleGljYWwvdXRpbHMnO1xuaW1wb3J0IHsgJGdldFJvb3QsICRpc0VsZW1lbnROb2RlLCAkY2xvbmVXaXRoUHJvcGVydGllcywgJGlzVGV4dE5vZGUsIGlzRG9jdW1lbnRGcmFnbWVudCwgJGlzUm9vdE9yU2hhZG93Um9vdCwgJGlzQmxvY2tFbGVtZW50Tm9kZSwgJGNyZWF0ZUxpbmVCcmVha05vZGUsIEFydGlmaWNpYWxOb2RlX19ET19OT1RfVVNFLCBpc0lubGluZURvbU5vZGUsICRjcmVhdGVQYXJhZ3JhcGhOb2RlIH0gZnJvbSAnbGV4aWNhbCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuXG4vKipcbiAqIEhvdyB5b3UgcGFyc2UgeW91ciBodG1sIHN0cmluZyB0byBnZXQgYSBkb2N1bWVudCBpcyBsZWZ0IHVwIHRvIHlvdS4gSW4gdGhlIGJyb3dzZXIgeW91IGNhbiB1c2UgdGhlIG5hdGl2ZVxuICogRE9NUGFyc2VyIEFQSSB0byBnZW5lcmF0ZSBhIGRvY3VtZW50IChzZWUgY2xpcGJvYXJkLnRzKSwgYnV0IHRvIHVzZSBpbiBhIGhlYWRsZXNzIGVudmlyb25tZW50IHlvdSBjYW4gdXNlIEpTRG9tXG4gKiBvciBhbiBlcXVpdmFsZW50IGxpYnJhcnkgYW5kIHBhc3MgaW4gdGhlIGRvY3VtZW50IGhlcmUuXG4gKi9cbmZ1bmN0aW9uICRnZW5lcmF0ZU5vZGVzRnJvbURPTShlZGl0b3IsIGRvbSkge1xuICBjb25zdCBlbGVtZW50cyA9IGRvbS5ib2R5ID8gZG9tLmJvZHkuY2hpbGROb2RlcyA6IFtdO1xuICBsZXQgbGV4aWNhbE5vZGVzID0gW107XG4gIGNvbnN0IGFsbEFydGlmaWNpYWxOb2RlcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuICAgIGlmICghSUdOT1JFX1RBR1MuaGFzKGVsZW1lbnQubm9kZU5hbWUpKSB7XG4gICAgICBjb25zdCBsZXhpY2FsTm9kZSA9ICRjcmVhdGVOb2Rlc0Zyb21ET00oZWxlbWVudCwgZWRpdG9yLCBhbGxBcnRpZmljaWFsTm9kZXMsIGZhbHNlKTtcbiAgICAgIGlmIChsZXhpY2FsTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICBsZXhpY2FsTm9kZXMgPSBsZXhpY2FsTm9kZXMuY29uY2F0KGxleGljYWxOb2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgJHVud3JhcEFydGlmaWNhbE5vZGVzKGFsbEFydGlmaWNpYWxOb2Rlcyk7XG4gIHJldHVybiBsZXhpY2FsTm9kZXM7XG59XG5mdW5jdGlvbiAkZ2VuZXJhdGVIdG1sRnJvbU5vZGVzKGVkaXRvciwgc2VsZWN0aW9uKSB7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBnbG9iYWwud2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIHRocm93IG5ldyBFcnJvcignVG8gdXNlICRnZW5lcmF0ZUh0bWxGcm9tTm9kZXMgaW4gaGVhZGxlc3MgbW9kZSBwbGVhc2UgaW5pdGlhbGl6ZSBhIGhlYWRsZXNzIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gc3VjaCBhcyBKU0RvbSBiZWZvcmUgY2FsbGluZyB0aGlzIGZ1bmN0aW9uLicpO1xuICB9XG4gIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBjb25zdCByb290ID0gJGdldFJvb3QoKTtcbiAgY29uc3QgdG9wTGV2ZWxDaGlsZHJlbiA9IHJvb3QuZ2V0Q2hpbGRyZW4oKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3BMZXZlbENoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdG9wTGV2ZWxOb2RlID0gdG9wTGV2ZWxDaGlsZHJlbltpXTtcbiAgICAkYXBwZW5kTm9kZXNUb0hUTUwoZWRpdG9yLCB0b3BMZXZlbE5vZGUsIGNvbnRhaW5lciwgc2VsZWN0aW9uKTtcbiAgfVxuICByZXR1cm4gY29udGFpbmVyLmlubmVySFRNTDtcbn1cbmZ1bmN0aW9uICRhcHBlbmROb2Rlc1RvSFRNTChlZGl0b3IsIGN1cnJlbnROb2RlLCBwYXJlbnRFbGVtZW50LCBzZWxlY3Rpb24gPSBudWxsKSB7XG4gIGxldCBzaG91bGRJbmNsdWRlID0gc2VsZWN0aW9uICE9PSBudWxsID8gY3VycmVudE5vZGUuaXNTZWxlY3RlZChzZWxlY3Rpb24pIDogdHJ1ZTtcbiAgY29uc3Qgc2hvdWxkRXhjbHVkZSA9ICRpc0VsZW1lbnROb2RlKGN1cnJlbnROb2RlKSAmJiBjdXJyZW50Tm9kZS5leGNsdWRlRnJvbUNvcHkoJ2h0bWwnKTtcbiAgbGV0IHRhcmdldCA9IGN1cnJlbnROb2RlO1xuICBpZiAoc2VsZWN0aW9uICE9PSBudWxsKSB7XG4gICAgbGV0IGNsb25lID0gJGNsb25lV2l0aFByb3BlcnRpZXMoY3VycmVudE5vZGUpO1xuICAgIGNsb25lID0gJGlzVGV4dE5vZGUoY2xvbmUpICYmIHNlbGVjdGlvbiAhPT0gbnVsbCA/ICRzbGljZVNlbGVjdGVkVGV4dE5vZGVDb250ZW50KHNlbGVjdGlvbiwgY2xvbmUpIDogY2xvbmU7XG4gICAgdGFyZ2V0ID0gY2xvbmU7XG4gIH1cbiAgY29uc3QgY2hpbGRyZW4gPSAkaXNFbGVtZW50Tm9kZSh0YXJnZXQpID8gdGFyZ2V0LmdldENoaWxkcmVuKCkgOiBbXTtcbiAgY29uc3QgcmVnaXN0ZXJlZE5vZGUgPSBlZGl0b3IuX25vZGVzLmdldCh0YXJnZXQuZ2V0VHlwZSgpKTtcbiAgbGV0IGV4cG9ydE91dHB1dDtcblxuICAvLyBVc2UgSFRNTENvbmZpZyBvdmVycmlkZXMsIGlmIGF2YWlsYWJsZS5cbiAgaWYgKHJlZ2lzdGVyZWROb2RlICYmIHJlZ2lzdGVyZWROb2RlLmV4cG9ydERPTSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZXhwb3J0T3V0cHV0ID0gcmVnaXN0ZXJlZE5vZGUuZXhwb3J0RE9NKGVkaXRvciwgdGFyZ2V0KTtcbiAgfSBlbHNlIHtcbiAgICBleHBvcnRPdXRwdXQgPSB0YXJnZXQuZXhwb3J0RE9NKGVkaXRvcik7XG4gIH1cbiAgY29uc3Qge1xuICAgIGVsZW1lbnQsXG4gICAgYWZ0ZXJcbiAgfSA9IGV4cG9ydE91dHB1dDtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hpbGROb2RlID0gY2hpbGRyZW5baV07XG4gICAgY29uc3Qgc2hvdWxkSW5jbHVkZUNoaWxkID0gJGFwcGVuZE5vZGVzVG9IVE1MKGVkaXRvciwgY2hpbGROb2RlLCBmcmFnbWVudCwgc2VsZWN0aW9uKTtcbiAgICBpZiAoIXNob3VsZEluY2x1ZGUgJiYgJGlzRWxlbWVudE5vZGUoY3VycmVudE5vZGUpICYmIHNob3VsZEluY2x1ZGVDaGlsZCAmJiBjdXJyZW50Tm9kZS5leHRyYWN0V2l0aENoaWxkKGNoaWxkTm9kZSwgc2VsZWN0aW9uLCAnaHRtbCcpKSB7XG4gICAgICBzaG91bGRJbmNsdWRlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKHNob3VsZEluY2x1ZGUgJiYgIXNob3VsZEV4Y2x1ZGUpIHtcbiAgICBpZiAoaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCBpc0RvY3VtZW50RnJhZ21lbnQoZWxlbWVudCkpIHtcbiAgICAgIGVsZW1lbnQuYXBwZW5kKGZyYWdtZW50KTtcbiAgICB9XG4gICAgcGFyZW50RWxlbWVudC5hcHBlbmQoZWxlbWVudCk7XG4gICAgaWYgKGFmdGVyKSB7XG4gICAgICBjb25zdCBuZXdFbGVtZW50ID0gYWZ0ZXIuY2FsbCh0YXJnZXQsIGVsZW1lbnQpO1xuICAgICAgaWYgKG5ld0VsZW1lbnQpIHtcbiAgICAgICAgaWYgKGlzRG9jdW1lbnRGcmFnbWVudChlbGVtZW50KSkge1xuICAgICAgICAgIGVsZW1lbnQucmVwbGFjZUNoaWxkcmVuKG5ld0VsZW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsZW1lbnQucmVwbGFjZVdpdGgobmV3RWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcGFyZW50RWxlbWVudC5hcHBlbmQoZnJhZ21lbnQpO1xuICB9XG4gIHJldHVybiBzaG91bGRJbmNsdWRlO1xufVxuZnVuY3Rpb24gZ2V0Q29udmVyc2lvbkZ1bmN0aW9uKGRvbU5vZGUsIGVkaXRvcikge1xuICBjb25zdCB7XG4gICAgbm9kZU5hbWVcbiAgfSA9IGRvbU5vZGU7XG4gIGNvbnN0IGNhY2hlZENvbnZlcnNpb25zID0gZWRpdG9yLl9odG1sQ29udmVyc2lvbnMuZ2V0KG5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICBsZXQgY3VycmVudENvbnZlcnNpb24gPSBudWxsO1xuICBpZiAoY2FjaGVkQ29udmVyc2lvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgIGZvciAoY29uc3QgY2FjaGVkQ29udmVyc2lvbiBvZiBjYWNoZWRDb252ZXJzaW9ucykge1xuICAgICAgY29uc3QgZG9tQ29udmVyc2lvbiA9IGNhY2hlZENvbnZlcnNpb24oZG9tTm9kZSk7XG4gICAgICBpZiAoZG9tQ29udmVyc2lvbiAhPT0gbnVsbCAmJiAoY3VycmVudENvbnZlcnNpb24gPT09IG51bGwgfHxcbiAgICAgIC8vIEdpdmVuIGVxdWFsIHByaW9yaXR5LCBwcmVmZXIgdGhlIGxhc3QgcmVnaXN0ZXJlZCBpbXBvcnRlclxuICAgICAgLy8gd2hpY2ggaXMgdHlwaWNhbGx5IGFuIGFwcGxpY2F0aW9uIGN1c3RvbSBub2RlIG9yIEhUTUxDb25maWdbJ2ltcG9ydCddXG4gICAgICAoY3VycmVudENvbnZlcnNpb24ucHJpb3JpdHkgfHwgMCkgPD0gKGRvbUNvbnZlcnNpb24ucHJpb3JpdHkgfHwgMCkpKSB7XG4gICAgICAgIGN1cnJlbnRDb252ZXJzaW9uID0gZG9tQ29udmVyc2lvbjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGN1cnJlbnRDb252ZXJzaW9uICE9PSBudWxsID8gY3VycmVudENvbnZlcnNpb24uY29udmVyc2lvbiA6IG51bGw7XG59XG5jb25zdCBJR05PUkVfVEFHUyA9IG5ldyBTZXQoWydTVFlMRScsICdTQ1JJUFQnXSk7XG5mdW5jdGlvbiAkY3JlYXRlTm9kZXNGcm9tRE9NKG5vZGUsIGVkaXRvciwgYWxsQXJ0aWZpY2lhbE5vZGVzLCBoYXNCbG9ja0FuY2VzdG9yTGV4aWNhbE5vZGUsIGZvckNoaWxkTWFwID0gbmV3IE1hcCgpLCBwYXJlbnRMZXhpY2FsTm9kZSkge1xuICBsZXQgbGV4aWNhbE5vZGVzID0gW107XG4gIGlmIChJR05PUkVfVEFHUy5oYXMobm9kZS5ub2RlTmFtZSkpIHtcbiAgICByZXR1cm4gbGV4aWNhbE5vZGVzO1xuICB9XG4gIGxldCBjdXJyZW50TGV4aWNhbE5vZGUgPSBudWxsO1xuICBjb25zdCB0cmFuc2Zvcm1GdW5jdGlvbiA9IGdldENvbnZlcnNpb25GdW5jdGlvbihub2RlLCBlZGl0b3IpO1xuICBjb25zdCB0cmFuc2Zvcm1PdXRwdXQgPSB0cmFuc2Zvcm1GdW5jdGlvbiA/IHRyYW5zZm9ybUZ1bmN0aW9uKG5vZGUpIDogbnVsbDtcbiAgbGV0IHBvc3RUcmFuc2Zvcm0gPSBudWxsO1xuICBpZiAodHJhbnNmb3JtT3V0cHV0ICE9PSBudWxsKSB7XG4gICAgcG9zdFRyYW5zZm9ybSA9IHRyYW5zZm9ybU91dHB1dC5hZnRlcjtcbiAgICBjb25zdCB0cmFuc2Zvcm1Ob2RlcyA9IHRyYW5zZm9ybU91dHB1dC5ub2RlO1xuICAgIGN1cnJlbnRMZXhpY2FsTm9kZSA9IEFycmF5LmlzQXJyYXkodHJhbnNmb3JtTm9kZXMpID8gdHJhbnNmb3JtTm9kZXNbdHJhbnNmb3JtTm9kZXMubGVuZ3RoIC0gMV0gOiB0cmFuc2Zvcm1Ob2RlcztcbiAgICBpZiAoY3VycmVudExleGljYWxOb2RlICE9PSBudWxsKSB7XG4gICAgICBmb3IgKGNvbnN0IFssIGZvckNoaWxkRnVuY3Rpb25dIG9mIGZvckNoaWxkTWFwKSB7XG4gICAgICAgIGN1cnJlbnRMZXhpY2FsTm9kZSA9IGZvckNoaWxkRnVuY3Rpb24oY3VycmVudExleGljYWxOb2RlLCBwYXJlbnRMZXhpY2FsTm9kZSk7XG4gICAgICAgIGlmICghY3VycmVudExleGljYWxOb2RlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50TGV4aWNhbE5vZGUpIHtcbiAgICAgICAgbGV4aWNhbE5vZGVzLnB1c2goLi4uKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtTm9kZXMpID8gdHJhbnNmb3JtTm9kZXMgOiBbY3VycmVudExleGljYWxOb2RlXSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHJhbnNmb3JtT3V0cHV0LmZvckNoaWxkICE9IG51bGwpIHtcbiAgICAgIGZvckNoaWxkTWFwLnNldChub2RlLm5vZGVOYW1lLCB0cmFuc2Zvcm1PdXRwdXQuZm9yQ2hpbGQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIElmIHRoZSBET00gbm9kZSBkb2Vzbid0IGhhdmUgYSB0cmFuc2Zvcm1lciwgd2UgZG9uJ3Qga25vdyB3aGF0XG4gIC8vIHRvIGRvIHdpdGggaXQgYnV0IHdlIHN0aWxsIG5lZWQgdG8gcHJvY2VzcyBhbnkgY2hpbGROb2Rlcy5cbiAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmNoaWxkTm9kZXM7XG4gIGxldCBjaGlsZExleGljYWxOb2RlcyA9IFtdO1xuICBjb25zdCBoYXNCbG9ja0FuY2VzdG9yTGV4aWNhbE5vZGVGb3JDaGlsZHJlbiA9IGN1cnJlbnRMZXhpY2FsTm9kZSAhPSBudWxsICYmICRpc1Jvb3RPclNoYWRvd1Jvb3QoY3VycmVudExleGljYWxOb2RlKSA/IGZhbHNlIDogY3VycmVudExleGljYWxOb2RlICE9IG51bGwgJiYgJGlzQmxvY2tFbGVtZW50Tm9kZShjdXJyZW50TGV4aWNhbE5vZGUpIHx8IGhhc0Jsb2NrQW5jZXN0b3JMZXhpY2FsTm9kZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGNoaWxkTGV4aWNhbE5vZGVzLnB1c2goLi4uJGNyZWF0ZU5vZGVzRnJvbURPTShjaGlsZHJlbltpXSwgZWRpdG9yLCBhbGxBcnRpZmljaWFsTm9kZXMsIGhhc0Jsb2NrQW5jZXN0b3JMZXhpY2FsTm9kZUZvckNoaWxkcmVuLCBuZXcgTWFwKGZvckNoaWxkTWFwKSwgY3VycmVudExleGljYWxOb2RlKSk7XG4gIH1cbiAgaWYgKHBvc3RUcmFuc2Zvcm0gIT0gbnVsbCkge1xuICAgIGNoaWxkTGV4aWNhbE5vZGVzID0gcG9zdFRyYW5zZm9ybShjaGlsZExleGljYWxOb2Rlcyk7XG4gIH1cbiAgaWYgKGlzQmxvY2tEb21Ob2RlKG5vZGUpKSB7XG4gICAgaWYgKCFoYXNCbG9ja0FuY2VzdG9yTGV4aWNhbE5vZGVGb3JDaGlsZHJlbikge1xuICAgICAgY2hpbGRMZXhpY2FsTm9kZXMgPSB3cmFwQ29udGludW91c0lubGluZXMobm9kZSwgY2hpbGRMZXhpY2FsTm9kZXMsICRjcmVhdGVQYXJhZ3JhcGhOb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hpbGRMZXhpY2FsTm9kZXMgPSB3cmFwQ29udGludW91c0lubGluZXMobm9kZSwgY2hpbGRMZXhpY2FsTm9kZXMsICgpID0+IHtcbiAgICAgICAgY29uc3QgYXJ0aWZpY2lhbE5vZGUgPSBuZXcgQXJ0aWZpY2lhbE5vZGVfX0RPX05PVF9VU0UoKTtcbiAgICAgICAgYWxsQXJ0aWZpY2lhbE5vZGVzLnB1c2goYXJ0aWZpY2lhbE5vZGUpO1xuICAgICAgICByZXR1cm4gYXJ0aWZpY2lhbE5vZGU7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKGN1cnJlbnRMZXhpY2FsTm9kZSA9PSBudWxsKSB7XG4gICAgaWYgKGNoaWxkTGV4aWNhbE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIElmIGl0IGhhc24ndCBiZWVuIGNvbnZlcnRlZCB0byBhIExleGljYWxOb2RlLCB3ZSBob2lzdCBpdHMgY2hpbGRyZW5cbiAgICAgIC8vIHVwIHRvIHRoZSBzYW1lIGxldmVsIGFzIGl0LlxuICAgICAgbGV4aWNhbE5vZGVzID0gbGV4aWNhbE5vZGVzLmNvbmNhdChjaGlsZExleGljYWxOb2Rlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc0Jsb2NrRG9tTm9kZShub2RlKSAmJiBpc0RvbU5vZGVCZXR3ZWVuVHdvSW5saW5lTm9kZXMobm9kZSkpIHtcbiAgICAgICAgLy8gRW1wdHkgYmxvY2sgZG9tIG5vZGUgdGhhdCBoYXNudCBiZWVuIGNvbnZlcnRlZCwgd2UgcmVwbGFjZSBpdCB3aXRoIGEgbGluZWJyZWFrIGlmIGl0cyBiZXR3ZWVuIGlubGluZSBub2Rlc1xuICAgICAgICBsZXhpY2FsTm9kZXMgPSBsZXhpY2FsTm9kZXMuY29uY2F0KCRjcmVhdGVMaW5lQnJlYWtOb2RlKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoJGlzRWxlbWVudE5vZGUoY3VycmVudExleGljYWxOb2RlKSkge1xuICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgbm9kZSBpcyBhIEVsZW1lbnROb2RlIGFmdGVyIGNvbnZlcnNpb24sXG4gICAgICAvLyB3ZSBjYW4gYXBwZW5kIGFsbCB0aGUgY2hpbGRyZW4gdG8gaXQuXG4gICAgICBjdXJyZW50TGV4aWNhbE5vZGUuYXBwZW5kKC4uLmNoaWxkTGV4aWNhbE5vZGVzKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxleGljYWxOb2Rlcztcbn1cbmZ1bmN0aW9uIHdyYXBDb250aW51b3VzSW5saW5lcyhkb21Ob2RlLCBub2RlcywgY3JlYXRlV3JhcHBlckZuKSB7XG4gIGNvbnN0IHRleHRBbGlnbiA9IGRvbU5vZGUuc3R5bGUudGV4dEFsaWduO1xuICBjb25zdCBvdXQgPSBbXTtcbiAgbGV0IGNvbnRpbnVvdXNJbmxpbmVzID0gW107XG4gIC8vIHdyYXAgY29udGlndW91cyBpbmxpbmUgY2hpbGQgbm9kZXMgaW4gcGFyYVxuICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgIGlmICgkaXNCbG9ja0VsZW1lbnROb2RlKG5vZGUpKSB7XG4gICAgICBpZiAodGV4dEFsaWduICYmICFub2RlLmdldEZvcm1hdCgpKSB7XG4gICAgICAgIG5vZGUuc2V0Rm9ybWF0KHRleHRBbGlnbik7XG4gICAgICB9XG4gICAgICBvdXQucHVzaChub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGludW91c0lubGluZXMucHVzaChub2RlKTtcbiAgICAgIGlmIChpID09PSBub2Rlcy5sZW5ndGggLSAxIHx8IGkgPCBub2Rlcy5sZW5ndGggLSAxICYmICRpc0Jsb2NrRWxlbWVudE5vZGUobm9kZXNbaSArIDFdKSkge1xuICAgICAgICBjb25zdCB3cmFwcGVyID0gY3JlYXRlV3JhcHBlckZuKCk7XG4gICAgICAgIHdyYXBwZXIuc2V0Rm9ybWF0KHRleHRBbGlnbik7XG4gICAgICAgIHdyYXBwZXIuYXBwZW5kKC4uLmNvbnRpbnVvdXNJbmxpbmVzKTtcbiAgICAgICAgb3V0LnB1c2god3JhcHBlcik7XG4gICAgICAgIGNvbnRpbnVvdXNJbmxpbmVzID0gW107XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXQ7XG59XG5mdW5jdGlvbiAkdW53cmFwQXJ0aWZpY2FsTm9kZXMoYWxsQXJ0aWZpY2lhbE5vZGVzKSB7XG4gIGZvciAoY29uc3Qgbm9kZSBvZiBhbGxBcnRpZmljaWFsTm9kZXMpIHtcbiAgICBpZiAobm9kZS5nZXROZXh0U2libGluZygpIGluc3RhbmNlb2YgQXJ0aWZpY2lhbE5vZGVfX0RPX05PVF9VU0UpIHtcbiAgICAgIG5vZGUuaW5zZXJ0QWZ0ZXIoJGNyZWF0ZUxpbmVCcmVha05vZGUoKSk7XG4gICAgfVxuICB9XG4gIC8vIFJlcGxhY2UgYXJ0aWZpY2lhbCBub2RlIHdpdGggaXQncyBjaGlsZHJlblxuICBmb3IgKGNvbnN0IG5vZGUgb2YgYWxsQXJ0aWZpY2lhbE5vZGVzKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmdldENoaWxkcmVuKCk7XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgICAgbm9kZS5pbnNlcnRCZWZvcmUoY2hpbGQpO1xuICAgIH1cbiAgICBub2RlLnJlbW92ZSgpO1xuICB9XG59XG5mdW5jdGlvbiBpc0RvbU5vZGVCZXR3ZWVuVHdvSW5saW5lTm9kZXMobm9kZSkge1xuICBpZiAobm9kZS5uZXh0U2libGluZyA9PSBudWxsIHx8IG5vZGUucHJldmlvdXNTaWJsaW5nID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzSW5saW5lRG9tTm9kZShub2RlLm5leHRTaWJsaW5nKSAmJiBpc0lubGluZURvbU5vZGUobm9kZS5wcmV2aW91c1NpYmxpbmcpO1xufVxuXG5leHBvcnQgeyAkZ2VuZXJhdGVIdG1sRnJvbU5vZGVzLCAkZ2VuZXJhdGVOb2Rlc0Zyb21ET00gfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/html/LexicalHtml.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/plain-text/LexicalPlainText.dev.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@lexical/plain-text/LexicalPlainText.dev.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   registerPlainText: () => (/* binding */ registerPlainText)\n/* harmony export */ });\n/* harmony import */ var _lexical_clipboard__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lexical/clipboard */ \"(ssr)/./node_modules/@lexical/clipboard/LexicalClipboard.dev.mjs\");\n/* harmony import */ var _lexical_selection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lexical/selection */ \"(ssr)/./node_modules/@lexical/selection/LexicalSelection.dev.mjs\");\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nconst CAN_USE_BEFORE_INPUT = CAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\n\n// Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\nconst IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent);\nconst IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction onCopyForPlainText(event, editor) {\n  editor.update(() => {\n    if (event !== null) {\n      const clipboardData = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_0__.objectKlassEquals)(event, KeyboardEvent) ? null : event.clipboardData;\n      const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$getSelection)();\n      if (selection !== null && clipboardData != null) {\n        event.preventDefault();\n        const htmlString = (0,_lexical_clipboard__WEBPACK_IMPORTED_MODULE_2__.$getHtmlContent)(editor);\n        if (htmlString !== null) {\n          clipboardData.setData('text/html', htmlString);\n        }\n        clipboardData.setData('text/plain', selection.getTextContent());\n      }\n    }\n  });\n}\nfunction onPasteForPlainText(event, editor) {\n  event.preventDefault();\n  editor.update(() => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$getSelection)();\n    const {\n      clipboardData\n    } = event;\n    if (clipboardData != null && (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isRangeSelection)(selection)) {\n      (0,_lexical_clipboard__WEBPACK_IMPORTED_MODULE_2__.$insertDataTransferForPlainText)(clipboardData, selection);\n    }\n  }, {\n    tag: 'paste'\n  });\n}\nfunction onCutForPlainText(event, editor) {\n  onCopyForPlainText(event, editor);\n  editor.update(() => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$getSelection)();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isRangeSelection)(selection)) {\n      selection.removeText();\n    }\n  });\n}\nfunction registerPlainText(editor) {\n  const removeListener = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_0__.mergeRegister)(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_1__.DELETE_CHARACTER_COMMAND, isBackward => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    selection.deleteCharacter(isBackward);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_1__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_1__.DELETE_WORD_COMMAND, isBackward => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    selection.deleteWord(isBackward);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_1__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_1__.DELETE_LINE_COMMAND, isBackward => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    selection.deleteLine(isBackward);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_1__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_1__.CONTROLLED_TEXT_INSERTION_COMMAND, eventOrText => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    if (typeof eventOrText === 'string') {\n      selection.insertText(eventOrText);\n    } else {\n      const dataTransfer = eventOrText.dataTransfer;\n      if (dataTransfer != null) {\n        (0,_lexical_clipboard__WEBPACK_IMPORTED_MODULE_2__.$insertDataTransferForPlainText)(dataTransfer, selection);\n      } else {\n        const data = eventOrText.data;\n        if (data) {\n          selection.insertText(data);\n        }\n      }\n    }\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_1__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_1__.REMOVE_TEXT_COMMAND, () => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    selection.removeText();\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_1__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_1__.INSERT_LINE_BREAK_COMMAND, selectStart => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    selection.insertLineBreak(selectStart);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_1__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_1__.INSERT_PARAGRAPH_COMMAND, () => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    selection.insertLineBreak();\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_1__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_1__.KEY_ARROW_LEFT_COMMAND, payload => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    const event = payload;\n    const isHoldingShift = event.shiftKey;\n    if ((0,_lexical_selection__WEBPACK_IMPORTED_MODULE_3__.$shouldOverrideDefaultCharacterSelection)(selection, true)) {\n      event.preventDefault();\n      (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_3__.$moveCharacter)(selection, isHoldingShift, true);\n      return true;\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_1__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_1__.KEY_ARROW_RIGHT_COMMAND, payload => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    const event = payload;\n    const isHoldingShift = event.shiftKey;\n    if ((0,_lexical_selection__WEBPACK_IMPORTED_MODULE_3__.$shouldOverrideDefaultCharacterSelection)(selection, false)) {\n      event.preventDefault();\n      (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_3__.$moveCharacter)(selection, isHoldingShift, false);\n      return true;\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_1__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_1__.KEY_BACKSPACE_COMMAND, event => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isRangeSelection)(selection)) {\n      return false;\n    }\n\n    // Exception handling for iOS native behavior instead of Lexical's behavior when using Korean on iOS devices.\n    // more details - https://github.com/facebook/lexical/issues/5841\n    if (IS_IOS && navigator.language === 'ko-KR') {\n      return false;\n    }\n    event.preventDefault();\n    return editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_1__.DELETE_CHARACTER_COMMAND, true);\n  }, lexical__WEBPACK_IMPORTED_MODULE_1__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_1__.KEY_DELETE_COMMAND, event => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    event.preventDefault();\n    return editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_1__.DELETE_CHARACTER_COMMAND, false);\n  }, lexical__WEBPACK_IMPORTED_MODULE_1__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_1__.KEY_ENTER_COMMAND, event => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    if (event !== null) {\n      // If we have beforeinput, then we can avoid blocking\n      // the default behavior. This ensures that the iOS can\n      // intercept that we're actually inserting a paragraph,\n      // and autocomplete, autocapitalize etc work as intended.\n      // This can also cause a strange performance issue in\n      // Safari, where there is a noticeable pause due to\n      // preventing the key down of enter.\n      if ((IS_IOS || IS_SAFARI || IS_APPLE_WEBKIT) && CAN_USE_BEFORE_INPUT) {\n        return false;\n      }\n      event.preventDefault();\n    }\n    return editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_1__.INSERT_LINE_BREAK_COMMAND, false);\n  }, lexical__WEBPACK_IMPORTED_MODULE_1__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_1__.SELECT_ALL_COMMAND, () => {\n    (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$selectAll)();\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_1__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_1__.COPY_COMMAND, event => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    onCopyForPlainText(event, editor);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_1__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_1__.CUT_COMMAND, event => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    onCutForPlainText(event, editor);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_1__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_1__.PASTE_COMMAND, event => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    onPasteForPlainText(event, editor);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_1__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_1__.DROP_COMMAND, event => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isRangeSelection)(selection)) {\n      return false;\n    }\n\n    // TODO: Make drag and drop work at some point.\n    event.preventDefault();\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_1__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_1__.DRAGSTART_COMMAND, event => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isRangeSelection)(selection)) {\n      return false;\n    }\n\n    // TODO: Make drag and drop work at some point.\n    event.preventDefault();\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_1__.COMMAND_PRIORITY_EDITOR));\n  return removeListener;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcGxhaW4tdGV4dC9MZXhpY2FsUGxhaW5UZXh0LmRldi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFc0Y7QUFDUTtBQUM1QjtBQUM2Wjs7QUFFL2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGlFQUFpQjtBQUM3Qyx3QkFBd0Isc0RBQWE7QUFDckM7QUFDQTtBQUNBLDJCQUEyQixtRUFBZTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0RBQWE7QUFDbkM7QUFDQTtBQUNBLE1BQU07QUFDTixpQ0FBaUMsMERBQWlCO0FBQ2xELE1BQU0sbUZBQStCO0FBQ3JDO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNEQUFhO0FBQ25DLFFBQVEsMERBQWlCO0FBQ3pCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHlCQUF5Qiw2REFBYSx3QkFBd0IsNkRBQXdCO0FBQ3RGLHNCQUFzQixzREFBYTtBQUNuQyxTQUFTLDBEQUFpQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRSw0REFBdUIsMEJBQTBCLHdEQUFtQjtBQUN6RSxzQkFBc0Isc0RBQWE7QUFDbkMsU0FBUywwREFBaUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLEVBQUUsNERBQXVCLDBCQUEwQix3REFBbUI7QUFDekUsc0JBQXNCLHNEQUFhO0FBQ25DLFNBQVMsMERBQWlCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxFQUFFLDREQUF1QiwwQkFBMEIsc0VBQWlDO0FBQ3ZGLHNCQUFzQixzREFBYTtBQUNuQyxTQUFTLDBEQUFpQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUSxtRkFBK0I7QUFDdkMsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxFQUFFLDREQUF1QiwwQkFBMEIsd0RBQW1CO0FBQ3pFLHNCQUFzQixzREFBYTtBQUNuQyxTQUFTLDBEQUFpQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRSw0REFBdUIsMEJBQTBCLDhEQUF5QjtBQUMvRSxzQkFBc0Isc0RBQWE7QUFDbkMsU0FBUywwREFBaUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLEVBQUUsNERBQXVCLDBCQUEwQiw2REFBd0I7QUFDOUUsc0JBQXNCLHNEQUFhO0FBQ25DLFNBQVMsMERBQWlCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxFQUFFLDREQUF1QiwwQkFBMEIsMkRBQXNCO0FBQzVFLHNCQUFzQixzREFBYTtBQUNuQyxTQUFTLDBEQUFpQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNEZBQXdDO0FBQ2hEO0FBQ0EsTUFBTSxrRUFBYztBQUNwQjtBQUNBO0FBQ0E7QUFDQSxHQUFHLEVBQUUsNERBQXVCLDBCQUEwQiw0REFBdUI7QUFDN0Usc0JBQXNCLHNEQUFhO0FBQ25DLFNBQVMsMERBQWlCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw0RkFBd0M7QUFDaEQ7QUFDQSxNQUFNLGtFQUFjO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRSw0REFBdUIsMEJBQTBCLDBEQUFxQjtBQUMzRSxzQkFBc0Isc0RBQWE7QUFDbkMsU0FBUywwREFBaUI7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsNkRBQXdCO0FBQzFELEdBQUcsRUFBRSw0REFBdUIsMEJBQTBCLHVEQUFrQjtBQUN4RSxzQkFBc0Isc0RBQWE7QUFDbkMsU0FBUywwREFBaUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDZEQUF3QjtBQUMxRCxHQUFHLEVBQUUsNERBQXVCLDBCQUEwQixzREFBaUI7QUFDdkUsc0JBQXNCLHNEQUFhO0FBQ25DLFNBQVMsMERBQWlCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyw4REFBeUI7QUFDM0QsR0FBRyxFQUFFLDREQUF1QiwwQkFBMEIsdURBQWtCO0FBQ3hFLElBQUksbURBQVU7QUFDZDtBQUNBLEdBQUcsRUFBRSw0REFBdUIsMEJBQTBCLGlEQUFZO0FBQ2xFLHNCQUFzQixzREFBYTtBQUNuQyxTQUFTLDBEQUFpQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRSw0REFBdUIsMEJBQTBCLGdEQUFXO0FBQ2pFLHNCQUFzQixzREFBYTtBQUNuQyxTQUFTLDBEQUFpQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRSw0REFBdUIsMEJBQTBCLGtEQUFhO0FBQ25FLHNCQUFzQixzREFBYTtBQUNuQyxTQUFTLDBEQUFpQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRSw0REFBdUIsMEJBQTBCLGlEQUFZO0FBQ2xFLHNCQUFzQixzREFBYTtBQUNuQyxTQUFTLDBEQUFpQjtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRSw0REFBdUIsMEJBQTBCLHNEQUFpQjtBQUN2RSxzQkFBc0Isc0RBQWE7QUFDbkMsU0FBUywwREFBaUI7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLEVBQUUsNERBQXVCO0FBQzVCO0FBQ0E7O0FBRTZCIiwic291cmNlcyI6WyIvVXNlcnMvbGVpL2hvbWUvdW5kZXJnL3RoZWF0cmUveTMvc2VncC9taWxrdXAvbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3BsYWluLXRleHQvTGV4aWNhbFBsYWluVGV4dC5kZXYubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuaW1wb3J0IHsgJGluc2VydERhdGFUcmFuc2ZlckZvclBsYWluVGV4dCwgJGdldEh0bWxDb250ZW50IH0gZnJvbSAnQGxleGljYWwvY2xpcGJvYXJkJztcbmltcG9ydCB7ICRzaG91bGRPdmVycmlkZURlZmF1bHRDaGFyYWN0ZXJTZWxlY3Rpb24sICRtb3ZlQ2hhcmFjdGVyIH0gZnJvbSAnQGxleGljYWwvc2VsZWN0aW9uJztcbmltcG9ydCB7IG1lcmdlUmVnaXN0ZXIsIG9iamVjdEtsYXNzRXF1YWxzIH0gZnJvbSAnQGxleGljYWwvdXRpbHMnO1xuaW1wb3J0IHsgREVMRVRFX0NIQVJBQ1RFUl9DT01NQU5ELCAkZ2V0U2VsZWN0aW9uLCAkaXNSYW5nZVNlbGVjdGlvbiwgQ09NTUFORF9QUklPUklUWV9FRElUT1IsIERFTEVURV9XT1JEX0NPTU1BTkQsIERFTEVURV9MSU5FX0NPTU1BTkQsIENPTlRST0xMRURfVEVYVF9JTlNFUlRJT05fQ09NTUFORCwgUkVNT1ZFX1RFWFRfQ09NTUFORCwgSU5TRVJUX0xJTkVfQlJFQUtfQ09NTUFORCwgSU5TRVJUX1BBUkFHUkFQSF9DT01NQU5ELCBLRVlfQVJST1dfTEVGVF9DT01NQU5ELCBLRVlfQVJST1dfUklHSFRfQ09NTUFORCwgS0VZX0JBQ0tTUEFDRV9DT01NQU5ELCBLRVlfREVMRVRFX0NPTU1BTkQsIEtFWV9FTlRFUl9DT01NQU5ELCBTRUxFQ1RfQUxMX0NPTU1BTkQsICRzZWxlY3RBbGwsIENPUFlfQ09NTUFORCwgQ1VUX0NPTU1BTkQsIFBBU1RFX0NPTU1BTkQsIERST1BfQ09NTUFORCwgRFJBR1NUQVJUX0NPTU1BTkQgfSBmcm9tICdsZXhpY2FsJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBDQU5fVVNFX0RPTSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuY29uc3QgZG9jdW1lbnRNb2RlID0gQ0FOX1VTRV9ET00gJiYgJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQgPyBkb2N1bWVudC5kb2N1bWVudE1vZGUgOiBudWxsO1xuY29uc3QgQ0FOX1VTRV9CRUZPUkVfSU5QVVQgPSBDQU5fVVNFX0RPTSAmJiAnSW5wdXRFdmVudCcgaW4gd2luZG93ICYmICFkb2N1bWVudE1vZGUgPyAnZ2V0VGFyZ2V0UmFuZ2VzJyBpbiBuZXcgd2luZG93LklucHV0RXZlbnQoJ2lucHV0JykgOiBmYWxzZTtcbmNvbnN0IElTX1NBRkFSSSA9IENBTl9VU0VfRE9NICYmIC9WZXJzaW9uXFwvW1xcZC5dKy4qU2FmYXJpLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuY29uc3QgSVNfSU9TID0gQ0FOX1VTRV9ET00gJiYgL2lQYWR8aVBob25lfGlQb2QvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgIXdpbmRvdy5NU1N0cmVhbTtcblxuLy8gS2VlcCB0aGVzZSBpbiBjYXNlIHdlIG5lZWQgdG8gdXNlIHRoZW0gaW4gdGhlIGZ1dHVyZS5cbi8vIGV4cG9ydCBjb25zdCBJU19XSU5ET1dTOiBib29sZWFuID0gQ0FOX1VTRV9ET00gJiYgL1dpbi8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pO1xuY29uc3QgSVNfQ0hST01FID0gQ0FOX1VTRV9ET00gJiYgL14oPz0uKkNocm9tZSkuKi9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5jb25zdCBJU19BUFBMRV9XRUJLSVQgPSBDQU5fVVNFX0RPTSAmJiAvQXBwbGVXZWJLaXRcXC9bXFxkLl0rLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICFJU19DSFJPTUU7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gb25Db3B5Rm9yUGxhaW5UZXh0KGV2ZW50LCBlZGl0b3IpIHtcbiAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgaWYgKGV2ZW50ICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBjbGlwYm9hcmREYXRhID0gb2JqZWN0S2xhc3NFcXVhbHMoZXZlbnQsIEtleWJvYXJkRXZlbnQpID8gbnVsbCA6IGV2ZW50LmNsaXBib2FyZERhdGE7XG4gICAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgICBpZiAoc2VsZWN0aW9uICE9PSBudWxsICYmIGNsaXBib2FyZERhdGEgIT0gbnVsbCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBjb25zdCBodG1sU3RyaW5nID0gJGdldEh0bWxDb250ZW50KGVkaXRvcik7XG4gICAgICAgIGlmIChodG1sU3RyaW5nICE9PSBudWxsKSB7XG4gICAgICAgICAgY2xpcGJvYXJkRGF0YS5zZXREYXRhKCd0ZXh0L2h0bWwnLCBodG1sU3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBjbGlwYm9hcmREYXRhLnNldERhdGEoJ3RleHQvcGxhaW4nLCBzZWxlY3Rpb24uZ2V0VGV4dENvbnRlbnQoKSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIG9uUGFzdGVGb3JQbGFpblRleHQoZXZlbnQsIGVkaXRvcikge1xuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICBlZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgY29uc3Qge1xuICAgICAgY2xpcGJvYXJkRGF0YVxuICAgIH0gPSBldmVudDtcbiAgICBpZiAoY2xpcGJvYXJkRGF0YSAhPSBudWxsICYmICRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgICRpbnNlcnREYXRhVHJhbnNmZXJGb3JQbGFpblRleHQoY2xpcGJvYXJkRGF0YSwgc2VsZWN0aW9uKTtcbiAgICB9XG4gIH0sIHtcbiAgICB0YWc6ICdwYXN0ZSdcbiAgfSk7XG59XG5mdW5jdGlvbiBvbkN1dEZvclBsYWluVGV4dChldmVudCwgZWRpdG9yKSB7XG4gIG9uQ29weUZvclBsYWluVGV4dChldmVudCwgZWRpdG9yKTtcbiAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBzZWxlY3Rpb24ucmVtb3ZlVGV4dCgpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiByZWdpc3RlclBsYWluVGV4dChlZGl0b3IpIHtcbiAgY29uc3QgcmVtb3ZlTGlzdGVuZXIgPSBtZXJnZVJlZ2lzdGVyKGVkaXRvci5yZWdpc3RlckNvbW1hbmQoREVMRVRFX0NIQVJBQ1RFUl9DT01NQU5ELCBpc0JhY2t3YXJkID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHNlbGVjdGlvbi5kZWxldGVDaGFyYWN0ZXIoaXNCYWNrd2FyZCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChERUxFVEVfV09SRF9DT01NQU5ELCBpc0JhY2t3YXJkID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHNlbGVjdGlvbi5kZWxldGVXb3JkKGlzQmFja3dhcmQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoREVMRVRFX0xJTkVfQ09NTUFORCwgaXNCYWNrd2FyZCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzZWxlY3Rpb24uZGVsZXRlTGluZShpc0JhY2t3YXJkKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKENPTlRST0xMRURfVEVYVF9JTlNFUlRJT05fQ09NTUFORCwgZXZlbnRPclRleHQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBldmVudE9yVGV4dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHNlbGVjdGlvbi5pbnNlcnRUZXh0KGV2ZW50T3JUZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZGF0YVRyYW5zZmVyID0gZXZlbnRPclRleHQuZGF0YVRyYW5zZmVyO1xuICAgICAgaWYgKGRhdGFUcmFuc2ZlciAhPSBudWxsKSB7XG4gICAgICAgICRpbnNlcnREYXRhVHJhbnNmZXJGb3JQbGFpblRleHQoZGF0YVRyYW5zZmVyLCBzZWxlY3Rpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGV2ZW50T3JUZXh0LmRhdGE7XG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgc2VsZWN0aW9uLmluc2VydFRleHQoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChSRU1PVkVfVEVYVF9DT01NQU5ELCAoKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzZWxlY3Rpb24ucmVtb3ZlVGV4dCgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoSU5TRVJUX0xJTkVfQlJFQUtfQ09NTUFORCwgc2VsZWN0U3RhcnQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc2VsZWN0aW9uLmluc2VydExpbmVCcmVhayhzZWxlY3RTdGFydCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChJTlNFUlRfUEFSQUdSQVBIX0NPTU1BTkQsICgpID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHNlbGVjdGlvbi5pbnNlcnRMaW5lQnJlYWsoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEtFWV9BUlJPV19MRUZUX0NPTU1BTkQsIHBheWxvYWQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgZXZlbnQgPSBwYXlsb2FkO1xuICAgIGNvbnN0IGlzSG9sZGluZ1NoaWZ0ID0gZXZlbnQuc2hpZnRLZXk7XG4gICAgaWYgKCRzaG91bGRPdmVycmlkZURlZmF1bHRDaGFyYWN0ZXJTZWxlY3Rpb24oc2VsZWN0aW9uLCB0cnVlKSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICRtb3ZlQ2hhcmFjdGVyKHNlbGVjdGlvbiwgaXNIb2xkaW5nU2hpZnQsIHRydWUpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEtFWV9BUlJPV19SSUdIVF9DT01NQU5ELCBwYXlsb2FkID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGV2ZW50ID0gcGF5bG9hZDtcbiAgICBjb25zdCBpc0hvbGRpbmdTaGlmdCA9IGV2ZW50LnNoaWZ0S2V5O1xuICAgIGlmICgkc2hvdWxkT3ZlcnJpZGVEZWZhdWx0Q2hhcmFjdGVyU2VsZWN0aW9uKHNlbGVjdGlvbiwgZmFsc2UpKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgJG1vdmVDaGFyYWN0ZXIoc2VsZWN0aW9uLCBpc0hvbGRpbmdTaGlmdCwgZmFsc2UpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEtFWV9CQUNLU1BBQ0VfQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBFeGNlcHRpb24gaGFuZGxpbmcgZm9yIGlPUyBuYXRpdmUgYmVoYXZpb3IgaW5zdGVhZCBvZiBMZXhpY2FsJ3MgYmVoYXZpb3Igd2hlbiB1c2luZyBLb3JlYW4gb24gaU9TIGRldmljZXMuXG4gICAgLy8gbW9yZSBkZXRhaWxzIC0gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2xleGljYWwvaXNzdWVzLzU4NDFcbiAgICBpZiAoSVNfSU9TICYmIG5hdmlnYXRvci5sYW5ndWFnZSA9PT0gJ2tvLUtSJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHJldHVybiBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKERFTEVURV9DSEFSQUNURVJfQ09NTUFORCwgdHJ1ZSk7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChLRVlfREVMRVRFX0NPTU1BTkQsIGV2ZW50ID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgcmV0dXJuIGVkaXRvci5kaXNwYXRjaENvbW1hbmQoREVMRVRFX0NIQVJBQ1RFUl9DT01NQU5ELCBmYWxzZSk7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChLRVlfRU5URVJfQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGV2ZW50ICE9PSBudWxsKSB7XG4gICAgICAvLyBJZiB3ZSBoYXZlIGJlZm9yZWlucHV0LCB0aGVuIHdlIGNhbiBhdm9pZCBibG9ja2luZ1xuICAgICAgLy8gdGhlIGRlZmF1bHQgYmVoYXZpb3IuIFRoaXMgZW5zdXJlcyB0aGF0IHRoZSBpT1MgY2FuXG4gICAgICAvLyBpbnRlcmNlcHQgdGhhdCB3ZSdyZSBhY3R1YWxseSBpbnNlcnRpbmcgYSBwYXJhZ3JhcGgsXG4gICAgICAvLyBhbmQgYXV0b2NvbXBsZXRlLCBhdXRvY2FwaXRhbGl6ZSBldGMgd29yayBhcyBpbnRlbmRlZC5cbiAgICAgIC8vIFRoaXMgY2FuIGFsc28gY2F1c2UgYSBzdHJhbmdlIHBlcmZvcm1hbmNlIGlzc3VlIGluXG4gICAgICAvLyBTYWZhcmksIHdoZXJlIHRoZXJlIGlzIGEgbm90aWNlYWJsZSBwYXVzZSBkdWUgdG9cbiAgICAgIC8vIHByZXZlbnRpbmcgdGhlIGtleSBkb3duIG9mIGVudGVyLlxuICAgICAgaWYgKChJU19JT1MgfHwgSVNfU0FGQVJJIHx8IElTX0FQUExFX1dFQktJVCkgJiYgQ0FOX1VTRV9CRUZPUkVfSU5QVVQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgcmV0dXJuIGVkaXRvci5kaXNwYXRjaENvbW1hbmQoSU5TRVJUX0xJTkVfQlJFQUtfQ09NTUFORCwgZmFsc2UpO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoU0VMRUNUX0FMTF9DT01NQU5ELCAoKSA9PiB7XG4gICAgJHNlbGVjdEFsbCgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoQ09QWV9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBvbkNvcHlGb3JQbGFpblRleHQoZXZlbnQsIGVkaXRvcik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChDVVRfQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgb25DdXRGb3JQbGFpblRleHQoZXZlbnQsIGVkaXRvcik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChQQVNURV9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBvblBhc3RlRm9yUGxhaW5UZXh0KGV2ZW50LCBlZGl0b3IpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoRFJPUF9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFRPRE86IE1ha2UgZHJhZyBhbmQgZHJvcCB3b3JrIGF0IHNvbWUgcG9pbnQuXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKERSQUdTVEFSVF9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFRPRE86IE1ha2UgZHJhZyBhbmQgZHJvcCB3b3JrIGF0IHNvbWUgcG9pbnQuXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9FRElUT1IpKTtcbiAgcmV0dXJuIHJlbW92ZUxpc3RlbmVyO1xufVxuXG5leHBvcnQgeyByZWdpc3RlclBsYWluVGV4dCB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/plain-text/LexicalPlainText.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalComposer.dev.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalComposer.dev.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LexicalComposer: () => (/* binding */ LexicalComposer)\n/* harmony export */ });\n/* harmony import */ var _lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.dev.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// This workaround is no longer necessary in React 19,\n// but we currently support React >=17.x\n// https://github.com/facebook/react/pull/26395\nconst useLayoutEffectImpl = CAN_USE_DOM ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst HISTORY_MERGE_OPTIONS = {\n  tag: 'history-merge'\n};\nfunction LexicalComposer({\n  initialConfig,\n  children\n}) {\n  const composerContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    const {\n      theme,\n      namespace,\n      nodes,\n      onError,\n      editorState: initialEditorState,\n      html\n    } = initialConfig;\n    const context = (0,_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_2__.createLexicalComposerContext)(null, theme);\n    const editor = (0,lexical__WEBPACK_IMPORTED_MODULE_3__.createEditor)({\n      editable: initialConfig.editable,\n      html,\n      namespace,\n      nodes,\n      onError: error => onError(error, editor),\n      theme\n    });\n    initializeEditor(editor, initialEditorState);\n    return [editor, context];\n  },\n  // We only do this for init\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  []);\n  useLayoutEffectImpl(() => {\n    const isEditable = initialConfig.editable;\n    const [editor] = composerContext;\n    editor.setEditable(isEditable !== undefined ? isEditable : true);\n\n    // We only do this for init\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_2__.LexicalComposerContext.Provider, {\n    value: composerContext,\n    children: children\n  });\n}\nfunction initializeEditor(editor, initialEditorState) {\n  if (initialEditorState === null) {\n    return;\n  } else if (initialEditorState === undefined) {\n    editor.update(() => {\n      const root = (0,lexical__WEBPACK_IMPORTED_MODULE_3__.$getRoot)();\n      if (root.isEmpty()) {\n        const paragraph = (0,lexical__WEBPACK_IMPORTED_MODULE_3__.$createParagraphNode)();\n        root.append(paragraph);\n        const activeElement = CAN_USE_DOM ? document.activeElement : null;\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_3__.$getSelection)() !== null || activeElement !== null && activeElement === editor.getRootElement()) {\n          paragraph.select();\n        }\n      }\n    }, HISTORY_MERGE_OPTIONS);\n  } else if (initialEditorState !== null) {\n    switch (typeof initialEditorState) {\n      case 'string':\n        {\n          const parsedEditorState = editor.parseEditorState(initialEditorState);\n          editor.setEditorState(parsedEditorState, HISTORY_MERGE_OPTIONS);\n          break;\n        }\n      case 'object':\n        {\n          editor.setEditorState(initialEditorState, HISTORY_MERGE_OPTIONS);\n          break;\n        }\n      case 'function':\n        {\n          editor.update(() => {\n            const root = (0,lexical__WEBPACK_IMPORTED_MODULE_3__.$getRoot)();\n            if (root.isEmpty()) {\n              initialEditorState(editor);\n            }\n          }, HISTORY_MERGE_OPTIONS);\n          break;\n        }\n    }\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbXBvc2VyLmRldi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNkc7QUFDdkI7QUFDMUI7QUFDcEI7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsa0RBQWUsR0FBRyw0Q0FBUzs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELDBCQUEwQiw4Q0FBTztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixvQkFBb0IsbUdBQTRCO0FBQ2hELG1CQUFtQixxREFBWTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNILHNCQUFzQixzREFBRyxDQUFDLHlGQUFzQjtBQUNoRDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsbUJBQW1CLGlEQUFRO0FBQzNCO0FBQ0EsMEJBQTBCLDZEQUFvQjtBQUM5QztBQUNBO0FBQ0EsWUFBWSxzREFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixpREFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMkIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9sZWkvaG9tZS91bmRlcmcvdGhlYXRyZS95My9zZWdwL21pbGt1cC9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbXBvc2VyLmRldi5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5pbXBvcnQgeyBjcmVhdGVMZXhpY2FsQ29tcG9zZXJDb250ZXh0LCBMZXhpY2FsQ29tcG9zZXJDb250ZXh0IH0gZnJvbSAnQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbXBvc2VyQ29udGV4dCc7XG5pbXBvcnQgeyBjcmVhdGVFZGl0b3IsICRnZXRSb290LCAkY3JlYXRlUGFyYWdyYXBoTm9kZSwgJGdldFNlbGVjdGlvbiB9IGZyb20gJ2xleGljYWwnO1xuaW1wb3J0IHsgdXNlTGF5b3V0RWZmZWN0LCB1c2VFZmZlY3QsIHVzZU1lbW8gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBqc3ggfSBmcm9tICdyZWFjdC9qc3gtcnVudGltZSc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuY29uc3QgQ0FOX1VTRV9ET00gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT09ICd1bmRlZmluZWQnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cblxuLy8gVGhpcyB3b3JrYXJvdW5kIGlzIG5vIGxvbmdlciBuZWNlc3NhcnkgaW4gUmVhY3QgMTksXG4vLyBidXQgd2UgY3VycmVudGx5IHN1cHBvcnQgUmVhY3QgPj0xNy54XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yNjM5NVxuY29uc3QgdXNlTGF5b3V0RWZmZWN0SW1wbCA9IENBTl9VU0VfRE9NID8gdXNlTGF5b3V0RWZmZWN0IDogdXNlRWZmZWN0O1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IEhJU1RPUllfTUVSR0VfT1BUSU9OUyA9IHtcbiAgdGFnOiAnaGlzdG9yeS1tZXJnZSdcbn07XG5mdW5jdGlvbiBMZXhpY2FsQ29tcG9zZXIoe1xuICBpbml0aWFsQ29uZmlnLFxuICBjaGlsZHJlblxufSkge1xuICBjb25zdCBjb21wb3NlckNvbnRleHQgPSB1c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICB0aGVtZSxcbiAgICAgIG5hbWVzcGFjZSxcbiAgICAgIG5vZGVzLFxuICAgICAgb25FcnJvcixcbiAgICAgIGVkaXRvclN0YXRlOiBpbml0aWFsRWRpdG9yU3RhdGUsXG4gICAgICBodG1sXG4gICAgfSA9IGluaXRpYWxDb25maWc7XG4gICAgY29uc3QgY29udGV4dCA9IGNyZWF0ZUxleGljYWxDb21wb3NlckNvbnRleHQobnVsbCwgdGhlbWUpO1xuICAgIGNvbnN0IGVkaXRvciA9IGNyZWF0ZUVkaXRvcih7XG4gICAgICBlZGl0YWJsZTogaW5pdGlhbENvbmZpZy5lZGl0YWJsZSxcbiAgICAgIGh0bWwsXG4gICAgICBuYW1lc3BhY2UsXG4gICAgICBub2RlcyxcbiAgICAgIG9uRXJyb3I6IGVycm9yID0+IG9uRXJyb3IoZXJyb3IsIGVkaXRvciksXG4gICAgICB0aGVtZVxuICAgIH0pO1xuICAgIGluaXRpYWxpemVFZGl0b3IoZWRpdG9yLCBpbml0aWFsRWRpdG9yU3RhdGUpO1xuICAgIHJldHVybiBbZWRpdG9yLCBjb250ZXh0XTtcbiAgfSxcbiAgLy8gV2Ugb25seSBkbyB0aGlzIGZvciBpbml0XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgW10pO1xuICB1c2VMYXlvdXRFZmZlY3RJbXBsKCgpID0+IHtcbiAgICBjb25zdCBpc0VkaXRhYmxlID0gaW5pdGlhbENvbmZpZy5lZGl0YWJsZTtcbiAgICBjb25zdCBbZWRpdG9yXSA9IGNvbXBvc2VyQ29udGV4dDtcbiAgICBlZGl0b3Iuc2V0RWRpdGFibGUoaXNFZGl0YWJsZSAhPT0gdW5kZWZpbmVkID8gaXNFZGl0YWJsZSA6IHRydWUpO1xuXG4gICAgLy8gV2Ugb25seSBkbyB0aGlzIGZvciBpbml0XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICB9LCBbXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4KExleGljYWxDb21wb3NlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY29tcG9zZXJDb250ZXh0LFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICB9KTtcbn1cbmZ1bmN0aW9uIGluaXRpYWxpemVFZGl0b3IoZWRpdG9yLCBpbml0aWFsRWRpdG9yU3RhdGUpIHtcbiAgaWYgKGluaXRpYWxFZGl0b3JTdGF0ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfSBlbHNlIGlmIChpbml0aWFsRWRpdG9yU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgICAgY29uc3Qgcm9vdCA9ICRnZXRSb290KCk7XG4gICAgICBpZiAocm9vdC5pc0VtcHR5KCkpIHtcbiAgICAgICAgY29uc3QgcGFyYWdyYXBoID0gJGNyZWF0ZVBhcmFncmFwaE5vZGUoKTtcbiAgICAgICAgcm9vdC5hcHBlbmQocGFyYWdyYXBoKTtcbiAgICAgICAgY29uc3QgYWN0aXZlRWxlbWVudCA9IENBTl9VU0VfRE9NID8gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA6IG51bGw7XG4gICAgICAgIGlmICgkZ2V0U2VsZWN0aW9uKCkgIT09IG51bGwgfHwgYWN0aXZlRWxlbWVudCAhPT0gbnVsbCAmJiBhY3RpdmVFbGVtZW50ID09PSBlZGl0b3IuZ2V0Um9vdEVsZW1lbnQoKSkge1xuICAgICAgICAgIHBhcmFncmFwaC5zZWxlY3QoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIEhJU1RPUllfTUVSR0VfT1BUSU9OUyk7XG4gIH0gZWxzZSBpZiAoaW5pdGlhbEVkaXRvclN0YXRlICE9PSBudWxsKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgaW5pdGlhbEVkaXRvclN0YXRlKSB7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgcGFyc2VkRWRpdG9yU3RhdGUgPSBlZGl0b3IucGFyc2VFZGl0b3JTdGF0ZShpbml0aWFsRWRpdG9yU3RhdGUpO1xuICAgICAgICAgIGVkaXRvci5zZXRFZGl0b3JTdGF0ZShwYXJzZWRFZGl0b3JTdGF0ZSwgSElTVE9SWV9NRVJHRV9PUFRJT05TKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAge1xuICAgICAgICAgIGVkaXRvci5zZXRFZGl0b3JTdGF0ZShpbml0aWFsRWRpdG9yU3RhdGUsIEhJU1RPUllfTUVSR0VfT1BUSU9OUyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAge1xuICAgICAgICAgIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9ICRnZXRSb290KCk7XG4gICAgICAgICAgICBpZiAocm9vdC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgaW5pdGlhbEVkaXRvclN0YXRlKGVkaXRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgSElTVE9SWV9NRVJHRV9PUFRJT05TKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgeyBMZXhpY2FsQ29tcG9zZXIgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalComposer.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalComposerContext.dev.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalComposerContext.dev.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LexicalComposerContext: () => (/* binding */ LexicalComposerContext),\n/* harmony export */   createLexicalComposerContext: () => (/* binding */ createLexicalComposerContext),\n/* harmony export */   useLexicalComposerContext: () => (/* binding */ useLexicalComposerContext)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst LexicalComposerContext = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nfunction createLexicalComposerContext(parent, theme) {\n  let parentContext = null;\n  if (parent != null) {\n    parentContext = parent[1];\n  }\n  function getTheme() {\n    if (theme != null) {\n      return theme;\n    }\n    return parentContext != null ? parentContext.getTheme() : null;\n  }\n  return {\n    getTheme\n  };\n}\nfunction useLexicalComposerContext() {\n  const composerContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(LexicalComposerContext);\n  if (composerContext == null) {\n    {\n      throw Error(`LexicalComposerContext.useLexicalComposerContext: cannot find a LexicalComposerContext`);\n    }\n  }\n  return composerContext;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbXBvc2VyQ29udGV4dC5kZXYubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFa0Q7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRDQUE0QyxvREFBYTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpREFBVTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMkYiLCJzb3VyY2VzIjpbIi9Vc2Vycy9sZWkvaG9tZS91bmRlcmcvdGhlYXRyZS95My9zZWdwL21pbGt1cC9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbXBvc2VyQ29udGV4dC5kZXYubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCB9IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBMZXhpY2FsQ29tcG9zZXJDb250ZXh0ID0gLyojX19QVVJFX18qL2NyZWF0ZUNvbnRleHQobnVsbCk7XG5mdW5jdGlvbiBjcmVhdGVMZXhpY2FsQ29tcG9zZXJDb250ZXh0KHBhcmVudCwgdGhlbWUpIHtcbiAgbGV0IHBhcmVudENvbnRleHQgPSBudWxsO1xuICBpZiAocGFyZW50ICE9IG51bGwpIHtcbiAgICBwYXJlbnRDb250ZXh0ID0gcGFyZW50WzFdO1xuICB9XG4gIGZ1bmN0aW9uIGdldFRoZW1lKCkge1xuICAgIGlmICh0aGVtZSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhlbWU7XG4gICAgfVxuICAgIHJldHVybiBwYXJlbnRDb250ZXh0ICE9IG51bGwgPyBwYXJlbnRDb250ZXh0LmdldFRoZW1lKCkgOiBudWxsO1xuICB9XG4gIHJldHVybiB7XG4gICAgZ2V0VGhlbWVcbiAgfTtcbn1cbmZ1bmN0aW9uIHVzZUxleGljYWxDb21wb3NlckNvbnRleHQoKSB7XG4gIGNvbnN0IGNvbXBvc2VyQ29udGV4dCA9IHVzZUNvbnRleHQoTGV4aWNhbENvbXBvc2VyQ29udGV4dCk7XG4gIGlmIChjb21wb3NlckNvbnRleHQgPT0gbnVsbCkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGBMZXhpY2FsQ29tcG9zZXJDb250ZXh0LnVzZUxleGljYWxDb21wb3NlckNvbnRleHQ6IGNhbm5vdCBmaW5kIGEgTGV4aWNhbENvbXBvc2VyQ29udGV4dGApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY29tcG9zZXJDb250ZXh0O1xufVxuXG5leHBvcnQgeyBMZXhpY2FsQ29tcG9zZXJDb250ZXh0LCBjcmVhdGVMZXhpY2FsQ29tcG9zZXJDb250ZXh0LCB1c2VMZXhpY2FsQ29tcG9zZXJDb250ZXh0IH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalComposerContext.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalContentEditable.dev.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalContentEditable.dev.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContentEditable: () => (/* binding */ ContentEditable)\n/* harmony export */ });\n/* harmony import */ var _lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.dev.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var _lexical_text__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lexical/text */ \"(ssr)/./node_modules/@lexical/text/LexicalText.dev.mjs\");\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// This workaround is no longer necessary in React 19,\n// but we currently support React >=17.x\n// https://github.com/facebook/react/pull/26395\nconst useLayoutEffectImpl = CAN_USE_DOM ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n// Source: https://github.com/gregberge/react-merge-refs/blob/main/src/index.tsx\n\nfunction mergeRefs(...refs) {\n  return value => {\n    refs.forEach(ref => {\n      if (typeof ref === 'function') {\n        ref(value);\n      } else if (ref != null) {\n        ref.current = value;\n      }\n    });\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction ContentEditableElementImpl({\n  editor,\n  ariaActiveDescendant,\n  ariaAutoComplete,\n  ariaControls,\n  ariaDescribedBy,\n  ariaErrorMessage,\n  ariaExpanded,\n  ariaInvalid,\n  ariaLabel,\n  ariaLabelledBy,\n  ariaMultiline,\n  ariaOwns,\n  ariaRequired,\n  autoCapitalize,\n  className,\n  id,\n  role = 'textbox',\n  spellCheck = true,\n  style,\n  tabIndex,\n  'data-testid': testid,\n  ...rest\n}, ref) {\n  const [isEditable, setEditable] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(editor.isEditable());\n  const handleRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(rootElement => {\n    // defaultView is required for a root element.\n    // In multi-window setups, the defaultView may not exist at certain points.\n    if (rootElement && rootElement.ownerDocument && rootElement.ownerDocument.defaultView) {\n      editor.setRootElement(rootElement);\n    } else {\n      editor.setRootElement(null);\n    }\n  }, [editor]);\n  const mergedRefs = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => mergeRefs(ref, handleRef), [handleRef, ref]);\n  useLayoutEffectImpl(() => {\n    setEditable(editor.isEditable());\n    return editor.registerEditableListener(currentIsEditable => {\n      setEditable(currentIsEditable);\n    });\n  }, [editor]);\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", {\n    \"aria-activedescendant\": isEditable ? ariaActiveDescendant : undefined,\n    \"aria-autocomplete\": isEditable ? ariaAutoComplete : 'none',\n    \"aria-controls\": isEditable ? ariaControls : undefined,\n    \"aria-describedby\": ariaDescribedBy\n    // for compat, only override aria-errormessage if ariaErrorMessage is defined\n    ,\n    ...(ariaErrorMessage != null ? {\n      'aria-errormessage': ariaErrorMessage\n    } : {}),\n    \"aria-expanded\": isEditable && role === 'combobox' ? !!ariaExpanded : undefined\n    // for compat, only override aria-invalid if ariaInvalid is defined\n    ,\n    ...(ariaInvalid != null ? {\n      'aria-invalid': ariaInvalid\n    } : {}),\n    \"aria-label\": ariaLabel,\n    \"aria-labelledby\": ariaLabelledBy,\n    \"aria-multiline\": ariaMultiline,\n    \"aria-owns\": isEditable ? ariaOwns : undefined,\n    \"aria-readonly\": isEditable ? undefined : true,\n    \"aria-required\": ariaRequired,\n    autoCapitalize: autoCapitalize,\n    className: className,\n    contentEditable: isEditable,\n    \"data-testid\": testid,\n    id: id,\n    ref: mergedRefs,\n    role: isEditable ? role : undefined,\n    spellCheck: spellCheck,\n    style: style,\n    tabIndex: tabIndex,\n    ...rest\n  });\n}\nconst ContentEditableElement = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(ContentEditableElementImpl);\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction canShowPlaceholderFromCurrentEditorState(editor) {\n  const currentCanShowPlaceholder = editor.getEditorState().read((0,_lexical_text__WEBPACK_IMPORTED_MODULE_2__.$canShowPlaceholderCurry)(editor.isComposing()));\n  return currentCanShowPlaceholder;\n}\nfunction useCanShowPlaceholder(editor) {\n  const [canShowPlaceholder, setCanShowPlaceholder] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => canShowPlaceholderFromCurrentEditorState(editor));\n  useLayoutEffectImpl(() => {\n    function resetCanShowPlaceholder() {\n      const currentCanShowPlaceholder = canShowPlaceholderFromCurrentEditorState(editor);\n      setCanShowPlaceholder(currentCanShowPlaceholder);\n    }\n    resetCanShowPlaceholder();\n    return (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_3__.mergeRegister)(editor.registerUpdateListener(() => {\n      resetCanShowPlaceholder();\n    }), editor.registerEditableListener(() => {\n      resetCanShowPlaceholder();\n    }));\n  }, [editor]);\n  return canShowPlaceholder;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst ContentEditable = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(ContentEditableImpl);\nfunction ContentEditableImpl(props, ref) {\n  const {\n    placeholder,\n    ...rest\n  } = props;\n  const [editor] = (0,_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_4__.useLexicalComposerContext)();\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, {\n    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ContentEditableElement, {\n      editor: editor,\n      ...rest,\n      ref: ref\n    }), placeholder != null && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Placeholder, {\n      editor: editor,\n      content: placeholder\n    })]\n  });\n}\nfunction Placeholder({\n  content,\n  editor\n}) {\n  const showPlaceholder = useCanShowPlaceholder(editor);\n  const [isEditable, setEditable] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(editor.isEditable());\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n    setEditable(editor.isEditable());\n    return editor.registerEditableListener(currentIsEditable => {\n      setEditable(currentIsEditable);\n    });\n  }, [editor]);\n  if (!showPlaceholder) {\n    return null;\n  }\n  let placeholder = null;\n  if (typeof content === 'function') {\n    placeholder = content(isEditable);\n  } else if (content !== null) {\n    placeholder = content;\n  }\n  if (placeholder === null) {\n    return null;\n  }\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", {\n    \"aria-hidden\": true,\n    children: placeholder\n  });\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbnRlbnRFZGl0YWJsZS5kZXYubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVrRjtBQUNhO0FBQ3ZDO0FBQ0M7QUFDVjs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxrREFBZSxHQUFHLDRDQUFTOztBQUVyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsb0NBQW9DLCtDQUFRO0FBQzVDLG9CQUFvQixrREFBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNILHFCQUFxQiw4Q0FBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsc0JBQXNCLHNEQUFHO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQUk7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFJO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLDRDQUE0QyxpREFBVTs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpRUFBaUUsdUVBQXdCO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCwrQ0FBUTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDZEQUFhO0FBQ3hCO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQyxpREFBVTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixtQkFBbUIsZ0dBQXlCO0FBQzVDLHNCQUFzQix1REFBSSxDQUFDLHVEQUFRO0FBQ25DLDRCQUE0QixzREFBRztBQUMvQjtBQUNBO0FBQ0E7QUFDQSxLQUFLLHVDQUF1QyxzREFBRztBQUMvQztBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLG9DQUFvQywrQ0FBUTtBQUM1QyxFQUFFLHNEQUFlO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0RBQUc7QUFDekI7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFMkIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9sZWkvaG9tZS91bmRlcmcvdGhlYXRyZS95My9zZWdwL21pbGt1cC9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbnRlbnRFZGl0YWJsZS5kZXYubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuaW1wb3J0IHsgdXNlTGV4aWNhbENvbXBvc2VyQ29udGV4dCB9IGZyb20gJ0BsZXhpY2FsL3JlYWN0L0xleGljYWxDb21wb3NlckNvbnRleHQnO1xuaW1wb3J0IHsgdXNlTGF5b3V0RWZmZWN0LCB1c2VFZmZlY3QsIGZvcndhcmRSZWYsIHVzZVN0YXRlLCB1c2VDYWxsYmFjaywgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGpzeCwganN4cywgRnJhZ21lbnQgfSBmcm9tICdyZWFjdC9qc3gtcnVudGltZSc7XG5pbXBvcnQgeyAkY2FuU2hvd1BsYWNlaG9sZGVyQ3VycnkgfSBmcm9tICdAbGV4aWNhbC90ZXh0JztcbmltcG9ydCB7IG1lcmdlUmVnaXN0ZXIgfSBmcm9tICdAbGV4aWNhbC91dGlscyc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuY29uc3QgQ0FOX1VTRV9ET00gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT09ICd1bmRlZmluZWQnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cblxuLy8gVGhpcyB3b3JrYXJvdW5kIGlzIG5vIGxvbmdlciBuZWNlc3NhcnkgaW4gUmVhY3QgMTksXG4vLyBidXQgd2UgY3VycmVudGx5IHN1cHBvcnQgUmVhY3QgPj0xNy54XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yNjM5NVxuY29uc3QgdXNlTGF5b3V0RWZmZWN0SW1wbCA9IENBTl9VU0VfRE9NID8gdXNlTGF5b3V0RWZmZWN0IDogdXNlRWZmZWN0O1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG4vLyBTb3VyY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9ncmVnYmVyZ2UvcmVhY3QtbWVyZ2UtcmVmcy9ibG9iL21haW4vc3JjL2luZGV4LnRzeFxuXG5mdW5jdGlvbiBtZXJnZVJlZnMoLi4ucmVmcykge1xuICByZXR1cm4gdmFsdWUgPT4ge1xuICAgIHJlZnMuZm9yRWFjaChyZWYgPT4ge1xuICAgICAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmVmKHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAocmVmICE9IG51bGwpIHtcbiAgICAgICAgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiBDb250ZW50RWRpdGFibGVFbGVtZW50SW1wbCh7XG4gIGVkaXRvcixcbiAgYXJpYUFjdGl2ZURlc2NlbmRhbnQsXG4gIGFyaWFBdXRvQ29tcGxldGUsXG4gIGFyaWFDb250cm9scyxcbiAgYXJpYURlc2NyaWJlZEJ5LFxuICBhcmlhRXJyb3JNZXNzYWdlLFxuICBhcmlhRXhwYW5kZWQsXG4gIGFyaWFJbnZhbGlkLFxuICBhcmlhTGFiZWwsXG4gIGFyaWFMYWJlbGxlZEJ5LFxuICBhcmlhTXVsdGlsaW5lLFxuICBhcmlhT3ducyxcbiAgYXJpYVJlcXVpcmVkLFxuICBhdXRvQ2FwaXRhbGl6ZSxcbiAgY2xhc3NOYW1lLFxuICBpZCxcbiAgcm9sZSA9ICd0ZXh0Ym94JyxcbiAgc3BlbGxDaGVjayA9IHRydWUsXG4gIHN0eWxlLFxuICB0YWJJbmRleCxcbiAgJ2RhdGEtdGVzdGlkJzogdGVzdGlkLFxuICAuLi5yZXN0XG59LCByZWYpIHtcbiAgY29uc3QgW2lzRWRpdGFibGUsIHNldEVkaXRhYmxlXSA9IHVzZVN0YXRlKGVkaXRvci5pc0VkaXRhYmxlKCkpO1xuICBjb25zdCBoYW5kbGVSZWYgPSB1c2VDYWxsYmFjayhyb290RWxlbWVudCA9PiB7XG4gICAgLy8gZGVmYXVsdFZpZXcgaXMgcmVxdWlyZWQgZm9yIGEgcm9vdCBlbGVtZW50LlxuICAgIC8vIEluIG11bHRpLXdpbmRvdyBzZXR1cHMsIHRoZSBkZWZhdWx0VmlldyBtYXkgbm90IGV4aXN0IGF0IGNlcnRhaW4gcG9pbnRzLlxuICAgIGlmIChyb290RWxlbWVudCAmJiByb290RWxlbWVudC5vd25lckRvY3VtZW50ICYmIHJvb3RFbGVtZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcpIHtcbiAgICAgIGVkaXRvci5zZXRSb290RWxlbWVudChyb290RWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVkaXRvci5zZXRSb290RWxlbWVudChudWxsKTtcbiAgICB9XG4gIH0sIFtlZGl0b3JdKTtcbiAgY29uc3QgbWVyZ2VkUmVmcyA9IHVzZU1lbW8oKCkgPT4gbWVyZ2VSZWZzKHJlZiwgaGFuZGxlUmVmKSwgW2hhbmRsZVJlZiwgcmVmXSk7XG4gIHVzZUxheW91dEVmZmVjdEltcGwoKCkgPT4ge1xuICAgIHNldEVkaXRhYmxlKGVkaXRvci5pc0VkaXRhYmxlKCkpO1xuICAgIHJldHVybiBlZGl0b3IucmVnaXN0ZXJFZGl0YWJsZUxpc3RlbmVyKGN1cnJlbnRJc0VkaXRhYmxlID0+IHtcbiAgICAgIHNldEVkaXRhYmxlKGN1cnJlbnRJc0VkaXRhYmxlKTtcbiAgICB9KTtcbiAgfSwgW2VkaXRvcl0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL2pzeChcImRpdlwiLCB7XG4gICAgXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIjogaXNFZGl0YWJsZSA/IGFyaWFBY3RpdmVEZXNjZW5kYW50IDogdW5kZWZpbmVkLFxuICAgIFwiYXJpYS1hdXRvY29tcGxldGVcIjogaXNFZGl0YWJsZSA/IGFyaWFBdXRvQ29tcGxldGUgOiAnbm9uZScsXG4gICAgXCJhcmlhLWNvbnRyb2xzXCI6IGlzRWRpdGFibGUgPyBhcmlhQ29udHJvbHMgOiB1bmRlZmluZWQsXG4gICAgXCJhcmlhLWRlc2NyaWJlZGJ5XCI6IGFyaWFEZXNjcmliZWRCeVxuICAgIC8vIGZvciBjb21wYXQsIG9ubHkgb3ZlcnJpZGUgYXJpYS1lcnJvcm1lc3NhZ2UgaWYgYXJpYUVycm9yTWVzc2FnZSBpcyBkZWZpbmVkXG4gICAgLFxuICAgIC4uLihhcmlhRXJyb3JNZXNzYWdlICE9IG51bGwgPyB7XG4gICAgICAnYXJpYS1lcnJvcm1lc3NhZ2UnOiBhcmlhRXJyb3JNZXNzYWdlXG4gICAgfSA6IHt9KSxcbiAgICBcImFyaWEtZXhwYW5kZWRcIjogaXNFZGl0YWJsZSAmJiByb2xlID09PSAnY29tYm9ib3gnID8gISFhcmlhRXhwYW5kZWQgOiB1bmRlZmluZWRcbiAgICAvLyBmb3IgY29tcGF0LCBvbmx5IG92ZXJyaWRlIGFyaWEtaW52YWxpZCBpZiBhcmlhSW52YWxpZCBpcyBkZWZpbmVkXG4gICAgLFxuICAgIC4uLihhcmlhSW52YWxpZCAhPSBudWxsID8ge1xuICAgICAgJ2FyaWEtaW52YWxpZCc6IGFyaWFJbnZhbGlkXG4gICAgfSA6IHt9KSxcbiAgICBcImFyaWEtbGFiZWxcIjogYXJpYUxhYmVsLFxuICAgIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IGFyaWFMYWJlbGxlZEJ5LFxuICAgIFwiYXJpYS1tdWx0aWxpbmVcIjogYXJpYU11bHRpbGluZSxcbiAgICBcImFyaWEtb3duc1wiOiBpc0VkaXRhYmxlID8gYXJpYU93bnMgOiB1bmRlZmluZWQsXG4gICAgXCJhcmlhLXJlYWRvbmx5XCI6IGlzRWRpdGFibGUgPyB1bmRlZmluZWQgOiB0cnVlLFxuICAgIFwiYXJpYS1yZXF1aXJlZFwiOiBhcmlhUmVxdWlyZWQsXG4gICAgYXV0b0NhcGl0YWxpemU6IGF1dG9DYXBpdGFsaXplLFxuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgIGNvbnRlbnRFZGl0YWJsZTogaXNFZGl0YWJsZSxcbiAgICBcImRhdGEtdGVzdGlkXCI6IHRlc3RpZCxcbiAgICBpZDogaWQsXG4gICAgcmVmOiBtZXJnZWRSZWZzLFxuICAgIHJvbGU6IGlzRWRpdGFibGUgPyByb2xlIDogdW5kZWZpbmVkLFxuICAgIHNwZWxsQ2hlY2s6IHNwZWxsQ2hlY2ssXG4gICAgc3R5bGU6IHN0eWxlLFxuICAgIHRhYkluZGV4OiB0YWJJbmRleCxcbiAgICAuLi5yZXN0XG4gIH0pO1xufVxuY29uc3QgQ29udGVudEVkaXRhYmxlRWxlbWVudCA9IC8qI19fUFVSRV9fKi9mb3J3YXJkUmVmKENvbnRlbnRFZGl0YWJsZUVsZW1lbnRJbXBsKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiBjYW5TaG93UGxhY2Vob2xkZXJGcm9tQ3VycmVudEVkaXRvclN0YXRlKGVkaXRvcikge1xuICBjb25zdCBjdXJyZW50Q2FuU2hvd1BsYWNlaG9sZGVyID0gZWRpdG9yLmdldEVkaXRvclN0YXRlKCkucmVhZCgkY2FuU2hvd1BsYWNlaG9sZGVyQ3VycnkoZWRpdG9yLmlzQ29tcG9zaW5nKCkpKTtcbiAgcmV0dXJuIGN1cnJlbnRDYW5TaG93UGxhY2Vob2xkZXI7XG59XG5mdW5jdGlvbiB1c2VDYW5TaG93UGxhY2Vob2xkZXIoZWRpdG9yKSB7XG4gIGNvbnN0IFtjYW5TaG93UGxhY2Vob2xkZXIsIHNldENhblNob3dQbGFjZWhvbGRlcl0gPSB1c2VTdGF0ZSgoKSA9PiBjYW5TaG93UGxhY2Vob2xkZXJGcm9tQ3VycmVudEVkaXRvclN0YXRlKGVkaXRvcikpO1xuICB1c2VMYXlvdXRFZmZlY3RJbXBsKCgpID0+IHtcbiAgICBmdW5jdGlvbiByZXNldENhblNob3dQbGFjZWhvbGRlcigpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRDYW5TaG93UGxhY2Vob2xkZXIgPSBjYW5TaG93UGxhY2Vob2xkZXJGcm9tQ3VycmVudEVkaXRvclN0YXRlKGVkaXRvcik7XG4gICAgICBzZXRDYW5TaG93UGxhY2Vob2xkZXIoY3VycmVudENhblNob3dQbGFjZWhvbGRlcik7XG4gICAgfVxuICAgIHJlc2V0Q2FuU2hvd1BsYWNlaG9sZGVyKCk7XG4gICAgcmV0dXJuIG1lcmdlUmVnaXN0ZXIoZWRpdG9yLnJlZ2lzdGVyVXBkYXRlTGlzdGVuZXIoKCkgPT4ge1xuICAgICAgcmVzZXRDYW5TaG93UGxhY2Vob2xkZXIoKTtcbiAgICB9KSwgZWRpdG9yLnJlZ2lzdGVyRWRpdGFibGVMaXN0ZW5lcigoKSA9PiB7XG4gICAgICByZXNldENhblNob3dQbGFjZWhvbGRlcigpO1xuICAgIH0pKTtcbiAgfSwgW2VkaXRvcl0pO1xuICByZXR1cm4gY2FuU2hvd1BsYWNlaG9sZGVyO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IENvbnRlbnRFZGl0YWJsZSA9IC8qI19fUFVSRV9fKi9mb3J3YXJkUmVmKENvbnRlbnRFZGl0YWJsZUltcGwpO1xuZnVuY3Rpb24gQ29udGVudEVkaXRhYmxlSW1wbChwcm9wcywgcmVmKSB7XG4gIGNvbnN0IHtcbiAgICBwbGFjZWhvbGRlcixcbiAgICAuLi5yZXN0XG4gIH0gPSBwcm9wcztcbiAgY29uc3QgW2VkaXRvcl0gPSB1c2VMZXhpY2FsQ29tcG9zZXJDb250ZXh0KCk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4cyhGcmFnbWVudCwge1xuICAgIGNoaWxkcmVuOiBbLyojX19QVVJFX18qL2pzeChDb250ZW50RWRpdGFibGVFbGVtZW50LCB7XG4gICAgICBlZGl0b3I6IGVkaXRvcixcbiAgICAgIC4uLnJlc3QsXG4gICAgICByZWY6IHJlZlxuICAgIH0pLCBwbGFjZWhvbGRlciAhPSBudWxsICYmIC8qI19fUFVSRV9fKi9qc3goUGxhY2Vob2xkZXIsIHtcbiAgICAgIGVkaXRvcjogZWRpdG9yLFxuICAgICAgY29udGVudDogcGxhY2Vob2xkZXJcbiAgICB9KV1cbiAgfSk7XG59XG5mdW5jdGlvbiBQbGFjZWhvbGRlcih7XG4gIGNvbnRlbnQsXG4gIGVkaXRvclxufSkge1xuICBjb25zdCBzaG93UGxhY2Vob2xkZXIgPSB1c2VDYW5TaG93UGxhY2Vob2xkZXIoZWRpdG9yKTtcbiAgY29uc3QgW2lzRWRpdGFibGUsIHNldEVkaXRhYmxlXSA9IHVzZVN0YXRlKGVkaXRvci5pc0VkaXRhYmxlKCkpO1xuICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIHNldEVkaXRhYmxlKGVkaXRvci5pc0VkaXRhYmxlKCkpO1xuICAgIHJldHVybiBlZGl0b3IucmVnaXN0ZXJFZGl0YWJsZUxpc3RlbmVyKGN1cnJlbnRJc0VkaXRhYmxlID0+IHtcbiAgICAgIHNldEVkaXRhYmxlKGN1cnJlbnRJc0VkaXRhYmxlKTtcbiAgICB9KTtcbiAgfSwgW2VkaXRvcl0pO1xuICBpZiAoIXNob3dQbGFjZWhvbGRlcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGxldCBwbGFjZWhvbGRlciA9IG51bGw7XG4gIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHBsYWNlaG9sZGVyID0gY29udGVudChpc0VkaXRhYmxlKTtcbiAgfSBlbHNlIGlmIChjb250ZW50ICE9PSBudWxsKSB7XG4gICAgcGxhY2Vob2xkZXIgPSBjb250ZW50O1xuICB9XG4gIGlmIChwbGFjZWhvbGRlciA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4KFwiZGl2XCIsIHtcbiAgICBcImFyaWEtaGlkZGVuXCI6IHRydWUsXG4gICAgY2hpbGRyZW46IHBsYWNlaG9sZGVyXG4gIH0pO1xufVxuXG5leHBvcnQgeyBDb250ZW50RWRpdGFibGUgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalContentEditable.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalErrorBoundary.dev.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalErrorBoundary.dev.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LexicalErrorBoundary: () => (/* binding */ LexicalErrorBoundary),\n/* harmony export */   \"default\": () => (/* binding */ LexicalErrorBoundary)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  _setPrototypeOf(subClass, superClass);\n}\n\nvar changedArray = function changedArray(a, b) {\n  if (a === void 0) {\n    a = [];\n  }\n\n  if (b === void 0) {\n    b = [];\n  }\n\n  return a.length !== b.length || a.some(function (item, index) {\n    return !Object.is(item, b[index]);\n  });\n};\n\nvar initialState = {\n  error: null\n};\n\nvar ErrorBoundary = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(ErrorBoundary, _React$Component);\n\n  function ErrorBoundary() {\n    var _this;\n\n    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {\n      _args[_key] = arguments[_key];\n    }\n\n    _this = _React$Component.call.apply(_React$Component, [this].concat(_args)) || this;\n    _this.state = initialState;\n\n    _this.resetErrorBoundary = function () {\n      var _this$props;\n\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      _this.props.onReset == null ? void 0 : (_this$props = _this.props).onReset.apply(_this$props, args);\n\n      _this.reset();\n    };\n\n    return _this;\n  }\n\n  ErrorBoundary.getDerivedStateFromError = function getDerivedStateFromError(error) {\n    return {\n      error: error\n    };\n  };\n\n  var _proto = ErrorBoundary.prototype;\n\n  _proto.reset = function reset() {\n    this.setState(initialState);\n  };\n\n  _proto.componentDidCatch = function componentDidCatch(error, info) {\n    var _this$props$onError, _this$props2;\n\n    (_this$props$onError = (_this$props2 = this.props).onError) == null ? void 0 : _this$props$onError.call(_this$props2, error, info);\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {\n    var error = this.state.error;\n    var resetKeys = this.props.resetKeys; // There's an edge case where if the thing that triggered the error\n    // happens to *also* be in the resetKeys array, we'd end up resetting\n    // the error boundary immediately. This would likely trigger a second\n    // error to be thrown.\n    // So we make sure that we don't check the resetKeys on the first call\n    // of cDU after the error is set\n\n    if (error !== null && prevState.error !== null && changedArray(prevProps.resetKeys, resetKeys)) {\n      var _this$props$onResetKe, _this$props3;\n\n      (_this$props$onResetKe = (_this$props3 = this.props).onResetKeysChange) == null ? void 0 : _this$props$onResetKe.call(_this$props3, prevProps.resetKeys, resetKeys);\n      this.reset();\n    }\n  };\n\n  _proto.render = function render() {\n    var error = this.state.error;\n    var _this$props4 = this.props,\n        fallbackRender = _this$props4.fallbackRender,\n        FallbackComponent = _this$props4.FallbackComponent,\n        fallback = _this$props4.fallback;\n\n    if (error !== null) {\n      var _props = {\n        error: error,\n        resetErrorBoundary: this.resetErrorBoundary\n      };\n\n      if ( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(fallback)) {\n        return fallback;\n      } else if (typeof fallbackRender === 'function') {\n        return fallbackRender(_props);\n      } else if (FallbackComponent) {\n        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(FallbackComponent, _props);\n      } else {\n        throw new Error('react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop');\n      }\n    }\n\n    return this.props.children;\n  };\n\n  return ErrorBoundary;\n}(react__WEBPACK_IMPORTED_MODULE_0__.Component);\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction LexicalErrorBoundary({\n  children,\n  onError\n}) {\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ErrorBoundary, {\n    fallback: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", {\n      style: {\n        border: '1px solid #f00',\n        color: '#f00',\n        padding: '8px'\n      },\n      children: \"An error was thrown.\"\n    }),\n    onError: onError,\n    children: children\n  });\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbEVycm9yQm91bmRhcnkuZGV2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRStCO0FBQ1M7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5RUFBeUUsYUFBYTtBQUN0RjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw2RUFBNkUsZUFBZTtBQUM1RjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLGlEQUFvQjtBQUM1QztBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUiw0QkFBNEIsZ0RBQW1CO0FBQy9DLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUMsQ0FBQyw0Q0FBZTs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHNCQUFzQixzREFBRztBQUN6QiwyQkFBMkIsc0RBQUc7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFaUUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9sZWkvaG9tZS91bmRlcmcvdGhlYXRyZS95My9zZWdwL21pbGt1cC9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbEVycm9yQm91bmRhcnkuZGV2Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGpzeCB9IGZyb20gJ3JlYWN0L2pzeC1ydW50aW1lJztcblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG4gIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5cbnZhciBjaGFuZ2VkQXJyYXkgPSBmdW5jdGlvbiBjaGFuZ2VkQXJyYXkoYSwgYikge1xuICBpZiAoYSA9PT0gdm9pZCAwKSB7XG4gICAgYSA9IFtdO1xuICB9XG5cbiAgaWYgKGIgPT09IHZvaWQgMCkge1xuICAgIGIgPSBbXTtcbiAgfVxuXG4gIHJldHVybiBhLmxlbmd0aCAhPT0gYi5sZW5ndGggfHwgYS5zb21lKGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgIHJldHVybiAhT2JqZWN0LmlzKGl0ZW0sIGJbaW5kZXhdKTtcbiAgfSk7XG59O1xuXG52YXIgaW5pdGlhbFN0YXRlID0ge1xuICBlcnJvcjogbnVsbFxufTtcblxudmFyIEVycm9yQm91bmRhcnkgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoRXJyb3JCb3VuZGFyeSwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gRXJyb3JCb3VuZGFyeSgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBfYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBfdGhpcyA9IF9SZWFjdCRDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KF9hcmdzKSkgfHwgdGhpcztcbiAgICBfdGhpcy5zdGF0ZSA9IGluaXRpYWxTdGF0ZTtcblxuICAgIF90aGlzLnJlc2V0RXJyb3JCb3VuZGFyeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wcztcblxuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMucHJvcHMub25SZXNldCA9PSBudWxsID8gdm9pZCAwIDogKF90aGlzJHByb3BzID0gX3RoaXMucHJvcHMpLm9uUmVzZXQuYXBwbHkoX3RoaXMkcHJvcHMsIGFyZ3MpO1xuXG4gICAgICBfdGhpcy5yZXNldCgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBFcnJvckJvdW5kYXJ5LmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciA9IGZ1bmN0aW9uIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihlcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICBlcnJvcjogZXJyb3JcbiAgICB9O1xuICB9O1xuXG4gIHZhciBfcHJvdG8gPSBFcnJvckJvdW5kYXJ5LnByb3RvdHlwZTtcblxuICBfcHJvdG8ucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICB0aGlzLnNldFN0YXRlKGluaXRpYWxTdGF0ZSk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBvbmVudERpZENhdGNoID0gZnVuY3Rpb24gY29tcG9uZW50RGlkQ2F0Y2goZXJyb3IsIGluZm8pIHtcbiAgICB2YXIgX3RoaXMkcHJvcHMkb25FcnJvciwgX3RoaXMkcHJvcHMyO1xuXG4gICAgKF90aGlzJHByb3BzJG9uRXJyb3IgPSAoX3RoaXMkcHJvcHMyID0gdGhpcy5wcm9wcykub25FcnJvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJHByb3BzJG9uRXJyb3IuY2FsbChfdGhpcyRwcm9wczIsIGVycm9yLCBpbmZvKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlKSB7XG4gICAgdmFyIGVycm9yID0gdGhpcy5zdGF0ZS5lcnJvcjtcbiAgICB2YXIgcmVzZXRLZXlzID0gdGhpcy5wcm9wcy5yZXNldEtleXM7IC8vIFRoZXJlJ3MgYW4gZWRnZSBjYXNlIHdoZXJlIGlmIHRoZSB0aGluZyB0aGF0IHRyaWdnZXJlZCB0aGUgZXJyb3JcbiAgICAvLyBoYXBwZW5zIHRvICphbHNvKiBiZSBpbiB0aGUgcmVzZXRLZXlzIGFycmF5LCB3ZSdkIGVuZCB1cCByZXNldHRpbmdcbiAgICAvLyB0aGUgZXJyb3IgYm91bmRhcnkgaW1tZWRpYXRlbHkuIFRoaXMgd291bGQgbGlrZWx5IHRyaWdnZXIgYSBzZWNvbmRcbiAgICAvLyBlcnJvciB0byBiZSB0aHJvd24uXG4gICAgLy8gU28gd2UgbWFrZSBzdXJlIHRoYXQgd2UgZG9uJ3QgY2hlY2sgdGhlIHJlc2V0S2V5cyBvbiB0aGUgZmlyc3QgY2FsbFxuICAgIC8vIG9mIGNEVSBhZnRlciB0aGUgZXJyb3IgaXMgc2V0XG5cbiAgICBpZiAoZXJyb3IgIT09IG51bGwgJiYgcHJldlN0YXRlLmVycm9yICE9PSBudWxsICYmIGNoYW5nZWRBcnJheShwcmV2UHJvcHMucmVzZXRLZXlzLCByZXNldEtleXMpKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMkb25SZXNldEtlLCBfdGhpcyRwcm9wczM7XG5cbiAgICAgIChfdGhpcyRwcm9wcyRvblJlc2V0S2UgPSAoX3RoaXMkcHJvcHMzID0gdGhpcy5wcm9wcykub25SZXNldEtleXNDaGFuZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRwcm9wcyRvblJlc2V0S2UuY2FsbChfdGhpcyRwcm9wczMsIHByZXZQcm9wcy5yZXNldEtleXMsIHJlc2V0S2V5cyk7XG4gICAgICB0aGlzLnJlc2V0KCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIGVycm9yID0gdGhpcy5zdGF0ZS5lcnJvcjtcbiAgICB2YXIgX3RoaXMkcHJvcHM0ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgZmFsbGJhY2tSZW5kZXIgPSBfdGhpcyRwcm9wczQuZmFsbGJhY2tSZW5kZXIsXG4gICAgICAgIEZhbGxiYWNrQ29tcG9uZW50ID0gX3RoaXMkcHJvcHM0LkZhbGxiYWNrQ29tcG9uZW50LFxuICAgICAgICBmYWxsYmFjayA9IF90aGlzJHByb3BzNC5mYWxsYmFjaztcblxuICAgIGlmIChlcnJvciAhPT0gbnVsbCkge1xuICAgICAgdmFyIF9wcm9wcyA9IHtcbiAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICByZXNldEVycm9yQm91bmRhcnk6IHRoaXMucmVzZXRFcnJvckJvdW5kYXJ5XG4gICAgICB9O1xuXG4gICAgICBpZiAoIC8qI19fUFVSRV9fKi9SZWFjdC5pc1ZhbGlkRWxlbWVudChmYWxsYmFjaykpIHtcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZmFsbGJhY2tSZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrUmVuZGVyKF9wcm9wcyk7XG4gICAgICB9IGVsc2UgaWYgKEZhbGxiYWNrQ29tcG9uZW50KSB7XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGYWxsYmFja0NvbXBvbmVudCwgX3Byb3BzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmVhY3QtZXJyb3ItYm91bmRhcnkgcmVxdWlyZXMgZWl0aGVyIGEgZmFsbGJhY2ssIGZhbGxiYWNrUmVuZGVyLCBvciBGYWxsYmFja0NvbXBvbmVudCBwcm9wJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW47XG4gIH07XG5cbiAgcmV0dXJuIEVycm9yQm91bmRhcnk7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gTGV4aWNhbEVycm9yQm91bmRhcnkoe1xuICBjaGlsZHJlbixcbiAgb25FcnJvclxufSkge1xuICByZXR1cm4gLyojX19QVVJFX18qL2pzeChFcnJvckJvdW5kYXJ5LCB7XG4gICAgZmFsbGJhY2s6IC8qI19fUFVSRV9fKi9qc3goXCJkaXZcIiwge1xuICAgICAgc3R5bGU6IHtcbiAgICAgICAgYm9yZGVyOiAnMXB4IHNvbGlkICNmMDAnLFxuICAgICAgICBjb2xvcjogJyNmMDAnLFxuICAgICAgICBwYWRkaW5nOiAnOHB4J1xuICAgICAgfSxcbiAgICAgIGNoaWxkcmVuOiBcIkFuIGVycm9yIHdhcyB0aHJvd24uXCJcbiAgICB9KSxcbiAgICBvbkVycm9yOiBvbkVycm9yLFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICB9KTtcbn1cblxuZXhwb3J0IHsgTGV4aWNhbEVycm9yQm91bmRhcnksIExleGljYWxFcnJvckJvdW5kYXJ5IGFzIGRlZmF1bHQgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalErrorBoundary.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalHistoryPlugin.dev.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalHistoryPlugin.dev.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HistoryPlugin: () => (/* binding */ HistoryPlugin),\n/* harmony export */   createEmptyHistoryState: () => (/* reexport safe */ _lexical_history__WEBPACK_IMPORTED_MODULE_0__.createEmptyHistoryState)\n/* harmony export */ });\n/* harmony import */ var _lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.dev.mjs\");\n/* harmony import */ var _lexical_history__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lexical/history */ \"(ssr)/./node_modules/@lexical/history/LexicalHistory.dev.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction useHistory(editor, externalHistoryState, delay = 1000) {\n  const historyState = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => externalHistoryState || (0,_lexical_history__WEBPACK_IMPORTED_MODULE_0__.createEmptyHistoryState)(), [externalHistoryState]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    return (0,_lexical_history__WEBPACK_IMPORTED_MODULE_0__.registerHistory)(editor, historyState, delay);\n  }, [delay, editor, historyState]);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction HistoryPlugin({\n  delay,\n  externalHistoryState\n}) {\n  const [editor] = (0,_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_2__.useLexicalComposerContext)();\n  useHistory(editor, externalHistoryState, delay);\n  return null;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbEhpc3RvcnlQbHVnaW4uZGV2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVrRjtBQUNOO0FBQ2pCO0FBQ2hCOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1Qiw4Q0FBTywrQkFBK0IseUVBQXVCO0FBQ3BGLEVBQUUsZ0RBQVM7QUFDWCxXQUFXLGlFQUFlO0FBQzFCLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsbUJBQW1CLGdHQUF5QjtBQUM1QztBQUNBO0FBQ0E7O0FBRXlCIiwic291cmNlcyI6WyIvVXNlcnMvbGVpL2hvbWUvdW5kZXJnL3RoZWF0cmUveTMvc2VncC9taWxrdXAvbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L0xleGljYWxIaXN0b3J5UGx1Z2luLmRldi5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5pbXBvcnQgeyB1c2VMZXhpY2FsQ29tcG9zZXJDb250ZXh0IH0gZnJvbSAnQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbXBvc2VyQ29udGV4dCc7XG5pbXBvcnQgeyBjcmVhdGVFbXB0eUhpc3RvcnlTdGF0ZSwgcmVnaXN0ZXJIaXN0b3J5IH0gZnJvbSAnQGxleGljYWwvaGlzdG9yeSc7XG5leHBvcnQgeyBjcmVhdGVFbXB0eUhpc3RvcnlTdGF0ZSB9IGZyb20gJ0BsZXhpY2FsL2hpc3RvcnknO1xuaW1wb3J0IHsgdXNlTWVtbywgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uIHVzZUhpc3RvcnkoZWRpdG9yLCBleHRlcm5hbEhpc3RvcnlTdGF0ZSwgZGVsYXkgPSAxMDAwKSB7XG4gIGNvbnN0IGhpc3RvcnlTdGF0ZSA9IHVzZU1lbW8oKCkgPT4gZXh0ZXJuYWxIaXN0b3J5U3RhdGUgfHwgY3JlYXRlRW1wdHlIaXN0b3J5U3RhdGUoKSwgW2V4dGVybmFsSGlzdG9yeVN0YXRlXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuIHJlZ2lzdGVySGlzdG9yeShlZGl0b3IsIGhpc3RvcnlTdGF0ZSwgZGVsYXkpO1xuICB9LCBbZGVsYXksIGVkaXRvciwgaGlzdG9yeVN0YXRlXSk7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gSGlzdG9yeVBsdWdpbih7XG4gIGRlbGF5LFxuICBleHRlcm5hbEhpc3RvcnlTdGF0ZVxufSkge1xuICBjb25zdCBbZWRpdG9yXSA9IHVzZUxleGljYWxDb21wb3NlckNvbnRleHQoKTtcbiAgdXNlSGlzdG9yeShlZGl0b3IsIGV4dGVybmFsSGlzdG9yeVN0YXRlLCBkZWxheSk7XG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgeyBIaXN0b3J5UGx1Z2luIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalHistoryPlugin.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalPlainTextPlugin.dev.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalPlainTextPlugin.dev.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PlainTextPlugin: () => (/* binding */ PlainTextPlugin)\n/* harmony export */ });\n/* harmony import */ var _lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.dev.mjs\");\n/* harmony import */ var _lexical_react_useLexicalEditable__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @lexical/react/useLexicalEditable */ \"(ssr)/./node_modules/@lexical/react/useLexicalEditable.dev.mjs\");\n/* harmony import */ var _lexical_text__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lexical/text */ \"(ssr)/./node_modules/@lexical/text/LexicalText.dev.mjs\");\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var _lexical_dragon__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lexical/dragon */ \"(ssr)/./node_modules/@lexical/dragon/LexicalDragon.dev.mjs\");\n/* harmony import */ var _lexical_plain_text__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lexical/plain-text */ \"(ssr)/./node_modules/@lexical/plain-text/LexicalPlainText.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// This workaround is no longer necessary in React 19,\n// but we currently support React >=17.x\n// https://github.com/facebook/react/pull/26395\nconst useLayoutEffectImpl = CAN_USE_DOM ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction canShowPlaceholderFromCurrentEditorState(editor) {\n  const currentCanShowPlaceholder = editor.getEditorState().read((0,_lexical_text__WEBPACK_IMPORTED_MODULE_3__.$canShowPlaceholderCurry)(editor.isComposing()));\n  return currentCanShowPlaceholder;\n}\nfunction useCanShowPlaceholder(editor) {\n  const [canShowPlaceholder, setCanShowPlaceholder] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => canShowPlaceholderFromCurrentEditorState(editor));\n  useLayoutEffectImpl(() => {\n    function resetCanShowPlaceholder() {\n      const currentCanShowPlaceholder = canShowPlaceholderFromCurrentEditorState(editor);\n      setCanShowPlaceholder(currentCanShowPlaceholder);\n    }\n    resetCanShowPlaceholder();\n    return (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_4__.mergeRegister)(editor.registerUpdateListener(() => {\n      resetCanShowPlaceholder();\n    }), editor.registerEditableListener(() => {\n      resetCanShowPlaceholder();\n    }));\n  }, [editor]);\n  return canShowPlaceholder;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction useDecorators(editor, ErrorBoundary) {\n  const [decorators, setDecorators] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => editor.getDecorators());\n\n  // Subscribe to changes\n  useLayoutEffectImpl(() => {\n    return editor.registerDecoratorListener(nextDecorators => {\n      (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(() => {\n        setDecorators(nextDecorators);\n      });\n    });\n  }, [editor]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    // If the content editable mounts before the subscription is added, then\n    // nothing will be rendered on initial pass. We can get around that by\n    // ensuring that we set the value.\n    setDecorators(editor.getDecorators());\n  }, [editor]);\n\n  // Return decorators defined as React Portals\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    const decoratedPortals = [];\n    const decoratorKeys = Object.keys(decorators);\n    for (let i = 0; i < decoratorKeys.length; i++) {\n      const nodeKey = decoratorKeys[i];\n      const reactDecorator = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ErrorBoundary, {\n        onError: e => editor._onError(e),\n        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, {\n          fallback: null,\n          children: decorators[nodeKey]\n        })\n      });\n      const element = editor.getElementByKey(nodeKey);\n      if (element !== null) {\n        decoratedPortals.push(/*#__PURE__*/(0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(reactDecorator, element, nodeKey));\n      }\n    }\n    return decoratedPortals;\n  }, [ErrorBoundary, decorators, editor]);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction usePlainTextSetup(editor) {\n  useLayoutEffectImpl(() => {\n    return (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_4__.mergeRegister)((0,_lexical_plain_text__WEBPACK_IMPORTED_MODULE_5__.registerPlainText)(editor), (0,_lexical_dragon__WEBPACK_IMPORTED_MODULE_6__.registerDragonSupport)(editor));\n\n    // We only do this for init\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [editor]);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction PlainTextPlugin({\n  contentEditable,\n  // TODO Remove. This property is now part of ContentEditable\n  placeholder = null,\n  ErrorBoundary\n}) {\n  const [editor] = (0,_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_7__.useLexicalComposerContext)();\n  const decorators = useDecorators(editor, ErrorBoundary);\n  usePlainTextSetup(editor);\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, {\n    children: [contentEditable, /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Placeholder, {\n      content: placeholder\n    }), decorators]\n  });\n}\n\n// TODO Remove\nfunction Placeholder({\n  content\n}) {\n  const [editor] = (0,_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_7__.useLexicalComposerContext)();\n  const showPlaceholder = useCanShowPlaceholder(editor);\n  const editable = (0,_lexical_react_useLexicalEditable__WEBPACK_IMPORTED_MODULE_8__.useLexicalEditable)();\n  if (!showPlaceholder) {\n    return null;\n  }\n  if (typeof content === 'function') {\n    return content(editable);\n  } else {\n    return content;\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbFBsYWluVGV4dFBsdWdpbi5kZXYubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFa0Y7QUFDWDtBQUNkO0FBQ1Y7QUFDaUM7QUFDNUI7QUFDSTtBQUNBO0FBQ0E7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsa0RBQWUsR0FBRyw0Q0FBUzs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpRUFBaUUsdUVBQXdCO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCwrQ0FBUTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDZEQUFhO0FBQ3hCO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDLCtDQUFROztBQUU5QztBQUNBO0FBQ0E7QUFDQSxNQUFNLG9EQUFTO0FBQ2Y7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSCxFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsU0FBUyw4Q0FBTztBQUNoQjtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBLDBDQUEwQyxzREFBRztBQUM3QztBQUNBLCtCQUErQixzREFBRyxDQUFDLDJDQUFRO0FBQzNDO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSwyQ0FBMkMsdURBQVk7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLDZEQUFhLENBQUMsc0VBQWlCLFVBQVUsc0VBQXFCOztBQUV6RTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsbUJBQW1CLGdHQUF5QjtBQUM1QztBQUNBO0FBQ0Esc0JBQXNCLHVEQUFJLENBQUMsdURBQVE7QUFDbkMsNkNBQTZDLHNEQUFHO0FBQ2hEO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsbUJBQW1CLGdHQUF5QjtBQUM1QztBQUNBLG1CQUFtQixxRkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRTJCIiwic291cmNlcyI6WyIvVXNlcnMvbGVpL2hvbWUvdW5kZXJnL3RoZWF0cmUveTMvc2VncC9taWxrdXAvbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L0xleGljYWxQbGFpblRleHRQbHVnaW4uZGV2Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmltcG9ydCB7IHVzZUxleGljYWxDb21wb3NlckNvbnRleHQgfSBmcm9tICdAbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ29tcG9zZXJDb250ZXh0JztcbmltcG9ydCB7IHVzZUxleGljYWxFZGl0YWJsZSB9IGZyb20gJ0BsZXhpY2FsL3JlYWN0L3VzZUxleGljYWxFZGl0YWJsZSc7XG5pbXBvcnQgeyAkY2FuU2hvd1BsYWNlaG9sZGVyQ3VycnkgfSBmcm9tICdAbGV4aWNhbC90ZXh0JztcbmltcG9ydCB7IG1lcmdlUmVnaXN0ZXIgfSBmcm9tICdAbGV4aWNhbC91dGlscyc7XG5pbXBvcnQgeyB1c2VMYXlvdXRFZmZlY3QsIHVzZUVmZmVjdCwgdXNlU3RhdGUsIHVzZU1lbW8sIFN1c3BlbnNlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgZmx1c2hTeW5jLCBjcmVhdGVQb3J0YWwgfSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IHsganN4LCBqc3hzLCBGcmFnbWVudCB9IGZyb20gJ3JlYWN0L2pzeC1ydW50aW1lJztcbmltcG9ydCB7IHJlZ2lzdGVyRHJhZ29uU3VwcG9ydCB9IGZyb20gJ0BsZXhpY2FsL2RyYWdvbic7XG5pbXBvcnQgeyByZWdpc3RlclBsYWluVGV4dCB9IGZyb20gJ0BsZXhpY2FsL3BsYWluLXRleHQnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IENBTl9VU0VfRE9NID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5cbi8vIFRoaXMgd29ya2Fyb3VuZCBpcyBubyBsb25nZXIgbmVjZXNzYXJ5IGluIFJlYWN0IDE5LFxuLy8gYnV0IHdlIGN1cnJlbnRseSBzdXBwb3J0IFJlYWN0ID49MTcueFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjYzOTVcbmNvbnN0IHVzZUxheW91dEVmZmVjdEltcGwgPSBDQU5fVVNFX0RPTSA/IHVzZUxheW91dEVmZmVjdCA6IHVzZUVmZmVjdDtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiBjYW5TaG93UGxhY2Vob2xkZXJGcm9tQ3VycmVudEVkaXRvclN0YXRlKGVkaXRvcikge1xuICBjb25zdCBjdXJyZW50Q2FuU2hvd1BsYWNlaG9sZGVyID0gZWRpdG9yLmdldEVkaXRvclN0YXRlKCkucmVhZCgkY2FuU2hvd1BsYWNlaG9sZGVyQ3VycnkoZWRpdG9yLmlzQ29tcG9zaW5nKCkpKTtcbiAgcmV0dXJuIGN1cnJlbnRDYW5TaG93UGxhY2Vob2xkZXI7XG59XG5mdW5jdGlvbiB1c2VDYW5TaG93UGxhY2Vob2xkZXIoZWRpdG9yKSB7XG4gIGNvbnN0IFtjYW5TaG93UGxhY2Vob2xkZXIsIHNldENhblNob3dQbGFjZWhvbGRlcl0gPSB1c2VTdGF0ZSgoKSA9PiBjYW5TaG93UGxhY2Vob2xkZXJGcm9tQ3VycmVudEVkaXRvclN0YXRlKGVkaXRvcikpO1xuICB1c2VMYXlvdXRFZmZlY3RJbXBsKCgpID0+IHtcbiAgICBmdW5jdGlvbiByZXNldENhblNob3dQbGFjZWhvbGRlcigpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRDYW5TaG93UGxhY2Vob2xkZXIgPSBjYW5TaG93UGxhY2Vob2xkZXJGcm9tQ3VycmVudEVkaXRvclN0YXRlKGVkaXRvcik7XG4gICAgICBzZXRDYW5TaG93UGxhY2Vob2xkZXIoY3VycmVudENhblNob3dQbGFjZWhvbGRlcik7XG4gICAgfVxuICAgIHJlc2V0Q2FuU2hvd1BsYWNlaG9sZGVyKCk7XG4gICAgcmV0dXJuIG1lcmdlUmVnaXN0ZXIoZWRpdG9yLnJlZ2lzdGVyVXBkYXRlTGlzdGVuZXIoKCkgPT4ge1xuICAgICAgcmVzZXRDYW5TaG93UGxhY2Vob2xkZXIoKTtcbiAgICB9KSwgZWRpdG9yLnJlZ2lzdGVyRWRpdGFibGVMaXN0ZW5lcigoKSA9PiB7XG4gICAgICByZXNldENhblNob3dQbGFjZWhvbGRlcigpO1xuICAgIH0pKTtcbiAgfSwgW2VkaXRvcl0pO1xuICByZXR1cm4gY2FuU2hvd1BsYWNlaG9sZGVyO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uIHVzZURlY29yYXRvcnMoZWRpdG9yLCBFcnJvckJvdW5kYXJ5KSB7XG4gIGNvbnN0IFtkZWNvcmF0b3JzLCBzZXREZWNvcmF0b3JzXSA9IHVzZVN0YXRlKCgpID0+IGVkaXRvci5nZXREZWNvcmF0b3JzKCkpO1xuXG4gIC8vIFN1YnNjcmliZSB0byBjaGFuZ2VzXG4gIHVzZUxheW91dEVmZmVjdEltcGwoKCkgPT4ge1xuICAgIHJldHVybiBlZGl0b3IucmVnaXN0ZXJEZWNvcmF0b3JMaXN0ZW5lcihuZXh0RGVjb3JhdG9ycyA9PiB7XG4gICAgICBmbHVzaFN5bmMoKCkgPT4ge1xuICAgICAgICBzZXREZWNvcmF0b3JzKG5leHREZWNvcmF0b3JzKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LCBbZWRpdG9yXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gSWYgdGhlIGNvbnRlbnQgZWRpdGFibGUgbW91bnRzIGJlZm9yZSB0aGUgc3Vic2NyaXB0aW9uIGlzIGFkZGVkLCB0aGVuXG4gICAgLy8gbm90aGluZyB3aWxsIGJlIHJlbmRlcmVkIG9uIGluaXRpYWwgcGFzcy4gV2UgY2FuIGdldCBhcm91bmQgdGhhdCBieVxuICAgIC8vIGVuc3VyaW5nIHRoYXQgd2Ugc2V0IHRoZSB2YWx1ZS5cbiAgICBzZXREZWNvcmF0b3JzKGVkaXRvci5nZXREZWNvcmF0b3JzKCkpO1xuICB9LCBbZWRpdG9yXSk7XG5cbiAgLy8gUmV0dXJuIGRlY29yYXRvcnMgZGVmaW5lZCBhcyBSZWFjdCBQb3J0YWxzXG4gIHJldHVybiB1c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCBkZWNvcmF0ZWRQb3J0YWxzID0gW107XG4gICAgY29uc3QgZGVjb3JhdG9yS2V5cyA9IE9iamVjdC5rZXlzKGRlY29yYXRvcnMpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVjb3JhdG9yS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgbm9kZUtleSA9IGRlY29yYXRvcktleXNbaV07XG4gICAgICBjb25zdCByZWFjdERlY29yYXRvciA9IC8qI19fUFVSRV9fKi9qc3goRXJyb3JCb3VuZGFyeSwge1xuICAgICAgICBvbkVycm9yOiBlID0+IGVkaXRvci5fb25FcnJvcihlKSxcbiAgICAgICAgY2hpbGRyZW46IC8qI19fUFVSRV9fKi9qc3goU3VzcGVuc2UsIHtcbiAgICAgICAgICBmYWxsYmFjazogbnVsbCxcbiAgICAgICAgICBjaGlsZHJlbjogZGVjb3JhdG9yc1tub2RlS2V5XVxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICBjb25zdCBlbGVtZW50ID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleShub2RlS2V5KTtcbiAgICAgIGlmIChlbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICAgIGRlY29yYXRlZFBvcnRhbHMucHVzaCgvKiNfX1BVUkVfXyovY3JlYXRlUG9ydGFsKHJlYWN0RGVjb3JhdG9yLCBlbGVtZW50LCBub2RlS2V5KSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZWNvcmF0ZWRQb3J0YWxzO1xuICB9LCBbRXJyb3JCb3VuZGFyeSwgZGVjb3JhdG9ycywgZWRpdG9yXSk7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gdXNlUGxhaW5UZXh0U2V0dXAoZWRpdG9yKSB7XG4gIHVzZUxheW91dEVmZmVjdEltcGwoKCkgPT4ge1xuICAgIHJldHVybiBtZXJnZVJlZ2lzdGVyKHJlZ2lzdGVyUGxhaW5UZXh0KGVkaXRvciksIHJlZ2lzdGVyRHJhZ29uU3VwcG9ydChlZGl0b3IpKTtcblxuICAgIC8vIFdlIG9ubHkgZG8gdGhpcyBmb3IgaW5pdFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgW2VkaXRvcl0pO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uIFBsYWluVGV4dFBsdWdpbih7XG4gIGNvbnRlbnRFZGl0YWJsZSxcbiAgLy8gVE9ETyBSZW1vdmUuIFRoaXMgcHJvcGVydHkgaXMgbm93IHBhcnQgb2YgQ29udGVudEVkaXRhYmxlXG4gIHBsYWNlaG9sZGVyID0gbnVsbCxcbiAgRXJyb3JCb3VuZGFyeVxufSkge1xuICBjb25zdCBbZWRpdG9yXSA9IHVzZUxleGljYWxDb21wb3NlckNvbnRleHQoKTtcbiAgY29uc3QgZGVjb3JhdG9ycyA9IHVzZURlY29yYXRvcnMoZWRpdG9yLCBFcnJvckJvdW5kYXJ5KTtcbiAgdXNlUGxhaW5UZXh0U2V0dXAoZWRpdG9yKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3hzKEZyYWdtZW50LCB7XG4gICAgY2hpbGRyZW46IFtjb250ZW50RWRpdGFibGUsIC8qI19fUFVSRV9fKi9qc3goUGxhY2Vob2xkZXIsIHtcbiAgICAgIGNvbnRlbnQ6IHBsYWNlaG9sZGVyXG4gICAgfSksIGRlY29yYXRvcnNdXG4gIH0pO1xufVxuXG4vLyBUT0RPIFJlbW92ZVxuZnVuY3Rpb24gUGxhY2Vob2xkZXIoe1xuICBjb250ZW50XG59KSB7XG4gIGNvbnN0IFtlZGl0b3JdID0gdXNlTGV4aWNhbENvbXBvc2VyQ29udGV4dCgpO1xuICBjb25zdCBzaG93UGxhY2Vob2xkZXIgPSB1c2VDYW5TaG93UGxhY2Vob2xkZXIoZWRpdG9yKTtcbiAgY29uc3QgZWRpdGFibGUgPSB1c2VMZXhpY2FsRWRpdGFibGUoKTtcbiAgaWYgKCFzaG93UGxhY2Vob2xkZXIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gY29udGVudChlZGl0YWJsZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cbn1cblxuZXhwb3J0IHsgUGxhaW5UZXh0UGx1Z2luIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalPlainTextPlugin.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/useLexicalEditable.dev.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@lexical/react/useLexicalEditable.dev.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ useLexicalEditable),\n/* harmony export */   useLexicalEditable: () => (/* binding */ useLexicalEditable)\n/* harmony export */ });\n/* harmony import */ var _lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.dev.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// This workaround is no longer necessary in React 19,\n// but we currently support React >=17.x\n// https://github.com/facebook/react/pull/26395\nconst useLayoutEffectImpl = CAN_USE_DOM ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Shortcut to Lexical subscriptions when values are used for render.\n * @param subscription - The function to create the {@link LexicalSubscription}. This function's identity must be stable (e.g. defined at module scope or with useCallback).\n */\nfunction useLexicalSubscription(subscription) {\n  const [editor] = (0,_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_1__.useLexicalComposerContext)();\n  const initializedSubscription = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => subscription(editor), [editor, subscription]);\n  const [value, setValue] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => initializedSubscription.initialValueFn());\n  const valueRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(value);\n  useLayoutEffectImpl(() => {\n    const {\n      initialValueFn,\n      subscribe\n    } = initializedSubscription;\n    const currentValue = initialValueFn();\n    if (valueRef.current !== currentValue) {\n      valueRef.current = currentValue;\n      setValue(currentValue);\n    }\n    return subscribe(newValue => {\n      valueRef.current = newValue;\n      setValue(newValue);\n    });\n  }, [initializedSubscription, subscription]);\n  return value;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction subscription(editor) {\n  return {\n    initialValueFn: () => editor.isEditable(),\n    subscribe: callback => {\n      return editor.registerEditableListener(callback);\n    }\n  };\n}\n\n/**\n * Get the current value for {@link LexicalEditor.isEditable}\n * using {@link useLexicalSubscription}.\n * You should prefer this over manually observing the value with\n * {@link LexicalEditor.registerEditableListener},\n * which is a bit tricky to do correctly, particularly when using\n * React StrictMode (the default for development) or concurrency.\n */\nfunction useLexicalEditable() {\n  return useLexicalSubscription(subscription);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvdXNlTGV4aWNhbEVkaXRhYmxlLmRldi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVrRjtBQUNKOztBQUU5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGtEQUFlLEdBQUcsNENBQVM7O0FBRXJFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxREFBcUQsMEJBQTBCO0FBQy9FO0FBQ0E7QUFDQSxtQkFBbUIsZ0dBQXlCO0FBQzVDLGtDQUFrQyw4Q0FBTztBQUN6Qyw0QkFBNEIsK0NBQVE7QUFDcEMsbUJBQW1CLDZDQUFNO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QixVQUFVLDZCQUE2QjtBQUN2QztBQUNBLElBQUksNkNBQTZDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNkQiLCJzb3VyY2VzIjpbIi9Vc2Vycy9sZWkvaG9tZS91bmRlcmcvdGhlYXRyZS95My9zZWdwL21pbGt1cC9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvdXNlTGV4aWNhbEVkaXRhYmxlLmRldi5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5pbXBvcnQgeyB1c2VMZXhpY2FsQ29tcG9zZXJDb250ZXh0IH0gZnJvbSAnQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbXBvc2VyQ29udGV4dCc7XG5pbXBvcnQgeyB1c2VMYXlvdXRFZmZlY3QsIHVzZUVmZmVjdCwgdXNlTWVtbywgdXNlU3RhdGUsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBDQU5fVVNFX0RPTSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuXG4vLyBUaGlzIHdvcmthcm91bmQgaXMgbm8gbG9uZ2VyIG5lY2Vzc2FyeSBpbiBSZWFjdCAxOSxcbi8vIGJ1dCB3ZSBjdXJyZW50bHkgc3VwcG9ydCBSZWFjdCA+PTE3Lnhcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzI2Mzk1XG5jb25zdCB1c2VMYXlvdXRFZmZlY3RJbXBsID0gQ0FOX1VTRV9ET00gPyB1c2VMYXlvdXRFZmZlY3QgOiB1c2VFZmZlY3Q7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLyoqXG4gKiBTaG9ydGN1dCB0byBMZXhpY2FsIHN1YnNjcmlwdGlvbnMgd2hlbiB2YWx1ZXMgYXJlIHVzZWQgZm9yIHJlbmRlci5cbiAqIEBwYXJhbSBzdWJzY3JpcHRpb24gLSBUaGUgZnVuY3Rpb24gdG8gY3JlYXRlIHRoZSB7QGxpbmsgTGV4aWNhbFN1YnNjcmlwdGlvbn0uIFRoaXMgZnVuY3Rpb24ncyBpZGVudGl0eSBtdXN0IGJlIHN0YWJsZSAoZS5nLiBkZWZpbmVkIGF0IG1vZHVsZSBzY29wZSBvciB3aXRoIHVzZUNhbGxiYWNrKS5cbiAqL1xuZnVuY3Rpb24gdXNlTGV4aWNhbFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pIHtcbiAgY29uc3QgW2VkaXRvcl0gPSB1c2VMZXhpY2FsQ29tcG9zZXJDb250ZXh0KCk7XG4gIGNvbnN0IGluaXRpYWxpemVkU3Vic2NyaXB0aW9uID0gdXNlTWVtbygoKSA9PiBzdWJzY3JpcHRpb24oZWRpdG9yKSwgW2VkaXRvciwgc3Vic2NyaXB0aW9uXSk7XG4gIGNvbnN0IFt2YWx1ZSwgc2V0VmFsdWVdID0gdXNlU3RhdGUoKCkgPT4gaW5pdGlhbGl6ZWRTdWJzY3JpcHRpb24uaW5pdGlhbFZhbHVlRm4oKSk7XG4gIGNvbnN0IHZhbHVlUmVmID0gdXNlUmVmKHZhbHVlKTtcbiAgdXNlTGF5b3V0RWZmZWN0SW1wbCgoKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgaW5pdGlhbFZhbHVlRm4sXG4gICAgICBzdWJzY3JpYmVcbiAgICB9ID0gaW5pdGlhbGl6ZWRTdWJzY3JpcHRpb247XG4gICAgY29uc3QgY3VycmVudFZhbHVlID0gaW5pdGlhbFZhbHVlRm4oKTtcbiAgICBpZiAodmFsdWVSZWYuY3VycmVudCAhPT0gY3VycmVudFZhbHVlKSB7XG4gICAgICB2YWx1ZVJlZi5jdXJyZW50ID0gY3VycmVudFZhbHVlO1xuICAgICAgc2V0VmFsdWUoY3VycmVudFZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1YnNjcmliZShuZXdWYWx1ZSA9PiB7XG4gICAgICB2YWx1ZVJlZi5jdXJyZW50ID0gbmV3VmFsdWU7XG4gICAgICBzZXRWYWx1ZShuZXdWYWx1ZSk7XG4gICAgfSk7XG4gIH0sIFtpbml0aWFsaXplZFN1YnNjcmlwdGlvbiwgc3Vic2NyaXB0aW9uXSk7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiBzdWJzY3JpcHRpb24oZWRpdG9yKSB7XG4gIHJldHVybiB7XG4gICAgaW5pdGlhbFZhbHVlRm46ICgpID0+IGVkaXRvci5pc0VkaXRhYmxlKCksXG4gICAgc3Vic2NyaWJlOiBjYWxsYmFjayA9PiB7XG4gICAgICByZXR1cm4gZWRpdG9yLnJlZ2lzdGVyRWRpdGFibGVMaXN0ZW5lcihjYWxsYmFjayk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCB2YWx1ZSBmb3Ige0BsaW5rIExleGljYWxFZGl0b3IuaXNFZGl0YWJsZX1cbiAqIHVzaW5nIHtAbGluayB1c2VMZXhpY2FsU3Vic2NyaXB0aW9ufS5cbiAqIFlvdSBzaG91bGQgcHJlZmVyIHRoaXMgb3ZlciBtYW51YWxseSBvYnNlcnZpbmcgdGhlIHZhbHVlIHdpdGhcbiAqIHtAbGluayBMZXhpY2FsRWRpdG9yLnJlZ2lzdGVyRWRpdGFibGVMaXN0ZW5lcn0sXG4gKiB3aGljaCBpcyBhIGJpdCB0cmlja3kgdG8gZG8gY29ycmVjdGx5LCBwYXJ0aWN1bGFybHkgd2hlbiB1c2luZ1xuICogUmVhY3QgU3RyaWN0TW9kZSAodGhlIGRlZmF1bHQgZm9yIGRldmVsb3BtZW50KSBvciBjb25jdXJyZW5jeS5cbiAqL1xuZnVuY3Rpb24gdXNlTGV4aWNhbEVkaXRhYmxlKCkge1xuICByZXR1cm4gdXNlTGV4aWNhbFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xufVxuXG5leHBvcnQgeyB1c2VMZXhpY2FsRWRpdGFibGUgYXMgZGVmYXVsdCwgdXNlTGV4aWNhbEVkaXRhYmxlIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/useLexicalEditable.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/selection/LexicalSelection.dev.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@lexical/selection/LexicalSelection.dev.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $addNodeStyle: () => (/* binding */ $addNodeStyle),\n/* harmony export */   $cloneWithProperties: () => (/* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.$cloneWithProperties),\n/* harmony export */   $forEachSelectedTextNode: () => (/* binding */ $forEachSelectedTextNode),\n/* harmony export */   $getSelectionStyleValueForProperty: () => (/* binding */ $getSelectionStyleValueForProperty),\n/* harmony export */   $isAtNodeEnd: () => (/* binding */ $isAtNodeEnd),\n/* harmony export */   $isParentElementRTL: () => (/* binding */ $isParentElementRTL),\n/* harmony export */   $moveCaretSelection: () => (/* binding */ $moveCaretSelection),\n/* harmony export */   $moveCharacter: () => (/* binding */ $moveCharacter),\n/* harmony export */   $patchStyleText: () => (/* binding */ $patchStyleText),\n/* harmony export */   $selectAll: () => (/* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.$selectAll),\n/* harmony export */   $setBlocksType: () => (/* binding */ $setBlocksType),\n/* harmony export */   $shouldOverrideDefaultCharacterSelection: () => (/* binding */ $shouldOverrideDefaultCharacterSelection),\n/* harmony export */   $sliceSelectedTextNodeContent: () => (/* binding */ $sliceSelectedTextNodeContent),\n/* harmony export */   $trimTextContentFromAnchor: () => (/* binding */ $trimTextContentFromAnchor),\n/* harmony export */   $wrapNodes: () => (/* binding */ $wrapNodes),\n/* harmony export */   createDOMRange: () => (/* binding */ createDOMRange),\n/* harmony export */   createRectsFromDOMRange: () => (/* binding */ createRectsFromDOMRange),\n/* harmony export */   getCSSFromStyleObject: () => (/* binding */ getCSSFromStyleObject),\n/* harmony export */   getStyleObjectFromCSS: () => (/* binding */ getStyleObjectFromCSS),\n/* harmony export */   trimTextContentFromAnchor: () => (/* binding */ trimTextContentFromAnchor)\n/* harmony export */ });\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CSS_TO_STYLES = new Map();\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction getDOMTextNode(element) {\n  let node = element;\n  while (node != null) {\n    if (node.nodeType === Node.TEXT_NODE) {\n      return node;\n    }\n    node = node.firstChild;\n  }\n  return null;\n}\nfunction getDOMIndexWithinParent(node) {\n  const parent = node.parentNode;\n  if (parent == null) {\n    throw new Error('Should never happen');\n  }\n  return [parent, Array.from(parent.childNodes).indexOf(node)];\n}\n\n/**\n * Creates a selection range for the DOM.\n * @param editor - The lexical editor.\n * @param anchorNode - The anchor node of a selection.\n * @param _anchorOffset - The amount of space offset from the anchor to the focus.\n * @param focusNode - The current focus.\n * @param _focusOffset - The amount of space offset from the focus to the anchor.\n * @returns The range of selection for the DOM that was created.\n */\nfunction createDOMRange(editor, anchorNode, _anchorOffset, focusNode, _focusOffset) {\n  const anchorKey = anchorNode.getKey();\n  const focusKey = focusNode.getKey();\n  const range = document.createRange();\n  let anchorDOM = editor.getElementByKey(anchorKey);\n  let focusDOM = editor.getElementByKey(focusKey);\n  let anchorOffset = _anchorOffset;\n  let focusOffset = _focusOffset;\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(anchorNode)) {\n    anchorDOM = getDOMTextNode(anchorDOM);\n  }\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(focusNode)) {\n    focusDOM = getDOMTextNode(focusDOM);\n  }\n  if (anchorNode === undefined || focusNode === undefined || anchorDOM === null || focusDOM === null) {\n    return null;\n  }\n  if (anchorDOM.nodeName === 'BR') {\n    [anchorDOM, anchorOffset] = getDOMIndexWithinParent(anchorDOM);\n  }\n  if (focusDOM.nodeName === 'BR') {\n    [focusDOM, focusOffset] = getDOMIndexWithinParent(focusDOM);\n  }\n  const firstChild = anchorDOM.firstChild;\n  if (anchorDOM === focusDOM && firstChild != null && firstChild.nodeName === 'BR' && anchorOffset === 0 && focusOffset === 0) {\n    focusOffset = 1;\n  }\n  try {\n    range.setStart(anchorDOM, anchorOffset);\n    range.setEnd(focusDOM, focusOffset);\n  } catch (e) {\n    return null;\n  }\n  if (range.collapsed && (anchorOffset !== focusOffset || anchorKey !== focusKey)) {\n    // Range is backwards, we need to reverse it\n    range.setStart(focusDOM, focusOffset);\n    range.setEnd(anchorDOM, anchorOffset);\n  }\n  return range;\n}\n\n/**\n * Creates DOMRects, generally used to help the editor find a specific location on the screen.\n * @param editor - The lexical editor\n * @param range - A fragment of a document that can contain nodes and parts of text nodes.\n * @returns The selectionRects as an array.\n */\nfunction createRectsFromDOMRange(editor, range) {\n  const rootElement = editor.getRootElement();\n  if (rootElement === null) {\n    return [];\n  }\n  const rootRect = rootElement.getBoundingClientRect();\n  const computedStyle = getComputedStyle(rootElement);\n  const rootPadding = parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);\n  const selectionRects = Array.from(range.getClientRects());\n  let selectionRectsLength = selectionRects.length;\n  //sort rects from top left to bottom right.\n  selectionRects.sort((a, b) => {\n    const top = a.top - b.top;\n    // Some rects match position closely, but not perfectly,\n    // so we give a 3px tolerance.\n    if (Math.abs(top) <= 3) {\n      return a.left - b.left;\n    }\n    return top;\n  });\n  let prevRect;\n  for (let i = 0; i < selectionRectsLength; i++) {\n    const selectionRect = selectionRects[i];\n    // Exclude rects that overlap preceding Rects in the sorted list.\n    const isOverlappingRect = prevRect && prevRect.top <= selectionRect.top && prevRect.top + prevRect.height > selectionRect.top && prevRect.left + prevRect.width > selectionRect.left;\n    // Exclude selections that span the entire element\n    const selectionSpansElement = selectionRect.width + rootPadding === rootRect.width;\n    if (isOverlappingRect || selectionSpansElement) {\n      selectionRects.splice(i--, 1);\n      selectionRectsLength--;\n      continue;\n    }\n    prevRect = selectionRect;\n  }\n  return selectionRects;\n}\n\n/**\n * Creates an object containing all the styles and their values provided in the CSS string.\n * @param css - The CSS string of styles and their values.\n * @returns The styleObject containing all the styles and their values.\n */\nfunction getStyleObjectFromRawCSS(css) {\n  const styleObject = {};\n  if (!css) {\n    return styleObject;\n  }\n  const styles = css.split(';');\n  for (const style of styles) {\n    if (style !== '') {\n      const [key, value] = style.split(/:([^]+)/); // split on first colon\n      if (key && value) {\n        styleObject[key.trim()] = value.trim();\n      }\n    }\n  }\n  return styleObject;\n}\n\n/**\n * Given a CSS string, returns an object from the style cache.\n * @param css - The CSS property as a string.\n * @returns The value of the given CSS property.\n */\nfunction getStyleObjectFromCSS(css) {\n  let value = CSS_TO_STYLES.get(css);\n  if (value === undefined) {\n    value = getStyleObjectFromRawCSS(css);\n    CSS_TO_STYLES.set(css, value);\n  }\n  {\n    // Freeze the value in DEV to prevent accidental mutations\n    Object.freeze(value);\n  }\n  return value;\n}\n\n/**\n * Gets the CSS styles from the style object.\n * @param styles - The style object containing the styles to get.\n * @returns A string containing the CSS styles and their values.\n */\nfunction getCSSFromStyleObject(styles) {\n  let css = '';\n  for (const style in styles) {\n    if (style) {\n      css += `${style}: ${styles[style]};`;\n    }\n  }\n  return css;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Generally used to append text content to HTML and JSON. Grabs the text content and \"slices\"\n * it to be generated into the new TextNode.\n * @param selection - The selection containing the node whose TextNode is to be edited.\n * @param textNode - The TextNode to be edited.\n * @returns The updated TextNode.\n */\nfunction $sliceSelectedTextNodeContent(selection, textNode) {\n  const anchorAndFocus = selection.getStartEndPoints();\n  if (textNode.isSelected(selection) && !textNode.isSegmented() && !textNode.isToken() && anchorAndFocus !== null) {\n    const [anchor, focus] = anchorAndFocus;\n    const isBackward = selection.isBackward();\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    const isAnchor = textNode.is(anchorNode);\n    const isFocus = textNode.is(focusNode);\n    if (isAnchor || isFocus) {\n      const [anchorOffset, focusOffset] = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getCharacterOffsets)(selection);\n      const isSame = anchorNode.is(focusNode);\n      const isFirst = textNode.is(isBackward ? focusNode : anchorNode);\n      const isLast = textNode.is(isBackward ? anchorNode : focusNode);\n      let startOffset = 0;\n      let endOffset = undefined;\n      if (isSame) {\n        startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\n        endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;\n      } else if (isFirst) {\n        const offset = isBackward ? focusOffset : anchorOffset;\n        startOffset = offset;\n        endOffset = undefined;\n      } else if (isLast) {\n        const offset = isBackward ? anchorOffset : focusOffset;\n        startOffset = 0;\n        endOffset = offset;\n      }\n      textNode.__text = textNode.__text.slice(startOffset, endOffset);\n      return textNode;\n    }\n  }\n  return textNode;\n}\n\n/**\n * Determines if the current selection is at the end of the node.\n * @param point - The point of the selection to test.\n * @returns true if the provided point offset is in the last possible position, false otherwise.\n */\nfunction $isAtNodeEnd(point) {\n  if (point.type === 'text') {\n    return point.offset === point.getNode().getTextContentSize();\n  }\n  const node = point.getNode();\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node)) {\n    throw Error(`isAtNodeEnd: node must be a TextNode or ElementNode`);\n  }\n  return point.offset === node.getChildrenSize();\n}\n\n/**\n * Trims text from a node in order to shorten it, eg. to enforce a text's max length. If it deletes text\n * that is an ancestor of the anchor then it will leave 2 indents, otherwise, if no text content exists, it deletes\n * the TextNode. It will move the focus to either the end of any left over text or beginning of a new TextNode.\n * @param editor - The lexical editor.\n * @param anchor - The anchor of the current selection, where the selection should be pointing.\n * @param delCount - The amount of characters to delete. Useful as a dynamic variable eg. textContentSize - maxLength;\n */\nfunction $trimTextContentFromAnchor(editor, anchor, delCount) {\n  // Work from the current selection anchor point\n  let currentNode = anchor.getNode();\n  let remaining = delCount;\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode)) {\n    const descendantNode = currentNode.getDescendantByIndex(anchor.offset);\n    if (descendantNode !== null) {\n      currentNode = descendantNode;\n    }\n  }\n  while (remaining > 0 && currentNode !== null) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode)) {\n      const lastDescendant = currentNode.getLastDescendant();\n      if (lastDescendant !== null) {\n        currentNode = lastDescendant;\n      }\n    }\n    let nextNode = currentNode.getPreviousSibling();\n    let additionalElementWhitespace = 0;\n    if (nextNode === null) {\n      let parent = currentNode.getParentOrThrow();\n      let parentSibling = parent.getPreviousSibling();\n      while (parentSibling === null) {\n        parent = parent.getParent();\n        if (parent === null) {\n          nextNode = null;\n          break;\n        }\n        parentSibling = parent.getPreviousSibling();\n      }\n      if (parent !== null) {\n        additionalElementWhitespace = parent.isInline() ? 0 : 2;\n        nextNode = parentSibling;\n      }\n    }\n    let text = currentNode.getTextContent();\n    // If the text is empty, we need to consider adding in two line breaks to match\n    // the content if we were to get it from its parent.\n    if (text === '' && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode) && !currentNode.isInline()) {\n      // TODO: should this be handled in core?\n      text = '\\n\\n';\n    }\n    const currentNodeSize = text.length;\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(currentNode) || remaining >= currentNodeSize) {\n      const parent = currentNode.getParent();\n      currentNode.remove();\n      if (parent != null && parent.getChildrenSize() === 0 && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootNode)(parent)) {\n        parent.remove();\n      }\n      remaining -= currentNodeSize + additionalElementWhitespace;\n      currentNode = nextNode;\n    } else {\n      const key = currentNode.getKey();\n      // See if we can just revert it to what was in the last editor state\n      const prevTextContent = editor.getEditorState().read(() => {\n        const prevNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNodeByKey)(key);\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(prevNode) && prevNode.isSimpleText()) {\n          return prevNode.getTextContent();\n        }\n        return null;\n      });\n      const offset = currentNodeSize - remaining;\n      const slicedText = text.slice(0, offset);\n      if (prevTextContent !== null && prevTextContent !== text) {\n        const prevSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getPreviousSelection)();\n        let target = currentNode;\n        if (!currentNode.isSimpleText()) {\n          const textNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTextNode)(prevTextContent);\n          currentNode.replace(textNode);\n          target = textNode;\n        } else {\n          currentNode.setTextContent(prevTextContent);\n        }\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(prevSelection) && prevSelection.isCollapsed()) {\n          const prevOffset = prevSelection.anchor.offset;\n          target.select(prevOffset, prevOffset);\n        }\n      } else if (currentNode.isSimpleText()) {\n        // Split text\n        const isSelected = anchor.key === key;\n        let anchorOffset = anchor.offset;\n        // Move offset to end if it's less than the remaining number, otherwise\n        // we'll have a negative splitStart.\n        if (anchorOffset < remaining) {\n          anchorOffset = currentNodeSize;\n        }\n        const splitStart = isSelected ? anchorOffset - remaining : 0;\n        const splitEnd = isSelected ? anchorOffset : offset;\n        if (isSelected && splitStart === 0) {\n          const [excessNode] = currentNode.splitText(splitStart, splitEnd);\n          excessNode.remove();\n        } else {\n          const [, excessNode] = currentNode.splitText(splitStart, splitEnd);\n          excessNode.remove();\n        }\n      } else {\n        const textNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTextNode)(slicedText);\n        currentNode.replace(textNode);\n      }\n      remaining = 0;\n    }\n  }\n}\n\n/**\n * Gets the TextNode's style object and adds the styles to the CSS.\n * @param node - The TextNode to add styles to.\n */\nfunction $addNodeStyle(node) {\n  const CSSText = node.getStyle();\n  const styles = getStyleObjectFromRawCSS(CSSText);\n  CSS_TO_STYLES.set(CSSText, styles);\n}\nfunction $patchStyle(target, patch) {\n  const prevStyles = getStyleObjectFromCSS('getStyle' in target ? target.getStyle() : target.style);\n  const newStyles = Object.entries(patch).reduce((styles, [key, value]) => {\n    if (typeof value === 'function') {\n      styles[key] = value(prevStyles[key], target);\n    } else if (value === null) {\n      delete styles[key];\n    } else {\n      styles[key] = value;\n    }\n    return styles;\n  }, {\n    ...prevStyles\n  } || {});\n  const newCSSText = getCSSFromStyleObject(newStyles);\n  target.setStyle(newCSSText);\n  CSS_TO_STYLES.set(newCSSText, newStyles);\n}\n\n/**\n * Applies the provided styles to the TextNodes in the provided Selection.\n * Will update partially selected TextNodes by splitting the TextNode and applying\n * the styles to the appropriate one.\n * @param selection - The selected node(s) to update.\n * @param patch - The patch to apply, which can include multiple styles. \\\\{CSSProperty: value\\\\} . Can also accept a function that returns the new property value.\n */\nfunction $patchStyleText(selection, patch) {\n  if (selection.isCollapsed() && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n    $patchStyle(selection, patch);\n  } else {\n    $forEachSelectedTextNode(textNode => {\n      $patchStyle(textNode, patch);\n    });\n  }\n}\nfunction $forEachSelectedTextNode(fn) {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n    return;\n  }\n  const selectedNodes = selection.getNodes();\n  const selectedNodesLength = selectedNodes.length;\n  const {\n    anchor,\n    focus\n  } = selection;\n  const lastIndex = selectedNodesLength - 1;\n  let firstNode = selectedNodes[0];\n  let lastNode = selectedNodes[lastIndex];\n  const firstNodeText = firstNode.getTextContent();\n  const firstNodeTextLength = firstNodeText.length;\n  const focusOffset = focus.offset;\n  let anchorOffset = anchor.offset;\n  const isBefore = anchor.isBefore(focus);\n  let startOffset = isBefore ? anchorOffset : focusOffset;\n  let endOffset = isBefore ? focusOffset : anchorOffset;\n  const startType = isBefore ? anchor.type : focus.type;\n  const endType = isBefore ? focus.type : anchor.type;\n  const endKey = isBefore ? focus.key : anchor.key;\n\n  // This is the case where the user only selected the very end of the\n  // first node so we don't want to include it in the formatting change.\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(firstNode) && startOffset === firstNodeTextLength) {\n    const nextSibling = firstNode.getNextSibling();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(nextSibling)) {\n      // we basically make the second node the firstNode, changing offsets accordingly\n      anchorOffset = 0;\n      startOffset = 0;\n      firstNode = nextSibling;\n    }\n  }\n\n  // This is the case where we only selected a single node\n  if (selectedNodes.length === 1) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(firstNode) && firstNode.canHaveFormat()) {\n      startOffset = startType === 'element' ? 0 : anchorOffset > focusOffset ? focusOffset : anchorOffset;\n      endOffset = endType === 'element' ? firstNodeTextLength : anchorOffset > focusOffset ? anchorOffset : focusOffset;\n\n      // No actual text is selected, so do nothing.\n      if (startOffset === endOffset) {\n        return;\n      }\n\n      // The entire node is selected or a token/segment, so just format it\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTokenOrSegmented)(firstNode) || startOffset === 0 && endOffset === firstNodeTextLength) {\n        fn(firstNode);\n        firstNode.select(startOffset, endOffset);\n      } else {\n        // The node is partially selected, so split it into two nodes\n        // and style the selected one.\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        fn(replacement);\n        replacement.select(0, endOffset - startOffset);\n      }\n    } // multiple nodes selected.\n  } else {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(firstNode) && startOffset < firstNode.getTextContentSize() && firstNode.canHaveFormat()) {\n      if (startOffset !== 0 && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTokenOrSegmented)(firstNode)) {\n        // the entire first node isn't selected and it isn't a token or segmented, so split it\n        firstNode = firstNode.splitText(startOffset)[1];\n        startOffset = 0;\n        if (isBefore) {\n          anchor.set(firstNode.getKey(), startOffset, 'text');\n        } else {\n          focus.set(firstNode.getKey(), startOffset, 'text');\n        }\n      }\n      fn(firstNode);\n    }\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(lastNode) && lastNode.canHaveFormat()) {\n      const lastNodeText = lastNode.getTextContent();\n      const lastNodeTextLength = lastNodeText.length;\n\n      // The last node might not actually be the end node\n      //\n      // If not, assume the last node is fully-selected unless the end offset is\n      // zero.\n      if (lastNode.__key !== endKey && endOffset !== 0) {\n        endOffset = lastNodeTextLength;\n      }\n\n      // if the entire last node isn't selected and it isn't a token or segmented, split it\n      if (endOffset !== lastNodeTextLength && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTokenOrSegmented)(lastNode)) {\n        [lastNode] = lastNode.splitText(endOffset);\n      }\n      if (endOffset !== 0 || endType === 'element') {\n        fn(lastNode);\n      }\n    }\n\n    // style all the text nodes in between\n    for (let i = 1; i < lastIndex; i++) {\n      const selectedNode = selectedNodes[i];\n      const selectedNodeKey = selectedNode.getKey();\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(selectedNode) && selectedNode.canHaveFormat() && selectedNodeKey !== firstNode.getKey() && selectedNodeKey !== lastNode.getKey() && !selectedNode.isToken()) {\n        fn(selectedNode);\n      }\n    }\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n/**\n * Converts all nodes in the selection that are of one block type to another.\n * @param selection - The selected blocks to be converted.\n * @param createElement - The function that creates the node. eg. $createParagraphNode.\n */\nfunction $setBlocksType(selection, createElement) {\n  if (selection === null) {\n    return;\n  }\n  const anchorAndFocus = selection.getStartEndPoints();\n  const anchor = anchorAndFocus ? anchorAndFocus[0] : null;\n  if (anchor !== null && anchor.key === 'root') {\n    const element = createElement();\n    const root = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)();\n    const firstChild = root.getFirstChild();\n    if (firstChild) {\n      firstChild.replace(element, true);\n    } else {\n      root.append(element);\n    }\n    return;\n  }\n  const nodes = selection.getNodes();\n  const firstSelectedBlock = anchor !== null ? $getAncestor(anchor.getNode(), INTERNAL_$isBlock) : false;\n  if (firstSelectedBlock && nodes.indexOf(firstSelectedBlock) === -1) {\n    nodes.push(firstSelectedBlock);\n  }\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (!INTERNAL_$isBlock(node)) {\n      continue;\n    }\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node)) {\n      throw Error(`Expected block node to be an ElementNode`);\n    }\n    const targetElement = createElement();\n    targetElement.setFormat(node.getFormatType());\n    targetElement.setIndent(node.getIndent());\n    node.replace(targetElement, true);\n  }\n}\nfunction isPointAttached(point) {\n  return point.getNode().isAttached();\n}\nfunction $removeParentEmptyElements(startingNode) {\n  let node = startingNode;\n  while (node !== null && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(node)) {\n    const latest = node.getLatest();\n    const parentNode = node.getParent();\n    if (latest.getChildrenSize() === 0) {\n      node.remove(true);\n    }\n    node = parentNode;\n  }\n}\n\n/**\n * @deprecated\n * Wraps all nodes in the selection into another node of the type returned by createElement.\n * @param selection - The selection of nodes to be wrapped.\n * @param createElement - A function that creates the wrapping ElementNode. eg. $createParagraphNode.\n * @param wrappingElement - An element to append the wrapped selection and its children to.\n */\nfunction $wrapNodes(selection, createElement, wrappingElement = null) {\n  const anchorAndFocus = selection.getStartEndPoints();\n  const anchor = anchorAndFocus ? anchorAndFocus[0] : null;\n  const nodes = selection.getNodes();\n  const nodesLength = nodes.length;\n  if (anchor !== null && (nodesLength === 0 || nodesLength === 1 && anchor.type === 'element' && anchor.getNode().getChildrenSize() === 0)) {\n    const target = anchor.type === 'text' ? anchor.getNode().getParentOrThrow() : anchor.getNode();\n    const children = target.getChildren();\n    let element = createElement();\n    element.setFormat(target.getFormatType());\n    element.setIndent(target.getIndent());\n    children.forEach(child => element.append(child));\n    if (wrappingElement) {\n      element = wrappingElement.append(element);\n    }\n    target.replace(element);\n    return;\n  }\n  let topLevelNode = null;\n  let descendants = [];\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    // Determine whether wrapping has to be broken down into multiple chunks. This can happen if the\n    // user selected multiple Root-like nodes that have to be treated separately as if they are\n    // their own branch. I.e. you don't want to wrap a whole table, but rather the contents of each\n    // of each of the cell nodes.\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(node)) {\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n      descendants = [];\n      topLevelNode = node;\n    } else if (topLevelNode === null || topLevelNode !== null && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$hasAncestor)(node, topLevelNode)) {\n      descendants.push(node);\n    } else {\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n      descendants = [node];\n    }\n  }\n  $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n}\n\n/**\n * Wraps each node into a new ElementNode.\n * @param selection - The selection of nodes to wrap.\n * @param nodes - An array of nodes, generally the descendants of the selection.\n * @param nodesLength - The length of nodes.\n * @param createElement - A function that creates the wrapping ElementNode. eg. $createParagraphNode.\n * @param wrappingElement - An element to wrap all the nodes into.\n * @returns\n */\nfunction $wrapNodesImpl(selection, nodes, nodesLength, createElement, wrappingElement = null) {\n  if (nodes.length === 0) {\n    return;\n  }\n  const firstNode = nodes[0];\n  const elementMapping = new Map();\n  const elements = [];\n  // The below logic is to find the right target for us to\n  // either insertAfter/insertBefore/append the corresponding\n  // elements to. This is made more complicated due to nested\n  // structures.\n  let target = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(firstNode) ? firstNode : firstNode.getParentOrThrow();\n  if (target.isInline()) {\n    target = target.getParentOrThrow();\n  }\n  let targetIsPrevSibling = false;\n  while (target !== null) {\n    const prevSibling = target.getPreviousSibling();\n    if (prevSibling !== null) {\n      target = prevSibling;\n      targetIsPrevSibling = true;\n      break;\n    }\n    target = target.getParentOrThrow();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(target)) {\n      break;\n    }\n  }\n  const emptyElements = new Set();\n\n  // Find any top level empty elements\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && node.getChildrenSize() === 0) {\n      emptyElements.add(node.getKey());\n    }\n  }\n  const movedNodes = new Set();\n\n  // Move out all leaf nodes into our elements array.\n  // If we find a top level empty element, also move make\n  // an element for that.\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    let parent = node.getParent();\n    if (parent !== null && parent.isInline()) {\n      parent = parent.getParent();\n    }\n    if (parent !== null && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isLeafNode)(node) && !movedNodes.has(node.getKey())) {\n      const parentKey = parent.getKey();\n      if (elementMapping.get(parentKey) === undefined) {\n        const targetElement = createElement();\n        targetElement.setFormat(parent.getFormatType());\n        targetElement.setIndent(parent.getIndent());\n        elements.push(targetElement);\n        elementMapping.set(parentKey, targetElement);\n        // Move node and its siblings to the new\n        // element.\n        parent.getChildren().forEach(child => {\n          targetElement.append(child);\n          movedNodes.add(child.getKey());\n          if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(child)) {\n            // Skip nested leaf nodes if the parent has already been moved\n            child.getChildrenKeys().forEach(key => movedNodes.add(key));\n          }\n        });\n        $removeParentEmptyElements(parent);\n      }\n    } else if (emptyElements.has(node.getKey())) {\n      if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node)) {\n        throw Error(`Expected node in emptyElements to be an ElementNode`);\n      }\n      const targetElement = createElement();\n      targetElement.setFormat(node.getFormatType());\n      targetElement.setIndent(node.getIndent());\n      elements.push(targetElement);\n      node.remove(true);\n    }\n  }\n  if (wrappingElement !== null) {\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      wrappingElement.append(element);\n    }\n  }\n  let lastElement = null;\n\n  // If our target is Root-like, let's see if we can re-adjust\n  // so that the target is the first child instead.\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(target)) {\n    if (targetIsPrevSibling) {\n      if (wrappingElement !== null) {\n        target.insertAfter(wrappingElement);\n      } else {\n        for (let i = elements.length - 1; i >= 0; i--) {\n          const element = elements[i];\n          target.insertAfter(element);\n        }\n      }\n    } else {\n      const firstChild = target.getFirstChild();\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(firstChild)) {\n        target = firstChild;\n      }\n      if (firstChild === null) {\n        if (wrappingElement) {\n          target.append(wrappingElement);\n        } else {\n          for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            target.append(element);\n            lastElement = element;\n          }\n        }\n      } else {\n        if (wrappingElement !== null) {\n          firstChild.insertBefore(wrappingElement);\n        } else {\n          for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            firstChild.insertBefore(element);\n            lastElement = element;\n          }\n        }\n      }\n    }\n  } else {\n    if (wrappingElement) {\n      target.insertAfter(wrappingElement);\n    } else {\n      for (let i = elements.length - 1; i >= 0; i--) {\n        const element = elements[i];\n        target.insertAfter(element);\n        lastElement = element;\n      }\n    }\n  }\n  const prevSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getPreviousSelection)();\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(prevSelection) && isPointAttached(prevSelection.anchor) && isPointAttached(prevSelection.focus)) {\n    (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(prevSelection.clone());\n  } else if (lastElement !== null) {\n    lastElement.selectEnd();\n  } else {\n    selection.dirty = true;\n  }\n}\n\n/**\n * Determines if the default character selection should be overridden. Used with DecoratorNodes\n * @param selection - The selection whose default character selection may need to be overridden.\n * @param isBackward - Is the selection backwards (the focus comes before the anchor)?\n * @returns true if it should be overridden, false if not.\n */\nfunction $shouldOverrideDefaultCharacterSelection(selection, isBackward) {\n  const possibleNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getAdjacentNode)(selection.focus, isBackward);\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isDecoratorNode)(possibleNode) && !possibleNode.isIsolated() || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(possibleNode) && !possibleNode.isInline() && !possibleNode.canBeEmpty();\n}\n\n/**\n * Moves the selection according to the arguments.\n * @param selection - The selected text or nodes.\n * @param isHoldingShift - Is the shift key being held down during the operation.\n * @param isBackward - Is the selection selected backwards (the focus comes before the anchor)?\n * @param granularity - The distance to adjust the current selection.\n */\nfunction $moveCaretSelection(selection, isHoldingShift, isBackward, granularity) {\n  selection.modify(isHoldingShift ? 'extend' : 'move', isBackward, granularity);\n}\n\n/**\n * Tests a parent element for right to left direction.\n * @param selection - The selection whose parent is to be tested.\n * @returns true if the selections' parent element has a direction of 'rtl' (right to left), false otherwise.\n */\nfunction $isParentElementRTL(selection) {\n  const anchorNode = selection.anchor.getNode();\n  const parent = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootNode)(anchorNode) ? anchorNode : anchorNode.getParentOrThrow();\n  return parent.getDirection() === 'rtl';\n}\n\n/**\n * Moves selection by character according to arguments.\n * @param selection - The selection of the characters to move.\n * @param isHoldingShift - Is the shift key being held down during the operation.\n * @param isBackward - Is the selection backward (the focus comes before the anchor)?\n */\nfunction $moveCharacter(selection, isHoldingShift, isBackward) {\n  const isRTL = $isParentElementRTL(selection);\n  $moveCaretSelection(selection, isHoldingShift, isBackward ? !isRTL : isRTL, 'character');\n}\n\n/**\n * Returns the current value of a CSS property for Nodes, if set. If not set, it returns the defaultValue.\n * @param node - The node whose style value to get.\n * @param styleProperty - The CSS style property.\n * @param defaultValue - The default value for the property.\n * @returns The value of the property for node.\n */\nfunction $getNodeStyleValueForProperty(node, styleProperty, defaultValue) {\n  const css = node.getStyle();\n  const styleObject = getStyleObjectFromCSS(css);\n  if (styleObject !== null) {\n    return styleObject[styleProperty] || defaultValue;\n  }\n  return defaultValue;\n}\n\n/**\n * Returns the current value of a CSS property for TextNodes in the Selection, if set. If not set, it returns the defaultValue.\n * If all TextNodes do not have the same value, it returns an empty string.\n * @param selection - The selection of TextNodes whose value to find.\n * @param styleProperty - The CSS style property.\n * @param defaultValue - The default value for the property, defaults to an empty string.\n * @returns The value of the property for the selected TextNodes.\n */\nfunction $getSelectionStyleValueForProperty(selection, styleProperty, defaultValue = '') {\n  let styleValue = null;\n  const nodes = selection.getNodes();\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const isBackward = selection.isBackward();\n  const endOffset = isBackward ? focus.offset : anchor.offset;\n  const endNode = isBackward ? focus.getNode() : anchor.getNode();\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) && selection.isCollapsed() && selection.style !== '') {\n    const css = selection.style;\n    const styleObject = getStyleObjectFromCSS(css);\n    if (styleObject !== null && styleProperty in styleObject) {\n      return styleObject[styleProperty];\n    }\n  }\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n\n    // if no actual characters in the end node are selected, we don't\n    // include it in the selection for purposes of determining style\n    // value\n    if (i !== 0 && endOffset === 0 && node.is(endNode)) {\n      continue;\n    }\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(node)) {\n      const nodeStyleValue = $getNodeStyleValueForProperty(node, styleProperty, defaultValue);\n      if (styleValue === null) {\n        styleValue = nodeStyleValue;\n      } else if (styleValue !== nodeStyleValue) {\n        // multiple text nodes are in the selection and they don't all\n        // have the same style.\n        styleValue = '';\n        break;\n      }\n    }\n  }\n  return styleValue === null ? defaultValue : styleValue;\n}\n\n/**\n * This function is for internal use of the library.\n * Please do not use it as it may change in the future.\n */\nfunction INTERNAL_$isBlock(node) {\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isDecoratorNode)(node)) {\n    return false;\n  }\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(node)) {\n    return false;\n  }\n  const firstChild = node.getFirstChild();\n  const isLeafElement = firstChild === null || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isLineBreakNode)(firstChild) || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(firstChild) || firstChild.isInline();\n  return !node.isInline() && node.canBeEmpty() !== false && isLeafElement;\n}\nfunction $getAncestor(node, predicate) {\n  let parent = node;\n  while (parent !== null && parent.getParent() !== null && !predicate(parent)) {\n    parent = parent.getParentOrThrow();\n  }\n  return predicate(parent) ? parent : null;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @deprecated renamed to {@link $trimTextContentFromAnchor} by @lexical/eslint-plugin rules-of-lexical */\nconst trimTextContentFromAnchor = $trimTextContentFromAnchor;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvc2VsZWN0aW9uL0xleGljYWxTZWxlY3Rpb24uZGV2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFc1U7QUFDM1E7O0FBRTNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxvREFBVztBQUNqQjtBQUNBO0FBQ0EsTUFBTSxvREFBVztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esa0JBQWtCLDBCQUEwQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsTUFBTSxJQUFJLGVBQWU7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyw2REFBb0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLHVEQUFjO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sdURBQWM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBYztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVEQUFjO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxvREFBVztBQUNwQjtBQUNBO0FBQ0EsK0RBQStELG9EQUFXO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixzREFBYTtBQUN0QyxZQUFZLG9EQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsOERBQXFCO0FBQ25EO0FBQ0E7QUFDQSwyQkFBMkIsd0RBQWU7QUFDMUM7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWSwwREFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUix5QkFBeUIsd0RBQWU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsSUFBSSxLQUFLO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxzQkFBc0I7QUFDbEc7QUFDQTtBQUNBLGlDQUFpQywwREFBaUI7QUFDbEQ7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0RBQWE7QUFDakMsT0FBTywwREFBaUI7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sb0RBQVc7QUFDakI7QUFDQSxRQUFRLG9EQUFXO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUSxvREFBVztBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSw0REFBbUI7QUFDN0I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixJQUFJO0FBQ0osUUFBUSxvREFBVztBQUNuQixnQ0FBZ0MsNERBQW1CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0RBQVc7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtDQUErQyw0REFBbUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBLFVBQVUsb0RBQVc7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsaURBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHVEQUFjO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDREQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNERBQW1CO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLE1BQU0sMkRBQTJELHFEQUFZO0FBQzdFO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1REFBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDREQUFtQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQSxRQUFRLHVEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixvREFBVztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHVEQUFjO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBTTtBQUNOLFdBQVcsdURBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sNERBQW1CO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUiwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLFVBQVUsdURBQWM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViwwQkFBMEIscUJBQXFCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDViwwQkFBMEIscUJBQXFCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNO0FBQ04sd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDhEQUFxQjtBQUM3QyxNQUFNLDBEQUFpQjtBQUN2QixJQUFJLHNEQUFhO0FBQ2pCLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIseURBQWdCO0FBQ3ZDLFNBQVMseURBQWdCLGdEQUFnRCx1REFBYztBQUN2Rjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixvREFBVztBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sMERBQWlCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvREFBVztBQUNuQjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHlEQUFnQjtBQUN0QjtBQUNBO0FBQ0EsT0FBTyx1REFBYyxVQUFVLDREQUFtQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MseURBQWdCLGdCQUFnQixvREFBVztBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLGtDQUFrQztBQUM5RDs7QUFFbWEiLCJzb3VyY2VzIjpbIi9Vc2Vycy9sZWkvaG9tZS91bmRlcmcvdGhlYXRyZS95My9zZWdwL21pbGt1cC9ub2RlX21vZHVsZXMvQGxleGljYWwvc2VsZWN0aW9uL0xleGljYWxTZWxlY3Rpb24uZGV2Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmltcG9ydCB7ICRpc1RleHROb2RlLCAkZ2V0Q2hhcmFjdGVyT2Zmc2V0cywgJGlzRWxlbWVudE5vZGUsICRpc1Jvb3ROb2RlLCAkZ2V0Tm9kZUJ5S2V5LCAkZ2V0UHJldmlvdXNTZWxlY3Rpb24sICRjcmVhdGVUZXh0Tm9kZSwgJGlzUmFuZ2VTZWxlY3Rpb24sICRnZXRTZWxlY3Rpb24sICRpc1Rva2VuT3JTZWdtZW50ZWQsICRnZXRSb290LCAkaXNSb290T3JTaGFkb3dSb290LCAkaGFzQW5jZXN0b3IsICRpc0xlYWZOb2RlLCAkc2V0U2VsZWN0aW9uLCAkZ2V0QWRqYWNlbnROb2RlLCAkaXNEZWNvcmF0b3JOb2RlLCAkaXNMaW5lQnJlYWtOb2RlIH0gZnJvbSAnbGV4aWNhbCc7XG5leHBvcnQgeyAkY2xvbmVXaXRoUHJvcGVydGllcywgJHNlbGVjdEFsbCB9IGZyb20gJ2xleGljYWwnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5jb25zdCBDU1NfVE9fU1RZTEVTID0gbmV3IE1hcCgpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uIGdldERPTVRleHROb2RlKGVsZW1lbnQpIHtcbiAgbGV0IG5vZGUgPSBlbGVtZW50O1xuICB3aGlsZSAobm9kZSAhPSBudWxsKSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgbm9kZSA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldERPTUluZGV4V2l0aGluUGFyZW50KG5vZGUpIHtcbiAgY29uc3QgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuICBpZiAocGFyZW50ID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Nob3VsZCBuZXZlciBoYXBwZW4nKTtcbiAgfVxuICByZXR1cm4gW3BhcmVudCwgQXJyYXkuZnJvbShwYXJlbnQuY2hpbGROb2RlcykuaW5kZXhPZihub2RlKV07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHNlbGVjdGlvbiByYW5nZSBmb3IgdGhlIERPTS5cbiAqIEBwYXJhbSBlZGl0b3IgLSBUaGUgbGV4aWNhbCBlZGl0b3IuXG4gKiBAcGFyYW0gYW5jaG9yTm9kZSAtIFRoZSBhbmNob3Igbm9kZSBvZiBhIHNlbGVjdGlvbi5cbiAqIEBwYXJhbSBfYW5jaG9yT2Zmc2V0IC0gVGhlIGFtb3VudCBvZiBzcGFjZSBvZmZzZXQgZnJvbSB0aGUgYW5jaG9yIHRvIHRoZSBmb2N1cy5cbiAqIEBwYXJhbSBmb2N1c05vZGUgLSBUaGUgY3VycmVudCBmb2N1cy5cbiAqIEBwYXJhbSBfZm9jdXNPZmZzZXQgLSBUaGUgYW1vdW50IG9mIHNwYWNlIG9mZnNldCBmcm9tIHRoZSBmb2N1cyB0byB0aGUgYW5jaG9yLlxuICogQHJldHVybnMgVGhlIHJhbmdlIG9mIHNlbGVjdGlvbiBmb3IgdGhlIERPTSB0aGF0IHdhcyBjcmVhdGVkLlxuICovXG5mdW5jdGlvbiBjcmVhdGVET01SYW5nZShlZGl0b3IsIGFuY2hvck5vZGUsIF9hbmNob3JPZmZzZXQsIGZvY3VzTm9kZSwgX2ZvY3VzT2Zmc2V0KSB7XG4gIGNvbnN0IGFuY2hvcktleSA9IGFuY2hvck5vZGUuZ2V0S2V5KCk7XG4gIGNvbnN0IGZvY3VzS2V5ID0gZm9jdXNOb2RlLmdldEtleSgpO1xuICBjb25zdCByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gIGxldCBhbmNob3JET00gPSBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KGFuY2hvcktleSk7XG4gIGxldCBmb2N1c0RPTSA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkoZm9jdXNLZXkpO1xuICBsZXQgYW5jaG9yT2Zmc2V0ID0gX2FuY2hvck9mZnNldDtcbiAgbGV0IGZvY3VzT2Zmc2V0ID0gX2ZvY3VzT2Zmc2V0O1xuICBpZiAoJGlzVGV4dE5vZGUoYW5jaG9yTm9kZSkpIHtcbiAgICBhbmNob3JET00gPSBnZXRET01UZXh0Tm9kZShhbmNob3JET00pO1xuICB9XG4gIGlmICgkaXNUZXh0Tm9kZShmb2N1c05vZGUpKSB7XG4gICAgZm9jdXNET00gPSBnZXRET01UZXh0Tm9kZShmb2N1c0RPTSk7XG4gIH1cbiAgaWYgKGFuY2hvck5vZGUgPT09IHVuZGVmaW5lZCB8fCBmb2N1c05vZGUgPT09IHVuZGVmaW5lZCB8fCBhbmNob3JET00gPT09IG51bGwgfHwgZm9jdXNET00gPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoYW5jaG9yRE9NLm5vZGVOYW1lID09PSAnQlInKSB7XG4gICAgW2FuY2hvckRPTSwgYW5jaG9yT2Zmc2V0XSA9IGdldERPTUluZGV4V2l0aGluUGFyZW50KGFuY2hvckRPTSk7XG4gIH1cbiAgaWYgKGZvY3VzRE9NLm5vZGVOYW1lID09PSAnQlInKSB7XG4gICAgW2ZvY3VzRE9NLCBmb2N1c09mZnNldF0gPSBnZXRET01JbmRleFdpdGhpblBhcmVudChmb2N1c0RPTSk7XG4gIH1cbiAgY29uc3QgZmlyc3RDaGlsZCA9IGFuY2hvckRPTS5maXJzdENoaWxkO1xuICBpZiAoYW5jaG9yRE9NID09PSBmb2N1c0RPTSAmJiBmaXJzdENoaWxkICE9IG51bGwgJiYgZmlyc3RDaGlsZC5ub2RlTmFtZSA9PT0gJ0JSJyAmJiBhbmNob3JPZmZzZXQgPT09IDAgJiYgZm9jdXNPZmZzZXQgPT09IDApIHtcbiAgICBmb2N1c09mZnNldCA9IDE7XG4gIH1cbiAgdHJ5IHtcbiAgICByYW5nZS5zZXRTdGFydChhbmNob3JET00sIGFuY2hvck9mZnNldCk7XG4gICAgcmFuZ2Uuc2V0RW5kKGZvY3VzRE9NLCBmb2N1c09mZnNldCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAocmFuZ2UuY29sbGFwc2VkICYmIChhbmNob3JPZmZzZXQgIT09IGZvY3VzT2Zmc2V0IHx8IGFuY2hvcktleSAhPT0gZm9jdXNLZXkpKSB7XG4gICAgLy8gUmFuZ2UgaXMgYmFja3dhcmRzLCB3ZSBuZWVkIHRvIHJldmVyc2UgaXRcbiAgICByYW5nZS5zZXRTdGFydChmb2N1c0RPTSwgZm9jdXNPZmZzZXQpO1xuICAgIHJhbmdlLnNldEVuZChhbmNob3JET00sIGFuY2hvck9mZnNldCk7XG4gIH1cbiAgcmV0dXJuIHJhbmdlO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgRE9NUmVjdHMsIGdlbmVyYWxseSB1c2VkIHRvIGhlbHAgdGhlIGVkaXRvciBmaW5kIGEgc3BlY2lmaWMgbG9jYXRpb24gb24gdGhlIHNjcmVlbi5cbiAqIEBwYXJhbSBlZGl0b3IgLSBUaGUgbGV4aWNhbCBlZGl0b3JcbiAqIEBwYXJhbSByYW5nZSAtIEEgZnJhZ21lbnQgb2YgYSBkb2N1bWVudCB0aGF0IGNhbiBjb250YWluIG5vZGVzIGFuZCBwYXJ0cyBvZiB0ZXh0IG5vZGVzLlxuICogQHJldHVybnMgVGhlIHNlbGVjdGlvblJlY3RzIGFzIGFuIGFycmF5LlxuICovXG5mdW5jdGlvbiBjcmVhdGVSZWN0c0Zyb21ET01SYW5nZShlZGl0b3IsIHJhbmdlKSB7XG4gIGNvbnN0IHJvb3RFbGVtZW50ID0gZWRpdG9yLmdldFJvb3RFbGVtZW50KCk7XG4gIGlmIChyb290RWxlbWVudCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBjb25zdCByb290UmVjdCA9IHJvb3RFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBjb25zdCBjb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShyb290RWxlbWVudCk7XG4gIGNvbnN0IHJvb3RQYWRkaW5nID0gcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlLnBhZGRpbmdMZWZ0KSArIHBhcnNlRmxvYXQoY29tcHV0ZWRTdHlsZS5wYWRkaW5nUmlnaHQpO1xuICBjb25zdCBzZWxlY3Rpb25SZWN0cyA9IEFycmF5LmZyb20ocmFuZ2UuZ2V0Q2xpZW50UmVjdHMoKSk7XG4gIGxldCBzZWxlY3Rpb25SZWN0c0xlbmd0aCA9IHNlbGVjdGlvblJlY3RzLmxlbmd0aDtcbiAgLy9zb3J0IHJlY3RzIGZyb20gdG9wIGxlZnQgdG8gYm90dG9tIHJpZ2h0LlxuICBzZWxlY3Rpb25SZWN0cy5zb3J0KChhLCBiKSA9PiB7XG4gICAgY29uc3QgdG9wID0gYS50b3AgLSBiLnRvcDtcbiAgICAvLyBTb21lIHJlY3RzIG1hdGNoIHBvc2l0aW9uIGNsb3NlbHksIGJ1dCBub3QgcGVyZmVjdGx5LFxuICAgIC8vIHNvIHdlIGdpdmUgYSAzcHggdG9sZXJhbmNlLlxuICAgIGlmIChNYXRoLmFicyh0b3ApIDw9IDMpIHtcbiAgICAgIHJldHVybiBhLmxlZnQgLSBiLmxlZnQ7XG4gICAgfVxuICAgIHJldHVybiB0b3A7XG4gIH0pO1xuICBsZXQgcHJldlJlY3Q7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2VsZWN0aW9uUmVjdHNMZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHNlbGVjdGlvblJlY3QgPSBzZWxlY3Rpb25SZWN0c1tpXTtcbiAgICAvLyBFeGNsdWRlIHJlY3RzIHRoYXQgb3ZlcmxhcCBwcmVjZWRpbmcgUmVjdHMgaW4gdGhlIHNvcnRlZCBsaXN0LlxuICAgIGNvbnN0IGlzT3ZlcmxhcHBpbmdSZWN0ID0gcHJldlJlY3QgJiYgcHJldlJlY3QudG9wIDw9IHNlbGVjdGlvblJlY3QudG9wICYmIHByZXZSZWN0LnRvcCArIHByZXZSZWN0LmhlaWdodCA+IHNlbGVjdGlvblJlY3QudG9wICYmIHByZXZSZWN0LmxlZnQgKyBwcmV2UmVjdC53aWR0aCA+IHNlbGVjdGlvblJlY3QubGVmdDtcbiAgICAvLyBFeGNsdWRlIHNlbGVjdGlvbnMgdGhhdCBzcGFuIHRoZSBlbnRpcmUgZWxlbWVudFxuICAgIGNvbnN0IHNlbGVjdGlvblNwYW5zRWxlbWVudCA9IHNlbGVjdGlvblJlY3Qud2lkdGggKyByb290UGFkZGluZyA9PT0gcm9vdFJlY3Qud2lkdGg7XG4gICAgaWYgKGlzT3ZlcmxhcHBpbmdSZWN0IHx8IHNlbGVjdGlvblNwYW5zRWxlbWVudCkge1xuICAgICAgc2VsZWN0aW9uUmVjdHMuc3BsaWNlKGktLSwgMSk7XG4gICAgICBzZWxlY3Rpb25SZWN0c0xlbmd0aC0tO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHByZXZSZWN0ID0gc2VsZWN0aW9uUmVjdDtcbiAgfVxuICByZXR1cm4gc2VsZWN0aW9uUmVjdHM7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIHN0eWxlcyBhbmQgdGhlaXIgdmFsdWVzIHByb3ZpZGVkIGluIHRoZSBDU1Mgc3RyaW5nLlxuICogQHBhcmFtIGNzcyAtIFRoZSBDU1Mgc3RyaW5nIG9mIHN0eWxlcyBhbmQgdGhlaXIgdmFsdWVzLlxuICogQHJldHVybnMgVGhlIHN0eWxlT2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBzdHlsZXMgYW5kIHRoZWlyIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0U3R5bGVPYmplY3RGcm9tUmF3Q1NTKGNzcykge1xuICBjb25zdCBzdHlsZU9iamVjdCA9IHt9O1xuICBpZiAoIWNzcykge1xuICAgIHJldHVybiBzdHlsZU9iamVjdDtcbiAgfVxuICBjb25zdCBzdHlsZXMgPSBjc3Muc3BsaXQoJzsnKTtcbiAgZm9yIChjb25zdCBzdHlsZSBvZiBzdHlsZXMpIHtcbiAgICBpZiAoc3R5bGUgIT09ICcnKSB7XG4gICAgICBjb25zdCBba2V5LCB2YWx1ZV0gPSBzdHlsZS5zcGxpdCgvOihbXl0rKS8pOyAvLyBzcGxpdCBvbiBmaXJzdCBjb2xvblxuICAgICAgaWYgKGtleSAmJiB2YWx1ZSkge1xuICAgICAgICBzdHlsZU9iamVjdFtrZXkudHJpbSgpXSA9IHZhbHVlLnRyaW0oKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0eWxlT2JqZWN0O1xufVxuXG4vKipcbiAqIEdpdmVuIGEgQ1NTIHN0cmluZywgcmV0dXJucyBhbiBvYmplY3QgZnJvbSB0aGUgc3R5bGUgY2FjaGUuXG4gKiBAcGFyYW0gY3NzIC0gVGhlIENTUyBwcm9wZXJ0eSBhcyBhIHN0cmluZy5cbiAqIEByZXR1cm5zIFRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gQ1NTIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBnZXRTdHlsZU9iamVjdEZyb21DU1MoY3NzKSB7XG4gIGxldCB2YWx1ZSA9IENTU19UT19TVFlMRVMuZ2V0KGNzcyk7XG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsdWUgPSBnZXRTdHlsZU9iamVjdEZyb21SYXdDU1MoY3NzKTtcbiAgICBDU1NfVE9fU1RZTEVTLnNldChjc3MsIHZhbHVlKTtcbiAgfVxuICB7XG4gICAgLy8gRnJlZXplIHRoZSB2YWx1ZSBpbiBERVYgdG8gcHJldmVudCBhY2NpZGVudGFsIG11dGF0aW9uc1xuICAgIE9iamVjdC5mcmVlemUodmFsdWUpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBDU1Mgc3R5bGVzIGZyb20gdGhlIHN0eWxlIG9iamVjdC5cbiAqIEBwYXJhbSBzdHlsZXMgLSBUaGUgc3R5bGUgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHN0eWxlcyB0byBnZXQuXG4gKiBAcmV0dXJucyBBIHN0cmluZyBjb250YWluaW5nIHRoZSBDU1Mgc3R5bGVzIGFuZCB0aGVpciB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGdldENTU0Zyb21TdHlsZU9iamVjdChzdHlsZXMpIHtcbiAgbGV0IGNzcyA9ICcnO1xuICBmb3IgKGNvbnN0IHN0eWxlIGluIHN0eWxlcykge1xuICAgIGlmIChzdHlsZSkge1xuICAgICAgY3NzICs9IGAke3N0eWxlfTogJHtzdHlsZXNbc3R5bGVdfTtgO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY3NzO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8qKlxuICogR2VuZXJhbGx5IHVzZWQgdG8gYXBwZW5kIHRleHQgY29udGVudCB0byBIVE1MIGFuZCBKU09OLiBHcmFicyB0aGUgdGV4dCBjb250ZW50IGFuZCBcInNsaWNlc1wiXG4gKiBpdCB0byBiZSBnZW5lcmF0ZWQgaW50byB0aGUgbmV3IFRleHROb2RlLlxuICogQHBhcmFtIHNlbGVjdGlvbiAtIFRoZSBzZWxlY3Rpb24gY29udGFpbmluZyB0aGUgbm9kZSB3aG9zZSBUZXh0Tm9kZSBpcyB0byBiZSBlZGl0ZWQuXG4gKiBAcGFyYW0gdGV4dE5vZGUgLSBUaGUgVGV4dE5vZGUgdG8gYmUgZWRpdGVkLlxuICogQHJldHVybnMgVGhlIHVwZGF0ZWQgVGV4dE5vZGUuXG4gKi9cbmZ1bmN0aW9uICRzbGljZVNlbGVjdGVkVGV4dE5vZGVDb250ZW50KHNlbGVjdGlvbiwgdGV4dE5vZGUpIHtcbiAgY29uc3QgYW5jaG9yQW5kRm9jdXMgPSBzZWxlY3Rpb24uZ2V0U3RhcnRFbmRQb2ludHMoKTtcbiAgaWYgKHRleHROb2RlLmlzU2VsZWN0ZWQoc2VsZWN0aW9uKSAmJiAhdGV4dE5vZGUuaXNTZWdtZW50ZWQoKSAmJiAhdGV4dE5vZGUuaXNUb2tlbigpICYmIGFuY2hvckFuZEZvY3VzICE9PSBudWxsKSB7XG4gICAgY29uc3QgW2FuY2hvciwgZm9jdXNdID0gYW5jaG9yQW5kRm9jdXM7XG4gICAgY29uc3QgaXNCYWNrd2FyZCA9IHNlbGVjdGlvbi5pc0JhY2t3YXJkKCk7XG4gICAgY29uc3QgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gICAgY29uc3QgZm9jdXNOb2RlID0gZm9jdXMuZ2V0Tm9kZSgpO1xuICAgIGNvbnN0IGlzQW5jaG9yID0gdGV4dE5vZGUuaXMoYW5jaG9yTm9kZSk7XG4gICAgY29uc3QgaXNGb2N1cyA9IHRleHROb2RlLmlzKGZvY3VzTm9kZSk7XG4gICAgaWYgKGlzQW5jaG9yIHx8IGlzRm9jdXMpIHtcbiAgICAgIGNvbnN0IFthbmNob3JPZmZzZXQsIGZvY3VzT2Zmc2V0XSA9ICRnZXRDaGFyYWN0ZXJPZmZzZXRzKHNlbGVjdGlvbik7XG4gICAgICBjb25zdCBpc1NhbWUgPSBhbmNob3JOb2RlLmlzKGZvY3VzTm9kZSk7XG4gICAgICBjb25zdCBpc0ZpcnN0ID0gdGV4dE5vZGUuaXMoaXNCYWNrd2FyZCA/IGZvY3VzTm9kZSA6IGFuY2hvck5vZGUpO1xuICAgICAgY29uc3QgaXNMYXN0ID0gdGV4dE5vZGUuaXMoaXNCYWNrd2FyZCA/IGFuY2hvck5vZGUgOiBmb2N1c05vZGUpO1xuICAgICAgbGV0IHN0YXJ0T2Zmc2V0ID0gMDtcbiAgICAgIGxldCBlbmRPZmZzZXQgPSB1bmRlZmluZWQ7XG4gICAgICBpZiAoaXNTYW1lKSB7XG4gICAgICAgIHN0YXJ0T2Zmc2V0ID0gYW5jaG9yT2Zmc2V0ID4gZm9jdXNPZmZzZXQgPyBmb2N1c09mZnNldCA6IGFuY2hvck9mZnNldDtcbiAgICAgICAgZW5kT2Zmc2V0ID0gYW5jaG9yT2Zmc2V0ID4gZm9jdXNPZmZzZXQgPyBhbmNob3JPZmZzZXQgOiBmb2N1c09mZnNldDtcbiAgICAgIH0gZWxzZSBpZiAoaXNGaXJzdCkge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBpc0JhY2t3YXJkID8gZm9jdXNPZmZzZXQgOiBhbmNob3JPZmZzZXQ7XG4gICAgICAgIHN0YXJ0T2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICBlbmRPZmZzZXQgPSB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2UgaWYgKGlzTGFzdCkge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBpc0JhY2t3YXJkID8gYW5jaG9yT2Zmc2V0IDogZm9jdXNPZmZzZXQ7XG4gICAgICAgIHN0YXJ0T2Zmc2V0ID0gMDtcbiAgICAgICAgZW5kT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgfVxuICAgICAgdGV4dE5vZGUuX190ZXh0ID0gdGV4dE5vZGUuX190ZXh0LnNsaWNlKHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpO1xuICAgICAgcmV0dXJuIHRleHROb2RlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGV4dE5vZGU7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgY3VycmVudCBzZWxlY3Rpb24gaXMgYXQgdGhlIGVuZCBvZiB0aGUgbm9kZS5cbiAqIEBwYXJhbSBwb2ludCAtIFRoZSBwb2ludCBvZiB0aGUgc2VsZWN0aW9uIHRvIHRlc3QuXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBwcm92aWRlZCBwb2ludCBvZmZzZXQgaXMgaW4gdGhlIGxhc3QgcG9zc2libGUgcG9zaXRpb24sIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gJGlzQXROb2RlRW5kKHBvaW50KSB7XG4gIGlmIChwb2ludC50eXBlID09PSAndGV4dCcpIHtcbiAgICByZXR1cm4gcG9pbnQub2Zmc2V0ID09PSBwb2ludC5nZXROb2RlKCkuZ2V0VGV4dENvbnRlbnRTaXplKCk7XG4gIH1cbiAgY29uc3Qgbm9kZSA9IHBvaW50LmdldE5vZGUoKTtcbiAgaWYgKCEkaXNFbGVtZW50Tm9kZShub2RlKSkge1xuICAgIHRocm93IEVycm9yKGBpc0F0Tm9kZUVuZDogbm9kZSBtdXN0IGJlIGEgVGV4dE5vZGUgb3IgRWxlbWVudE5vZGVgKTtcbiAgfVxuICByZXR1cm4gcG9pbnQub2Zmc2V0ID09PSBub2RlLmdldENoaWxkcmVuU2l6ZSgpO1xufVxuXG4vKipcbiAqIFRyaW1zIHRleHQgZnJvbSBhIG5vZGUgaW4gb3JkZXIgdG8gc2hvcnRlbiBpdCwgZWcuIHRvIGVuZm9yY2UgYSB0ZXh0J3MgbWF4IGxlbmd0aC4gSWYgaXQgZGVsZXRlcyB0ZXh0XG4gKiB0aGF0IGlzIGFuIGFuY2VzdG9yIG9mIHRoZSBhbmNob3IgdGhlbiBpdCB3aWxsIGxlYXZlIDIgaW5kZW50cywgb3RoZXJ3aXNlLCBpZiBubyB0ZXh0IGNvbnRlbnQgZXhpc3RzLCBpdCBkZWxldGVzXG4gKiB0aGUgVGV4dE5vZGUuIEl0IHdpbGwgbW92ZSB0aGUgZm9jdXMgdG8gZWl0aGVyIHRoZSBlbmQgb2YgYW55IGxlZnQgb3ZlciB0ZXh0IG9yIGJlZ2lubmluZyBvZiBhIG5ldyBUZXh0Tm9kZS5cbiAqIEBwYXJhbSBlZGl0b3IgLSBUaGUgbGV4aWNhbCBlZGl0b3IuXG4gKiBAcGFyYW0gYW5jaG9yIC0gVGhlIGFuY2hvciBvZiB0aGUgY3VycmVudCBzZWxlY3Rpb24sIHdoZXJlIHRoZSBzZWxlY3Rpb24gc2hvdWxkIGJlIHBvaW50aW5nLlxuICogQHBhcmFtIGRlbENvdW50IC0gVGhlIGFtb3VudCBvZiBjaGFyYWN0ZXJzIHRvIGRlbGV0ZS4gVXNlZnVsIGFzIGEgZHluYW1pYyB2YXJpYWJsZSBlZy4gdGV4dENvbnRlbnRTaXplIC0gbWF4TGVuZ3RoO1xuICovXG5mdW5jdGlvbiAkdHJpbVRleHRDb250ZW50RnJvbUFuY2hvcihlZGl0b3IsIGFuY2hvciwgZGVsQ291bnQpIHtcbiAgLy8gV29yayBmcm9tIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBhbmNob3IgcG9pbnRcbiAgbGV0IGN1cnJlbnROb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgbGV0IHJlbWFpbmluZyA9IGRlbENvdW50O1xuICBpZiAoJGlzRWxlbWVudE5vZGUoY3VycmVudE5vZGUpKSB7XG4gICAgY29uc3QgZGVzY2VuZGFudE5vZGUgPSBjdXJyZW50Tm9kZS5nZXREZXNjZW5kYW50QnlJbmRleChhbmNob3Iub2Zmc2V0KTtcbiAgICBpZiAoZGVzY2VuZGFudE5vZGUgIT09IG51bGwpIHtcbiAgICAgIGN1cnJlbnROb2RlID0gZGVzY2VuZGFudE5vZGU7XG4gICAgfVxuICB9XG4gIHdoaWxlIChyZW1haW5pbmcgPiAwICYmIGN1cnJlbnROb2RlICE9PSBudWxsKSB7XG4gICAgaWYgKCRpc0VsZW1lbnROb2RlKGN1cnJlbnROb2RlKSkge1xuICAgICAgY29uc3QgbGFzdERlc2NlbmRhbnQgPSBjdXJyZW50Tm9kZS5nZXRMYXN0RGVzY2VuZGFudCgpO1xuICAgICAgaWYgKGxhc3REZXNjZW5kYW50ICE9PSBudWxsKSB7XG4gICAgICAgIGN1cnJlbnROb2RlID0gbGFzdERlc2NlbmRhbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBuZXh0Tm9kZSA9IGN1cnJlbnROb2RlLmdldFByZXZpb3VzU2libGluZygpO1xuICAgIGxldCBhZGRpdGlvbmFsRWxlbWVudFdoaXRlc3BhY2UgPSAwO1xuICAgIGlmIChuZXh0Tm9kZSA9PT0gbnVsbCkge1xuICAgICAgbGV0IHBhcmVudCA9IGN1cnJlbnROb2RlLmdldFBhcmVudE9yVGhyb3coKTtcbiAgICAgIGxldCBwYXJlbnRTaWJsaW5nID0gcGFyZW50LmdldFByZXZpb3VzU2libGluZygpO1xuICAgICAgd2hpbGUgKHBhcmVudFNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50LmdldFBhcmVudCgpO1xuICAgICAgICBpZiAocGFyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgbmV4dE5vZGUgPSBudWxsO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudFNpYmxpbmcgPSBwYXJlbnQuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgICAgIGFkZGl0aW9uYWxFbGVtZW50V2hpdGVzcGFjZSA9IHBhcmVudC5pc0lubGluZSgpID8gMCA6IDI7XG4gICAgICAgIG5leHROb2RlID0gcGFyZW50U2libGluZztcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHRleHQgPSBjdXJyZW50Tm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICAgIC8vIElmIHRoZSB0ZXh0IGlzIGVtcHR5LCB3ZSBuZWVkIHRvIGNvbnNpZGVyIGFkZGluZyBpbiB0d28gbGluZSBicmVha3MgdG8gbWF0Y2hcbiAgICAvLyB0aGUgY29udGVudCBpZiB3ZSB3ZXJlIHRvIGdldCBpdCBmcm9tIGl0cyBwYXJlbnQuXG4gICAgaWYgKHRleHQgPT09ICcnICYmICRpc0VsZW1lbnROb2RlKGN1cnJlbnROb2RlKSAmJiAhY3VycmVudE5vZGUuaXNJbmxpbmUoKSkge1xuICAgICAgLy8gVE9ETzogc2hvdWxkIHRoaXMgYmUgaGFuZGxlZCBpbiBjb3JlP1xuICAgICAgdGV4dCA9ICdcXG5cXG4nO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50Tm9kZVNpemUgPSB0ZXh0Lmxlbmd0aDtcbiAgICBpZiAoISRpc1RleHROb2RlKGN1cnJlbnROb2RlKSB8fCByZW1haW5pbmcgPj0gY3VycmVudE5vZGVTaXplKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSBjdXJyZW50Tm9kZS5nZXRQYXJlbnQoKTtcbiAgICAgIGN1cnJlbnROb2RlLnJlbW92ZSgpO1xuICAgICAgaWYgKHBhcmVudCAhPSBudWxsICYmIHBhcmVudC5nZXRDaGlsZHJlblNpemUoKSA9PT0gMCAmJiAhJGlzUm9vdE5vZGUocGFyZW50KSkge1xuICAgICAgICBwYXJlbnQucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgICByZW1haW5pbmcgLT0gY3VycmVudE5vZGVTaXplICsgYWRkaXRpb25hbEVsZW1lbnRXaGl0ZXNwYWNlO1xuICAgICAgY3VycmVudE5vZGUgPSBuZXh0Tm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qga2V5ID0gY3VycmVudE5vZGUuZ2V0S2V5KCk7XG4gICAgICAvLyBTZWUgaWYgd2UgY2FuIGp1c3QgcmV2ZXJ0IGl0IHRvIHdoYXQgd2FzIGluIHRoZSBsYXN0IGVkaXRvciBzdGF0ZVxuICAgICAgY29uc3QgcHJldlRleHRDb250ZW50ID0gZWRpdG9yLmdldEVkaXRvclN0YXRlKCkucmVhZCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHByZXZOb2RlID0gJGdldE5vZGVCeUtleShrZXkpO1xuICAgICAgICBpZiAoJGlzVGV4dE5vZGUocHJldk5vZGUpICYmIHByZXZOb2RlLmlzU2ltcGxlVGV4dCgpKSB7XG4gICAgICAgICAgcmV0dXJuIHByZXZOb2RlLmdldFRleHRDb250ZW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG9mZnNldCA9IGN1cnJlbnROb2RlU2l6ZSAtIHJlbWFpbmluZztcbiAgICAgIGNvbnN0IHNsaWNlZFRleHQgPSB0ZXh0LnNsaWNlKDAsIG9mZnNldCk7XG4gICAgICBpZiAocHJldlRleHRDb250ZW50ICE9PSBudWxsICYmIHByZXZUZXh0Q29udGVudCAhPT0gdGV4dCkge1xuICAgICAgICBjb25zdCBwcmV2U2VsZWN0aW9uID0gJGdldFByZXZpb3VzU2VsZWN0aW9uKCk7XG4gICAgICAgIGxldCB0YXJnZXQgPSBjdXJyZW50Tm9kZTtcbiAgICAgICAgaWYgKCFjdXJyZW50Tm9kZS5pc1NpbXBsZVRleHQoKSkge1xuICAgICAgICAgIGNvbnN0IHRleHROb2RlID0gJGNyZWF0ZVRleHROb2RlKHByZXZUZXh0Q29udGVudCk7XG4gICAgICAgICAgY3VycmVudE5vZGUucmVwbGFjZSh0ZXh0Tm9kZSk7XG4gICAgICAgICAgdGFyZ2V0ID0gdGV4dE5vZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudE5vZGUuc2V0VGV4dENvbnRlbnQocHJldlRleHRDb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24ocHJldlNlbGVjdGlvbikgJiYgcHJldlNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpKSB7XG4gICAgICAgICAgY29uc3QgcHJldk9mZnNldCA9IHByZXZTZWxlY3Rpb24uYW5jaG9yLm9mZnNldDtcbiAgICAgICAgICB0YXJnZXQuc2VsZWN0KHByZXZPZmZzZXQsIHByZXZPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGN1cnJlbnROb2RlLmlzU2ltcGxlVGV4dCgpKSB7XG4gICAgICAgIC8vIFNwbGl0IHRleHRcbiAgICAgICAgY29uc3QgaXNTZWxlY3RlZCA9IGFuY2hvci5rZXkgPT09IGtleTtcbiAgICAgICAgbGV0IGFuY2hvck9mZnNldCA9IGFuY2hvci5vZmZzZXQ7XG4gICAgICAgIC8vIE1vdmUgb2Zmc2V0IHRvIGVuZCBpZiBpdCdzIGxlc3MgdGhhbiB0aGUgcmVtYWluaW5nIG51bWJlciwgb3RoZXJ3aXNlXG4gICAgICAgIC8vIHdlJ2xsIGhhdmUgYSBuZWdhdGl2ZSBzcGxpdFN0YXJ0LlxuICAgICAgICBpZiAoYW5jaG9yT2Zmc2V0IDwgcmVtYWluaW5nKSB7XG4gICAgICAgICAgYW5jaG9yT2Zmc2V0ID0gY3VycmVudE5vZGVTaXplO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNwbGl0U3RhcnQgPSBpc1NlbGVjdGVkID8gYW5jaG9yT2Zmc2V0IC0gcmVtYWluaW5nIDogMDtcbiAgICAgICAgY29uc3Qgc3BsaXRFbmQgPSBpc1NlbGVjdGVkID8gYW5jaG9yT2Zmc2V0IDogb2Zmc2V0O1xuICAgICAgICBpZiAoaXNTZWxlY3RlZCAmJiBzcGxpdFN0YXJ0ID09PSAwKSB7XG4gICAgICAgICAgY29uc3QgW2V4Y2Vzc05vZGVdID0gY3VycmVudE5vZGUuc3BsaXRUZXh0KHNwbGl0U3RhcnQsIHNwbGl0RW5kKTtcbiAgICAgICAgICBleGNlc3NOb2RlLnJlbW92ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IFssIGV4Y2Vzc05vZGVdID0gY3VycmVudE5vZGUuc3BsaXRUZXh0KHNwbGl0U3RhcnQsIHNwbGl0RW5kKTtcbiAgICAgICAgICBleGNlc3NOb2RlLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0ZXh0Tm9kZSA9ICRjcmVhdGVUZXh0Tm9kZShzbGljZWRUZXh0KTtcbiAgICAgICAgY3VycmVudE5vZGUucmVwbGFjZSh0ZXh0Tm9kZSk7XG4gICAgICB9XG4gICAgICByZW1haW5pbmcgPSAwO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdldHMgdGhlIFRleHROb2RlJ3Mgc3R5bGUgb2JqZWN0IGFuZCBhZGRzIHRoZSBzdHlsZXMgdG8gdGhlIENTUy5cbiAqIEBwYXJhbSBub2RlIC0gVGhlIFRleHROb2RlIHRvIGFkZCBzdHlsZXMgdG8uXG4gKi9cbmZ1bmN0aW9uICRhZGROb2RlU3R5bGUobm9kZSkge1xuICBjb25zdCBDU1NUZXh0ID0gbm9kZS5nZXRTdHlsZSgpO1xuICBjb25zdCBzdHlsZXMgPSBnZXRTdHlsZU9iamVjdEZyb21SYXdDU1MoQ1NTVGV4dCk7XG4gIENTU19UT19TVFlMRVMuc2V0KENTU1RleHQsIHN0eWxlcyk7XG59XG5mdW5jdGlvbiAkcGF0Y2hTdHlsZSh0YXJnZXQsIHBhdGNoKSB7XG4gIGNvbnN0IHByZXZTdHlsZXMgPSBnZXRTdHlsZU9iamVjdEZyb21DU1MoJ2dldFN0eWxlJyBpbiB0YXJnZXQgPyB0YXJnZXQuZ2V0U3R5bGUoKSA6IHRhcmdldC5zdHlsZSk7XG4gIGNvbnN0IG5ld1N0eWxlcyA9IE9iamVjdC5lbnRyaWVzKHBhdGNoKS5yZWR1Y2UoKHN0eWxlcywgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgc3R5bGVzW2tleV0gPSB2YWx1ZShwcmV2U3R5bGVzW2tleV0sIHRhcmdldCk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgZGVsZXRlIHN0eWxlc1trZXldO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZXNba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gc3R5bGVzO1xuICB9LCB7XG4gICAgLi4ucHJldlN0eWxlc1xuICB9IHx8IHt9KTtcbiAgY29uc3QgbmV3Q1NTVGV4dCA9IGdldENTU0Zyb21TdHlsZU9iamVjdChuZXdTdHlsZXMpO1xuICB0YXJnZXQuc2V0U3R5bGUobmV3Q1NTVGV4dCk7XG4gIENTU19UT19TVFlMRVMuc2V0KG5ld0NTU1RleHQsIG5ld1N0eWxlcyk7XG59XG5cbi8qKlxuICogQXBwbGllcyB0aGUgcHJvdmlkZWQgc3R5bGVzIHRvIHRoZSBUZXh0Tm9kZXMgaW4gdGhlIHByb3ZpZGVkIFNlbGVjdGlvbi5cbiAqIFdpbGwgdXBkYXRlIHBhcnRpYWxseSBzZWxlY3RlZCBUZXh0Tm9kZXMgYnkgc3BsaXR0aW5nIHRoZSBUZXh0Tm9kZSBhbmQgYXBwbHlpbmdcbiAqIHRoZSBzdHlsZXMgdG8gdGhlIGFwcHJvcHJpYXRlIG9uZS5cbiAqIEBwYXJhbSBzZWxlY3Rpb24gLSBUaGUgc2VsZWN0ZWQgbm9kZShzKSB0byB1cGRhdGUuXG4gKiBAcGFyYW0gcGF0Y2ggLSBUaGUgcGF0Y2ggdG8gYXBwbHksIHdoaWNoIGNhbiBpbmNsdWRlIG11bHRpcGxlIHN0eWxlcy4gXFxcXHtDU1NQcm9wZXJ0eTogdmFsdWVcXFxcfSAuIENhbiBhbHNvIGFjY2VwdCBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgbmV3IHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiAkcGF0Y2hTdHlsZVRleHQoc2VsZWN0aW9uLCBwYXRjaCkge1xuICBpZiAoc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgJiYgJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICRwYXRjaFN0eWxlKHNlbGVjdGlvbiwgcGF0Y2gpO1xuICB9IGVsc2Uge1xuICAgICRmb3JFYWNoU2VsZWN0ZWRUZXh0Tm9kZSh0ZXh0Tm9kZSA9PiB7XG4gICAgICAkcGF0Y2hTdHlsZSh0ZXh0Tm9kZSwgcGF0Y2gpO1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiAkZm9yRWFjaFNlbGVjdGVkVGV4dE5vZGUoZm4pIHtcbiAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgc2VsZWN0ZWROb2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpO1xuICBjb25zdCBzZWxlY3RlZE5vZGVzTGVuZ3RoID0gc2VsZWN0ZWROb2Rlcy5sZW5ndGg7XG4gIGNvbnN0IHtcbiAgICBhbmNob3IsXG4gICAgZm9jdXNcbiAgfSA9IHNlbGVjdGlvbjtcbiAgY29uc3QgbGFzdEluZGV4ID0gc2VsZWN0ZWROb2Rlc0xlbmd0aCAtIDE7XG4gIGxldCBmaXJzdE5vZGUgPSBzZWxlY3RlZE5vZGVzWzBdO1xuICBsZXQgbGFzdE5vZGUgPSBzZWxlY3RlZE5vZGVzW2xhc3RJbmRleF07XG4gIGNvbnN0IGZpcnN0Tm9kZVRleHQgPSBmaXJzdE5vZGUuZ2V0VGV4dENvbnRlbnQoKTtcbiAgY29uc3QgZmlyc3ROb2RlVGV4dExlbmd0aCA9IGZpcnN0Tm9kZVRleHQubGVuZ3RoO1xuICBjb25zdCBmb2N1c09mZnNldCA9IGZvY3VzLm9mZnNldDtcbiAgbGV0IGFuY2hvck9mZnNldCA9IGFuY2hvci5vZmZzZXQ7XG4gIGNvbnN0IGlzQmVmb3JlID0gYW5jaG9yLmlzQmVmb3JlKGZvY3VzKTtcbiAgbGV0IHN0YXJ0T2Zmc2V0ID0gaXNCZWZvcmUgPyBhbmNob3JPZmZzZXQgOiBmb2N1c09mZnNldDtcbiAgbGV0IGVuZE9mZnNldCA9IGlzQmVmb3JlID8gZm9jdXNPZmZzZXQgOiBhbmNob3JPZmZzZXQ7XG4gIGNvbnN0IHN0YXJ0VHlwZSA9IGlzQmVmb3JlID8gYW5jaG9yLnR5cGUgOiBmb2N1cy50eXBlO1xuICBjb25zdCBlbmRUeXBlID0gaXNCZWZvcmUgPyBmb2N1cy50eXBlIDogYW5jaG9yLnR5cGU7XG4gIGNvbnN0IGVuZEtleSA9IGlzQmVmb3JlID8gZm9jdXMua2V5IDogYW5jaG9yLmtleTtcblxuICAvLyBUaGlzIGlzIHRoZSBjYXNlIHdoZXJlIHRoZSB1c2VyIG9ubHkgc2VsZWN0ZWQgdGhlIHZlcnkgZW5kIG9mIHRoZVxuICAvLyBmaXJzdCBub2RlIHNvIHdlIGRvbid0IHdhbnQgdG8gaW5jbHVkZSBpdCBpbiB0aGUgZm9ybWF0dGluZyBjaGFuZ2UuXG4gIGlmICgkaXNUZXh0Tm9kZShmaXJzdE5vZGUpICYmIHN0YXJ0T2Zmc2V0ID09PSBmaXJzdE5vZGVUZXh0TGVuZ3RoKSB7XG4gICAgY29uc3QgbmV4dFNpYmxpbmcgPSBmaXJzdE5vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICBpZiAoJGlzVGV4dE5vZGUobmV4dFNpYmxpbmcpKSB7XG4gICAgICAvLyB3ZSBiYXNpY2FsbHkgbWFrZSB0aGUgc2Vjb25kIG5vZGUgdGhlIGZpcnN0Tm9kZSwgY2hhbmdpbmcgb2Zmc2V0cyBhY2NvcmRpbmdseVxuICAgICAgYW5jaG9yT2Zmc2V0ID0gMDtcbiAgICAgIHN0YXJ0T2Zmc2V0ID0gMDtcbiAgICAgIGZpcnN0Tm9kZSA9IG5leHRTaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRoaXMgaXMgdGhlIGNhc2Ugd2hlcmUgd2Ugb25seSBzZWxlY3RlZCBhIHNpbmdsZSBub2RlXG4gIGlmIChzZWxlY3RlZE5vZGVzLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmICgkaXNUZXh0Tm9kZShmaXJzdE5vZGUpICYmIGZpcnN0Tm9kZS5jYW5IYXZlRm9ybWF0KCkpIHtcbiAgICAgIHN0YXJ0T2Zmc2V0ID0gc3RhcnRUeXBlID09PSAnZWxlbWVudCcgPyAwIDogYW5jaG9yT2Zmc2V0ID4gZm9jdXNPZmZzZXQgPyBmb2N1c09mZnNldCA6IGFuY2hvck9mZnNldDtcbiAgICAgIGVuZE9mZnNldCA9IGVuZFR5cGUgPT09ICdlbGVtZW50JyA/IGZpcnN0Tm9kZVRleHRMZW5ndGggOiBhbmNob3JPZmZzZXQgPiBmb2N1c09mZnNldCA/IGFuY2hvck9mZnNldCA6IGZvY3VzT2Zmc2V0O1xuXG4gICAgICAvLyBObyBhY3R1YWwgdGV4dCBpcyBzZWxlY3RlZCwgc28gZG8gbm90aGluZy5cbiAgICAgIGlmIChzdGFydE9mZnNldCA9PT0gZW5kT2Zmc2V0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGVudGlyZSBub2RlIGlzIHNlbGVjdGVkIG9yIGEgdG9rZW4vc2VnbWVudCwgc28ganVzdCBmb3JtYXQgaXRcbiAgICAgIGlmICgkaXNUb2tlbk9yU2VnbWVudGVkKGZpcnN0Tm9kZSkgfHwgc3RhcnRPZmZzZXQgPT09IDAgJiYgZW5kT2Zmc2V0ID09PSBmaXJzdE5vZGVUZXh0TGVuZ3RoKSB7XG4gICAgICAgIGZuKGZpcnN0Tm9kZSk7XG4gICAgICAgIGZpcnN0Tm9kZS5zZWxlY3Qoc3RhcnRPZmZzZXQsIGVuZE9mZnNldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGUgbm9kZSBpcyBwYXJ0aWFsbHkgc2VsZWN0ZWQsIHNvIHNwbGl0IGl0IGludG8gdHdvIG5vZGVzXG4gICAgICAgIC8vIGFuZCBzdHlsZSB0aGUgc2VsZWN0ZWQgb25lLlxuICAgICAgICBjb25zdCBzcGxpdE5vZGVzID0gZmlyc3ROb2RlLnNwbGl0VGV4dChzdGFydE9mZnNldCwgZW5kT2Zmc2V0KTtcbiAgICAgICAgY29uc3QgcmVwbGFjZW1lbnQgPSBzdGFydE9mZnNldCA9PT0gMCA/IHNwbGl0Tm9kZXNbMF0gOiBzcGxpdE5vZGVzWzFdO1xuICAgICAgICBmbihyZXBsYWNlbWVudCk7XG4gICAgICAgIHJlcGxhY2VtZW50LnNlbGVjdCgwLCBlbmRPZmZzZXQgLSBzdGFydE9mZnNldCk7XG4gICAgICB9XG4gICAgfSAvLyBtdWx0aXBsZSBub2RlcyBzZWxlY3RlZC5cbiAgfSBlbHNlIHtcbiAgICBpZiAoJGlzVGV4dE5vZGUoZmlyc3ROb2RlKSAmJiBzdGFydE9mZnNldCA8IGZpcnN0Tm9kZS5nZXRUZXh0Q29udGVudFNpemUoKSAmJiBmaXJzdE5vZGUuY2FuSGF2ZUZvcm1hdCgpKSB7XG4gICAgICBpZiAoc3RhcnRPZmZzZXQgIT09IDAgJiYgISRpc1Rva2VuT3JTZWdtZW50ZWQoZmlyc3ROb2RlKSkge1xuICAgICAgICAvLyB0aGUgZW50aXJlIGZpcnN0IG5vZGUgaXNuJ3Qgc2VsZWN0ZWQgYW5kIGl0IGlzbid0IGEgdG9rZW4gb3Igc2VnbWVudGVkLCBzbyBzcGxpdCBpdFxuICAgICAgICBmaXJzdE5vZGUgPSBmaXJzdE5vZGUuc3BsaXRUZXh0KHN0YXJ0T2Zmc2V0KVsxXTtcbiAgICAgICAgc3RhcnRPZmZzZXQgPSAwO1xuICAgICAgICBpZiAoaXNCZWZvcmUpIHtcbiAgICAgICAgICBhbmNob3Iuc2V0KGZpcnN0Tm9kZS5nZXRLZXkoKSwgc3RhcnRPZmZzZXQsICd0ZXh0Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9jdXMuc2V0KGZpcnN0Tm9kZS5nZXRLZXkoKSwgc3RhcnRPZmZzZXQsICd0ZXh0Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZuKGZpcnN0Tm9kZSk7XG4gICAgfVxuICAgIGlmICgkaXNUZXh0Tm9kZShsYXN0Tm9kZSkgJiYgbGFzdE5vZGUuY2FuSGF2ZUZvcm1hdCgpKSB7XG4gICAgICBjb25zdCBsYXN0Tm9kZVRleHQgPSBsYXN0Tm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICAgICAgY29uc3QgbGFzdE5vZGVUZXh0TGVuZ3RoID0gbGFzdE5vZGVUZXh0Lmxlbmd0aDtcblxuICAgICAgLy8gVGhlIGxhc3Qgbm9kZSBtaWdodCBub3QgYWN0dWFsbHkgYmUgdGhlIGVuZCBub2RlXG4gICAgICAvL1xuICAgICAgLy8gSWYgbm90LCBhc3N1bWUgdGhlIGxhc3Qgbm9kZSBpcyBmdWxseS1zZWxlY3RlZCB1bmxlc3MgdGhlIGVuZCBvZmZzZXQgaXNcbiAgICAgIC8vIHplcm8uXG4gICAgICBpZiAobGFzdE5vZGUuX19rZXkgIT09IGVuZEtleSAmJiBlbmRPZmZzZXQgIT09IDApIHtcbiAgICAgICAgZW5kT2Zmc2V0ID0gbGFzdE5vZGVUZXh0TGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiB0aGUgZW50aXJlIGxhc3Qgbm9kZSBpc24ndCBzZWxlY3RlZCBhbmQgaXQgaXNuJ3QgYSB0b2tlbiBvciBzZWdtZW50ZWQsIHNwbGl0IGl0XG4gICAgICBpZiAoZW5kT2Zmc2V0ICE9PSBsYXN0Tm9kZVRleHRMZW5ndGggJiYgISRpc1Rva2VuT3JTZWdtZW50ZWQobGFzdE5vZGUpKSB7XG4gICAgICAgIFtsYXN0Tm9kZV0gPSBsYXN0Tm9kZS5zcGxpdFRleHQoZW5kT2Zmc2V0KTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmRPZmZzZXQgIT09IDAgfHwgZW5kVHlwZSA9PT0gJ2VsZW1lbnQnKSB7XG4gICAgICAgIGZuKGxhc3ROb2RlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzdHlsZSBhbGwgdGhlIHRleHQgbm9kZXMgaW4gYmV0d2VlblxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbGFzdEluZGV4OyBpKyspIHtcbiAgICAgIGNvbnN0IHNlbGVjdGVkTm9kZSA9IHNlbGVjdGVkTm9kZXNbaV07XG4gICAgICBjb25zdCBzZWxlY3RlZE5vZGVLZXkgPSBzZWxlY3RlZE5vZGUuZ2V0S2V5KCk7XG4gICAgICBpZiAoJGlzVGV4dE5vZGUoc2VsZWN0ZWROb2RlKSAmJiBzZWxlY3RlZE5vZGUuY2FuSGF2ZUZvcm1hdCgpICYmIHNlbGVjdGVkTm9kZUtleSAhPT0gZmlyc3ROb2RlLmdldEtleSgpICYmIHNlbGVjdGVkTm9kZUtleSAhPT0gbGFzdE5vZGUuZ2V0S2V5KCkgJiYgIXNlbGVjdGVkTm9kZS5pc1Rva2VuKCkpIHtcbiAgICAgICAgZm4oc2VsZWN0ZWROb2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5cbi8qKlxuICogQ29udmVydHMgYWxsIG5vZGVzIGluIHRoZSBzZWxlY3Rpb24gdGhhdCBhcmUgb2Ygb25lIGJsb2NrIHR5cGUgdG8gYW5vdGhlci5cbiAqIEBwYXJhbSBzZWxlY3Rpb24gLSBUaGUgc2VsZWN0ZWQgYmxvY2tzIHRvIGJlIGNvbnZlcnRlZC5cbiAqIEBwYXJhbSBjcmVhdGVFbGVtZW50IC0gVGhlIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyB0aGUgbm9kZS4gZWcuICRjcmVhdGVQYXJhZ3JhcGhOb2RlLlxuICovXG5mdW5jdGlvbiAkc2V0QmxvY2tzVHlwZShzZWxlY3Rpb24sIGNyZWF0ZUVsZW1lbnQpIHtcbiAgaWYgKHNlbGVjdGlvbiA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBhbmNob3JBbmRGb2N1cyA9IHNlbGVjdGlvbi5nZXRTdGFydEVuZFBvaW50cygpO1xuICBjb25zdCBhbmNob3IgPSBhbmNob3JBbmRGb2N1cyA/IGFuY2hvckFuZEZvY3VzWzBdIDogbnVsbDtcbiAgaWYgKGFuY2hvciAhPT0gbnVsbCAmJiBhbmNob3Iua2V5ID09PSAncm9vdCcpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gY3JlYXRlRWxlbWVudCgpO1xuICAgIGNvbnN0IHJvb3QgPSAkZ2V0Um9vdCgpO1xuICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSByb290LmdldEZpcnN0Q2hpbGQoKTtcbiAgICBpZiAoZmlyc3RDaGlsZCkge1xuICAgICAgZmlyc3RDaGlsZC5yZXBsYWNlKGVsZW1lbnQsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByb290LmFwcGVuZChlbGVtZW50KTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG5vZGVzID0gc2VsZWN0aW9uLmdldE5vZGVzKCk7XG4gIGNvbnN0IGZpcnN0U2VsZWN0ZWRCbG9jayA9IGFuY2hvciAhPT0gbnVsbCA/ICRnZXRBbmNlc3RvcihhbmNob3IuZ2V0Tm9kZSgpLCBJTlRFUk5BTF8kaXNCbG9jaykgOiBmYWxzZTtcbiAgaWYgKGZpcnN0U2VsZWN0ZWRCbG9jayAmJiBub2Rlcy5pbmRleE9mKGZpcnN0U2VsZWN0ZWRCbG9jaykgPT09IC0xKSB7XG4gICAgbm9kZXMucHVzaChmaXJzdFNlbGVjdGVkQmxvY2spO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgaWYgKCFJTlRFUk5BTF8kaXNCbG9jayhub2RlKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICghJGlzRWxlbWVudE5vZGUobm9kZSkpIHtcbiAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCBibG9jayBub2RlIHRvIGJlIGFuIEVsZW1lbnROb2RlYCk7XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldEVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KCk7XG4gICAgdGFyZ2V0RWxlbWVudC5zZXRGb3JtYXQobm9kZS5nZXRGb3JtYXRUeXBlKCkpO1xuICAgIHRhcmdldEVsZW1lbnQuc2V0SW5kZW50KG5vZGUuZ2V0SW5kZW50KCkpO1xuICAgIG5vZGUucmVwbGFjZSh0YXJnZXRFbGVtZW50LCB0cnVlKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNQb2ludEF0dGFjaGVkKHBvaW50KSB7XG4gIHJldHVybiBwb2ludC5nZXROb2RlKCkuaXNBdHRhY2hlZCgpO1xufVxuZnVuY3Rpb24gJHJlbW92ZVBhcmVudEVtcHR5RWxlbWVudHMoc3RhcnRpbmdOb2RlKSB7XG4gIGxldCBub2RlID0gc3RhcnRpbmdOb2RlO1xuICB3aGlsZSAobm9kZSAhPT0gbnVsbCAmJiAhJGlzUm9vdE9yU2hhZG93Um9vdChub2RlKSkge1xuICAgIGNvbnN0IGxhdGVzdCA9IG5vZGUuZ2V0TGF0ZXN0KCk7XG4gICAgY29uc3QgcGFyZW50Tm9kZSA9IG5vZGUuZ2V0UGFyZW50KCk7XG4gICAgaWYgKGxhdGVzdC5nZXRDaGlsZHJlblNpemUoKSA9PT0gMCkge1xuICAgICAgbm9kZS5yZW1vdmUodHJ1ZSk7XG4gICAgfVxuICAgIG5vZGUgPSBwYXJlbnROb2RlO1xuICB9XG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWRcbiAqIFdyYXBzIGFsbCBub2RlcyBpbiB0aGUgc2VsZWN0aW9uIGludG8gYW5vdGhlciBub2RlIG9mIHRoZSB0eXBlIHJldHVybmVkIGJ5IGNyZWF0ZUVsZW1lbnQuXG4gKiBAcGFyYW0gc2VsZWN0aW9uIC0gVGhlIHNlbGVjdGlvbiBvZiBub2RlcyB0byBiZSB3cmFwcGVkLlxuICogQHBhcmFtIGNyZWF0ZUVsZW1lbnQgLSBBIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyB0aGUgd3JhcHBpbmcgRWxlbWVudE5vZGUuIGVnLiAkY3JlYXRlUGFyYWdyYXBoTm9kZS5cbiAqIEBwYXJhbSB3cmFwcGluZ0VsZW1lbnQgLSBBbiBlbGVtZW50IHRvIGFwcGVuZCB0aGUgd3JhcHBlZCBzZWxlY3Rpb24gYW5kIGl0cyBjaGlsZHJlbiB0by5cbiAqL1xuZnVuY3Rpb24gJHdyYXBOb2RlcyhzZWxlY3Rpb24sIGNyZWF0ZUVsZW1lbnQsIHdyYXBwaW5nRWxlbWVudCA9IG51bGwpIHtcbiAgY29uc3QgYW5jaG9yQW5kRm9jdXMgPSBzZWxlY3Rpb24uZ2V0U3RhcnRFbmRQb2ludHMoKTtcbiAgY29uc3QgYW5jaG9yID0gYW5jaG9yQW5kRm9jdXMgPyBhbmNob3JBbmRGb2N1c1swXSA6IG51bGw7XG4gIGNvbnN0IG5vZGVzID0gc2VsZWN0aW9uLmdldE5vZGVzKCk7XG4gIGNvbnN0IG5vZGVzTGVuZ3RoID0gbm9kZXMubGVuZ3RoO1xuICBpZiAoYW5jaG9yICE9PSBudWxsICYmIChub2Rlc0xlbmd0aCA9PT0gMCB8fCBub2Rlc0xlbmd0aCA9PT0gMSAmJiBhbmNob3IudHlwZSA9PT0gJ2VsZW1lbnQnICYmIGFuY2hvci5nZXROb2RlKCkuZ2V0Q2hpbGRyZW5TaXplKCkgPT09IDApKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gYW5jaG9yLnR5cGUgPT09ICd0ZXh0JyA/IGFuY2hvci5nZXROb2RlKCkuZ2V0UGFyZW50T3JUaHJvdygpIDogYW5jaG9yLmdldE5vZGUoKTtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRhcmdldC5nZXRDaGlsZHJlbigpO1xuICAgIGxldCBlbGVtZW50ID0gY3JlYXRlRWxlbWVudCgpO1xuICAgIGVsZW1lbnQuc2V0Rm9ybWF0KHRhcmdldC5nZXRGb3JtYXRUeXBlKCkpO1xuICAgIGVsZW1lbnQuc2V0SW5kZW50KHRhcmdldC5nZXRJbmRlbnQoKSk7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiBlbGVtZW50LmFwcGVuZChjaGlsZCkpO1xuICAgIGlmICh3cmFwcGluZ0VsZW1lbnQpIHtcbiAgICAgIGVsZW1lbnQgPSB3cmFwcGluZ0VsZW1lbnQuYXBwZW5kKGVsZW1lbnQpO1xuICAgIH1cbiAgICB0YXJnZXQucmVwbGFjZShlbGVtZW50KTtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IHRvcExldmVsTm9kZSA9IG51bGw7XG4gIGxldCBkZXNjZW5kYW50cyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzTGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgLy8gRGV0ZXJtaW5lIHdoZXRoZXIgd3JhcHBpbmcgaGFzIHRvIGJlIGJyb2tlbiBkb3duIGludG8gbXVsdGlwbGUgY2h1bmtzLiBUaGlzIGNhbiBoYXBwZW4gaWYgdGhlXG4gICAgLy8gdXNlciBzZWxlY3RlZCBtdWx0aXBsZSBSb290LWxpa2Ugbm9kZXMgdGhhdCBoYXZlIHRvIGJlIHRyZWF0ZWQgc2VwYXJhdGVseSBhcyBpZiB0aGV5IGFyZVxuICAgIC8vIHRoZWlyIG93biBicmFuY2guIEkuZS4geW91IGRvbid0IHdhbnQgdG8gd3JhcCBhIHdob2xlIHRhYmxlLCBidXQgcmF0aGVyIHRoZSBjb250ZW50cyBvZiBlYWNoXG4gICAgLy8gb2YgZWFjaCBvZiB0aGUgY2VsbCBub2Rlcy5cbiAgICBpZiAoJGlzUm9vdE9yU2hhZG93Um9vdChub2RlKSkge1xuICAgICAgJHdyYXBOb2Rlc0ltcGwoc2VsZWN0aW9uLCBkZXNjZW5kYW50cywgZGVzY2VuZGFudHMubGVuZ3RoLCBjcmVhdGVFbGVtZW50LCB3cmFwcGluZ0VsZW1lbnQpO1xuICAgICAgZGVzY2VuZGFudHMgPSBbXTtcbiAgICAgIHRvcExldmVsTm9kZSA9IG5vZGU7XG4gICAgfSBlbHNlIGlmICh0b3BMZXZlbE5vZGUgPT09IG51bGwgfHwgdG9wTGV2ZWxOb2RlICE9PSBudWxsICYmICRoYXNBbmNlc3Rvcihub2RlLCB0b3BMZXZlbE5vZGUpKSB7XG4gICAgICBkZXNjZW5kYW50cy5wdXNoKG5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkd3JhcE5vZGVzSW1wbChzZWxlY3Rpb24sIGRlc2NlbmRhbnRzLCBkZXNjZW5kYW50cy5sZW5ndGgsIGNyZWF0ZUVsZW1lbnQsIHdyYXBwaW5nRWxlbWVudCk7XG4gICAgICBkZXNjZW5kYW50cyA9IFtub2RlXTtcbiAgICB9XG4gIH1cbiAgJHdyYXBOb2Rlc0ltcGwoc2VsZWN0aW9uLCBkZXNjZW5kYW50cywgZGVzY2VuZGFudHMubGVuZ3RoLCBjcmVhdGVFbGVtZW50LCB3cmFwcGluZ0VsZW1lbnQpO1xufVxuXG4vKipcbiAqIFdyYXBzIGVhY2ggbm9kZSBpbnRvIGEgbmV3IEVsZW1lbnROb2RlLlxuICogQHBhcmFtIHNlbGVjdGlvbiAtIFRoZSBzZWxlY3Rpb24gb2Ygbm9kZXMgdG8gd3JhcC5cbiAqIEBwYXJhbSBub2RlcyAtIEFuIGFycmF5IG9mIG5vZGVzLCBnZW5lcmFsbHkgdGhlIGRlc2NlbmRhbnRzIG9mIHRoZSBzZWxlY3Rpb24uXG4gKiBAcGFyYW0gbm9kZXNMZW5ndGggLSBUaGUgbGVuZ3RoIG9mIG5vZGVzLlxuICogQHBhcmFtIGNyZWF0ZUVsZW1lbnQgLSBBIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyB0aGUgd3JhcHBpbmcgRWxlbWVudE5vZGUuIGVnLiAkY3JlYXRlUGFyYWdyYXBoTm9kZS5cbiAqIEBwYXJhbSB3cmFwcGluZ0VsZW1lbnQgLSBBbiBlbGVtZW50IHRvIHdyYXAgYWxsIHRoZSBub2RlcyBpbnRvLlxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gJHdyYXBOb2Rlc0ltcGwoc2VsZWN0aW9uLCBub2Rlcywgbm9kZXNMZW5ndGgsIGNyZWF0ZUVsZW1lbnQsIHdyYXBwaW5nRWxlbWVudCA9IG51bGwpIHtcbiAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBmaXJzdE5vZGUgPSBub2Rlc1swXTtcbiAgY29uc3QgZWxlbWVudE1hcHBpbmcgPSBuZXcgTWFwKCk7XG4gIGNvbnN0IGVsZW1lbnRzID0gW107XG4gIC8vIFRoZSBiZWxvdyBsb2dpYyBpcyB0byBmaW5kIHRoZSByaWdodCB0YXJnZXQgZm9yIHVzIHRvXG4gIC8vIGVpdGhlciBpbnNlcnRBZnRlci9pbnNlcnRCZWZvcmUvYXBwZW5kIHRoZSBjb3JyZXNwb25kaW5nXG4gIC8vIGVsZW1lbnRzIHRvLiBUaGlzIGlzIG1hZGUgbW9yZSBjb21wbGljYXRlZCBkdWUgdG8gbmVzdGVkXG4gIC8vIHN0cnVjdHVyZXMuXG4gIGxldCB0YXJnZXQgPSAkaXNFbGVtZW50Tm9kZShmaXJzdE5vZGUpID8gZmlyc3ROb2RlIDogZmlyc3ROb2RlLmdldFBhcmVudE9yVGhyb3coKTtcbiAgaWYgKHRhcmdldC5pc0lubGluZSgpKSB7XG4gICAgdGFyZ2V0ID0gdGFyZ2V0LmdldFBhcmVudE9yVGhyb3coKTtcbiAgfVxuICBsZXQgdGFyZ2V0SXNQcmV2U2libGluZyA9IGZhbHNlO1xuICB3aGlsZSAodGFyZ2V0ICE9PSBudWxsKSB7XG4gICAgY29uc3QgcHJldlNpYmxpbmcgPSB0YXJnZXQuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgaWYgKHByZXZTaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICB0YXJnZXQgPSBwcmV2U2libGluZztcbiAgICAgIHRhcmdldElzUHJldlNpYmxpbmcgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRhcmdldCA9IHRhcmdldC5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgaWYgKCRpc1Jvb3RPclNoYWRvd1Jvb3QodGFyZ2V0KSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGNvbnN0IGVtcHR5RWxlbWVudHMgPSBuZXcgU2V0KCk7XG5cbiAgLy8gRmluZCBhbnkgdG9wIGxldmVsIGVtcHR5IGVsZW1lbnRzXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXNMZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICBpZiAoJGlzRWxlbWVudE5vZGUobm9kZSkgJiYgbm9kZS5nZXRDaGlsZHJlblNpemUoKSA9PT0gMCkge1xuICAgICAgZW1wdHlFbGVtZW50cy5hZGQobm9kZS5nZXRLZXkoKSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IG1vdmVkTm9kZXMgPSBuZXcgU2V0KCk7XG5cbiAgLy8gTW92ZSBvdXQgYWxsIGxlYWYgbm9kZXMgaW50byBvdXIgZWxlbWVudHMgYXJyYXkuXG4gIC8vIElmIHdlIGZpbmQgYSB0b3AgbGV2ZWwgZW1wdHkgZWxlbWVudCwgYWxzbyBtb3ZlIG1ha2VcbiAgLy8gYW4gZWxlbWVudCBmb3IgdGhhdC5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlc0xlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgIGxldCBwYXJlbnQgPSBub2RlLmdldFBhcmVudCgpO1xuICAgIGlmIChwYXJlbnQgIT09IG51bGwgJiYgcGFyZW50LmlzSW5saW5lKCkpIHtcbiAgICAgIHBhcmVudCA9IHBhcmVudC5nZXRQYXJlbnQoKTtcbiAgICB9XG4gICAgaWYgKHBhcmVudCAhPT0gbnVsbCAmJiAkaXNMZWFmTm9kZShub2RlKSAmJiAhbW92ZWROb2Rlcy5oYXMobm9kZS5nZXRLZXkoKSkpIHtcbiAgICAgIGNvbnN0IHBhcmVudEtleSA9IHBhcmVudC5nZXRLZXkoKTtcbiAgICAgIGlmIChlbGVtZW50TWFwcGluZy5nZXQocGFyZW50S2V5KSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldEVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KCk7XG4gICAgICAgIHRhcmdldEVsZW1lbnQuc2V0Rm9ybWF0KHBhcmVudC5nZXRGb3JtYXRUeXBlKCkpO1xuICAgICAgICB0YXJnZXRFbGVtZW50LnNldEluZGVudChwYXJlbnQuZ2V0SW5kZW50KCkpO1xuICAgICAgICBlbGVtZW50cy5wdXNoKHRhcmdldEVsZW1lbnQpO1xuICAgICAgICBlbGVtZW50TWFwcGluZy5zZXQocGFyZW50S2V5LCB0YXJnZXRFbGVtZW50KTtcbiAgICAgICAgLy8gTW92ZSBub2RlIGFuZCBpdHMgc2libGluZ3MgdG8gdGhlIG5ld1xuICAgICAgICAvLyBlbGVtZW50LlxuICAgICAgICBwYXJlbnQuZ2V0Q2hpbGRyZW4oKS5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgICB0YXJnZXRFbGVtZW50LmFwcGVuZChjaGlsZCk7XG4gICAgICAgICAgbW92ZWROb2Rlcy5hZGQoY2hpbGQuZ2V0S2V5KCkpO1xuICAgICAgICAgIGlmICgkaXNFbGVtZW50Tm9kZShjaGlsZCkpIHtcbiAgICAgICAgICAgIC8vIFNraXAgbmVzdGVkIGxlYWYgbm9kZXMgaWYgdGhlIHBhcmVudCBoYXMgYWxyZWFkeSBiZWVuIG1vdmVkXG4gICAgICAgICAgICBjaGlsZC5nZXRDaGlsZHJlbktleXMoKS5mb3JFYWNoKGtleSA9PiBtb3ZlZE5vZGVzLmFkZChrZXkpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAkcmVtb3ZlUGFyZW50RW1wdHlFbGVtZW50cyhwYXJlbnQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZW1wdHlFbGVtZW50cy5oYXMobm9kZS5nZXRLZXkoKSkpIHtcbiAgICAgIGlmICghJGlzRWxlbWVudE5vZGUobm9kZSkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIG5vZGUgaW4gZW1wdHlFbGVtZW50cyB0byBiZSBhbiBFbGVtZW50Tm9kZWApO1xuICAgICAgfVxuICAgICAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQoKTtcbiAgICAgIHRhcmdldEVsZW1lbnQuc2V0Rm9ybWF0KG5vZGUuZ2V0Rm9ybWF0VHlwZSgpKTtcbiAgICAgIHRhcmdldEVsZW1lbnQuc2V0SW5kZW50KG5vZGUuZ2V0SW5kZW50KCkpO1xuICAgICAgZWxlbWVudHMucHVzaCh0YXJnZXRFbGVtZW50KTtcbiAgICAgIG5vZGUucmVtb3ZlKHRydWUpO1xuICAgIH1cbiAgfVxuICBpZiAod3JhcHBpbmdFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuICAgICAgd3JhcHBpbmdFbGVtZW50LmFwcGVuZChlbGVtZW50KTtcbiAgICB9XG4gIH1cbiAgbGV0IGxhc3RFbGVtZW50ID0gbnVsbDtcblxuICAvLyBJZiBvdXIgdGFyZ2V0IGlzIFJvb3QtbGlrZSwgbGV0J3Mgc2VlIGlmIHdlIGNhbiByZS1hZGp1c3RcbiAgLy8gc28gdGhhdCB0aGUgdGFyZ2V0IGlzIHRoZSBmaXJzdCBjaGlsZCBpbnN0ZWFkLlxuICBpZiAoJGlzUm9vdE9yU2hhZG93Um9vdCh0YXJnZXQpKSB7XG4gICAgaWYgKHRhcmdldElzUHJldlNpYmxpbmcpIHtcbiAgICAgIGlmICh3cmFwcGluZ0VsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgdGFyZ2V0Lmluc2VydEFmdGVyKHdyYXBwaW5nRWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpID0gZWxlbWVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICAgICAgdGFyZ2V0Lmluc2VydEFmdGVyKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSB0YXJnZXQuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgICAgaWYgKCRpc0VsZW1lbnROb2RlKGZpcnN0Q2hpbGQpKSB7XG4gICAgICAgIHRhcmdldCA9IGZpcnN0Q2hpbGQ7XG4gICAgICB9XG4gICAgICBpZiAoZmlyc3RDaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICBpZiAod3JhcHBpbmdFbGVtZW50KSB7XG4gICAgICAgICAgdGFyZ2V0LmFwcGVuZCh3cmFwcGluZ0VsZW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICAgICAgICAgIHRhcmdldC5hcHBlbmQoZWxlbWVudCk7XG4gICAgICAgICAgICBsYXN0RWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAod3JhcHBpbmdFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgZmlyc3RDaGlsZC5pbnNlcnRCZWZvcmUod3JhcHBpbmdFbGVtZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICAgICAgICBmaXJzdENoaWxkLmluc2VydEJlZm9yZShlbGVtZW50KTtcbiAgICAgICAgICAgIGxhc3RFbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHdyYXBwaW5nRWxlbWVudCkge1xuICAgICAgdGFyZ2V0Lmluc2VydEFmdGVyKHdyYXBwaW5nRWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGkgPSBlbGVtZW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICAgIHRhcmdldC5pbnNlcnRBZnRlcihlbGVtZW50KTtcbiAgICAgICAgbGFzdEVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBwcmV2U2VsZWN0aW9uID0gJGdldFByZXZpb3VzU2VsZWN0aW9uKCk7XG4gIGlmICgkaXNSYW5nZVNlbGVjdGlvbihwcmV2U2VsZWN0aW9uKSAmJiBpc1BvaW50QXR0YWNoZWQocHJldlNlbGVjdGlvbi5hbmNob3IpICYmIGlzUG9pbnRBdHRhY2hlZChwcmV2U2VsZWN0aW9uLmZvY3VzKSkge1xuICAgICRzZXRTZWxlY3Rpb24ocHJldlNlbGVjdGlvbi5jbG9uZSgpKTtcbiAgfSBlbHNlIGlmIChsYXN0RWxlbWVudCAhPT0gbnVsbCkge1xuICAgIGxhc3RFbGVtZW50LnNlbGVjdEVuZCgpO1xuICB9IGVsc2Uge1xuICAgIHNlbGVjdGlvbi5kaXJ0eSA9IHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBkZWZhdWx0IGNoYXJhY3RlciBzZWxlY3Rpb24gc2hvdWxkIGJlIG92ZXJyaWRkZW4uIFVzZWQgd2l0aCBEZWNvcmF0b3JOb2Rlc1xuICogQHBhcmFtIHNlbGVjdGlvbiAtIFRoZSBzZWxlY3Rpb24gd2hvc2UgZGVmYXVsdCBjaGFyYWN0ZXIgc2VsZWN0aW9uIG1heSBuZWVkIHRvIGJlIG92ZXJyaWRkZW4uXG4gKiBAcGFyYW0gaXNCYWNrd2FyZCAtIElzIHRoZSBzZWxlY3Rpb24gYmFja3dhcmRzICh0aGUgZm9jdXMgY29tZXMgYmVmb3JlIHRoZSBhbmNob3IpP1xuICogQHJldHVybnMgdHJ1ZSBpZiBpdCBzaG91bGQgYmUgb3ZlcnJpZGRlbiwgZmFsc2UgaWYgbm90LlxuICovXG5mdW5jdGlvbiAkc2hvdWxkT3ZlcnJpZGVEZWZhdWx0Q2hhcmFjdGVyU2VsZWN0aW9uKHNlbGVjdGlvbiwgaXNCYWNrd2FyZCkge1xuICBjb25zdCBwb3NzaWJsZU5vZGUgPSAkZ2V0QWRqYWNlbnROb2RlKHNlbGVjdGlvbi5mb2N1cywgaXNCYWNrd2FyZCk7XG4gIHJldHVybiAkaXNEZWNvcmF0b3JOb2RlKHBvc3NpYmxlTm9kZSkgJiYgIXBvc3NpYmxlTm9kZS5pc0lzb2xhdGVkKCkgfHwgJGlzRWxlbWVudE5vZGUocG9zc2libGVOb2RlKSAmJiAhcG9zc2libGVOb2RlLmlzSW5saW5lKCkgJiYgIXBvc3NpYmxlTm9kZS5jYW5CZUVtcHR5KCk7XG59XG5cbi8qKlxuICogTW92ZXMgdGhlIHNlbGVjdGlvbiBhY2NvcmRpbmcgdG8gdGhlIGFyZ3VtZW50cy5cbiAqIEBwYXJhbSBzZWxlY3Rpb24gLSBUaGUgc2VsZWN0ZWQgdGV4dCBvciBub2Rlcy5cbiAqIEBwYXJhbSBpc0hvbGRpbmdTaGlmdCAtIElzIHRoZSBzaGlmdCBrZXkgYmVpbmcgaGVsZCBkb3duIGR1cmluZyB0aGUgb3BlcmF0aW9uLlxuICogQHBhcmFtIGlzQmFja3dhcmQgLSBJcyB0aGUgc2VsZWN0aW9uIHNlbGVjdGVkIGJhY2t3YXJkcyAodGhlIGZvY3VzIGNvbWVzIGJlZm9yZSB0aGUgYW5jaG9yKT9cbiAqIEBwYXJhbSBncmFudWxhcml0eSAtIFRoZSBkaXN0YW5jZSB0byBhZGp1c3QgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICovXG5mdW5jdGlvbiAkbW92ZUNhcmV0U2VsZWN0aW9uKHNlbGVjdGlvbiwgaXNIb2xkaW5nU2hpZnQsIGlzQmFja3dhcmQsIGdyYW51bGFyaXR5KSB7XG4gIHNlbGVjdGlvbi5tb2RpZnkoaXNIb2xkaW5nU2hpZnQgPyAnZXh0ZW5kJyA6ICdtb3ZlJywgaXNCYWNrd2FyZCwgZ3JhbnVsYXJpdHkpO1xufVxuXG4vKipcbiAqIFRlc3RzIGEgcGFyZW50IGVsZW1lbnQgZm9yIHJpZ2h0IHRvIGxlZnQgZGlyZWN0aW9uLlxuICogQHBhcmFtIHNlbGVjdGlvbiAtIFRoZSBzZWxlY3Rpb24gd2hvc2UgcGFyZW50IGlzIHRvIGJlIHRlc3RlZC5cbiAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHNlbGVjdGlvbnMnIHBhcmVudCBlbGVtZW50IGhhcyBhIGRpcmVjdGlvbiBvZiAncnRsJyAocmlnaHQgdG8gbGVmdCksIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gJGlzUGFyZW50RWxlbWVudFJUTChzZWxlY3Rpb24pIHtcbiAgY29uc3QgYW5jaG9yTm9kZSA9IHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpO1xuICBjb25zdCBwYXJlbnQgPSAkaXNSb290Tm9kZShhbmNob3JOb2RlKSA/IGFuY2hvck5vZGUgOiBhbmNob3JOb2RlLmdldFBhcmVudE9yVGhyb3coKTtcbiAgcmV0dXJuIHBhcmVudC5nZXREaXJlY3Rpb24oKSA9PT0gJ3J0bCc7XG59XG5cbi8qKlxuICogTW92ZXMgc2VsZWN0aW9uIGJ5IGNoYXJhY3RlciBhY2NvcmRpbmcgdG8gYXJndW1lbnRzLlxuICogQHBhcmFtIHNlbGVjdGlvbiAtIFRoZSBzZWxlY3Rpb24gb2YgdGhlIGNoYXJhY3RlcnMgdG8gbW92ZS5cbiAqIEBwYXJhbSBpc0hvbGRpbmdTaGlmdCAtIElzIHRoZSBzaGlmdCBrZXkgYmVpbmcgaGVsZCBkb3duIGR1cmluZyB0aGUgb3BlcmF0aW9uLlxuICogQHBhcmFtIGlzQmFja3dhcmQgLSBJcyB0aGUgc2VsZWN0aW9uIGJhY2t3YXJkICh0aGUgZm9jdXMgY29tZXMgYmVmb3JlIHRoZSBhbmNob3IpP1xuICovXG5mdW5jdGlvbiAkbW92ZUNoYXJhY3RlcihzZWxlY3Rpb24sIGlzSG9sZGluZ1NoaWZ0LCBpc0JhY2t3YXJkKSB7XG4gIGNvbnN0IGlzUlRMID0gJGlzUGFyZW50RWxlbWVudFJUTChzZWxlY3Rpb24pO1xuICAkbW92ZUNhcmV0U2VsZWN0aW9uKHNlbGVjdGlvbiwgaXNIb2xkaW5nU2hpZnQsIGlzQmFja3dhcmQgPyAhaXNSVEwgOiBpc1JUTCwgJ2NoYXJhY3RlcicpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgYSBDU1MgcHJvcGVydHkgZm9yIE5vZGVzLCBpZiBzZXQuIElmIG5vdCBzZXQsIGl0IHJldHVybnMgdGhlIGRlZmF1bHRWYWx1ZS5cbiAqIEBwYXJhbSBub2RlIC0gVGhlIG5vZGUgd2hvc2Ugc3R5bGUgdmFsdWUgdG8gZ2V0LlxuICogQHBhcmFtIHN0eWxlUHJvcGVydHkgLSBUaGUgQ1NTIHN0eWxlIHByb3BlcnR5LlxuICogQHBhcmFtIGRlZmF1bHRWYWx1ZSAtIFRoZSBkZWZhdWx0IHZhbHVlIGZvciB0aGUgcHJvcGVydHkuXG4gKiBAcmV0dXJucyBUaGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5IGZvciBub2RlLlxuICovXG5mdW5jdGlvbiAkZ2V0Tm9kZVN0eWxlVmFsdWVGb3JQcm9wZXJ0eShub2RlLCBzdHlsZVByb3BlcnR5LCBkZWZhdWx0VmFsdWUpIHtcbiAgY29uc3QgY3NzID0gbm9kZS5nZXRTdHlsZSgpO1xuICBjb25zdCBzdHlsZU9iamVjdCA9IGdldFN0eWxlT2JqZWN0RnJvbUNTUyhjc3MpO1xuICBpZiAoc3R5bGVPYmplY3QgIT09IG51bGwpIHtcbiAgICByZXR1cm4gc3R5bGVPYmplY3Rbc3R5bGVQcm9wZXJ0eV0gfHwgZGVmYXVsdFZhbHVlO1xuICB9XG4gIHJldHVybiBkZWZhdWx0VmFsdWU7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCB2YWx1ZSBvZiBhIENTUyBwcm9wZXJ0eSBmb3IgVGV4dE5vZGVzIGluIHRoZSBTZWxlY3Rpb24sIGlmIHNldC4gSWYgbm90IHNldCwgaXQgcmV0dXJucyB0aGUgZGVmYXVsdFZhbHVlLlxuICogSWYgYWxsIFRleHROb2RlcyBkbyBub3QgaGF2ZSB0aGUgc2FtZSB2YWx1ZSwgaXQgcmV0dXJucyBhbiBlbXB0eSBzdHJpbmcuXG4gKiBAcGFyYW0gc2VsZWN0aW9uIC0gVGhlIHNlbGVjdGlvbiBvZiBUZXh0Tm9kZXMgd2hvc2UgdmFsdWUgdG8gZmluZC5cbiAqIEBwYXJhbSBzdHlsZVByb3BlcnR5IC0gVGhlIENTUyBzdHlsZSBwcm9wZXJ0eS5cbiAqIEBwYXJhbSBkZWZhdWx0VmFsdWUgLSBUaGUgZGVmYXVsdCB2YWx1ZSBmb3IgdGhlIHByb3BlcnR5LCBkZWZhdWx0cyB0byBhbiBlbXB0eSBzdHJpbmcuXG4gKiBAcmV0dXJucyBUaGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5IGZvciB0aGUgc2VsZWN0ZWQgVGV4dE5vZGVzLlxuICovXG5mdW5jdGlvbiAkZ2V0U2VsZWN0aW9uU3R5bGVWYWx1ZUZvclByb3BlcnR5KHNlbGVjdGlvbiwgc3R5bGVQcm9wZXJ0eSwgZGVmYXVsdFZhbHVlID0gJycpIHtcbiAgbGV0IHN0eWxlVmFsdWUgPSBudWxsO1xuICBjb25zdCBub2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpO1xuICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICBjb25zdCBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cztcbiAgY29uc3QgaXNCYWNrd2FyZCA9IHNlbGVjdGlvbi5pc0JhY2t3YXJkKCk7XG4gIGNvbnN0IGVuZE9mZnNldCA9IGlzQmFja3dhcmQgPyBmb2N1cy5vZmZzZXQgOiBhbmNob3Iub2Zmc2V0O1xuICBjb25zdCBlbmROb2RlID0gaXNCYWNrd2FyZCA/IGZvY3VzLmdldE5vZGUoKSA6IGFuY2hvci5nZXROb2RlKCk7XG4gIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pICYmIHNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpICYmIHNlbGVjdGlvbi5zdHlsZSAhPT0gJycpIHtcbiAgICBjb25zdCBjc3MgPSBzZWxlY3Rpb24uc3R5bGU7XG4gICAgY29uc3Qgc3R5bGVPYmplY3QgPSBnZXRTdHlsZU9iamVjdEZyb21DU1MoY3NzKTtcbiAgICBpZiAoc3R5bGVPYmplY3QgIT09IG51bGwgJiYgc3R5bGVQcm9wZXJ0eSBpbiBzdHlsZU9iamVjdCkge1xuICAgICAgcmV0dXJuIHN0eWxlT2JqZWN0W3N0eWxlUHJvcGVydHldO1xuICAgIH1cbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuXG4gICAgLy8gaWYgbm8gYWN0dWFsIGNoYXJhY3RlcnMgaW4gdGhlIGVuZCBub2RlIGFyZSBzZWxlY3RlZCwgd2UgZG9uJ3RcbiAgICAvLyBpbmNsdWRlIGl0IGluIHRoZSBzZWxlY3Rpb24gZm9yIHB1cnBvc2VzIG9mIGRldGVybWluaW5nIHN0eWxlXG4gICAgLy8gdmFsdWVcbiAgICBpZiAoaSAhPT0gMCAmJiBlbmRPZmZzZXQgPT09IDAgJiYgbm9kZS5pcyhlbmROb2RlKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICgkaXNUZXh0Tm9kZShub2RlKSkge1xuICAgICAgY29uc3Qgbm9kZVN0eWxlVmFsdWUgPSAkZ2V0Tm9kZVN0eWxlVmFsdWVGb3JQcm9wZXJ0eShub2RlLCBzdHlsZVByb3BlcnR5LCBkZWZhdWx0VmFsdWUpO1xuICAgICAgaWYgKHN0eWxlVmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgc3R5bGVWYWx1ZSA9IG5vZGVTdHlsZVZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChzdHlsZVZhbHVlICE9PSBub2RlU3R5bGVWYWx1ZSkge1xuICAgICAgICAvLyBtdWx0aXBsZSB0ZXh0IG5vZGVzIGFyZSBpbiB0aGUgc2VsZWN0aW9uIGFuZCB0aGV5IGRvbid0IGFsbFxuICAgICAgICAvLyBoYXZlIHRoZSBzYW1lIHN0eWxlLlxuICAgICAgICBzdHlsZVZhbHVlID0gJyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gc3R5bGVWYWx1ZSA9PT0gbnVsbCA/IGRlZmF1bHRWYWx1ZSA6IHN0eWxlVmFsdWU7XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBmb3IgaW50ZXJuYWwgdXNlIG9mIHRoZSBsaWJyYXJ5LlxuICogUGxlYXNlIGRvIG5vdCB1c2UgaXQgYXMgaXQgbWF5IGNoYW5nZSBpbiB0aGUgZnV0dXJlLlxuICovXG5mdW5jdGlvbiBJTlRFUk5BTF8kaXNCbG9jayhub2RlKSB7XG4gIGlmICgkaXNEZWNvcmF0b3JOb2RlKG5vZGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghJGlzRWxlbWVudE5vZGUobm9kZSkgfHwgJGlzUm9vdE9yU2hhZG93Um9vdChub2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBmaXJzdENoaWxkID0gbm9kZS5nZXRGaXJzdENoaWxkKCk7XG4gIGNvbnN0IGlzTGVhZkVsZW1lbnQgPSBmaXJzdENoaWxkID09PSBudWxsIHx8ICRpc0xpbmVCcmVha05vZGUoZmlyc3RDaGlsZCkgfHwgJGlzVGV4dE5vZGUoZmlyc3RDaGlsZCkgfHwgZmlyc3RDaGlsZC5pc0lubGluZSgpO1xuICByZXR1cm4gIW5vZGUuaXNJbmxpbmUoKSAmJiBub2RlLmNhbkJlRW1wdHkoKSAhPT0gZmFsc2UgJiYgaXNMZWFmRWxlbWVudDtcbn1cbmZ1bmN0aW9uICRnZXRBbmNlc3Rvcihub2RlLCBwcmVkaWNhdGUpIHtcbiAgbGV0IHBhcmVudCA9IG5vZGU7XG4gIHdoaWxlIChwYXJlbnQgIT09IG51bGwgJiYgcGFyZW50LmdldFBhcmVudCgpICE9PSBudWxsICYmICFwcmVkaWNhdGUocGFyZW50KSkge1xuICAgIHBhcmVudCA9IHBhcmVudC5nZXRQYXJlbnRPclRocm93KCk7XG4gIH1cbiAgcmV0dXJuIHByZWRpY2F0ZShwYXJlbnQpID8gcGFyZW50IDogbnVsbDtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4vKiogQGRlcHJlY2F0ZWQgcmVuYW1lZCB0byB7QGxpbmsgJHRyaW1UZXh0Q29udGVudEZyb21BbmNob3J9IGJ5IEBsZXhpY2FsL2VzbGludC1wbHVnaW4gcnVsZXMtb2YtbGV4aWNhbCAqL1xuY29uc3QgdHJpbVRleHRDb250ZW50RnJvbUFuY2hvciA9ICR0cmltVGV4dENvbnRlbnRGcm9tQW5jaG9yO1xuXG5leHBvcnQgeyAkYWRkTm9kZVN0eWxlLCAkZm9yRWFjaFNlbGVjdGVkVGV4dE5vZGUsICRnZXRTZWxlY3Rpb25TdHlsZVZhbHVlRm9yUHJvcGVydHksICRpc0F0Tm9kZUVuZCwgJGlzUGFyZW50RWxlbWVudFJUTCwgJG1vdmVDYXJldFNlbGVjdGlvbiwgJG1vdmVDaGFyYWN0ZXIsICRwYXRjaFN0eWxlVGV4dCwgJHNldEJsb2Nrc1R5cGUsICRzaG91bGRPdmVycmlkZURlZmF1bHRDaGFyYWN0ZXJTZWxlY3Rpb24sICRzbGljZVNlbGVjdGVkVGV4dE5vZGVDb250ZW50LCAkdHJpbVRleHRDb250ZW50RnJvbUFuY2hvciwgJHdyYXBOb2RlcywgY3JlYXRlRE9NUmFuZ2UsIGNyZWF0ZVJlY3RzRnJvbURPTVJhbmdlLCBnZXRDU1NGcm9tU3R5bGVPYmplY3QsIGdldFN0eWxlT2JqZWN0RnJvbUNTUywgdHJpbVRleHRDb250ZW50RnJvbUFuY2hvciB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/selection/LexicalSelection.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/text/LexicalText.dev.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@lexical/text/LexicalText.dev.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $canShowPlaceholder: () => (/* binding */ $canShowPlaceholder),\n/* harmony export */   $canShowPlaceholderCurry: () => (/* binding */ $canShowPlaceholderCurry),\n/* harmony export */   $findTextIntersectionFromCharacters: () => (/* binding */ $findTextIntersectionFromCharacters),\n/* harmony export */   $isRootTextContentEmpty: () => (/* binding */ $isRootTextContentEmpty),\n/* harmony export */   $isRootTextContentEmptyCurry: () => (/* binding */ $isRootTextContentEmptyCurry),\n/* harmony export */   $rootTextContent: () => (/* binding */ $rootTextContent),\n/* harmony export */   registerLexicalTextEntity: () => (/* binding */ registerLexicalTextEntity)\n/* harmony export */ });\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Returns the root's text content.\n * @returns The root's text content.\n */\nfunction $rootTextContent() {\n  const root = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)();\n  return root.getTextContent();\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Determines if the root has any text content and can trim any whitespace if it does.\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @param trim - Should the root text have its whitespaced trimmed? Defaults to true.\n * @returns true if text content is empty, false if there is text or isEditorComposing is true.\n */\nfunction $isRootTextContentEmpty(isEditorComposing, trim = true) {\n  if (isEditorComposing) {\n    return false;\n  }\n  let text = $rootTextContent();\n  if (trim) {\n    text = text.trim();\n  }\n  return text === '';\n}\n\n/**\n * Returns a function that executes {@link $isRootTextContentEmpty}\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @param trim - Should the root text have its whitespaced trimmed? Defaults to true.\n * @returns A function that executes $isRootTextContentEmpty based on arguments.\n */\nfunction $isRootTextContentEmptyCurry(isEditorComposing, trim) {\n  return () => $isRootTextContentEmpty(isEditorComposing, trim);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Determines if the input should show the placeholder. If anything is in\n * in the root the placeholder should not be shown.\n * @param isComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @returns true if the input should show the placeholder, false otherwise.\n */\nfunction $canShowPlaceholder(isComposing) {\n  if (!$isRootTextContentEmpty(isComposing, false)) {\n    return false;\n  }\n  const root = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)();\n  const children = root.getChildren();\n  const childrenLength = children.length;\n  if (childrenLength > 1) {\n    return false;\n  }\n  for (let i = 0; i < childrenLength; i++) {\n    const topBlock = children[i];\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isDecoratorNode)(topBlock)) {\n      return false;\n    }\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(topBlock)) {\n      if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isParagraphNode)(topBlock)) {\n        return false;\n      }\n      if (topBlock.__indent !== 0) {\n        return false;\n      }\n      const topBlockChildren = topBlock.getChildren();\n      const topBlockChildrenLength = topBlockChildren.length;\n      for (let s = 0; s < topBlockChildrenLength; s++) {\n        const child = topBlockChildren[i];\n        if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(child)) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * Returns a function that executes {@link $canShowPlaceholder}\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @returns A function that executes $canShowPlaceholder with arguments.\n */\nfunction $canShowPlaceholderCurry(isEditorComposing) {\n  return () => $canShowPlaceholder(isEditorComposing);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Finds a TextNode with a size larger than targetCharacters and returns\n * the node along with the remaining length of the text.\n * @param root - The RootNode.\n * @param targetCharacters - The number of characters whose TextNode must be larger than.\n * @returns The TextNode and the intersections offset, or null if no TextNode is found.\n */\nfunction $findTextIntersectionFromCharacters(root, targetCharacters) {\n  let node = root.getFirstChild();\n  let currentCharacters = 0;\n  mainLoop: while (node !== null) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node)) {\n      const child = node.getFirstChild();\n      if (child !== null) {\n        node = child;\n        continue;\n      }\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(node)) {\n      const characters = node.getTextContentSize();\n      if (currentCharacters + characters > targetCharacters) {\n        return {\n          node,\n          offset: targetCharacters - currentCharacters\n        };\n      }\n      currentCharacters += characters;\n    }\n    const sibling = node.getNextSibling();\n    if (sibling !== null) {\n      node = sibling;\n      continue;\n    }\n    let parent = node.getParent();\n    while (parent !== null) {\n      const parentSibling = parent.getNextSibling();\n      if (parentSibling !== null) {\n        node = parentSibling;\n        continue mainLoop;\n      }\n      parent = parent.getParent();\n    }\n    break;\n  }\n  return null;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Returns a tuple that can be rested (...) into mergeRegister to clean up\n * node transforms listeners that transforms text into another node, eg. a HashtagNode.\n * @example\n * ```ts\n *   useEffect(() => {\n    return mergeRegister(\n      ...registerLexicalTextEntity(editor, getMatch, targetNode, createNode),\n    );\n  }, [createNode, editor, getMatch, targetNode]);\n * ```\n * Where targetNode is the type of node containing the text you want to transform (like a text input),\n * then getMatch uses a regex to find a matching text and creates the proper node to include the matching text.\n * @param editor - The lexical editor.\n * @param getMatch - Finds a matching string that satisfies a regex expression.\n * @param targetNode - The node type that contains text to match with. eg. HashtagNode\n * @param createNode - A function that creates a new node to contain the matched text. eg createHashtagNode\n * @returns An array containing the plain text and reverse node transform listeners.\n */\nfunction registerLexicalTextEntity(editor, getMatch, targetNode, createNode) {\n  const isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n  const $replaceWithSimpleText = node => {\n    const textNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTextNode)(node.getTextContent());\n    textNode.setFormat(node.getFormat());\n    node.replace(textNode);\n  };\n  const getMode = node => {\n    return node.getLatest().__mode;\n  };\n  const $textNodeTransform = node => {\n    if (!node.isSimpleText()) {\n      return;\n    }\n    let prevSibling = node.getPreviousSibling();\n    let text = node.getTextContent();\n    let currentNode = node;\n    let match;\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(prevSibling)) {\n      const previousText = prevSibling.getTextContent();\n      const combinedText = previousText + text;\n      const prevMatch = getMatch(combinedText);\n      if (isTargetNode(prevSibling)) {\n        if (prevMatch === null || getMode(prevSibling) !== 0) {\n          $replaceWithSimpleText(prevSibling);\n          return;\n        } else {\n          const diff = prevMatch.end - previousText.length;\n          if (diff > 0) {\n            const concatText = text.slice(0, diff);\n            const newTextContent = previousText + concatText;\n            prevSibling.select();\n            prevSibling.setTextContent(newTextContent);\n            if (diff === text.length) {\n              node.remove();\n            } else {\n              const remainingText = text.slice(diff);\n              node.setTextContent(remainingText);\n            }\n            return;\n          }\n        }\n      } else if (prevMatch === null || prevMatch.start < previousText.length) {\n        return;\n      }\n    }\n    let prevMatchLengthToSkip = 0;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      match = getMatch(text);\n      let nextText = match === null ? '' : text.slice(match.end);\n      text = nextText;\n      if (nextText === '') {\n        const nextSibling = currentNode.getNextSibling();\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(nextSibling)) {\n          nextText = currentNode.getTextContent() + nextSibling.getTextContent();\n          const nextMatch = getMatch(nextText);\n          if (nextMatch === null) {\n            if (isTargetNode(nextSibling)) {\n              $replaceWithSimpleText(nextSibling);\n            } else {\n              nextSibling.markDirty();\n            }\n            return;\n          } else if (nextMatch.start !== 0) {\n            return;\n          }\n        }\n      }\n      if (match === null) {\n        return;\n      }\n      if (match.start === 0 && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(prevSibling) && prevSibling.isTextEntity()) {\n        prevMatchLengthToSkip += match.end;\n        continue;\n      }\n      let nodeToReplace;\n      if (match.start === 0) {\n        [nodeToReplace, currentNode] = currentNode.splitText(match.end);\n      } else {\n        [, nodeToReplace, currentNode] = currentNode.splitText(match.start + prevMatchLengthToSkip, match.end + prevMatchLengthToSkip);\n      }\n      if (!(nodeToReplace !== undefined)) {\n        throw Error(`${'nodeToReplace'} should not be undefined. You may want to check splitOffsets passed to the splitText.`);\n      }\n      const replacementNode = createNode(nodeToReplace);\n      replacementNode.setFormat(nodeToReplace.getFormat());\n      nodeToReplace.replace(replacementNode);\n      if (currentNode == null) {\n        return;\n      }\n      prevMatchLengthToSkip = 0;\n      prevSibling = replacementNode;\n    }\n  };\n  const $reverseNodeTransform = node => {\n    const text = node.getTextContent();\n    const match = getMatch(text);\n    if (match === null || match.start !== 0) {\n      $replaceWithSimpleText(node);\n      return;\n    }\n    if (text.length > match.end) {\n      // This will split out the rest of the text as simple text\n      node.splitText(match.end);\n      return;\n    }\n    const prevSibling = node.getPreviousSibling();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(prevSibling) && prevSibling.isTextEntity()) {\n      $replaceWithSimpleText(prevSibling);\n      $replaceWithSimpleText(node);\n    }\n    const nextSibling = node.getNextSibling();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(nextSibling) && nextSibling.isTextEntity()) {\n      $replaceWithSimpleText(nextSibling);\n\n      // This may have already been converted in the previous block\n      if (isTargetNode(node)) {\n        $replaceWithSimpleText(node);\n      }\n    }\n  };\n  const removePlainTextTransform = editor.registerNodeTransform(lexical__WEBPACK_IMPORTED_MODULE_0__.TextNode, $textNodeTransform);\n  const removeReverseNodeTransform = editor.registerNodeTransform(targetNode, $reverseNodeTransform);\n  return [removePlainTextTransform, removeReverseNodeTransform];\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvdGV4dC9MZXhpY2FsVGV4dC5kZXYubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRStIOztBQUUvSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpREFBUTtBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpREFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBLFFBQVEseURBQWdCO0FBQ3hCO0FBQ0E7QUFDQSxRQUFRLHVEQUFjO0FBQ3RCLFdBQVcseURBQWdCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDRCQUE0QjtBQUNsRDtBQUNBLGFBQWEsb0RBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFNBQVMsb0RBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHdEQUFlO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9EQUFXO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9EQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG9EQUFXO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0RBQVc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9EQUFXO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSw2Q0FBUTtBQUN4RTtBQUNBO0FBQ0E7O0FBRWtNIiwic291cmNlcyI6WyIvVXNlcnMvbGVpL2hvbWUvdW5kZXJnL3RoZWF0cmUveTMvc2VncC9taWxrdXAvbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3RleHQvTGV4aWNhbFRleHQuZGV2Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmltcG9ydCB7ICRnZXRSb290LCAkaXNEZWNvcmF0b3JOb2RlLCAkaXNFbGVtZW50Tm9kZSwgJGlzUGFyYWdyYXBoTm9kZSwgJGlzVGV4dE5vZGUsIFRleHROb2RlLCAkY3JlYXRlVGV4dE5vZGUgfSBmcm9tICdsZXhpY2FsJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHJvb3QncyB0ZXh0IGNvbnRlbnQuXG4gKiBAcmV0dXJucyBUaGUgcm9vdCdzIHRleHQgY29udGVudC5cbiAqL1xuZnVuY3Rpb24gJHJvb3RUZXh0Q29udGVudCgpIHtcbiAgY29uc3Qgcm9vdCA9ICRnZXRSb290KCk7XG4gIHJldHVybiByb290LmdldFRleHRDb250ZW50KCk7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSByb290IGhhcyBhbnkgdGV4dCBjb250ZW50IGFuZCBjYW4gdHJpbSBhbnkgd2hpdGVzcGFjZSBpZiBpdCBkb2VzLlxuICogQHBhcmFtIGlzRWRpdG9yQ29tcG9zaW5nIC0gSXMgdGhlIGVkaXRvciBpbiBjb21wb3NpdGlvbiBtb2RlIGR1ZSB0byBhbiBhY3RpdmUgSW5wdXQgTWV0aG9kIEVkaXRvcj9cbiAqIEBwYXJhbSB0cmltIC0gU2hvdWxkIHRoZSByb290IHRleHQgaGF2ZSBpdHMgd2hpdGVzcGFjZWQgdHJpbW1lZD8gRGVmYXVsdHMgdG8gdHJ1ZS5cbiAqIEByZXR1cm5zIHRydWUgaWYgdGV4dCBjb250ZW50IGlzIGVtcHR5LCBmYWxzZSBpZiB0aGVyZSBpcyB0ZXh0IG9yIGlzRWRpdG9yQ29tcG9zaW5nIGlzIHRydWUuXG4gKi9cbmZ1bmN0aW9uICRpc1Jvb3RUZXh0Q29udGVudEVtcHR5KGlzRWRpdG9yQ29tcG9zaW5nLCB0cmltID0gdHJ1ZSkge1xuICBpZiAoaXNFZGl0b3JDb21wb3NpbmcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbGV0IHRleHQgPSAkcm9vdFRleHRDb250ZW50KCk7XG4gIGlmICh0cmltKSB7XG4gICAgdGV4dCA9IHRleHQudHJpbSgpO1xuICB9XG4gIHJldHVybiB0ZXh0ID09PSAnJztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBleGVjdXRlcyB7QGxpbmsgJGlzUm9vdFRleHRDb250ZW50RW1wdHl9XG4gKiBAcGFyYW0gaXNFZGl0b3JDb21wb3NpbmcgLSBJcyB0aGUgZWRpdG9yIGluIGNvbXBvc2l0aW9uIG1vZGUgZHVlIHRvIGFuIGFjdGl2ZSBJbnB1dCBNZXRob2QgRWRpdG9yP1xuICogQHBhcmFtIHRyaW0gLSBTaG91bGQgdGhlIHJvb3QgdGV4dCBoYXZlIGl0cyB3aGl0ZXNwYWNlZCB0cmltbWVkPyBEZWZhdWx0cyB0byB0cnVlLlxuICogQHJldHVybnMgQSBmdW5jdGlvbiB0aGF0IGV4ZWN1dGVzICRpc1Jvb3RUZXh0Q29udGVudEVtcHR5IGJhc2VkIG9uIGFyZ3VtZW50cy5cbiAqL1xuZnVuY3Rpb24gJGlzUm9vdFRleHRDb250ZW50RW1wdHlDdXJyeShpc0VkaXRvckNvbXBvc2luZywgdHJpbSkge1xuICByZXR1cm4gKCkgPT4gJGlzUm9vdFRleHRDb250ZW50RW1wdHkoaXNFZGl0b3JDb21wb3NpbmcsIHRyaW0pO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgaW5wdXQgc2hvdWxkIHNob3cgdGhlIHBsYWNlaG9sZGVyLiBJZiBhbnl0aGluZyBpcyBpblxuICogaW4gdGhlIHJvb3QgdGhlIHBsYWNlaG9sZGVyIHNob3VsZCBub3QgYmUgc2hvd24uXG4gKiBAcGFyYW0gaXNDb21wb3NpbmcgLSBJcyB0aGUgZWRpdG9yIGluIGNvbXBvc2l0aW9uIG1vZGUgZHVlIHRvIGFuIGFjdGl2ZSBJbnB1dCBNZXRob2QgRWRpdG9yP1xuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgaW5wdXQgc2hvdWxkIHNob3cgdGhlIHBsYWNlaG9sZGVyLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uICRjYW5TaG93UGxhY2Vob2xkZXIoaXNDb21wb3NpbmcpIHtcbiAgaWYgKCEkaXNSb290VGV4dENvbnRlbnRFbXB0eShpc0NvbXBvc2luZywgZmFsc2UpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHJvb3QgPSAkZ2V0Um9vdCgpO1xuICBjb25zdCBjaGlsZHJlbiA9IHJvb3QuZ2V0Q2hpbGRyZW4oKTtcbiAgY29uc3QgY2hpbGRyZW5MZW5ndGggPSBjaGlsZHJlbi5sZW5ndGg7XG4gIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdG9wQmxvY2sgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoJGlzRGVjb3JhdG9yTm9kZSh0b3BCbG9jaykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCRpc0VsZW1lbnROb2RlKHRvcEJsb2NrKSkge1xuICAgICAgaWYgKCEkaXNQYXJhZ3JhcGhOb2RlKHRvcEJsb2NrKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAodG9wQmxvY2suX19pbmRlbnQgIT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3QgdG9wQmxvY2tDaGlsZHJlbiA9IHRvcEJsb2NrLmdldENoaWxkcmVuKCk7XG4gICAgICBjb25zdCB0b3BCbG9ja0NoaWxkcmVuTGVuZ3RoID0gdG9wQmxvY2tDaGlsZHJlbi5sZW5ndGg7XG4gICAgICBmb3IgKGxldCBzID0gMDsgcyA8IHRvcEJsb2NrQ2hpbGRyZW5MZW5ndGg7IHMrKykge1xuICAgICAgICBjb25zdCBjaGlsZCA9IHRvcEJsb2NrQ2hpbGRyZW5baV07XG4gICAgICAgIGlmICghJGlzVGV4dE5vZGUoY2hpbGQpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGV4ZWN1dGVzIHtAbGluayAkY2FuU2hvd1BsYWNlaG9sZGVyfVxuICogQHBhcmFtIGlzRWRpdG9yQ29tcG9zaW5nIC0gSXMgdGhlIGVkaXRvciBpbiBjb21wb3NpdGlvbiBtb2RlIGR1ZSB0byBhbiBhY3RpdmUgSW5wdXQgTWV0aG9kIEVkaXRvcj9cbiAqIEByZXR1cm5zIEEgZnVuY3Rpb24gdGhhdCBleGVjdXRlcyAkY2FuU2hvd1BsYWNlaG9sZGVyIHdpdGggYXJndW1lbnRzLlxuICovXG5mdW5jdGlvbiAkY2FuU2hvd1BsYWNlaG9sZGVyQ3VycnkoaXNFZGl0b3JDb21wb3NpbmcpIHtcbiAgcmV0dXJuICgpID0+ICRjYW5TaG93UGxhY2Vob2xkZXIoaXNFZGl0b3JDb21wb3NpbmcpO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8qKlxuICogRmluZHMgYSBUZXh0Tm9kZSB3aXRoIGEgc2l6ZSBsYXJnZXIgdGhhbiB0YXJnZXRDaGFyYWN0ZXJzIGFuZCByZXR1cm5zXG4gKiB0aGUgbm9kZSBhbG9uZyB3aXRoIHRoZSByZW1haW5pbmcgbGVuZ3RoIG9mIHRoZSB0ZXh0LlxuICogQHBhcmFtIHJvb3QgLSBUaGUgUm9vdE5vZGUuXG4gKiBAcGFyYW0gdGFyZ2V0Q2hhcmFjdGVycyAtIFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyB3aG9zZSBUZXh0Tm9kZSBtdXN0IGJlIGxhcmdlciB0aGFuLlxuICogQHJldHVybnMgVGhlIFRleHROb2RlIGFuZCB0aGUgaW50ZXJzZWN0aW9ucyBvZmZzZXQsIG9yIG51bGwgaWYgbm8gVGV4dE5vZGUgaXMgZm91bmQuXG4gKi9cbmZ1bmN0aW9uICRmaW5kVGV4dEludGVyc2VjdGlvbkZyb21DaGFyYWN0ZXJzKHJvb3QsIHRhcmdldENoYXJhY3RlcnMpIHtcbiAgbGV0IG5vZGUgPSByb290LmdldEZpcnN0Q2hpbGQoKTtcbiAgbGV0IGN1cnJlbnRDaGFyYWN0ZXJzID0gMDtcbiAgbWFpbkxvb3A6IHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgaWYgKCRpc0VsZW1lbnROb2RlKG5vZGUpKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IG5vZGUuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUgPSBjaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgkaXNUZXh0Tm9kZShub2RlKSkge1xuICAgICAgY29uc3QgY2hhcmFjdGVycyA9IG5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCk7XG4gICAgICBpZiAoY3VycmVudENoYXJhY3RlcnMgKyBjaGFyYWN0ZXJzID4gdGFyZ2V0Q2hhcmFjdGVycykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgb2Zmc2V0OiB0YXJnZXRDaGFyYWN0ZXJzIC0gY3VycmVudENoYXJhY3RlcnNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnRDaGFyYWN0ZXJzICs9IGNoYXJhY3RlcnM7XG4gICAgfVxuICAgIGNvbnN0IHNpYmxpbmcgPSBub2RlLmdldE5leHRTaWJsaW5nKCk7XG4gICAgaWYgKHNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgIG5vZGUgPSBzaWJsaW5nO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGxldCBwYXJlbnQgPSBub2RlLmdldFBhcmVudCgpO1xuICAgIHdoaWxlIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHBhcmVudFNpYmxpbmcgPSBwYXJlbnQuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICAgIGlmIChwYXJlbnRTaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUgPSBwYXJlbnRTaWJsaW5nO1xuICAgICAgICBjb250aW51ZSBtYWluTG9vcDtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudC5nZXRQYXJlbnQoKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLyoqXG4gKiBSZXR1cm5zIGEgdHVwbGUgdGhhdCBjYW4gYmUgcmVzdGVkICguLi4pIGludG8gbWVyZ2VSZWdpc3RlciB0byBjbGVhbiB1cFxuICogbm9kZSB0cmFuc2Zvcm1zIGxpc3RlbmVycyB0aGF0IHRyYW5zZm9ybXMgdGV4dCBpbnRvIGFub3RoZXIgbm9kZSwgZWcuIGEgSGFzaHRhZ05vZGUuXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gbWVyZ2VSZWdpc3RlcihcbiAgICAgIC4uLnJlZ2lzdGVyTGV4aWNhbFRleHRFbnRpdHkoZWRpdG9yLCBnZXRNYXRjaCwgdGFyZ2V0Tm9kZSwgY3JlYXRlTm9kZSksXG4gICAgKTtcbiAgfSwgW2NyZWF0ZU5vZGUsIGVkaXRvciwgZ2V0TWF0Y2gsIHRhcmdldE5vZGVdKTtcbiAqIGBgYFxuICogV2hlcmUgdGFyZ2V0Tm9kZSBpcyB0aGUgdHlwZSBvZiBub2RlIGNvbnRhaW5pbmcgdGhlIHRleHQgeW91IHdhbnQgdG8gdHJhbnNmb3JtIChsaWtlIGEgdGV4dCBpbnB1dCksXG4gKiB0aGVuIGdldE1hdGNoIHVzZXMgYSByZWdleCB0byBmaW5kIGEgbWF0Y2hpbmcgdGV4dCBhbmQgY3JlYXRlcyB0aGUgcHJvcGVyIG5vZGUgdG8gaW5jbHVkZSB0aGUgbWF0Y2hpbmcgdGV4dC5cbiAqIEBwYXJhbSBlZGl0b3IgLSBUaGUgbGV4aWNhbCBlZGl0b3IuXG4gKiBAcGFyYW0gZ2V0TWF0Y2ggLSBGaW5kcyBhIG1hdGNoaW5nIHN0cmluZyB0aGF0IHNhdGlzZmllcyBhIHJlZ2V4IGV4cHJlc3Npb24uXG4gKiBAcGFyYW0gdGFyZ2V0Tm9kZSAtIFRoZSBub2RlIHR5cGUgdGhhdCBjb250YWlucyB0ZXh0IHRvIG1hdGNoIHdpdGguIGVnLiBIYXNodGFnTm9kZVxuICogQHBhcmFtIGNyZWF0ZU5vZGUgLSBBIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhIG5ldyBub2RlIHRvIGNvbnRhaW4gdGhlIG1hdGNoZWQgdGV4dC4gZWcgY3JlYXRlSGFzaHRhZ05vZGVcbiAqIEByZXR1cm5zIEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIHBsYWluIHRleHQgYW5kIHJldmVyc2Ugbm9kZSB0cmFuc2Zvcm0gbGlzdGVuZXJzLlxuICovXG5mdW5jdGlvbiByZWdpc3RlckxleGljYWxUZXh0RW50aXR5KGVkaXRvciwgZ2V0TWF0Y2gsIHRhcmdldE5vZGUsIGNyZWF0ZU5vZGUpIHtcbiAgY29uc3QgaXNUYXJnZXROb2RlID0gbm9kZSA9PiB7XG4gICAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiB0YXJnZXROb2RlO1xuICB9O1xuICBjb25zdCAkcmVwbGFjZVdpdGhTaW1wbGVUZXh0ID0gbm9kZSA9PiB7XG4gICAgY29uc3QgdGV4dE5vZGUgPSAkY3JlYXRlVGV4dE5vZGUobm9kZS5nZXRUZXh0Q29udGVudCgpKTtcbiAgICB0ZXh0Tm9kZS5zZXRGb3JtYXQobm9kZS5nZXRGb3JtYXQoKSk7XG4gICAgbm9kZS5yZXBsYWNlKHRleHROb2RlKTtcbiAgfTtcbiAgY29uc3QgZ2V0TW9kZSA9IG5vZGUgPT4ge1xuICAgIHJldHVybiBub2RlLmdldExhdGVzdCgpLl9fbW9kZTtcbiAgfTtcbiAgY29uc3QgJHRleHROb2RlVHJhbnNmb3JtID0gbm9kZSA9PiB7XG4gICAgaWYgKCFub2RlLmlzU2ltcGxlVGV4dCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBwcmV2U2libGluZyA9IG5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgbGV0IHRleHQgPSBub2RlLmdldFRleHRDb250ZW50KCk7XG4gICAgbGV0IGN1cnJlbnROb2RlID0gbm9kZTtcbiAgICBsZXQgbWF0Y2g7XG4gICAgaWYgKCRpc1RleHROb2RlKHByZXZTaWJsaW5nKSkge1xuICAgICAgY29uc3QgcHJldmlvdXNUZXh0ID0gcHJldlNpYmxpbmcuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICAgIGNvbnN0IGNvbWJpbmVkVGV4dCA9IHByZXZpb3VzVGV4dCArIHRleHQ7XG4gICAgICBjb25zdCBwcmV2TWF0Y2ggPSBnZXRNYXRjaChjb21iaW5lZFRleHQpO1xuICAgICAgaWYgKGlzVGFyZ2V0Tm9kZShwcmV2U2libGluZykpIHtcbiAgICAgICAgaWYgKHByZXZNYXRjaCA9PT0gbnVsbCB8fCBnZXRNb2RlKHByZXZTaWJsaW5nKSAhPT0gMCkge1xuICAgICAgICAgICRyZXBsYWNlV2l0aFNpbXBsZVRleHQocHJldlNpYmxpbmcpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBkaWZmID0gcHJldk1hdGNoLmVuZCAtIHByZXZpb3VzVGV4dC5sZW5ndGg7XG4gICAgICAgICAgaWYgKGRpZmYgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBjb25jYXRUZXh0ID0gdGV4dC5zbGljZSgwLCBkaWZmKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1RleHRDb250ZW50ID0gcHJldmlvdXNUZXh0ICsgY29uY2F0VGV4dDtcbiAgICAgICAgICAgIHByZXZTaWJsaW5nLnNlbGVjdCgpO1xuICAgICAgICAgICAgcHJldlNpYmxpbmcuc2V0VGV4dENvbnRlbnQobmV3VGV4dENvbnRlbnQpO1xuICAgICAgICAgICAgaWYgKGRpZmYgPT09IHRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIG5vZGUucmVtb3ZlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zdCByZW1haW5pbmdUZXh0ID0gdGV4dC5zbGljZShkaWZmKTtcbiAgICAgICAgICAgICAgbm9kZS5zZXRUZXh0Q29udGVudChyZW1haW5pbmdUZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocHJldk1hdGNoID09PSBudWxsIHx8IHByZXZNYXRjaC5zdGFydCA8IHByZXZpb3VzVGV4dC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgcHJldk1hdGNoTGVuZ3RoVG9Ta2lwID0gMDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIG1hdGNoID0gZ2V0TWF0Y2godGV4dCk7XG4gICAgICBsZXQgbmV4dFRleHQgPSBtYXRjaCA9PT0gbnVsbCA/ICcnIDogdGV4dC5zbGljZShtYXRjaC5lbmQpO1xuICAgICAgdGV4dCA9IG5leHRUZXh0O1xuICAgICAgaWYgKG5leHRUZXh0ID09PSAnJykge1xuICAgICAgICBjb25zdCBuZXh0U2libGluZyA9IGN1cnJlbnROb2RlLmdldE5leHRTaWJsaW5nKCk7XG4gICAgICAgIGlmICgkaXNUZXh0Tm9kZShuZXh0U2libGluZykpIHtcbiAgICAgICAgICBuZXh0VGV4dCA9IGN1cnJlbnROb2RlLmdldFRleHRDb250ZW50KCkgKyBuZXh0U2libGluZy5nZXRUZXh0Q29udGVudCgpO1xuICAgICAgICAgIGNvbnN0IG5leHRNYXRjaCA9IGdldE1hdGNoKG5leHRUZXh0KTtcbiAgICAgICAgICBpZiAobmV4dE1hdGNoID09PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoaXNUYXJnZXROb2RlKG5leHRTaWJsaW5nKSkge1xuICAgICAgICAgICAgICAkcmVwbGFjZVdpdGhTaW1wbGVUZXh0KG5leHRTaWJsaW5nKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5leHRTaWJsaW5nLm1hcmtEaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gZWxzZSBpZiAobmV4dE1hdGNoLnN0YXJ0ICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG1hdGNoLnN0YXJ0ID09PSAwICYmICRpc1RleHROb2RlKHByZXZTaWJsaW5nKSAmJiBwcmV2U2libGluZy5pc1RleHRFbnRpdHkoKSkge1xuICAgICAgICBwcmV2TWF0Y2hMZW5ndGhUb1NraXAgKz0gbWF0Y2guZW5kO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGxldCBub2RlVG9SZXBsYWNlO1xuICAgICAgaWYgKG1hdGNoLnN0YXJ0ID09PSAwKSB7XG4gICAgICAgIFtub2RlVG9SZXBsYWNlLCBjdXJyZW50Tm9kZV0gPSBjdXJyZW50Tm9kZS5zcGxpdFRleHQobWF0Y2guZW5kKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFssIG5vZGVUb1JlcGxhY2UsIGN1cnJlbnROb2RlXSA9IGN1cnJlbnROb2RlLnNwbGl0VGV4dChtYXRjaC5zdGFydCArIHByZXZNYXRjaExlbmd0aFRvU2tpcCwgbWF0Y2guZW5kICsgcHJldk1hdGNoTGVuZ3RoVG9Ta2lwKTtcbiAgICAgIH1cbiAgICAgIGlmICghKG5vZGVUb1JlcGxhY2UgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYCR7J25vZGVUb1JlcGxhY2UnfSBzaG91bGQgbm90IGJlIHVuZGVmaW5lZC4gWW91IG1heSB3YW50IHRvIGNoZWNrIHNwbGl0T2Zmc2V0cyBwYXNzZWQgdG8gdGhlIHNwbGl0VGV4dC5gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlcGxhY2VtZW50Tm9kZSA9IGNyZWF0ZU5vZGUobm9kZVRvUmVwbGFjZSk7XG4gICAgICByZXBsYWNlbWVudE5vZGUuc2V0Rm9ybWF0KG5vZGVUb1JlcGxhY2UuZ2V0Rm9ybWF0KCkpO1xuICAgICAgbm9kZVRvUmVwbGFjZS5yZXBsYWNlKHJlcGxhY2VtZW50Tm9kZSk7XG4gICAgICBpZiAoY3VycmVudE5vZGUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBwcmV2TWF0Y2hMZW5ndGhUb1NraXAgPSAwO1xuICAgICAgcHJldlNpYmxpbmcgPSByZXBsYWNlbWVudE5vZGU7XG4gICAgfVxuICB9O1xuICBjb25zdCAkcmV2ZXJzZU5vZGVUcmFuc2Zvcm0gPSBub2RlID0+IHtcbiAgICBjb25zdCB0ZXh0ID0gbm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICAgIGNvbnN0IG1hdGNoID0gZ2V0TWF0Y2godGV4dCk7XG4gICAgaWYgKG1hdGNoID09PSBudWxsIHx8IG1hdGNoLnN0YXJ0ICE9PSAwKSB7XG4gICAgICAkcmVwbGFjZVdpdGhTaW1wbGVUZXh0KG5vZGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGV4dC5sZW5ndGggPiBtYXRjaC5lbmQpIHtcbiAgICAgIC8vIFRoaXMgd2lsbCBzcGxpdCBvdXQgdGhlIHJlc3Qgb2YgdGhlIHRleHQgYXMgc2ltcGxlIHRleHRcbiAgICAgIG5vZGUuc3BsaXRUZXh0KG1hdGNoLmVuZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHByZXZTaWJsaW5nID0gbm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICBpZiAoJGlzVGV4dE5vZGUocHJldlNpYmxpbmcpICYmIHByZXZTaWJsaW5nLmlzVGV4dEVudGl0eSgpKSB7XG4gICAgICAkcmVwbGFjZVdpdGhTaW1wbGVUZXh0KHByZXZTaWJsaW5nKTtcbiAgICAgICRyZXBsYWNlV2l0aFNpbXBsZVRleHQobm9kZSk7XG4gICAgfVxuICAgIGNvbnN0IG5leHRTaWJsaW5nID0gbm9kZS5nZXROZXh0U2libGluZygpO1xuICAgIGlmICgkaXNUZXh0Tm9kZShuZXh0U2libGluZykgJiYgbmV4dFNpYmxpbmcuaXNUZXh0RW50aXR5KCkpIHtcbiAgICAgICRyZXBsYWNlV2l0aFNpbXBsZVRleHQobmV4dFNpYmxpbmcpO1xuXG4gICAgICAvLyBUaGlzIG1heSBoYXZlIGFscmVhZHkgYmVlbiBjb252ZXJ0ZWQgaW4gdGhlIHByZXZpb3VzIGJsb2NrXG4gICAgICBpZiAoaXNUYXJnZXROb2RlKG5vZGUpKSB7XG4gICAgICAgICRyZXBsYWNlV2l0aFNpbXBsZVRleHQobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCByZW1vdmVQbGFpblRleHRUcmFuc2Zvcm0gPSBlZGl0b3IucmVnaXN0ZXJOb2RlVHJhbnNmb3JtKFRleHROb2RlLCAkdGV4dE5vZGVUcmFuc2Zvcm0pO1xuICBjb25zdCByZW1vdmVSZXZlcnNlTm9kZVRyYW5zZm9ybSA9IGVkaXRvci5yZWdpc3Rlck5vZGVUcmFuc2Zvcm0odGFyZ2V0Tm9kZSwgJHJldmVyc2VOb2RlVHJhbnNmb3JtKTtcbiAgcmV0dXJuIFtyZW1vdmVQbGFpblRleHRUcmFuc2Zvcm0sIHJlbW92ZVJldmVyc2VOb2RlVHJhbnNmb3JtXTtcbn1cblxuZXhwb3J0IHsgJGNhblNob3dQbGFjZWhvbGRlciwgJGNhblNob3dQbGFjZWhvbGRlckN1cnJ5LCAkZmluZFRleHRJbnRlcnNlY3Rpb25Gcm9tQ2hhcmFjdGVycywgJGlzUm9vdFRleHRDb250ZW50RW1wdHksICRpc1Jvb3RUZXh0Q29udGVudEVtcHR5Q3VycnksICRyb290VGV4dENvbnRlbnQsIHJlZ2lzdGVyTGV4aWNhbFRleHRFbnRpdHkgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/text/LexicalText.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/utils/LexicalUtils.dev.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@lexical/utils/LexicalUtils.dev.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $descendantsMatching: () => (/* binding */ $descendantsMatching),\n/* harmony export */   $dfs: () => (/* binding */ $dfs),\n/* harmony export */   $dfsIterator: () => (/* binding */ $dfsIterator),\n/* harmony export */   $filter: () => (/* binding */ $filter),\n/* harmony export */   $findMatchingParent: () => (/* binding */ $findMatchingParent),\n/* harmony export */   $firstToLastIterator: () => (/* binding */ $firstToLastIterator),\n/* harmony export */   $getDepth: () => (/* binding */ $getDepth),\n/* harmony export */   $getNearestBlockElementAncestorOrThrow: () => (/* binding */ $getNearestBlockElementAncestorOrThrow),\n/* harmony export */   $getNearestNodeOfType: () => (/* binding */ $getNearestNodeOfType),\n/* harmony export */   $getNextRightPreorderNode: () => (/* binding */ $getNextRightPreorderNode),\n/* harmony export */   $getNextSiblingOrParentSibling: () => (/* binding */ $getNextSiblingOrParentSibling),\n/* harmony export */   $insertFirst: () => (/* binding */ $insertFirst),\n/* harmony export */   $insertNodeToNearestRoot: () => (/* binding */ $insertNodeToNearestRoot),\n/* harmony export */   $isEditorIsNestedEditor: () => (/* binding */ $isEditorIsNestedEditor),\n/* harmony export */   $lastToFirstIterator: () => (/* binding */ $lastToFirstIterator),\n/* harmony export */   $restoreEditorState: () => (/* binding */ $restoreEditorState),\n/* harmony export */   $splitNode: () => (/* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.$splitNode),\n/* harmony export */   $unwrapAndFilterDescendants: () => (/* binding */ $unwrapAndFilterDescendants),\n/* harmony export */   $unwrapNode: () => (/* binding */ $unwrapNode),\n/* harmony export */   $wrapNodeInElement: () => (/* binding */ $wrapNodeInElement),\n/* harmony export */   CAN_USE_BEFORE_INPUT: () => (/* binding */ CAN_USE_BEFORE_INPUT),\n/* harmony export */   CAN_USE_DOM: () => (/* binding */ CAN_USE_DOM),\n/* harmony export */   IS_ANDROID: () => (/* binding */ IS_ANDROID),\n/* harmony export */   IS_ANDROID_CHROME: () => (/* binding */ IS_ANDROID_CHROME),\n/* harmony export */   IS_APPLE: () => (/* binding */ IS_APPLE),\n/* harmony export */   IS_APPLE_WEBKIT: () => (/* binding */ IS_APPLE_WEBKIT),\n/* harmony export */   IS_CHROME: () => (/* binding */ IS_CHROME),\n/* harmony export */   IS_FIREFOX: () => (/* binding */ IS_FIREFOX),\n/* harmony export */   IS_IOS: () => (/* binding */ IS_IOS),\n/* harmony export */   IS_SAFARI: () => (/* binding */ IS_SAFARI),\n/* harmony export */   addClassNamesToElement: () => (/* binding */ addClassNamesToElement),\n/* harmony export */   calculateZoomLevel: () => (/* binding */ calculateZoomLevel),\n/* harmony export */   isBlockDomNode: () => (/* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.isBlockDomNode),\n/* harmony export */   isHTMLAnchorElement: () => (/* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLAnchorElement),\n/* harmony export */   isHTMLElement: () => (/* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement),\n/* harmony export */   isInlineDomNode: () => (/* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.isInlineDomNode),\n/* harmony export */   isMimeType: () => (/* binding */ isMimeType),\n/* harmony export */   markSelection: () => (/* binding */ markSelection),\n/* harmony export */   mediaFileReader: () => (/* binding */ mediaFileReader),\n/* harmony export */   mergeRegister: () => (/* binding */ mergeRegister),\n/* harmony export */   objectKlassEquals: () => (/* binding */ objectKlassEquals),\n/* harmony export */   positionNodeOnRange: () => (/* binding */ mlcPositionNodeOnRange),\n/* harmony export */   registerNestedElementResolver: () => (/* binding */ registerNestedElementResolver),\n/* harmony export */   removeClassNamesFromElement: () => (/* binding */ removeClassNamesFromElement),\n/* harmony export */   selectionAlwaysOnDisplay: () => (/* binding */ selectionAlwaysOnDisplay)\n/* harmony export */ });\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.dev.mjs\");\n/* harmony import */ var _lexical_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/selection */ \"(ssr)/./node_modules/@lexical/selection/LexicalSelection.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM$1 = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst documentMode = CAN_USE_DOM$1 && 'documentMode' in document ? document.documentMode : null;\nconst IS_APPLE$1 = CAN_USE_DOM$1 && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nconst IS_FIREFOX$1 = CAN_USE_DOM$1 && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nconst CAN_USE_BEFORE_INPUT$1 = CAN_USE_DOM$1 && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI$1 = CAN_USE_DOM$1 && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS$1 = CAN_USE_DOM$1 && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\nconst IS_ANDROID$1 = CAN_USE_DOM$1 && /Android/.test(navigator.userAgent);\n\n// Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\nconst IS_CHROME$1 = CAN_USE_DOM$1 && /^(?=.*Chrome).*/i.test(navigator.userAgent);\n// export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\nconst IS_ANDROID_CHROME$1 = CAN_USE_DOM$1 && IS_ANDROID$1 && IS_CHROME$1;\nconst IS_APPLE_WEBKIT$1 = CAN_USE_DOM$1 && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME$1;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction normalizeClassNames(...classNames) {\n  const rval = [];\n  for (const className of classNames) {\n    if (className && typeof className === 'string') {\n      for (const [s] of className.matchAll(/\\S+/g)) {\n        rval.push(s);\n      }\n    }\n  }\n  return rval;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Returns a function that will execute all functions passed when called. It is generally used\n * to register multiple lexical listeners and then tear them down with a single function call, such\n * as React's useEffect hook.\n * @example\n * ```ts\n * useEffect(() => {\n *   return mergeRegister(\n *     editor.registerCommand(...registerCommand1 logic),\n *     editor.registerCommand(...registerCommand2 logic),\n *     editor.registerCommand(...registerCommand3 logic)\n *   )\n * }, [editor])\n * ```\n * In this case, useEffect is returning the function returned by mergeRegister as a cleanup\n * function to be executed after either the useEffect runs again (due to one of its dependencies\n * updating) or the component it resides in unmounts.\n * Note the functions don't neccesarily need to be in an array as all arguments\n * are considered to be the func argument and spread from there.\n * The order of cleanup is the reverse of the argument order. Generally it is\n * expected that the first \"acquire\" will be \"released\" last (LIFO order),\n * because a later step may have some dependency on an earlier one.\n * @param func - An array of cleanup functions meant to be executed by the returned function.\n * @returns the function which executes all the passed cleanup functions.\n */\nfunction mergeRegister(...func) {\n  return () => {\n    for (let i = func.length - 1; i >= 0; i--) {\n      func[i]();\n    }\n    // Clean up the references and make future calls a no-op\n    func.length = 0;\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction px(value) {\n  return `${value}px`;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst mutationObserverConfig = {\n  attributes: true,\n  characterData: true,\n  childList: true,\n  subtree: true\n};\nfunction prependDOMNode(parent, node) {\n  parent.insertBefore(node, parent.firstChild);\n}\n\n/**\n * Place one or multiple newly created Nodes at the passed Range's position.\n * Multiple nodes will only be created when the Range spans multiple lines (aka\n * client rects).\n *\n * This function can come particularly useful to highlight particular parts of\n * the text without interfering with the EditorState, that will often replicate\n * the state across collab and clipboard.\n *\n * This function accounts for DOM updates which can modify the passed Range.\n * Hence, the function return to remove the listener.\n */\nfunction mlcPositionNodeOnRange(editor, range, onReposition) {\n  let rootDOMNode = null;\n  let parentDOMNode = null;\n  let observer = null;\n  let lastNodes = [];\n  const wrapperNode = document.createElement('div');\n  wrapperNode.style.position = 'relative';\n  function position() {\n    if (!(rootDOMNode !== null)) {\n      throw Error(`Unexpected null rootDOMNode`);\n    }\n    if (!(parentDOMNode !== null)) {\n      throw Error(`Unexpected null parentDOMNode`);\n    }\n    const {\n      left: parentLeft,\n      top: parentTop\n    } = parentDOMNode.getBoundingClientRect();\n    const rects = (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_1__.createRectsFromDOMRange)(editor, range);\n    if (!wrapperNode.isConnected) {\n      prependDOMNode(parentDOMNode, wrapperNode);\n    }\n    let hasRepositioned = false;\n    for (let i = 0; i < rects.length; i++) {\n      const rect = rects[i];\n      // Try to reuse the previously created Node when possible, no need to\n      // remove/create on the most common case reposition case\n      const rectNode = lastNodes[i] || document.createElement('div');\n      const rectNodeStyle = rectNode.style;\n      if (rectNodeStyle.position !== 'absolute') {\n        rectNodeStyle.position = 'absolute';\n        hasRepositioned = true;\n      }\n      const left = px(rect.left - parentLeft);\n      if (rectNodeStyle.left !== left) {\n        rectNodeStyle.left = left;\n        hasRepositioned = true;\n      }\n      const top = px(rect.top - parentTop);\n      if (rectNodeStyle.top !== top) {\n        rectNode.style.top = top;\n        hasRepositioned = true;\n      }\n      const width = px(rect.width);\n      if (rectNodeStyle.width !== width) {\n        rectNode.style.width = width;\n        hasRepositioned = true;\n      }\n      const height = px(rect.height);\n      if (rectNodeStyle.height !== height) {\n        rectNode.style.height = height;\n        hasRepositioned = true;\n      }\n      if (rectNode.parentNode !== wrapperNode) {\n        wrapperNode.append(rectNode);\n        hasRepositioned = true;\n      }\n      lastNodes[i] = rectNode;\n    }\n    while (lastNodes.length > rects.length) {\n      lastNodes.pop();\n    }\n    if (hasRepositioned) {\n      onReposition(lastNodes);\n    }\n  }\n  function stop() {\n    parentDOMNode = null;\n    rootDOMNode = null;\n    if (observer !== null) {\n      observer.disconnect();\n    }\n    observer = null;\n    wrapperNode.remove();\n    for (const node of lastNodes) {\n      node.remove();\n    }\n    lastNodes = [];\n  }\n  function restart() {\n    const currentRootDOMNode = editor.getRootElement();\n    if (currentRootDOMNode === null) {\n      return stop();\n    }\n    const currentParentDOMNode = currentRootDOMNode.parentElement;\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(currentParentDOMNode)) {\n      return stop();\n    }\n    stop();\n    rootDOMNode = currentRootDOMNode;\n    parentDOMNode = currentParentDOMNode;\n    observer = new MutationObserver(mutations => {\n      const nextRootDOMNode = editor.getRootElement();\n      const nextParentDOMNode = nextRootDOMNode && nextRootDOMNode.parentElement;\n      if (nextRootDOMNode !== rootDOMNode || nextParentDOMNode !== parentDOMNode) {\n        return restart();\n      }\n      for (const mutation of mutations) {\n        if (!wrapperNode.contains(mutation.target)) {\n          // TODO throttle\n          return position();\n        }\n      }\n    });\n    observer.observe(currentParentDOMNode, mutationObserverConfig);\n    position();\n  }\n  const removeRootListener = editor.registerRootListener(restart);\n  return () => {\n    removeRootListener();\n    stop();\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction rangeTargetFromPoint(point, node, dom) {\n  if (point.type === 'text' || !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node)) {\n    const textDOM = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.getDOMTextNode)(dom) || dom;\n    return [textDOM, point.offset];\n  } else {\n    const slot = node.getDOMSlot(dom);\n    return [slot.element, slot.getFirstChildOffset() + point.offset];\n  }\n}\nfunction rangeFromPoints(editor, anchor, anchorNode, anchorDOM, focus, focusNode, focusDOM) {\n  const editorDocument = editor._window ? editor._window.document : document;\n  const range = editorDocument.createRange();\n  if (focusNode.isBefore(anchorNode)) {\n    range.setStart(...rangeTargetFromPoint(focus, focusNode, focusDOM));\n    range.setEnd(...rangeTargetFromPoint(anchor, anchorNode, anchorDOM));\n  } else {\n    range.setStart(...rangeTargetFromPoint(anchor, anchorNode, anchorDOM));\n    range.setEnd(...rangeTargetFromPoint(focus, focusNode, focusDOM));\n  }\n  return range;\n}\n/**\n * Place one or multiple newly created Nodes at the current selection. Multiple\n * nodes will only be created when the selection spans multiple lines (aka\n * client rects).\n *\n * This function can come useful when you want to show the selection but the\n * editor has been focused away.\n */\nfunction markSelection(editor, onReposition) {\n  let previousAnchorNode = null;\n  let previousAnchorNodeDOM = null;\n  let previousAnchorOffset = null;\n  let previousFocusNode = null;\n  let previousFocusNodeDOM = null;\n  let previousFocusOffset = null;\n  let removeRangeListener = () => {};\n  function compute(editorState) {\n    editorState.read(() => {\n      const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n      if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n        // TODO\n        previousAnchorNode = null;\n        previousAnchorOffset = null;\n        previousFocusNode = null;\n        previousFocusOffset = null;\n        removeRangeListener();\n        removeRangeListener = () => {};\n        return;\n      }\n      const {\n        anchor,\n        focus\n      } = selection;\n      const currentAnchorNode = anchor.getNode();\n      const currentAnchorNodeKey = currentAnchorNode.getKey();\n      const currentAnchorOffset = anchor.offset;\n      const currentFocusNode = focus.getNode();\n      const currentFocusNodeKey = currentFocusNode.getKey();\n      const currentFocusOffset = focus.offset;\n      const currentAnchorNodeDOM = editor.getElementByKey(currentAnchorNodeKey);\n      const currentFocusNodeDOM = editor.getElementByKey(currentFocusNodeKey);\n      const differentAnchorDOM = previousAnchorNode === null || currentAnchorNodeDOM !== previousAnchorNodeDOM || currentAnchorOffset !== previousAnchorOffset || currentAnchorNodeKey !== previousAnchorNode.getKey();\n      const differentFocusDOM = previousFocusNode === null || currentFocusNodeDOM !== previousFocusNodeDOM || currentFocusOffset !== previousFocusOffset || currentFocusNodeKey !== previousFocusNode.getKey();\n      if ((differentAnchorDOM || differentFocusDOM) && currentAnchorNodeDOM !== null && currentFocusNodeDOM !== null) {\n        const range = rangeFromPoints(editor, anchor, currentAnchorNode, currentAnchorNodeDOM, focus, currentFocusNode, currentFocusNodeDOM);\n        removeRangeListener();\n        removeRangeListener = mlcPositionNodeOnRange(editor, range, domNodes => {\n          if (onReposition === undefined) {\n            for (const domNode of domNodes) {\n              const domNodeStyle = domNode.style;\n              if (domNodeStyle.background !== 'Highlight') {\n                domNodeStyle.background = 'Highlight';\n              }\n              if (domNodeStyle.color !== 'HighlightText') {\n                domNodeStyle.color = 'HighlightText';\n              }\n              if (domNodeStyle.marginTop !== px(-1.5)) {\n                domNodeStyle.marginTop = px(-1.5);\n              }\n              if (domNodeStyle.paddingTop !== px(4)) {\n                domNodeStyle.paddingTop = px(4);\n              }\n              if (domNodeStyle.paddingBottom !== px(0)) {\n                domNodeStyle.paddingBottom = px(0);\n              }\n            }\n          } else {\n            onReposition(domNodes);\n          }\n        });\n      }\n      previousAnchorNode = currentAnchorNode;\n      previousAnchorNodeDOM = currentAnchorNodeDOM;\n      previousAnchorOffset = currentAnchorOffset;\n      previousFocusNode = currentFocusNode;\n      previousFocusNodeDOM = currentFocusNodeDOM;\n      previousFocusOffset = currentFocusOffset;\n    });\n  }\n  compute(editor.getEditorState());\n  return mergeRegister(editor.registerUpdateListener(({\n    editorState\n  }) => compute(editorState)), () => {\n    removeRangeListener();\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction selectionAlwaysOnDisplay(editor) {\n  let removeSelectionMark = null;\n  const onSelectionChange = () => {\n    const domSelection = getSelection();\n    const domAnchorNode = domSelection && domSelection.anchorNode;\n    const editorRootElement = editor.getRootElement();\n    const isSelectionInsideEditor = domAnchorNode !== null && editorRootElement !== null && editorRootElement.contains(domAnchorNode);\n    if (isSelectionInsideEditor) {\n      if (removeSelectionMark !== null) {\n        removeSelectionMark();\n        removeSelectionMark = null;\n      }\n    } else {\n      if (removeSelectionMark === null) {\n        removeSelectionMark = markSelection(editor);\n      }\n    }\n  };\n  document.addEventListener('selectionchange', onSelectionChange);\n  return () => {\n    if (removeSelectionMark !== null) {\n      removeSelectionMark();\n    }\n    document.removeEventListener('selectionchange', onSelectionChange);\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Hotfix to export these with inlined types #5918\nconst CAN_USE_BEFORE_INPUT = CAN_USE_BEFORE_INPUT$1;\nconst CAN_USE_DOM = CAN_USE_DOM$1;\nconst IS_ANDROID = IS_ANDROID$1;\nconst IS_ANDROID_CHROME = IS_ANDROID_CHROME$1;\nconst IS_APPLE = IS_APPLE$1;\nconst IS_APPLE_WEBKIT = IS_APPLE_WEBKIT$1;\nconst IS_CHROME = IS_CHROME$1;\nconst IS_FIREFOX = IS_FIREFOX$1;\nconst IS_IOS = IS_IOS$1;\nconst IS_SAFARI = IS_SAFARI$1;\n\n/**\n * Takes an HTML element and adds the classNames passed within an array,\n * ignoring any non-string types. A space can be used to add multiple classes\n * eg. addClassNamesToElement(element, ['element-inner active', true, null])\n * will add both 'element-inner' and 'active' as classes to that element.\n * @param element - The element in which the classes are added\n * @param classNames - An array defining the class names to add to the element\n */\nfunction addClassNamesToElement(element, ...classNames) {\n  const classesToAdd = normalizeClassNames(...classNames);\n  if (classesToAdd.length > 0) {\n    element.classList.add(...classesToAdd);\n  }\n}\n\n/**\n * Takes an HTML element and removes the classNames passed within an array,\n * ignoring any non-string types. A space can be used to remove multiple classes\n * eg. removeClassNamesFromElement(element, ['active small', true, null])\n * will remove both the 'active' and 'small' classes from that element.\n * @param element - The element in which the classes are removed\n * @param classNames - An array defining the class names to remove from the element\n */\nfunction removeClassNamesFromElement(element, ...classNames) {\n  const classesToRemove = normalizeClassNames(...classNames);\n  if (classesToRemove.length > 0) {\n    element.classList.remove(...classesToRemove);\n  }\n}\n\n/**\n * Returns true if the file type matches the types passed within the acceptableMimeTypes array, false otherwise.\n * The types passed must be strings and are CASE-SENSITIVE.\n * eg. if file is of type 'text' and acceptableMimeTypes = ['TEXT', 'IMAGE'] the function will return false.\n * @param file - The file you want to type check.\n * @param acceptableMimeTypes - An array of strings of types which the file is checked against.\n * @returns true if the file is an acceptable mime type, false otherwise.\n */\nfunction isMimeType(file, acceptableMimeTypes) {\n  for (const acceptableType of acceptableMimeTypes) {\n    if (file.type.startsWith(acceptableType)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Lexical File Reader with:\n *  1. MIME type support\n *  2. batched results (HistoryPlugin compatibility)\n *  3. Order aware (respects the order when multiple Files are passed)\n *\n * const filesResult = await mediaFileReader(files, ['image/']);\n * filesResult.forEach(file => editor.dispatchCommand('INSERT_IMAGE', \\\\{\n *   src: file.result,\n * \\\\}));\n */\nfunction mediaFileReader(files, acceptableMimeTypes) {\n  const filesIterator = files[Symbol.iterator]();\n  return new Promise((resolve, reject) => {\n    const processed = [];\n    const handleNextFile = () => {\n      const {\n        done,\n        value: file\n      } = filesIterator.next();\n      if (done) {\n        return resolve(processed);\n      }\n      const fileReader = new FileReader();\n      fileReader.addEventListener('error', reject);\n      fileReader.addEventListener('load', () => {\n        const result = fileReader.result;\n        if (typeof result === 'string') {\n          processed.push({\n            file,\n            result\n          });\n        }\n        handleNextFile();\n      });\n      if (isMimeType(file, acceptableMimeTypes)) {\n        fileReader.readAsDataURL(file);\n      } else {\n        handleNextFile();\n      }\n    };\n    handleNextFile();\n  });\n}\n/**\n * \"Depth-First Search\" starts at the root/top node of a tree and goes as far as it can down a branch end\n * before backtracking and finding a new path. Consider solving a maze by hugging either wall, moving down a\n * branch until you hit a dead-end (leaf) and backtracking to find the nearest branching path and repeat.\n * It will then return all the nodes found in the search in an array of objects.\n * @param startNode - The node to start the search, if omitted, it will start at the root node.\n * @param endNode - The node to end the search, if omitted, it will find all descendants of the startingNode.\n * @returns An array of objects of all the nodes found by the search, including their depth into the tree.\n * \\\\{depth: number, node: LexicalNode\\\\} It will always return at least 1 node (the start node).\n */\nfunction $dfs(startNode, endNode) {\n  return Array.from($dfsIterator(startNode, endNode));\n}\nconst iteratorDone = {\n  done: true,\n  value: undefined\n};\nconst iteratorNotDone = value => ({\n  done: false,\n  value\n});\n\n/**\n * $dfs iterator. Tree traversal is done on the fly as new values are requested with O(1) memory.\n * @param startNode - The node to start the search, if omitted, it will start at the root node.\n * @param endNode - The node to end the search, if omitted, it will find all descendants of the startingNode.\n * @returns An iterator, each yielded value is a DFSNode. It will always return at least 1 node (the start node).\n */\nfunction $dfsIterator(startNode, endNode) {\n  const start = (startNode || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)()).getLatest();\n  const startDepth = $getDepth(start);\n  const end = endNode;\n  let node = start;\n  let depth = startDepth;\n  let isFirstNext = true;\n  const iterator = {\n    next() {\n      if (node === null) {\n        return iteratorDone;\n      }\n      if (isFirstNext) {\n        isFirstNext = false;\n        return iteratorNotDone({\n          depth,\n          node\n        });\n      }\n      if (node === end) {\n        return iteratorDone;\n      }\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && node.getChildrenSize() > 0) {\n        node = node.getFirstChild();\n        depth++;\n      } else {\n        let depthDiff;\n        [node, depthDiff] = $getNextSiblingOrParentSibling(node) || [null, 0];\n        depth += depthDiff;\n        if (end == null && depth <= startDepth) {\n          node = null;\n        }\n      }\n      if (node === null) {\n        return iteratorDone;\n      }\n      return iteratorNotDone({\n        depth,\n        node\n      });\n    },\n    [Symbol.iterator]() {\n      return iterator;\n    }\n  };\n  return iterator;\n}\n\n/**\n * Returns the Node sibling when this exists, otherwise the closest parent sibling. For example\n * R -> P -> T1, T2\n *   -> P2\n * returns T2 for node T1, P2 for node T2, and null for node P2.\n * @param node LexicalNode.\n * @returns An array (tuple) containing the found Lexical node and the depth difference, or null, if this node doesn't exist.\n */\nfunction $getNextSiblingOrParentSibling(node) {\n  let node_ = node;\n  // Find immediate sibling or nearest parent sibling\n  let sibling = null;\n  let depthDiff = 0;\n  while (sibling === null && node_ !== null) {\n    sibling = node_.getNextSibling();\n    if (sibling === null) {\n      node_ = node_.getParent();\n      depthDiff--;\n    } else {\n      node_ = sibling;\n    }\n  }\n  if (node_ === null) {\n    return null;\n  }\n  return [node_, depthDiff];\n}\nfunction $getDepth(node) {\n  let innerNode = node;\n  let depth = 0;\n  while ((innerNode = innerNode.getParent()) !== null) {\n    depth++;\n  }\n  return depth;\n}\n\n/**\n * Performs a right-to-left preorder tree traversal.\n * From the starting node it goes to the rightmost child, than backtracks to paret and finds new rightmost path.\n * It will return the next node in traversal sequence after the startingNode.\n * The traversal is similar to $dfs functions above, but the nodes are visited right-to-left, not left-to-right.\n * @param startingNode - The node to start the search.\n * @returns The next node in pre-order right to left traversal sequence or `null`, if the node does not exist\n */\nfunction $getNextRightPreorderNode(startingNode) {\n  let node = startingNode;\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && node.getChildrenSize() > 0) {\n    node = node.getLastChild();\n  } else {\n    let sibling = null;\n    while (sibling === null && node !== null) {\n      sibling = node.getPreviousSibling();\n      if (sibling === null) {\n        node = node.getParent();\n      } else {\n        node = sibling;\n      }\n    }\n  }\n  return node;\n}\n\n/**\n * Takes a node and traverses up its ancestors (toward the root node)\n * in order to find a specific type of node.\n * @param node - the node to begin searching.\n * @param klass - an instance of the type of node to look for.\n * @returns the node of type klass that was passed, or null if none exist.\n */\nfunction $getNearestNodeOfType(node, klass) {\n  let parent = node;\n  while (parent != null) {\n    if (parent instanceof klass) {\n      return parent;\n    }\n    parent = parent.getParent();\n  }\n  return null;\n}\n\n/**\n * Returns the element node of the nearest ancestor, otherwise throws an error.\n * @param startNode - The starting node of the search\n * @returns The ancestor node found\n */\nfunction $getNearestBlockElementAncestorOrThrow(startNode) {\n  const blockNode = $findMatchingParent(startNode, node => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && !node.isInline());\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(blockNode)) {\n    {\n      throw Error(`Expected node ${startNode.__key} to have closest block element node.`);\n    }\n  }\n  return blockNode;\n}\n/**\n * Starts with a node and moves up the tree (toward the root node) to find a matching node based on\n * the search parameters of the findFn. (Consider JavaScripts' .find() function where a testing function must be\n * passed as an argument. eg. if( (node) => node.__type === 'div') ) return true; otherwise return false\n * @param startingNode - The node where the search starts.\n * @param findFn - A testing function that returns true if the current node satisfies the testing parameters.\n * @returns A parent node that matches the findFn parameters, or null if one wasn't found.\n */\nconst $findMatchingParent = (startingNode, findFn) => {\n  let curr = startingNode;\n  while (curr !== (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)() && curr != null) {\n    if (findFn(curr)) {\n      return curr;\n    }\n    curr = curr.getParent();\n  }\n  return null;\n};\n\n/**\n * Attempts to resolve nested element nodes of the same type into a single node of that type.\n * It is generally used for marks/commenting\n * @param editor - The lexical editor\n * @param targetNode - The target for the nested element to be extracted from.\n * @param cloneNode - See {@link $createMarkNode}\n * @param handleOverlap - Handles any overlap between the node to extract and the targetNode\n * @returns The lexical editor\n */\nfunction registerNestedElementResolver(editor, targetNode, cloneNode, handleOverlap) {\n  const $isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n  const $findMatch = node => {\n    // First validate we don't have any children that are of the target,\n    // as we need to handle them first.\n    const children = node.getChildren();\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if ($isTargetNode(child)) {\n        return null;\n      }\n    }\n    let parentNode = node;\n    let childNode = node;\n    while (parentNode !== null) {\n      childNode = parentNode;\n      parentNode = parentNode.getParent();\n      if ($isTargetNode(parentNode)) {\n        return {\n          child: childNode,\n          parent: parentNode\n        };\n      }\n    }\n    return null;\n  };\n  const $elementNodeTransform = node => {\n    const match = $findMatch(node);\n    if (match !== null) {\n      const {\n        child,\n        parent\n      } = match;\n\n      // Simple path, we can move child out and siblings into a new parent.\n\n      if (child.is(node)) {\n        handleOverlap(parent, node);\n        const nextSiblings = child.getNextSiblings();\n        const nextSiblingsLength = nextSiblings.length;\n        parent.insertAfter(child);\n        if (nextSiblingsLength !== 0) {\n          const newParent = cloneNode(parent);\n          child.insertAfter(newParent);\n          for (let i = 0; i < nextSiblingsLength; i++) {\n            newParent.append(nextSiblings[i]);\n          }\n        }\n        if (!parent.canBeEmpty() && parent.getChildrenSize() === 0) {\n          parent.remove();\n        }\n      }\n    }\n  };\n  return editor.registerNodeTransform(targetNode, $elementNodeTransform);\n}\n\n/**\n * Clones the editor and marks it as dirty to be reconciled. If there was a selection,\n * it would be set back to its previous state, or null otherwise.\n * @param editor - The lexical editor\n * @param editorState - The editor's state\n */\nfunction $restoreEditorState(editor, editorState) {\n  const FULL_RECONCILE = 2;\n  const nodeMap = new Map();\n  const activeEditorState = editor._pendingEditorState;\n  for (const [key, node] of editorState._nodeMap) {\n    nodeMap.set(key, (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$cloneWithProperties)(node));\n  }\n  if (activeEditorState) {\n    activeEditorState._nodeMap = nodeMap;\n  }\n  editor._dirtyType = FULL_RECONCILE;\n  const selection = editorState._selection;\n  (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(selection === null ? null : selection.clone());\n}\n\n/**\n * If the selected insertion area is the root/shadow root node (see {@link lexical!$isRootOrShadowRoot}),\n * the node will be appended there, otherwise, it will be inserted before the insertion area.\n * If there is no selection where the node is to be inserted, it will be appended after any current nodes\n * within the tree, as a child of the root node. A paragraph node will then be added after the inserted node and selected.\n * @param node - The node to be inserted\n * @returns The node after its insertion\n */\nfunction $insertNodeToNearestRoot(node) {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)() || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getPreviousSelection)();\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n    const {\n      focus\n    } = selection;\n    const focusNode = focus.getNode();\n    const focusOffset = focus.offset;\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(focusNode)) {\n      const focusChild = focusNode.getChildAtIndex(focusOffset);\n      if (focusChild == null) {\n        focusNode.append(node);\n      } else {\n        focusChild.insertBefore(node);\n      }\n      node.selectNext();\n    } else {\n      let splitNode;\n      let splitOffset;\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(focusNode)) {\n        splitNode = focusNode.getParentOrThrow();\n        splitOffset = focusNode.getIndexWithinParent();\n        if (focusOffset > 0) {\n          splitOffset += 1;\n          focusNode.splitText(focusOffset);\n        }\n      } else {\n        splitNode = focusNode;\n        splitOffset = focusOffset;\n      }\n      const [, rightTree] = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$splitNode)(splitNode, splitOffset);\n      rightTree.insertBefore(node);\n      rightTree.selectStart();\n    }\n  } else {\n    if (selection != null) {\n      const nodes = selection.getNodes();\n      nodes[nodes.length - 1].getTopLevelElementOrThrow().insertAfter(node);\n    } else {\n      const root = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)();\n      root.append(node);\n    }\n    const paragraphNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n    node.insertAfter(paragraphNode);\n    paragraphNode.select();\n  }\n  return node.getLatest();\n}\n\n/**\n * Wraps the node into another node created from a createElementNode function, eg. $createParagraphNode\n * @param node - Node to be wrapped.\n * @param createElementNode - Creates a new lexical element to wrap the to-be-wrapped node and returns it.\n * @returns A new lexical element with the previous node appended within (as a child, including its children).\n */\nfunction $wrapNodeInElement(node, createElementNode) {\n  const elementNode = createElementNode();\n  node.replace(elementNode);\n  elementNode.append(node);\n  return elementNode;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n/**\n * @param object = The instance of the type\n * @param objectClass = The class of the type\n * @returns Whether the object is has the same Klass of the objectClass, ignoring the difference across window (e.g. different iframs)\n */\nfunction objectKlassEquals(object, objectClass) {\n  return object !== null ? Object.getPrototypeOf(object).constructor.name === objectClass.name : false;\n}\n\n/**\n * Filter the nodes\n * @param nodes Array of nodes that needs to be filtered\n * @param filterFn A filter function that returns node if the current node satisfies the condition otherwise null\n * @returns Array of filtered nodes\n */\n\nfunction $filter(nodes, filterFn) {\n  const result = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = filterFn(nodes[i]);\n    if (node !== null) {\n      result.push(node);\n    }\n  }\n  return result;\n}\n/**\n * Appends the node before the first child of the parent node\n * @param parent A parent node\n * @param node Node that needs to be appended\n */\nfunction $insertFirst(parent, node) {\n  const firstChild = parent.getFirstChild();\n  if (firstChild !== null) {\n    firstChild.insertBefore(node);\n  } else {\n    parent.append(node);\n  }\n}\nlet NEEDS_MANUAL_ZOOM = IS_FIREFOX || !CAN_USE_DOM ? false : undefined;\nfunction needsManualZoom() {\n  if (NEEDS_MANUAL_ZOOM === undefined) {\n    // If the browser implements standardized CSS zoom, then the client rect\n    // will be wider after zoom is applied\n    // https://chromestatus.com/feature/5198254868529152\n    // https://github.com/facebook/lexical/issues/6863\n    const div = document.createElement('div');\n    div.style.cssText = 'position: absolute; opacity: 0; width: 100px; left: -1000px;';\n    document.body.appendChild(div);\n    const noZoom = div.getBoundingClientRect();\n    div.style.setProperty('zoom', '2');\n    NEEDS_MANUAL_ZOOM = div.getBoundingClientRect().width === noZoom.width;\n    document.body.removeChild(div);\n  }\n  return NEEDS_MANUAL_ZOOM;\n}\n\n/**\n * Calculates the zoom level of an element as a result of using\n * css zoom property. For browsers that implement standardized CSS\n * zoom (Firefox, Chrome >= 128), this will always return 1.\n * @param element\n */\nfunction calculateZoomLevel(element) {\n  let zoom = 1;\n  if (needsManualZoom()) {\n    while (element) {\n      zoom *= Number(window.getComputedStyle(element).getPropertyValue('zoom'));\n      element = element.parentElement;\n    }\n  }\n  return zoom;\n}\n\n/**\n * Checks if the editor is a nested editor created by LexicalNestedComposer\n */\nfunction $isEditorIsNestedEditor(editor) {\n  return editor._parentEditor !== null;\n}\n\n/**\n * A depth first last-to-first traversal of root that stops at each node that matches\n * $predicate and ensures that its parent is root. This is typically used to discard\n * invalid or unsupported wrapping nodes. For example, a TableNode must only have\n * TableRowNode as children, but an importer might add invalid nodes based on\n * caption, tbody, thead, etc. and this will unwrap and discard those.\n *\n * @param root The root to start the traversal\n * @param $predicate Should return true for nodes that are permitted to be children of root\n * @returns true if this unwrapped or removed any nodes\n */\nfunction $unwrapAndFilterDescendants(root, $predicate) {\n  return $unwrapAndFilterDescendantsImpl(root, $predicate, null);\n}\nfunction $unwrapAndFilterDescendantsImpl(root, $predicate, $onSuccess) {\n  let didMutate = false;\n  for (const node of $lastToFirstIterator(root)) {\n    if ($predicate(node)) {\n      if ($onSuccess !== null) {\n        $onSuccess(node);\n      }\n      continue;\n    }\n    didMutate = true;\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node)) {\n      $unwrapAndFilterDescendantsImpl(node, $predicate, $onSuccess ? $onSuccess : child => node.insertAfter(child));\n    }\n    node.remove();\n  }\n  return didMutate;\n}\n\n/**\n * A depth first traversal of the children array that stops at and collects\n * each node that `$predicate` matches. This is typically used to discard\n * invalid or unsupported wrapping nodes on a children array in the `after`\n * of an {@link lexical!DOMConversionOutput}. For example, a TableNode must only have\n * TableRowNode as children, but an importer might add invalid nodes based on\n * caption, tbody, thead, etc. and this will unwrap and discard those.\n *\n * This function is read-only and performs no mutation operations, which makes\n * it suitable for import and export purposes but likely not for any in-place\n * mutation. You should use {@link $unwrapAndFilterDescendants} for in-place\n * mutations such as node transforms.\n *\n * @param children The children to traverse\n * @param $predicate Should return true for nodes that are permitted to be children of root\n * @returns The children or their descendants that match $predicate\n */\n\nfunction $descendantsMatching(children, $predicate) {\n  const result = [];\n  const stack = [...children].reverse();\n  for (let child = stack.pop(); child !== undefined; child = stack.pop()) {\n    if ($predicate(child)) {\n      result.push(child);\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(child)) {\n      for (const grandchild of $lastToFirstIterator(child)) {\n        stack.push(grandchild);\n      }\n    }\n  }\n  return result;\n}\n\n/**\n * Return an iterator that yields each child of node from first to last, taking\n * care to preserve the next sibling before yielding the value in case the caller\n * removes the yielded node.\n *\n * @param node The node whose children to iterate\n * @returns An iterator of the node's children\n */\nfunction $firstToLastIterator(node) {\n  return {\n    [Symbol.iterator]: () => $childIterator(node.getFirstChild(), child => child.getNextSibling())\n  };\n}\n\n/**\n * Return an iterator that yields each child of node from last to first, taking\n * care to preserve the previous sibling before yielding the value in case the caller\n * removes the yielded node.\n *\n * @param node The node whose children to iterate\n * @returns An iterator of the node's children\n */\nfunction $lastToFirstIterator(node) {\n  return {\n    [Symbol.iterator]: () => $childIterator(node.getLastChild(), child => child.getPreviousSibling())\n  };\n}\nfunction $childIterator(initialNode, nextNode) {\n  let state = initialNode;\n  const seen = new Set() ;\n  return {\n    next() {\n      if (state === null) {\n        return iteratorDone;\n      }\n      const rval = iteratorNotDone(state);\n      if (seen !== null) {\n        const key = state.getKey();\n        if (!!seen.has(key)) {\n          throw Error(`$childIterator: Cycle detected, node with key ${String(key)} has already been traversed`);\n        }\n        seen.add(key);\n      }\n      state = nextNode(state);\n      return rval;\n    }\n  };\n}\n\n/**\n * Insert all children before this node, and then remove it.\n *\n * @param node The ElementNode to unwrap and remove\n */\nfunction $unwrapNode(node) {\n  for (const child of $firstToLastIterator(node)) {\n    node.insertBefore(child);\n  }\n  node.remove();\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvdXRpbHMvTGV4aWNhbFV0aWxzLmRldi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFb1A7QUFDMUk7QUFDN0M7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksTUFBTTtBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixrQkFBa0IsMkVBQXVCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsc0RBQWE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0MsdURBQWM7QUFDOUMsb0JBQW9CLHVEQUFjO0FBQ2xDO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0RBQWE7QUFDckMsV0FBVywwREFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sb0NBQW9DO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGlEQUFRO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsdURBQWM7QUFDeEI7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sdURBQWM7QUFDcEI7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsdURBQWM7QUFDekUsT0FBTyx1REFBYztBQUNyQjtBQUNBLG1DQUFtQyxpQkFBaUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0Y7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlEQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsd0JBQXdCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw2REFBb0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxzREFBYTtBQUNmOztBQUVBO0FBQ0EscUVBQXFFLGtDQUFrQztBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzREFBYSxNQUFNLDhEQUFxQjtBQUM1RCxNQUFNLDBEQUFpQjtBQUN2QjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRLDREQUFtQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxVQUFVLG9EQUFXO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbURBQVU7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixtQkFBbUIsaURBQVE7QUFDM0I7QUFDQTtBQUNBLDBCQUEwQiw2REFBb0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxZQUFZLGNBQWMsY0FBYztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsa0NBQWtDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsbUNBQW1DO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MscUJBQXFCO0FBQ3JEO0FBQ0E7QUFDQSxNQUFNLFNBQVMsdURBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsYUFBYTtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTZ4QiIsInNvdXJjZXMiOlsiL1VzZXJzL2xlaS9ob21lL3VuZGVyZy90aGVhdHJlL3kzL3NlZ3AvbWlsa3VwL25vZGVfbW9kdWxlcy9AbGV4aWNhbC91dGlscy9MZXhpY2FsVXRpbHMuZGV2Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQsICRnZXRTZWxlY3Rpb24sICRpc1JhbmdlU2VsZWN0aW9uLCAkaXNFbGVtZW50Tm9kZSwgZ2V0RE9NVGV4dE5vZGUsICRnZXRSb290LCAkY2xvbmVXaXRoUHJvcGVydGllcywgJHNldFNlbGVjdGlvbiwgJGdldFByZXZpb3VzU2VsZWN0aW9uLCAkaXNSb290T3JTaGFkb3dSb290LCAkaXNUZXh0Tm9kZSwgJHNwbGl0Tm9kZSwgJGNyZWF0ZVBhcmFncmFwaE5vZGUgfSBmcm9tICdsZXhpY2FsJztcbmV4cG9ydCB7ICRzcGxpdE5vZGUsIGlzQmxvY2tEb21Ob2RlLCBpc0hUTUxBbmNob3JFbGVtZW50LCBpc0hUTUxFbGVtZW50LCBpc0lubGluZURvbU5vZGUgfSBmcm9tICdsZXhpY2FsJztcbmltcG9ydCB7IGNyZWF0ZVJlY3RzRnJvbURPTVJhbmdlIH0gZnJvbSAnQGxleGljYWwvc2VsZWN0aW9uJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBDQU5fVVNFX0RPTSQxID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBkb2N1bWVudE1vZGUgPSBDQU5fVVNFX0RPTSQxICYmICdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50ID8gZG9jdW1lbnQuZG9jdW1lbnRNb2RlIDogbnVsbDtcbmNvbnN0IElTX0FQUExFJDEgPSBDQU5fVVNFX0RPTSQxICYmIC9NYWN8aVBvZHxpUGhvbmV8aVBhZC8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pO1xuY29uc3QgSVNfRklSRUZPWCQxID0gQ0FOX1VTRV9ET00kMSAmJiAvXig/IS4qU2VhbW9ua2V5KSg/PS4qRmlyZWZveCkuKi9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5jb25zdCBDQU5fVVNFX0JFRk9SRV9JTlBVVCQxID0gQ0FOX1VTRV9ET00kMSAmJiAnSW5wdXRFdmVudCcgaW4gd2luZG93ICYmICFkb2N1bWVudE1vZGUgPyAnZ2V0VGFyZ2V0UmFuZ2VzJyBpbiBuZXcgd2luZG93LklucHV0RXZlbnQoJ2lucHV0JykgOiBmYWxzZTtcbmNvbnN0IElTX1NBRkFSSSQxID0gQ0FOX1VTRV9ET00kMSAmJiAvVmVyc2lvblxcL1tcXGQuXSsuKlNhZmFyaS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbmNvbnN0IElTX0lPUyQxID0gQ0FOX1VTRV9ET00kMSAmJiAvaVBhZHxpUGhvbmV8aVBvZC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAhd2luZG93Lk1TU3RyZWFtO1xuY29uc3QgSVNfQU5EUk9JRCQxID0gQ0FOX1VTRV9ET00kMSAmJiAvQW5kcm9pZC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuLy8gS2VlcCB0aGVzZSBpbiBjYXNlIHdlIG5lZWQgdG8gdXNlIHRoZW0gaW4gdGhlIGZ1dHVyZS5cbi8vIGV4cG9ydCBjb25zdCBJU19XSU5ET1dTOiBib29sZWFuID0gQ0FOX1VTRV9ET00gJiYgL1dpbi8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pO1xuY29uc3QgSVNfQ0hST01FJDEgPSBDQU5fVVNFX0RPTSQxICYmIC9eKD89LipDaHJvbWUpLiovaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuLy8gZXhwb3J0IGNvbnN0IGNhblVzZVRleHRJbnB1dEV2ZW50OiBib29sZWFuID0gQ0FOX1VTRV9ET00gJiYgJ1RleHRFdmVudCcgaW4gd2luZG93ICYmICFkb2N1bWVudE1vZGU7XG5cbmNvbnN0IElTX0FORFJPSURfQ0hST01FJDEgPSBDQU5fVVNFX0RPTSQxICYmIElTX0FORFJPSUQkMSAmJiBJU19DSFJPTUUkMTtcbmNvbnN0IElTX0FQUExFX1dFQktJVCQxID0gQ0FOX1VTRV9ET00kMSAmJiAvQXBwbGVXZWJLaXRcXC9bXFxkLl0rLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICFJU19DSFJPTUUkMTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiBub3JtYWxpemVDbGFzc05hbWVzKC4uLmNsYXNzTmFtZXMpIHtcbiAgY29uc3QgcnZhbCA9IFtdO1xuICBmb3IgKGNvbnN0IGNsYXNzTmFtZSBvZiBjbGFzc05hbWVzKSB7XG4gICAgaWYgKGNsYXNzTmFtZSAmJiB0eXBlb2YgY2xhc3NOYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgZm9yIChjb25zdCBbc10gb2YgY2xhc3NOYW1lLm1hdGNoQWxsKC9cXFMrL2cpKSB7XG4gICAgICAgIHJ2YWwucHVzaChzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJ2YWw7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGV4ZWN1dGUgYWxsIGZ1bmN0aW9ucyBwYXNzZWQgd2hlbiBjYWxsZWQuIEl0IGlzIGdlbmVyYWxseSB1c2VkXG4gKiB0byByZWdpc3RlciBtdWx0aXBsZSBsZXhpY2FsIGxpc3RlbmVycyBhbmQgdGhlbiB0ZWFyIHRoZW0gZG93biB3aXRoIGEgc2luZ2xlIGZ1bmN0aW9uIGNhbGwsIHN1Y2hcbiAqIGFzIFJlYWN0J3MgdXNlRWZmZWN0IGhvb2suXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIHVzZUVmZmVjdCgoKSA9PiB7XG4gKiAgIHJldHVybiBtZXJnZVJlZ2lzdGVyKFxuICogICAgIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoLi4ucmVnaXN0ZXJDb21tYW5kMSBsb2dpYyksXG4gKiAgICAgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZCguLi5yZWdpc3RlckNvbW1hbmQyIGxvZ2ljKSxcbiAqICAgICBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKC4uLnJlZ2lzdGVyQ29tbWFuZDMgbG9naWMpXG4gKiAgIClcbiAqIH0sIFtlZGl0b3JdKVxuICogYGBgXG4gKiBJbiB0aGlzIGNhc2UsIHVzZUVmZmVjdCBpcyByZXR1cm5pbmcgdGhlIGZ1bmN0aW9uIHJldHVybmVkIGJ5IG1lcmdlUmVnaXN0ZXIgYXMgYSBjbGVhbnVwXG4gKiBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCBhZnRlciBlaXRoZXIgdGhlIHVzZUVmZmVjdCBydW5zIGFnYWluIChkdWUgdG8gb25lIG9mIGl0cyBkZXBlbmRlbmNpZXNcbiAqIHVwZGF0aW5nKSBvciB0aGUgY29tcG9uZW50IGl0IHJlc2lkZXMgaW4gdW5tb3VudHMuXG4gKiBOb3RlIHRoZSBmdW5jdGlvbnMgZG9uJ3QgbmVjY2VzYXJpbHkgbmVlZCB0byBiZSBpbiBhbiBhcnJheSBhcyBhbGwgYXJndW1lbnRzXG4gKiBhcmUgY29uc2lkZXJlZCB0byBiZSB0aGUgZnVuYyBhcmd1bWVudCBhbmQgc3ByZWFkIGZyb20gdGhlcmUuXG4gKiBUaGUgb3JkZXIgb2YgY2xlYW51cCBpcyB0aGUgcmV2ZXJzZSBvZiB0aGUgYXJndW1lbnQgb3JkZXIuIEdlbmVyYWxseSBpdCBpc1xuICogZXhwZWN0ZWQgdGhhdCB0aGUgZmlyc3QgXCJhY3F1aXJlXCIgd2lsbCBiZSBcInJlbGVhc2VkXCIgbGFzdCAoTElGTyBvcmRlciksXG4gKiBiZWNhdXNlIGEgbGF0ZXIgc3RlcCBtYXkgaGF2ZSBzb21lIGRlcGVuZGVuY3kgb24gYW4gZWFybGllciBvbmUuXG4gKiBAcGFyYW0gZnVuYyAtIEFuIGFycmF5IG9mIGNsZWFudXAgZnVuY3Rpb25zIG1lYW50IHRvIGJlIGV4ZWN1dGVkIGJ5IHRoZSByZXR1cm5lZCBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHRoZSBmdW5jdGlvbiB3aGljaCBleGVjdXRlcyBhbGwgdGhlIHBhc3NlZCBjbGVhbnVwIGZ1bmN0aW9ucy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VSZWdpc3RlciguLi5mdW5jKSB7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IGZ1bmMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGZ1bmNbaV0oKTtcbiAgICB9XG4gICAgLy8gQ2xlYW4gdXAgdGhlIHJlZmVyZW5jZXMgYW5kIG1ha2UgZnV0dXJlIGNhbGxzIGEgbm8tb3BcbiAgICBmdW5jLmxlbmd0aCA9IDA7XG4gIH07XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gcHgodmFsdWUpIHtcbiAgcmV0dXJuIGAke3ZhbHVlfXB4YDtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBtdXRhdGlvbk9ic2VydmVyQ29uZmlnID0ge1xuICBhdHRyaWJ1dGVzOiB0cnVlLFxuICBjaGFyYWN0ZXJEYXRhOiB0cnVlLFxuICBjaGlsZExpc3Q6IHRydWUsXG4gIHN1YnRyZWU6IHRydWVcbn07XG5mdW5jdGlvbiBwcmVwZW5kRE9NTm9kZShwYXJlbnQsIG5vZGUpIHtcbiAgcGFyZW50Lmluc2VydEJlZm9yZShub2RlLCBwYXJlbnQuZmlyc3RDaGlsZCk7XG59XG5cbi8qKlxuICogUGxhY2Ugb25lIG9yIG11bHRpcGxlIG5ld2x5IGNyZWF0ZWQgTm9kZXMgYXQgdGhlIHBhc3NlZCBSYW5nZSdzIHBvc2l0aW9uLlxuICogTXVsdGlwbGUgbm9kZXMgd2lsbCBvbmx5IGJlIGNyZWF0ZWQgd2hlbiB0aGUgUmFuZ2Ugc3BhbnMgbXVsdGlwbGUgbGluZXMgKGFrYVxuICogY2xpZW50IHJlY3RzKS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGNhbiBjb21lIHBhcnRpY3VsYXJseSB1c2VmdWwgdG8gaGlnaGxpZ2h0IHBhcnRpY3VsYXIgcGFydHMgb2ZcbiAqIHRoZSB0ZXh0IHdpdGhvdXQgaW50ZXJmZXJpbmcgd2l0aCB0aGUgRWRpdG9yU3RhdGUsIHRoYXQgd2lsbCBvZnRlbiByZXBsaWNhdGVcbiAqIHRoZSBzdGF0ZSBhY3Jvc3MgY29sbGFiIGFuZCBjbGlwYm9hcmQuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBhY2NvdW50cyBmb3IgRE9NIHVwZGF0ZXMgd2hpY2ggY2FuIG1vZGlmeSB0aGUgcGFzc2VkIFJhbmdlLlxuICogSGVuY2UsIHRoZSBmdW5jdGlvbiByZXR1cm4gdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lci5cbiAqL1xuZnVuY3Rpb24gbWxjUG9zaXRpb25Ob2RlT25SYW5nZShlZGl0b3IsIHJhbmdlLCBvblJlcG9zaXRpb24pIHtcbiAgbGV0IHJvb3RET01Ob2RlID0gbnVsbDtcbiAgbGV0IHBhcmVudERPTU5vZGUgPSBudWxsO1xuICBsZXQgb2JzZXJ2ZXIgPSBudWxsO1xuICBsZXQgbGFzdE5vZGVzID0gW107XG4gIGNvbnN0IHdyYXBwZXJOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHdyYXBwZXJOb2RlLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgZnVuY3Rpb24gcG9zaXRpb24oKSB7XG4gICAgaWYgKCEocm9vdERPTU5vZGUgIT09IG51bGwpKSB7XG4gICAgICB0aHJvdyBFcnJvcihgVW5leHBlY3RlZCBudWxsIHJvb3RET01Ob2RlYCk7XG4gICAgfVxuICAgIGlmICghKHBhcmVudERPTU5vZGUgIT09IG51bGwpKSB7XG4gICAgICB0aHJvdyBFcnJvcihgVW5leHBlY3RlZCBudWxsIHBhcmVudERPTU5vZGVgKTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgbGVmdDogcGFyZW50TGVmdCxcbiAgICAgIHRvcDogcGFyZW50VG9wXG4gICAgfSA9IHBhcmVudERPTU5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgcmVjdHMgPSBjcmVhdGVSZWN0c0Zyb21ET01SYW5nZShlZGl0b3IsIHJhbmdlKTtcbiAgICBpZiAoIXdyYXBwZXJOb2RlLmlzQ29ubmVjdGVkKSB7XG4gICAgICBwcmVwZW5kRE9NTm9kZShwYXJlbnRET01Ob2RlLCB3cmFwcGVyTm9kZSk7XG4gICAgfVxuICAgIGxldCBoYXNSZXBvc2l0aW9uZWQgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCByZWN0ID0gcmVjdHNbaV07XG4gICAgICAvLyBUcnkgdG8gcmV1c2UgdGhlIHByZXZpb3VzbHkgY3JlYXRlZCBOb2RlIHdoZW4gcG9zc2libGUsIG5vIG5lZWQgdG9cbiAgICAgIC8vIHJlbW92ZS9jcmVhdGUgb24gdGhlIG1vc3QgY29tbW9uIGNhc2UgcmVwb3NpdGlvbiBjYXNlXG4gICAgICBjb25zdCByZWN0Tm9kZSA9IGxhc3ROb2Rlc1tpXSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGNvbnN0IHJlY3ROb2RlU3R5bGUgPSByZWN0Tm9kZS5zdHlsZTtcbiAgICAgIGlmIChyZWN0Tm9kZVN0eWxlLnBvc2l0aW9uICE9PSAnYWJzb2x1dGUnKSB7XG4gICAgICAgIHJlY3ROb2RlU3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICBoYXNSZXBvc2l0aW9uZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgbGVmdCA9IHB4KHJlY3QubGVmdCAtIHBhcmVudExlZnQpO1xuICAgICAgaWYgKHJlY3ROb2RlU3R5bGUubGVmdCAhPT0gbGVmdCkge1xuICAgICAgICByZWN0Tm9kZVN0eWxlLmxlZnQgPSBsZWZ0O1xuICAgICAgICBoYXNSZXBvc2l0aW9uZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgdG9wID0gcHgocmVjdC50b3AgLSBwYXJlbnRUb3ApO1xuICAgICAgaWYgKHJlY3ROb2RlU3R5bGUudG9wICE9PSB0b3ApIHtcbiAgICAgICAgcmVjdE5vZGUuc3R5bGUudG9wID0gdG9wO1xuICAgICAgICBoYXNSZXBvc2l0aW9uZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgY29uc3Qgd2lkdGggPSBweChyZWN0LndpZHRoKTtcbiAgICAgIGlmIChyZWN0Tm9kZVN0eWxlLndpZHRoICE9PSB3aWR0aCkge1xuICAgICAgICByZWN0Tm9kZS5zdHlsZS53aWR0aCA9IHdpZHRoO1xuICAgICAgICBoYXNSZXBvc2l0aW9uZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgaGVpZ2h0ID0gcHgocmVjdC5oZWlnaHQpO1xuICAgICAgaWYgKHJlY3ROb2RlU3R5bGUuaGVpZ2h0ICE9PSBoZWlnaHQpIHtcbiAgICAgICAgcmVjdE5vZGUuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICBoYXNSZXBvc2l0aW9uZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHJlY3ROb2RlLnBhcmVudE5vZGUgIT09IHdyYXBwZXJOb2RlKSB7XG4gICAgICAgIHdyYXBwZXJOb2RlLmFwcGVuZChyZWN0Tm9kZSk7XG4gICAgICAgIGhhc1JlcG9zaXRpb25lZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBsYXN0Tm9kZXNbaV0gPSByZWN0Tm9kZTtcbiAgICB9XG4gICAgd2hpbGUgKGxhc3ROb2Rlcy5sZW5ndGggPiByZWN0cy5sZW5ndGgpIHtcbiAgICAgIGxhc3ROb2Rlcy5wb3AoKTtcbiAgICB9XG4gICAgaWYgKGhhc1JlcG9zaXRpb25lZCkge1xuICAgICAgb25SZXBvc2l0aW9uKGxhc3ROb2Rlcyk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgcGFyZW50RE9NTm9kZSA9IG51bGw7XG4gICAgcm9vdERPTU5vZGUgPSBudWxsO1xuICAgIGlmIChvYnNlcnZlciAhPT0gbnVsbCkge1xuICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIH1cbiAgICBvYnNlcnZlciA9IG51bGw7XG4gICAgd3JhcHBlck5vZGUucmVtb3ZlKCk7XG4gICAgZm9yIChjb25zdCBub2RlIG9mIGxhc3ROb2Rlcykge1xuICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICB9XG4gICAgbGFzdE5vZGVzID0gW107XG4gIH1cbiAgZnVuY3Rpb24gcmVzdGFydCgpIHtcbiAgICBjb25zdCBjdXJyZW50Um9vdERPTU5vZGUgPSBlZGl0b3IuZ2V0Um9vdEVsZW1lbnQoKTtcbiAgICBpZiAoY3VycmVudFJvb3RET01Ob2RlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gc3RvcCgpO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50UGFyZW50RE9NTm9kZSA9IGN1cnJlbnRSb290RE9NTm9kZS5wYXJlbnRFbGVtZW50O1xuICAgIGlmICghaXNIVE1MRWxlbWVudChjdXJyZW50UGFyZW50RE9NTm9kZSkpIHtcbiAgICAgIHJldHVybiBzdG9wKCk7XG4gICAgfVxuICAgIHN0b3AoKTtcbiAgICByb290RE9NTm9kZSA9IGN1cnJlbnRSb290RE9NTm9kZTtcbiAgICBwYXJlbnRET01Ob2RlID0gY3VycmVudFBhcmVudERPTU5vZGU7XG4gICAgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihtdXRhdGlvbnMgPT4ge1xuICAgICAgY29uc3QgbmV4dFJvb3RET01Ob2RlID0gZWRpdG9yLmdldFJvb3RFbGVtZW50KCk7XG4gICAgICBjb25zdCBuZXh0UGFyZW50RE9NTm9kZSA9IG5leHRSb290RE9NTm9kZSAmJiBuZXh0Um9vdERPTU5vZGUucGFyZW50RWxlbWVudDtcbiAgICAgIGlmIChuZXh0Um9vdERPTU5vZGUgIT09IHJvb3RET01Ob2RlIHx8IG5leHRQYXJlbnRET01Ob2RlICE9PSBwYXJlbnRET01Ob2RlKSB7XG4gICAgICAgIHJldHVybiByZXN0YXJ0KCk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IG11dGF0aW9uIG9mIG11dGF0aW9ucykge1xuICAgICAgICBpZiAoIXdyYXBwZXJOb2RlLmNvbnRhaW5zKG11dGF0aW9uLnRhcmdldCkpIHtcbiAgICAgICAgICAvLyBUT0RPIHRocm90dGxlXG4gICAgICAgICAgcmV0dXJuIHBvc2l0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKGN1cnJlbnRQYXJlbnRET01Ob2RlLCBtdXRhdGlvbk9ic2VydmVyQ29uZmlnKTtcbiAgICBwb3NpdGlvbigpO1xuICB9XG4gIGNvbnN0IHJlbW92ZVJvb3RMaXN0ZW5lciA9IGVkaXRvci5yZWdpc3RlclJvb3RMaXN0ZW5lcihyZXN0YXJ0KTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICByZW1vdmVSb290TGlzdGVuZXIoKTtcbiAgICBzdG9wKCk7XG4gIH07XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gcmFuZ2VUYXJnZXRGcm9tUG9pbnQocG9pbnQsIG5vZGUsIGRvbSkge1xuICBpZiAocG9pbnQudHlwZSA9PT0gJ3RleHQnIHx8ICEkaXNFbGVtZW50Tm9kZShub2RlKSkge1xuICAgIGNvbnN0IHRleHRET00gPSBnZXRET01UZXh0Tm9kZShkb20pIHx8IGRvbTtcbiAgICByZXR1cm4gW3RleHRET00sIHBvaW50Lm9mZnNldF07XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgc2xvdCA9IG5vZGUuZ2V0RE9NU2xvdChkb20pO1xuICAgIHJldHVybiBbc2xvdC5lbGVtZW50LCBzbG90LmdldEZpcnN0Q2hpbGRPZmZzZXQoKSArIHBvaW50Lm9mZnNldF07XG4gIH1cbn1cbmZ1bmN0aW9uIHJhbmdlRnJvbVBvaW50cyhlZGl0b3IsIGFuY2hvciwgYW5jaG9yTm9kZSwgYW5jaG9yRE9NLCBmb2N1cywgZm9jdXNOb2RlLCBmb2N1c0RPTSkge1xuICBjb25zdCBlZGl0b3JEb2N1bWVudCA9IGVkaXRvci5fd2luZG93ID8gZWRpdG9yLl93aW5kb3cuZG9jdW1lbnQgOiBkb2N1bWVudDtcbiAgY29uc3QgcmFuZ2UgPSBlZGl0b3JEb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICBpZiAoZm9jdXNOb2RlLmlzQmVmb3JlKGFuY2hvck5vZGUpKSB7XG4gICAgcmFuZ2Uuc2V0U3RhcnQoLi4ucmFuZ2VUYXJnZXRGcm9tUG9pbnQoZm9jdXMsIGZvY3VzTm9kZSwgZm9jdXNET00pKTtcbiAgICByYW5nZS5zZXRFbmQoLi4ucmFuZ2VUYXJnZXRGcm9tUG9pbnQoYW5jaG9yLCBhbmNob3JOb2RlLCBhbmNob3JET00pKTtcbiAgfSBlbHNlIHtcbiAgICByYW5nZS5zZXRTdGFydCguLi5yYW5nZVRhcmdldEZyb21Qb2ludChhbmNob3IsIGFuY2hvck5vZGUsIGFuY2hvckRPTSkpO1xuICAgIHJhbmdlLnNldEVuZCguLi5yYW5nZVRhcmdldEZyb21Qb2ludChmb2N1cywgZm9jdXNOb2RlLCBmb2N1c0RPTSkpO1xuICB9XG4gIHJldHVybiByYW5nZTtcbn1cbi8qKlxuICogUGxhY2Ugb25lIG9yIG11bHRpcGxlIG5ld2x5IGNyZWF0ZWQgTm9kZXMgYXQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLiBNdWx0aXBsZVxuICogbm9kZXMgd2lsbCBvbmx5IGJlIGNyZWF0ZWQgd2hlbiB0aGUgc2VsZWN0aW9uIHNwYW5zIG11bHRpcGxlIGxpbmVzIChha2FcbiAqIGNsaWVudCByZWN0cykuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBjYW4gY29tZSB1c2VmdWwgd2hlbiB5b3Ugd2FudCB0byBzaG93IHRoZSBzZWxlY3Rpb24gYnV0IHRoZVxuICogZWRpdG9yIGhhcyBiZWVuIGZvY3VzZWQgYXdheS5cbiAqL1xuZnVuY3Rpb24gbWFya1NlbGVjdGlvbihlZGl0b3IsIG9uUmVwb3NpdGlvbikge1xuICBsZXQgcHJldmlvdXNBbmNob3JOb2RlID0gbnVsbDtcbiAgbGV0IHByZXZpb3VzQW5jaG9yTm9kZURPTSA9IG51bGw7XG4gIGxldCBwcmV2aW91c0FuY2hvck9mZnNldCA9IG51bGw7XG4gIGxldCBwcmV2aW91c0ZvY3VzTm9kZSA9IG51bGw7XG4gIGxldCBwcmV2aW91c0ZvY3VzTm9kZURPTSA9IG51bGw7XG4gIGxldCBwcmV2aW91c0ZvY3VzT2Zmc2V0ID0gbnVsbDtcbiAgbGV0IHJlbW92ZVJhbmdlTGlzdGVuZXIgPSAoKSA9PiB7fTtcbiAgZnVuY3Rpb24gY29tcHV0ZShlZGl0b3JTdGF0ZSkge1xuICAgIGVkaXRvclN0YXRlLnJlYWQoKCkgPT4ge1xuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgcHJldmlvdXNBbmNob3JOb2RlID0gbnVsbDtcbiAgICAgICAgcHJldmlvdXNBbmNob3JPZmZzZXQgPSBudWxsO1xuICAgICAgICBwcmV2aW91c0ZvY3VzTm9kZSA9IG51bGw7XG4gICAgICAgIHByZXZpb3VzRm9jdXNPZmZzZXQgPSBudWxsO1xuICAgICAgICByZW1vdmVSYW5nZUxpc3RlbmVyKCk7XG4gICAgICAgIHJlbW92ZVJhbmdlTGlzdGVuZXIgPSAoKSA9PiB7fTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qge1xuICAgICAgICBhbmNob3IsXG4gICAgICAgIGZvY3VzXG4gICAgICB9ID0gc2VsZWN0aW9uO1xuICAgICAgY29uc3QgY3VycmVudEFuY2hvck5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICAgICAgY29uc3QgY3VycmVudEFuY2hvck5vZGVLZXkgPSBjdXJyZW50QW5jaG9yTm9kZS5nZXRLZXkoKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRBbmNob3JPZmZzZXQgPSBhbmNob3Iub2Zmc2V0O1xuICAgICAgY29uc3QgY3VycmVudEZvY3VzTm9kZSA9IGZvY3VzLmdldE5vZGUoKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRGb2N1c05vZGVLZXkgPSBjdXJyZW50Rm9jdXNOb2RlLmdldEtleSgpO1xuICAgICAgY29uc3QgY3VycmVudEZvY3VzT2Zmc2V0ID0gZm9jdXMub2Zmc2V0O1xuICAgICAgY29uc3QgY3VycmVudEFuY2hvck5vZGVET00gPSBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KGN1cnJlbnRBbmNob3JOb2RlS2V5KTtcbiAgICAgIGNvbnN0IGN1cnJlbnRGb2N1c05vZGVET00gPSBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KGN1cnJlbnRGb2N1c05vZGVLZXkpO1xuICAgICAgY29uc3QgZGlmZmVyZW50QW5jaG9yRE9NID0gcHJldmlvdXNBbmNob3JOb2RlID09PSBudWxsIHx8IGN1cnJlbnRBbmNob3JOb2RlRE9NICE9PSBwcmV2aW91c0FuY2hvck5vZGVET00gfHwgY3VycmVudEFuY2hvck9mZnNldCAhPT0gcHJldmlvdXNBbmNob3JPZmZzZXQgfHwgY3VycmVudEFuY2hvck5vZGVLZXkgIT09IHByZXZpb3VzQW5jaG9yTm9kZS5nZXRLZXkoKTtcbiAgICAgIGNvbnN0IGRpZmZlcmVudEZvY3VzRE9NID0gcHJldmlvdXNGb2N1c05vZGUgPT09IG51bGwgfHwgY3VycmVudEZvY3VzTm9kZURPTSAhPT0gcHJldmlvdXNGb2N1c05vZGVET00gfHwgY3VycmVudEZvY3VzT2Zmc2V0ICE9PSBwcmV2aW91c0ZvY3VzT2Zmc2V0IHx8IGN1cnJlbnRGb2N1c05vZGVLZXkgIT09IHByZXZpb3VzRm9jdXNOb2RlLmdldEtleSgpO1xuICAgICAgaWYgKChkaWZmZXJlbnRBbmNob3JET00gfHwgZGlmZmVyZW50Rm9jdXNET00pICYmIGN1cnJlbnRBbmNob3JOb2RlRE9NICE9PSBudWxsICYmIGN1cnJlbnRGb2N1c05vZGVET00gIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSByYW5nZUZyb21Qb2ludHMoZWRpdG9yLCBhbmNob3IsIGN1cnJlbnRBbmNob3JOb2RlLCBjdXJyZW50QW5jaG9yTm9kZURPTSwgZm9jdXMsIGN1cnJlbnRGb2N1c05vZGUsIGN1cnJlbnRGb2N1c05vZGVET00pO1xuICAgICAgICByZW1vdmVSYW5nZUxpc3RlbmVyKCk7XG4gICAgICAgIHJlbW92ZVJhbmdlTGlzdGVuZXIgPSBtbGNQb3NpdGlvbk5vZGVPblJhbmdlKGVkaXRvciwgcmFuZ2UsIGRvbU5vZGVzID0+IHtcbiAgICAgICAgICBpZiAob25SZXBvc2l0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZG9tTm9kZSBvZiBkb21Ob2Rlcykge1xuICAgICAgICAgICAgICBjb25zdCBkb21Ob2RlU3R5bGUgPSBkb21Ob2RlLnN0eWxlO1xuICAgICAgICAgICAgICBpZiAoZG9tTm9kZVN0eWxlLmJhY2tncm91bmQgIT09ICdIaWdobGlnaHQnKSB7XG4gICAgICAgICAgICAgICAgZG9tTm9kZVN0eWxlLmJhY2tncm91bmQgPSAnSGlnaGxpZ2h0JztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZG9tTm9kZVN0eWxlLmNvbG9yICE9PSAnSGlnaGxpZ2h0VGV4dCcpIHtcbiAgICAgICAgICAgICAgICBkb21Ob2RlU3R5bGUuY29sb3IgPSAnSGlnaGxpZ2h0VGV4dCc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGRvbU5vZGVTdHlsZS5tYXJnaW5Ub3AgIT09IHB4KC0xLjUpKSB7XG4gICAgICAgICAgICAgICAgZG9tTm9kZVN0eWxlLm1hcmdpblRvcCA9IHB4KC0xLjUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChkb21Ob2RlU3R5bGUucGFkZGluZ1RvcCAhPT0gcHgoNCkpIHtcbiAgICAgICAgICAgICAgICBkb21Ob2RlU3R5bGUucGFkZGluZ1RvcCA9IHB4KDQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChkb21Ob2RlU3R5bGUucGFkZGluZ0JvdHRvbSAhPT0gcHgoMCkpIHtcbiAgICAgICAgICAgICAgICBkb21Ob2RlU3R5bGUucGFkZGluZ0JvdHRvbSA9IHB4KDApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9uUmVwb3NpdGlvbihkb21Ob2Rlcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHByZXZpb3VzQW5jaG9yTm9kZSA9IGN1cnJlbnRBbmNob3JOb2RlO1xuICAgICAgcHJldmlvdXNBbmNob3JOb2RlRE9NID0gY3VycmVudEFuY2hvck5vZGVET007XG4gICAgICBwcmV2aW91c0FuY2hvck9mZnNldCA9IGN1cnJlbnRBbmNob3JPZmZzZXQ7XG4gICAgICBwcmV2aW91c0ZvY3VzTm9kZSA9IGN1cnJlbnRGb2N1c05vZGU7XG4gICAgICBwcmV2aW91c0ZvY3VzTm9kZURPTSA9IGN1cnJlbnRGb2N1c05vZGVET007XG4gICAgICBwcmV2aW91c0ZvY3VzT2Zmc2V0ID0gY3VycmVudEZvY3VzT2Zmc2V0O1xuICAgIH0pO1xuICB9XG4gIGNvbXB1dGUoZWRpdG9yLmdldEVkaXRvclN0YXRlKCkpO1xuICByZXR1cm4gbWVyZ2VSZWdpc3RlcihlZGl0b3IucmVnaXN0ZXJVcGRhdGVMaXN0ZW5lcigoe1xuICAgIGVkaXRvclN0YXRlXG4gIH0pID0+IGNvbXB1dGUoZWRpdG9yU3RhdGUpKSwgKCkgPT4ge1xuICAgIHJlbW92ZVJhbmdlTGlzdGVuZXIoKTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gc2VsZWN0aW9uQWx3YXlzT25EaXNwbGF5KGVkaXRvcikge1xuICBsZXQgcmVtb3ZlU2VsZWN0aW9uTWFyayA9IG51bGw7XG4gIGNvbnN0IG9uU2VsZWN0aW9uQ2hhbmdlID0gKCkgPT4ge1xuICAgIGNvbnN0IGRvbVNlbGVjdGlvbiA9IGdldFNlbGVjdGlvbigpO1xuICAgIGNvbnN0IGRvbUFuY2hvck5vZGUgPSBkb21TZWxlY3Rpb24gJiYgZG9tU2VsZWN0aW9uLmFuY2hvck5vZGU7XG4gICAgY29uc3QgZWRpdG9yUm9vdEVsZW1lbnQgPSBlZGl0b3IuZ2V0Um9vdEVsZW1lbnQoKTtcbiAgICBjb25zdCBpc1NlbGVjdGlvbkluc2lkZUVkaXRvciA9IGRvbUFuY2hvck5vZGUgIT09IG51bGwgJiYgZWRpdG9yUm9vdEVsZW1lbnQgIT09IG51bGwgJiYgZWRpdG9yUm9vdEVsZW1lbnQuY29udGFpbnMoZG9tQW5jaG9yTm9kZSk7XG4gICAgaWYgKGlzU2VsZWN0aW9uSW5zaWRlRWRpdG9yKSB7XG4gICAgICBpZiAocmVtb3ZlU2VsZWN0aW9uTWFyayAhPT0gbnVsbCkge1xuICAgICAgICByZW1vdmVTZWxlY3Rpb25NYXJrKCk7XG4gICAgICAgIHJlbW92ZVNlbGVjdGlvbk1hcmsgPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocmVtb3ZlU2VsZWN0aW9uTWFyayA9PT0gbnVsbCkge1xuICAgICAgICByZW1vdmVTZWxlY3Rpb25NYXJrID0gbWFya1NlbGVjdGlvbihlZGl0b3IpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0aW9uY2hhbmdlJywgb25TZWxlY3Rpb25DaGFuZ2UpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGlmIChyZW1vdmVTZWxlY3Rpb25NYXJrICE9PSBudWxsKSB7XG4gICAgICByZW1vdmVTZWxlY3Rpb25NYXJrKCk7XG4gICAgfVxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlbGVjdGlvbmNoYW5nZScsIG9uU2VsZWN0aW9uQ2hhbmdlKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4vLyBIb3RmaXggdG8gZXhwb3J0IHRoZXNlIHdpdGggaW5saW5lZCB0eXBlcyAjNTkxOFxuY29uc3QgQ0FOX1VTRV9CRUZPUkVfSU5QVVQgPSBDQU5fVVNFX0JFRk9SRV9JTlBVVCQxO1xuY29uc3QgQ0FOX1VTRV9ET00gPSBDQU5fVVNFX0RPTSQxO1xuY29uc3QgSVNfQU5EUk9JRCA9IElTX0FORFJPSUQkMTtcbmNvbnN0IElTX0FORFJPSURfQ0hST01FID0gSVNfQU5EUk9JRF9DSFJPTUUkMTtcbmNvbnN0IElTX0FQUExFID0gSVNfQVBQTEUkMTtcbmNvbnN0IElTX0FQUExFX1dFQktJVCA9IElTX0FQUExFX1dFQktJVCQxO1xuY29uc3QgSVNfQ0hST01FID0gSVNfQ0hST01FJDE7XG5jb25zdCBJU19GSVJFRk9YID0gSVNfRklSRUZPWCQxO1xuY29uc3QgSVNfSU9TID0gSVNfSU9TJDE7XG5jb25zdCBJU19TQUZBUkkgPSBJU19TQUZBUkkkMTtcblxuLyoqXG4gKiBUYWtlcyBhbiBIVE1MIGVsZW1lbnQgYW5kIGFkZHMgdGhlIGNsYXNzTmFtZXMgcGFzc2VkIHdpdGhpbiBhbiBhcnJheSxcbiAqIGlnbm9yaW5nIGFueSBub24tc3RyaW5nIHR5cGVzLiBBIHNwYWNlIGNhbiBiZSB1c2VkIHRvIGFkZCBtdWx0aXBsZSBjbGFzc2VzXG4gKiBlZy4gYWRkQ2xhc3NOYW1lc1RvRWxlbWVudChlbGVtZW50LCBbJ2VsZW1lbnQtaW5uZXIgYWN0aXZlJywgdHJ1ZSwgbnVsbF0pXG4gKiB3aWxsIGFkZCBib3RoICdlbGVtZW50LWlubmVyJyBhbmQgJ2FjdGl2ZScgYXMgY2xhc3NlcyB0byB0aGF0IGVsZW1lbnQuXG4gKiBAcGFyYW0gZWxlbWVudCAtIFRoZSBlbGVtZW50IGluIHdoaWNoIHRoZSBjbGFzc2VzIGFyZSBhZGRlZFxuICogQHBhcmFtIGNsYXNzTmFtZXMgLSBBbiBhcnJheSBkZWZpbmluZyB0aGUgY2xhc3MgbmFtZXMgdG8gYWRkIHRvIHRoZSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIGFkZENsYXNzTmFtZXNUb0VsZW1lbnQoZWxlbWVudCwgLi4uY2xhc3NOYW1lcykge1xuICBjb25zdCBjbGFzc2VzVG9BZGQgPSBub3JtYWxpemVDbGFzc05hbWVzKC4uLmNsYXNzTmFtZXMpO1xuICBpZiAoY2xhc3Nlc1RvQWRkLmxlbmd0aCA+IDApIHtcbiAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoLi4uY2xhc3Nlc1RvQWRkKTtcbiAgfVxufVxuXG4vKipcbiAqIFRha2VzIGFuIEhUTUwgZWxlbWVudCBhbmQgcmVtb3ZlcyB0aGUgY2xhc3NOYW1lcyBwYXNzZWQgd2l0aGluIGFuIGFycmF5LFxuICogaWdub3JpbmcgYW55IG5vbi1zdHJpbmcgdHlwZXMuIEEgc3BhY2UgY2FuIGJlIHVzZWQgdG8gcmVtb3ZlIG11bHRpcGxlIGNsYXNzZXNcbiAqIGVnLiByZW1vdmVDbGFzc05hbWVzRnJvbUVsZW1lbnQoZWxlbWVudCwgWydhY3RpdmUgc21hbGwnLCB0cnVlLCBudWxsXSlcbiAqIHdpbGwgcmVtb3ZlIGJvdGggdGhlICdhY3RpdmUnIGFuZCAnc21hbGwnIGNsYXNzZXMgZnJvbSB0aGF0IGVsZW1lbnQuXG4gKiBAcGFyYW0gZWxlbWVudCAtIFRoZSBlbGVtZW50IGluIHdoaWNoIHRoZSBjbGFzc2VzIGFyZSByZW1vdmVkXG4gKiBAcGFyYW0gY2xhc3NOYW1lcyAtIEFuIGFycmF5IGRlZmluaW5nIHRoZSBjbGFzcyBuYW1lcyB0byByZW1vdmUgZnJvbSB0aGUgZWxlbWVudFxuICovXG5mdW5jdGlvbiByZW1vdmVDbGFzc05hbWVzRnJvbUVsZW1lbnQoZWxlbWVudCwgLi4uY2xhc3NOYW1lcykge1xuICBjb25zdCBjbGFzc2VzVG9SZW1vdmUgPSBub3JtYWxpemVDbGFzc05hbWVzKC4uLmNsYXNzTmFtZXMpO1xuICBpZiAoY2xhc3Nlc1RvUmVtb3ZlLmxlbmd0aCA+IDApIHtcbiAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoLi4uY2xhc3Nlc1RvUmVtb3ZlKTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZmlsZSB0eXBlIG1hdGNoZXMgdGhlIHR5cGVzIHBhc3NlZCB3aXRoaW4gdGhlIGFjY2VwdGFibGVNaW1lVHlwZXMgYXJyYXksIGZhbHNlIG90aGVyd2lzZS5cbiAqIFRoZSB0eXBlcyBwYXNzZWQgbXVzdCBiZSBzdHJpbmdzIGFuZCBhcmUgQ0FTRS1TRU5TSVRJVkUuXG4gKiBlZy4gaWYgZmlsZSBpcyBvZiB0eXBlICd0ZXh0JyBhbmQgYWNjZXB0YWJsZU1pbWVUeXBlcyA9IFsnVEVYVCcsICdJTUFHRSddIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiBmYWxzZS5cbiAqIEBwYXJhbSBmaWxlIC0gVGhlIGZpbGUgeW91IHdhbnQgdG8gdHlwZSBjaGVjay5cbiAqIEBwYXJhbSBhY2NlcHRhYmxlTWltZVR5cGVzIC0gQW4gYXJyYXkgb2Ygc3RyaW5ncyBvZiB0eXBlcyB3aGljaCB0aGUgZmlsZSBpcyBjaGVja2VkIGFnYWluc3QuXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBmaWxlIGlzIGFuIGFjY2VwdGFibGUgbWltZSB0eXBlLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzTWltZVR5cGUoZmlsZSwgYWNjZXB0YWJsZU1pbWVUeXBlcykge1xuICBmb3IgKGNvbnN0IGFjY2VwdGFibGVUeXBlIG9mIGFjY2VwdGFibGVNaW1lVHlwZXMpIHtcbiAgICBpZiAoZmlsZS50eXBlLnN0YXJ0c1dpdGgoYWNjZXB0YWJsZVR5cGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIExleGljYWwgRmlsZSBSZWFkZXIgd2l0aDpcbiAqICAxLiBNSU1FIHR5cGUgc3VwcG9ydFxuICogIDIuIGJhdGNoZWQgcmVzdWx0cyAoSGlzdG9yeVBsdWdpbiBjb21wYXRpYmlsaXR5KVxuICogIDMuIE9yZGVyIGF3YXJlIChyZXNwZWN0cyB0aGUgb3JkZXIgd2hlbiBtdWx0aXBsZSBGaWxlcyBhcmUgcGFzc2VkKVxuICpcbiAqIGNvbnN0IGZpbGVzUmVzdWx0ID0gYXdhaXQgbWVkaWFGaWxlUmVhZGVyKGZpbGVzLCBbJ2ltYWdlLyddKTtcbiAqIGZpbGVzUmVzdWx0LmZvckVhY2goZmlsZSA9PiBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKCdJTlNFUlRfSU1BR0UnLCBcXFxce1xuICogICBzcmM6IGZpbGUucmVzdWx0LFxuICogXFxcXH0pKTtcbiAqL1xuZnVuY3Rpb24gbWVkaWFGaWxlUmVhZGVyKGZpbGVzLCBhY2NlcHRhYmxlTWltZVR5cGVzKSB7XG4gIGNvbnN0IGZpbGVzSXRlcmF0b3IgPSBmaWxlc1tTeW1ib2wuaXRlcmF0b3JdKCk7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgcHJvY2Vzc2VkID0gW107XG4gICAgY29uc3QgaGFuZGxlTmV4dEZpbGUgPSAoKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRvbmUsXG4gICAgICAgIHZhbHVlOiBmaWxlXG4gICAgICB9ID0gZmlsZXNJdGVyYXRvci5uZXh0KCk7XG4gICAgICBpZiAoZG9uZSkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZShwcm9jZXNzZWQpO1xuICAgICAgfVxuICAgICAgY29uc3QgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICBmaWxlUmVhZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgcmVqZWN0KTtcbiAgICAgIGZpbGVSZWFkZXIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZmlsZVJlYWRlci5yZXN1bHQ7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHByb2Nlc3NlZC5wdXNoKHtcbiAgICAgICAgICAgIGZpbGUsXG4gICAgICAgICAgICByZXN1bHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBoYW5kbGVOZXh0RmlsZSgpO1xuICAgICAgfSk7XG4gICAgICBpZiAoaXNNaW1lVHlwZShmaWxlLCBhY2NlcHRhYmxlTWltZVR5cGVzKSkge1xuICAgICAgICBmaWxlUmVhZGVyLnJlYWRBc0RhdGFVUkwoZmlsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoYW5kbGVOZXh0RmlsZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgaGFuZGxlTmV4dEZpbGUoKTtcbiAgfSk7XG59XG4vKipcbiAqIFwiRGVwdGgtRmlyc3QgU2VhcmNoXCIgc3RhcnRzIGF0IHRoZSByb290L3RvcCBub2RlIG9mIGEgdHJlZSBhbmQgZ29lcyBhcyBmYXIgYXMgaXQgY2FuIGRvd24gYSBicmFuY2ggZW5kXG4gKiBiZWZvcmUgYmFja3RyYWNraW5nIGFuZCBmaW5kaW5nIGEgbmV3IHBhdGguIENvbnNpZGVyIHNvbHZpbmcgYSBtYXplIGJ5IGh1Z2dpbmcgZWl0aGVyIHdhbGwsIG1vdmluZyBkb3duIGFcbiAqIGJyYW5jaCB1bnRpbCB5b3UgaGl0IGEgZGVhZC1lbmQgKGxlYWYpIGFuZCBiYWNrdHJhY2tpbmcgdG8gZmluZCB0aGUgbmVhcmVzdCBicmFuY2hpbmcgcGF0aCBhbmQgcmVwZWF0LlxuICogSXQgd2lsbCB0aGVuIHJldHVybiBhbGwgdGhlIG5vZGVzIGZvdW5kIGluIHRoZSBzZWFyY2ggaW4gYW4gYXJyYXkgb2Ygb2JqZWN0cy5cbiAqIEBwYXJhbSBzdGFydE5vZGUgLSBUaGUgbm9kZSB0byBzdGFydCB0aGUgc2VhcmNoLCBpZiBvbWl0dGVkLCBpdCB3aWxsIHN0YXJ0IGF0IHRoZSByb290IG5vZGUuXG4gKiBAcGFyYW0gZW5kTm9kZSAtIFRoZSBub2RlIHRvIGVuZCB0aGUgc2VhcmNoLCBpZiBvbWl0dGVkLCBpdCB3aWxsIGZpbmQgYWxsIGRlc2NlbmRhbnRzIG9mIHRoZSBzdGFydGluZ05vZGUuXG4gKiBAcmV0dXJucyBBbiBhcnJheSBvZiBvYmplY3RzIG9mIGFsbCB0aGUgbm9kZXMgZm91bmQgYnkgdGhlIHNlYXJjaCwgaW5jbHVkaW5nIHRoZWlyIGRlcHRoIGludG8gdGhlIHRyZWUuXG4gKiBcXFxce2RlcHRoOiBudW1iZXIsIG5vZGU6IExleGljYWxOb2RlXFxcXH0gSXQgd2lsbCBhbHdheXMgcmV0dXJuIGF0IGxlYXN0IDEgbm9kZSAodGhlIHN0YXJ0IG5vZGUpLlxuICovXG5mdW5jdGlvbiAkZGZzKHN0YXJ0Tm9kZSwgZW5kTm9kZSkge1xuICByZXR1cm4gQXJyYXkuZnJvbSgkZGZzSXRlcmF0b3Ioc3RhcnROb2RlLCBlbmROb2RlKSk7XG59XG5jb25zdCBpdGVyYXRvckRvbmUgPSB7XG4gIGRvbmU6IHRydWUsXG4gIHZhbHVlOiB1bmRlZmluZWRcbn07XG5jb25zdCBpdGVyYXRvck5vdERvbmUgPSB2YWx1ZSA9PiAoe1xuICBkb25lOiBmYWxzZSxcbiAgdmFsdWVcbn0pO1xuXG4vKipcbiAqICRkZnMgaXRlcmF0b3IuIFRyZWUgdHJhdmVyc2FsIGlzIGRvbmUgb24gdGhlIGZseSBhcyBuZXcgdmFsdWVzIGFyZSByZXF1ZXN0ZWQgd2l0aCBPKDEpIG1lbW9yeS5cbiAqIEBwYXJhbSBzdGFydE5vZGUgLSBUaGUgbm9kZSB0byBzdGFydCB0aGUgc2VhcmNoLCBpZiBvbWl0dGVkLCBpdCB3aWxsIHN0YXJ0IGF0IHRoZSByb290IG5vZGUuXG4gKiBAcGFyYW0gZW5kTm9kZSAtIFRoZSBub2RlIHRvIGVuZCB0aGUgc2VhcmNoLCBpZiBvbWl0dGVkLCBpdCB3aWxsIGZpbmQgYWxsIGRlc2NlbmRhbnRzIG9mIHRoZSBzdGFydGluZ05vZGUuXG4gKiBAcmV0dXJucyBBbiBpdGVyYXRvciwgZWFjaCB5aWVsZGVkIHZhbHVlIGlzIGEgREZTTm9kZS4gSXQgd2lsbCBhbHdheXMgcmV0dXJuIGF0IGxlYXN0IDEgbm9kZSAodGhlIHN0YXJ0IG5vZGUpLlxuICovXG5mdW5jdGlvbiAkZGZzSXRlcmF0b3Ioc3RhcnROb2RlLCBlbmROb2RlKSB7XG4gIGNvbnN0IHN0YXJ0ID0gKHN0YXJ0Tm9kZSB8fCAkZ2V0Um9vdCgpKS5nZXRMYXRlc3QoKTtcbiAgY29uc3Qgc3RhcnREZXB0aCA9ICRnZXREZXB0aChzdGFydCk7XG4gIGNvbnN0IGVuZCA9IGVuZE5vZGU7XG4gIGxldCBub2RlID0gc3RhcnQ7XG4gIGxldCBkZXB0aCA9IHN0YXJ0RGVwdGg7XG4gIGxldCBpc0ZpcnN0TmV4dCA9IHRydWU7XG4gIGNvbnN0IGl0ZXJhdG9yID0ge1xuICAgIG5leHQoKSB7XG4gICAgICBpZiAobm9kZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JEb25lO1xuICAgICAgfVxuICAgICAgaWYgKGlzRmlyc3ROZXh0KSB7XG4gICAgICAgIGlzRmlyc3ROZXh0ID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck5vdERvbmUoe1xuICAgICAgICAgIGRlcHRoLFxuICAgICAgICAgIG5vZGVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAobm9kZSA9PT0gZW5kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvckRvbmU7XG4gICAgICB9XG4gICAgICBpZiAoJGlzRWxlbWVudE5vZGUobm9kZSkgJiYgbm9kZS5nZXRDaGlsZHJlblNpemUoKSA+IDApIHtcbiAgICAgICAgbm9kZSA9IG5vZGUuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgICAgICBkZXB0aCsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGRlcHRoRGlmZjtcbiAgICAgICAgW25vZGUsIGRlcHRoRGlmZl0gPSAkZ2V0TmV4dFNpYmxpbmdPclBhcmVudFNpYmxpbmcobm9kZSkgfHwgW251bGwsIDBdO1xuICAgICAgICBkZXB0aCArPSBkZXB0aERpZmY7XG4gICAgICAgIGlmIChlbmQgPT0gbnVsbCAmJiBkZXB0aCA8PSBzdGFydERlcHRoKSB7XG4gICAgICAgICAgbm9kZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChub2RlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvckRvbmU7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlcmF0b3JOb3REb25lKHtcbiAgICAgICAgZGVwdGgsXG4gICAgICAgIG5vZGVcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICByZXR1cm4gaXRlcmF0b3I7XG4gICAgfVxuICB9O1xuICByZXR1cm4gaXRlcmF0b3I7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgTm9kZSBzaWJsaW5nIHdoZW4gdGhpcyBleGlzdHMsIG90aGVyd2lzZSB0aGUgY2xvc2VzdCBwYXJlbnQgc2libGluZy4gRm9yIGV4YW1wbGVcbiAqIFIgLT4gUCAtPiBUMSwgVDJcbiAqICAgLT4gUDJcbiAqIHJldHVybnMgVDIgZm9yIG5vZGUgVDEsIFAyIGZvciBub2RlIFQyLCBhbmQgbnVsbCBmb3Igbm9kZSBQMi5cbiAqIEBwYXJhbSBub2RlIExleGljYWxOb2RlLlxuICogQHJldHVybnMgQW4gYXJyYXkgKHR1cGxlKSBjb250YWluaW5nIHRoZSBmb3VuZCBMZXhpY2FsIG5vZGUgYW5kIHRoZSBkZXB0aCBkaWZmZXJlbmNlLCBvciBudWxsLCBpZiB0aGlzIG5vZGUgZG9lc24ndCBleGlzdC5cbiAqL1xuZnVuY3Rpb24gJGdldE5leHRTaWJsaW5nT3JQYXJlbnRTaWJsaW5nKG5vZGUpIHtcbiAgbGV0IG5vZGVfID0gbm9kZTtcbiAgLy8gRmluZCBpbW1lZGlhdGUgc2libGluZyBvciBuZWFyZXN0IHBhcmVudCBzaWJsaW5nXG4gIGxldCBzaWJsaW5nID0gbnVsbDtcbiAgbGV0IGRlcHRoRGlmZiA9IDA7XG4gIHdoaWxlIChzaWJsaW5nID09PSBudWxsICYmIG5vZGVfICE9PSBudWxsKSB7XG4gICAgc2libGluZyA9IG5vZGVfLmdldE5leHRTaWJsaW5nKCk7XG4gICAgaWYgKHNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgIG5vZGVfID0gbm9kZV8uZ2V0UGFyZW50KCk7XG4gICAgICBkZXB0aERpZmYtLTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZV8gPSBzaWJsaW5nO1xuICAgIH1cbiAgfVxuICBpZiAobm9kZV8gPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gW25vZGVfLCBkZXB0aERpZmZdO1xufVxuZnVuY3Rpb24gJGdldERlcHRoKG5vZGUpIHtcbiAgbGV0IGlubmVyTm9kZSA9IG5vZGU7XG4gIGxldCBkZXB0aCA9IDA7XG4gIHdoaWxlICgoaW5uZXJOb2RlID0gaW5uZXJOb2RlLmdldFBhcmVudCgpKSAhPT0gbnVsbCkge1xuICAgIGRlcHRoKys7XG4gIH1cbiAgcmV0dXJuIGRlcHRoO1xufVxuXG4vKipcbiAqIFBlcmZvcm1zIGEgcmlnaHQtdG8tbGVmdCBwcmVvcmRlciB0cmVlIHRyYXZlcnNhbC5cbiAqIEZyb20gdGhlIHN0YXJ0aW5nIG5vZGUgaXQgZ29lcyB0byB0aGUgcmlnaHRtb3N0IGNoaWxkLCB0aGFuIGJhY2t0cmFja3MgdG8gcGFyZXQgYW5kIGZpbmRzIG5ldyByaWdodG1vc3QgcGF0aC5cbiAqIEl0IHdpbGwgcmV0dXJuIHRoZSBuZXh0IG5vZGUgaW4gdHJhdmVyc2FsIHNlcXVlbmNlIGFmdGVyIHRoZSBzdGFydGluZ05vZGUuXG4gKiBUaGUgdHJhdmVyc2FsIGlzIHNpbWlsYXIgdG8gJGRmcyBmdW5jdGlvbnMgYWJvdmUsIGJ1dCB0aGUgbm9kZXMgYXJlIHZpc2l0ZWQgcmlnaHQtdG8tbGVmdCwgbm90IGxlZnQtdG8tcmlnaHQuXG4gKiBAcGFyYW0gc3RhcnRpbmdOb2RlIC0gVGhlIG5vZGUgdG8gc3RhcnQgdGhlIHNlYXJjaC5cbiAqIEByZXR1cm5zIFRoZSBuZXh0IG5vZGUgaW4gcHJlLW9yZGVyIHJpZ2h0IHRvIGxlZnQgdHJhdmVyc2FsIHNlcXVlbmNlIG9yIGBudWxsYCwgaWYgdGhlIG5vZGUgZG9lcyBub3QgZXhpc3RcbiAqL1xuZnVuY3Rpb24gJGdldE5leHRSaWdodFByZW9yZGVyTm9kZShzdGFydGluZ05vZGUpIHtcbiAgbGV0IG5vZGUgPSBzdGFydGluZ05vZGU7XG4gIGlmICgkaXNFbGVtZW50Tm9kZShub2RlKSAmJiBub2RlLmdldENoaWxkcmVuU2l6ZSgpID4gMCkge1xuICAgIG5vZGUgPSBub2RlLmdldExhc3RDaGlsZCgpO1xuICB9IGVsc2Uge1xuICAgIGxldCBzaWJsaW5nID0gbnVsbDtcbiAgICB3aGlsZSAoc2libGluZyA9PT0gbnVsbCAmJiBub2RlICE9PSBudWxsKSB7XG4gICAgICBzaWJsaW5nID0gbm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICAgIGlmIChzaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLmdldFBhcmVudCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZSA9IHNpYmxpbmc7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBub2RlO1xufVxuXG4vKipcbiAqIFRha2VzIGEgbm9kZSBhbmQgdHJhdmVyc2VzIHVwIGl0cyBhbmNlc3RvcnMgKHRvd2FyZCB0aGUgcm9vdCBub2RlKVxuICogaW4gb3JkZXIgdG8gZmluZCBhIHNwZWNpZmljIHR5cGUgb2Ygbm9kZS5cbiAqIEBwYXJhbSBub2RlIC0gdGhlIG5vZGUgdG8gYmVnaW4gc2VhcmNoaW5nLlxuICogQHBhcmFtIGtsYXNzIC0gYW4gaW5zdGFuY2Ugb2YgdGhlIHR5cGUgb2Ygbm9kZSB0byBsb29rIGZvci5cbiAqIEByZXR1cm5zIHRoZSBub2RlIG9mIHR5cGUga2xhc3MgdGhhdCB3YXMgcGFzc2VkLCBvciBudWxsIGlmIG5vbmUgZXhpc3QuXG4gKi9cbmZ1bmN0aW9uICRnZXROZWFyZXN0Tm9kZU9mVHlwZShub2RlLCBrbGFzcykge1xuICBsZXQgcGFyZW50ID0gbm9kZTtcbiAgd2hpbGUgKHBhcmVudCAhPSBudWxsKSB7XG4gICAgaWYgKHBhcmVudCBpbnN0YW5jZW9mIGtsYXNzKSB7XG4gICAgICByZXR1cm4gcGFyZW50O1xuICAgIH1cbiAgICBwYXJlbnQgPSBwYXJlbnQuZ2V0UGFyZW50KCk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZWxlbWVudCBub2RlIG9mIHRoZSBuZWFyZXN0IGFuY2VzdG9yLCBvdGhlcndpc2UgdGhyb3dzIGFuIGVycm9yLlxuICogQHBhcmFtIHN0YXJ0Tm9kZSAtIFRoZSBzdGFydGluZyBub2RlIG9mIHRoZSBzZWFyY2hcbiAqIEByZXR1cm5zIFRoZSBhbmNlc3RvciBub2RlIGZvdW5kXG4gKi9cbmZ1bmN0aW9uICRnZXROZWFyZXN0QmxvY2tFbGVtZW50QW5jZXN0b3JPclRocm93KHN0YXJ0Tm9kZSkge1xuICBjb25zdCBibG9ja05vZGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KHN0YXJ0Tm9kZSwgbm9kZSA9PiAkaXNFbGVtZW50Tm9kZShub2RlKSAmJiAhbm9kZS5pc0lubGluZSgpKTtcbiAgaWYgKCEkaXNFbGVtZW50Tm9kZShibG9ja05vZGUpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIG5vZGUgJHtzdGFydE5vZGUuX19rZXl9IHRvIGhhdmUgY2xvc2VzdCBibG9jayBlbGVtZW50IG5vZGUuYCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBibG9ja05vZGU7XG59XG4vKipcbiAqIFN0YXJ0cyB3aXRoIGEgbm9kZSBhbmQgbW92ZXMgdXAgdGhlIHRyZWUgKHRvd2FyZCB0aGUgcm9vdCBub2RlKSB0byBmaW5kIGEgbWF0Y2hpbmcgbm9kZSBiYXNlZCBvblxuICogdGhlIHNlYXJjaCBwYXJhbWV0ZXJzIG9mIHRoZSBmaW5kRm4uIChDb25zaWRlciBKYXZhU2NyaXB0cycgLmZpbmQoKSBmdW5jdGlvbiB3aGVyZSBhIHRlc3RpbmcgZnVuY3Rpb24gbXVzdCBiZVxuICogcGFzc2VkIGFzIGFuIGFyZ3VtZW50LiBlZy4gaWYoIChub2RlKSA9PiBub2RlLl9fdHlwZSA9PT0gJ2RpdicpICkgcmV0dXJuIHRydWU7IG90aGVyd2lzZSByZXR1cm4gZmFsc2VcbiAqIEBwYXJhbSBzdGFydGluZ05vZGUgLSBUaGUgbm9kZSB3aGVyZSB0aGUgc2VhcmNoIHN0YXJ0cy5cbiAqIEBwYXJhbSBmaW5kRm4gLSBBIHRlc3RpbmcgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRydWUgaWYgdGhlIGN1cnJlbnQgbm9kZSBzYXRpc2ZpZXMgdGhlIHRlc3RpbmcgcGFyYW1ldGVycy5cbiAqIEByZXR1cm5zIEEgcGFyZW50IG5vZGUgdGhhdCBtYXRjaGVzIHRoZSBmaW5kRm4gcGFyYW1ldGVycywgb3IgbnVsbCBpZiBvbmUgd2Fzbid0IGZvdW5kLlxuICovXG5jb25zdCAkZmluZE1hdGNoaW5nUGFyZW50ID0gKHN0YXJ0aW5nTm9kZSwgZmluZEZuKSA9PiB7XG4gIGxldCBjdXJyID0gc3RhcnRpbmdOb2RlO1xuICB3aGlsZSAoY3VyciAhPT0gJGdldFJvb3QoKSAmJiBjdXJyICE9IG51bGwpIHtcbiAgICBpZiAoZmluZEZuKGN1cnIpKSB7XG4gICAgICByZXR1cm4gY3VycjtcbiAgICB9XG4gICAgY3VyciA9IGN1cnIuZ2V0UGFyZW50KCk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIEF0dGVtcHRzIHRvIHJlc29sdmUgbmVzdGVkIGVsZW1lbnQgbm9kZXMgb2YgdGhlIHNhbWUgdHlwZSBpbnRvIGEgc2luZ2xlIG5vZGUgb2YgdGhhdCB0eXBlLlxuICogSXQgaXMgZ2VuZXJhbGx5IHVzZWQgZm9yIG1hcmtzL2NvbW1lbnRpbmdcbiAqIEBwYXJhbSBlZGl0b3IgLSBUaGUgbGV4aWNhbCBlZGl0b3JcbiAqIEBwYXJhbSB0YXJnZXROb2RlIC0gVGhlIHRhcmdldCBmb3IgdGhlIG5lc3RlZCBlbGVtZW50IHRvIGJlIGV4dHJhY3RlZCBmcm9tLlxuICogQHBhcmFtIGNsb25lTm9kZSAtIFNlZSB7QGxpbmsgJGNyZWF0ZU1hcmtOb2RlfVxuICogQHBhcmFtIGhhbmRsZU92ZXJsYXAgLSBIYW5kbGVzIGFueSBvdmVybGFwIGJldHdlZW4gdGhlIG5vZGUgdG8gZXh0cmFjdCBhbmQgdGhlIHRhcmdldE5vZGVcbiAqIEByZXR1cm5zIFRoZSBsZXhpY2FsIGVkaXRvclxuICovXG5mdW5jdGlvbiByZWdpc3Rlck5lc3RlZEVsZW1lbnRSZXNvbHZlcihlZGl0b3IsIHRhcmdldE5vZGUsIGNsb25lTm9kZSwgaGFuZGxlT3ZlcmxhcCkge1xuICBjb25zdCAkaXNUYXJnZXROb2RlID0gbm9kZSA9PiB7XG4gICAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiB0YXJnZXROb2RlO1xuICB9O1xuICBjb25zdCAkZmluZE1hdGNoID0gbm9kZSA9PiB7XG4gICAgLy8gRmlyc3QgdmFsaWRhdGUgd2UgZG9uJ3QgaGF2ZSBhbnkgY2hpbGRyZW4gdGhhdCBhcmUgb2YgdGhlIHRhcmdldCxcbiAgICAvLyBhcyB3ZSBuZWVkIHRvIGhhbmRsZSB0aGVtIGZpcnN0LlxuICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5nZXRDaGlsZHJlbigpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBpZiAoJGlzVGFyZ2V0Tm9kZShjaGlsZCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBwYXJlbnROb2RlID0gbm9kZTtcbiAgICBsZXQgY2hpbGROb2RlID0gbm9kZTtcbiAgICB3aGlsZSAocGFyZW50Tm9kZSAhPT0gbnVsbCkge1xuICAgICAgY2hpbGROb2RlID0gcGFyZW50Tm9kZTtcbiAgICAgIHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLmdldFBhcmVudCgpO1xuICAgICAgaWYgKCRpc1RhcmdldE5vZGUocGFyZW50Tm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjaGlsZDogY2hpbGROb2RlLFxuICAgICAgICAgIHBhcmVudDogcGFyZW50Tm9kZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbiAgY29uc3QgJGVsZW1lbnROb2RlVHJhbnNmb3JtID0gbm9kZSA9PiB7XG4gICAgY29uc3QgbWF0Y2ggPSAkZmluZE1hdGNoKG5vZGUpO1xuICAgIGlmIChtYXRjaCAhPT0gbnVsbCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjaGlsZCxcbiAgICAgICAgcGFyZW50XG4gICAgICB9ID0gbWF0Y2g7XG5cbiAgICAgIC8vIFNpbXBsZSBwYXRoLCB3ZSBjYW4gbW92ZSBjaGlsZCBvdXQgYW5kIHNpYmxpbmdzIGludG8gYSBuZXcgcGFyZW50LlxuXG4gICAgICBpZiAoY2hpbGQuaXMobm9kZSkpIHtcbiAgICAgICAgaGFuZGxlT3ZlcmxhcChwYXJlbnQsIG5vZGUpO1xuICAgICAgICBjb25zdCBuZXh0U2libGluZ3MgPSBjaGlsZC5nZXROZXh0U2libGluZ3MoKTtcbiAgICAgICAgY29uc3QgbmV4dFNpYmxpbmdzTGVuZ3RoID0gbmV4dFNpYmxpbmdzLmxlbmd0aDtcbiAgICAgICAgcGFyZW50Lmluc2VydEFmdGVyKGNoaWxkKTtcbiAgICAgICAgaWYgKG5leHRTaWJsaW5nc0xlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIGNvbnN0IG5ld1BhcmVudCA9IGNsb25lTm9kZShwYXJlbnQpO1xuICAgICAgICAgIGNoaWxkLmluc2VydEFmdGVyKG5ld1BhcmVudCk7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXh0U2libGluZ3NMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbmV3UGFyZW50LmFwcGVuZChuZXh0U2libGluZ3NbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhcmVudC5jYW5CZUVtcHR5KCkgJiYgcGFyZW50LmdldENoaWxkcmVuU2l6ZSgpID09PSAwKSB7XG4gICAgICAgICAgcGFyZW50LnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZXR1cm4gZWRpdG9yLnJlZ2lzdGVyTm9kZVRyYW5zZm9ybSh0YXJnZXROb2RlLCAkZWxlbWVudE5vZGVUcmFuc2Zvcm0pO1xufVxuXG4vKipcbiAqIENsb25lcyB0aGUgZWRpdG9yIGFuZCBtYXJrcyBpdCBhcyBkaXJ0eSB0byBiZSByZWNvbmNpbGVkLiBJZiB0aGVyZSB3YXMgYSBzZWxlY3Rpb24sXG4gKiBpdCB3b3VsZCBiZSBzZXQgYmFjayB0byBpdHMgcHJldmlvdXMgc3RhdGUsIG9yIG51bGwgb3RoZXJ3aXNlLlxuICogQHBhcmFtIGVkaXRvciAtIFRoZSBsZXhpY2FsIGVkaXRvclxuICogQHBhcmFtIGVkaXRvclN0YXRlIC0gVGhlIGVkaXRvcidzIHN0YXRlXG4gKi9cbmZ1bmN0aW9uICRyZXN0b3JlRWRpdG9yU3RhdGUoZWRpdG9yLCBlZGl0b3JTdGF0ZSkge1xuICBjb25zdCBGVUxMX1JFQ09OQ0lMRSA9IDI7XG4gIGNvbnN0IG5vZGVNYXAgPSBuZXcgTWFwKCk7XG4gIGNvbnN0IGFjdGl2ZUVkaXRvclN0YXRlID0gZWRpdG9yLl9wZW5kaW5nRWRpdG9yU3RhdGU7XG4gIGZvciAoY29uc3QgW2tleSwgbm9kZV0gb2YgZWRpdG9yU3RhdGUuX25vZGVNYXApIHtcbiAgICBub2RlTWFwLnNldChrZXksICRjbG9uZVdpdGhQcm9wZXJ0aWVzKG5vZGUpKTtcbiAgfVxuICBpZiAoYWN0aXZlRWRpdG9yU3RhdGUpIHtcbiAgICBhY3RpdmVFZGl0b3JTdGF0ZS5fbm9kZU1hcCA9IG5vZGVNYXA7XG4gIH1cbiAgZWRpdG9yLl9kaXJ0eVR5cGUgPSBGVUxMX1JFQ09OQ0lMRTtcbiAgY29uc3Qgc2VsZWN0aW9uID0gZWRpdG9yU3RhdGUuX3NlbGVjdGlvbjtcbiAgJHNldFNlbGVjdGlvbihzZWxlY3Rpb24gPT09IG51bGwgPyBudWxsIDogc2VsZWN0aW9uLmNsb25lKCkpO1xufVxuXG4vKipcbiAqIElmIHRoZSBzZWxlY3RlZCBpbnNlcnRpb24gYXJlYSBpcyB0aGUgcm9vdC9zaGFkb3cgcm9vdCBub2RlIChzZWUge0BsaW5rIGxleGljYWwhJGlzUm9vdE9yU2hhZG93Um9vdH0pLFxuICogdGhlIG5vZGUgd2lsbCBiZSBhcHBlbmRlZCB0aGVyZSwgb3RoZXJ3aXNlLCBpdCB3aWxsIGJlIGluc2VydGVkIGJlZm9yZSB0aGUgaW5zZXJ0aW9uIGFyZWEuXG4gKiBJZiB0aGVyZSBpcyBubyBzZWxlY3Rpb24gd2hlcmUgdGhlIG5vZGUgaXMgdG8gYmUgaW5zZXJ0ZWQsIGl0IHdpbGwgYmUgYXBwZW5kZWQgYWZ0ZXIgYW55IGN1cnJlbnQgbm9kZXNcbiAqIHdpdGhpbiB0aGUgdHJlZSwgYXMgYSBjaGlsZCBvZiB0aGUgcm9vdCBub2RlLiBBIHBhcmFncmFwaCBub2RlIHdpbGwgdGhlbiBiZSBhZGRlZCBhZnRlciB0aGUgaW5zZXJ0ZWQgbm9kZSBhbmQgc2VsZWN0ZWQuXG4gKiBAcGFyYW0gbm9kZSAtIFRoZSBub2RlIHRvIGJlIGluc2VydGVkXG4gKiBAcmV0dXJucyBUaGUgbm9kZSBhZnRlciBpdHMgaW5zZXJ0aW9uXG4gKi9cbmZ1bmN0aW9uICRpbnNlcnROb2RlVG9OZWFyZXN0Um9vdChub2RlKSB7XG4gIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKSB8fCAkZ2V0UHJldmlvdXNTZWxlY3Rpb24oKTtcbiAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICBjb25zdCB7XG4gICAgICBmb2N1c1xuICAgIH0gPSBzZWxlY3Rpb247XG4gICAgY29uc3QgZm9jdXNOb2RlID0gZm9jdXMuZ2V0Tm9kZSgpO1xuICAgIGNvbnN0IGZvY3VzT2Zmc2V0ID0gZm9jdXMub2Zmc2V0O1xuICAgIGlmICgkaXNSb290T3JTaGFkb3dSb290KGZvY3VzTm9kZSkpIHtcbiAgICAgIGNvbnN0IGZvY3VzQ2hpbGQgPSBmb2N1c05vZGUuZ2V0Q2hpbGRBdEluZGV4KGZvY3VzT2Zmc2V0KTtcbiAgICAgIGlmIChmb2N1c0NoaWxkID09IG51bGwpIHtcbiAgICAgICAgZm9jdXNOb2RlLmFwcGVuZChub2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvY3VzQ2hpbGQuaW5zZXJ0QmVmb3JlKG5vZGUpO1xuICAgICAgfVxuICAgICAgbm9kZS5zZWxlY3ROZXh0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBzcGxpdE5vZGU7XG4gICAgICBsZXQgc3BsaXRPZmZzZXQ7XG4gICAgICBpZiAoJGlzVGV4dE5vZGUoZm9jdXNOb2RlKSkge1xuICAgICAgICBzcGxpdE5vZGUgPSBmb2N1c05vZGUuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgICAgICBzcGxpdE9mZnNldCA9IGZvY3VzTm9kZS5nZXRJbmRleFdpdGhpblBhcmVudCgpO1xuICAgICAgICBpZiAoZm9jdXNPZmZzZXQgPiAwKSB7XG4gICAgICAgICAgc3BsaXRPZmZzZXQgKz0gMTtcbiAgICAgICAgICBmb2N1c05vZGUuc3BsaXRUZXh0KGZvY3VzT2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3BsaXROb2RlID0gZm9jdXNOb2RlO1xuICAgICAgICBzcGxpdE9mZnNldCA9IGZvY3VzT2Zmc2V0O1xuICAgICAgfVxuICAgICAgY29uc3QgWywgcmlnaHRUcmVlXSA9ICRzcGxpdE5vZGUoc3BsaXROb2RlLCBzcGxpdE9mZnNldCk7XG4gICAgICByaWdodFRyZWUuaW5zZXJ0QmVmb3JlKG5vZGUpO1xuICAgICAgcmlnaHRUcmVlLnNlbGVjdFN0YXJ0KCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChzZWxlY3Rpb24gIT0gbnVsbCkge1xuICAgICAgY29uc3Qgbm9kZXMgPSBzZWxlY3Rpb24uZ2V0Tm9kZXMoKTtcbiAgICAgIG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdLmdldFRvcExldmVsRWxlbWVudE9yVGhyb3coKS5pbnNlcnRBZnRlcihub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgcm9vdCA9ICRnZXRSb290KCk7XG4gICAgICByb290LmFwcGVuZChub2RlKTtcbiAgICB9XG4gICAgY29uc3QgcGFyYWdyYXBoTm9kZSA9ICRjcmVhdGVQYXJhZ3JhcGhOb2RlKCk7XG4gICAgbm9kZS5pbnNlcnRBZnRlcihwYXJhZ3JhcGhOb2RlKTtcbiAgICBwYXJhZ3JhcGhOb2RlLnNlbGVjdCgpO1xuICB9XG4gIHJldHVybiBub2RlLmdldExhdGVzdCgpO1xufVxuXG4vKipcbiAqIFdyYXBzIHRoZSBub2RlIGludG8gYW5vdGhlciBub2RlIGNyZWF0ZWQgZnJvbSBhIGNyZWF0ZUVsZW1lbnROb2RlIGZ1bmN0aW9uLCBlZy4gJGNyZWF0ZVBhcmFncmFwaE5vZGVcbiAqIEBwYXJhbSBub2RlIC0gTm9kZSB0byBiZSB3cmFwcGVkLlxuICogQHBhcmFtIGNyZWF0ZUVsZW1lbnROb2RlIC0gQ3JlYXRlcyBhIG5ldyBsZXhpY2FsIGVsZW1lbnQgdG8gd3JhcCB0aGUgdG8tYmUtd3JhcHBlZCBub2RlIGFuZCByZXR1cm5zIGl0LlxuICogQHJldHVybnMgQSBuZXcgbGV4aWNhbCBlbGVtZW50IHdpdGggdGhlIHByZXZpb3VzIG5vZGUgYXBwZW5kZWQgd2l0aGluIChhcyBhIGNoaWxkLCBpbmNsdWRpbmcgaXRzIGNoaWxkcmVuKS5cbiAqL1xuZnVuY3Rpb24gJHdyYXBOb2RlSW5FbGVtZW50KG5vZGUsIGNyZWF0ZUVsZW1lbnROb2RlKSB7XG4gIGNvbnN0IGVsZW1lbnROb2RlID0gY3JlYXRlRWxlbWVudE5vZGUoKTtcbiAgbm9kZS5yZXBsYWNlKGVsZW1lbnROb2RlKTtcbiAgZWxlbWVudE5vZGUuYXBwZW5kKG5vZGUpO1xuICByZXR1cm4gZWxlbWVudE5vZGU7XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5cbi8qKlxuICogQHBhcmFtIG9iamVjdCA9IFRoZSBpbnN0YW5jZSBvZiB0aGUgdHlwZVxuICogQHBhcmFtIG9iamVjdENsYXNzID0gVGhlIGNsYXNzIG9mIHRoZSB0eXBlXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBvYmplY3QgaXMgaGFzIHRoZSBzYW1lIEtsYXNzIG9mIHRoZSBvYmplY3RDbGFzcywgaWdub3JpbmcgdGhlIGRpZmZlcmVuY2UgYWNyb3NzIHdpbmRvdyAoZS5nLiBkaWZmZXJlbnQgaWZyYW1zKVxuICovXG5mdW5jdGlvbiBvYmplY3RLbGFzc0VxdWFscyhvYmplY3QsIG9iamVjdENsYXNzKSB7XG4gIHJldHVybiBvYmplY3QgIT09IG51bGwgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KS5jb25zdHJ1Y3Rvci5uYW1lID09PSBvYmplY3RDbGFzcy5uYW1lIDogZmFsc2U7XG59XG5cbi8qKlxuICogRmlsdGVyIHRoZSBub2Rlc1xuICogQHBhcmFtIG5vZGVzIEFycmF5IG9mIG5vZGVzIHRoYXQgbmVlZHMgdG8gYmUgZmlsdGVyZWRcbiAqIEBwYXJhbSBmaWx0ZXJGbiBBIGZpbHRlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgbm9kZSBpZiB0aGUgY3VycmVudCBub2RlIHNhdGlzZmllcyB0aGUgY29uZGl0aW9uIG90aGVyd2lzZSBudWxsXG4gKiBAcmV0dXJucyBBcnJheSBvZiBmaWx0ZXJlZCBub2Rlc1xuICovXG5cbmZ1bmN0aW9uICRmaWx0ZXIobm9kZXMsIGZpbHRlckZuKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgbm9kZSA9IGZpbHRlckZuKG5vZGVzW2ldKTtcbiAgICBpZiAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgcmVzdWx0LnB1c2gobm9kZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEFwcGVuZHMgdGhlIG5vZGUgYmVmb3JlIHRoZSBmaXJzdCBjaGlsZCBvZiB0aGUgcGFyZW50IG5vZGVcbiAqIEBwYXJhbSBwYXJlbnQgQSBwYXJlbnQgbm9kZVxuICogQHBhcmFtIG5vZGUgTm9kZSB0aGF0IG5lZWRzIHRvIGJlIGFwcGVuZGVkXG4gKi9cbmZ1bmN0aW9uICRpbnNlcnRGaXJzdChwYXJlbnQsIG5vZGUpIHtcbiAgY29uc3QgZmlyc3RDaGlsZCA9IHBhcmVudC5nZXRGaXJzdENoaWxkKCk7XG4gIGlmIChmaXJzdENoaWxkICE9PSBudWxsKSB7XG4gICAgZmlyc3RDaGlsZC5pbnNlcnRCZWZvcmUobm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgcGFyZW50LmFwcGVuZChub2RlKTtcbiAgfVxufVxubGV0IE5FRURTX01BTlVBTF9aT09NID0gSVNfRklSRUZPWCB8fCAhQ0FOX1VTRV9ET00gPyBmYWxzZSA6IHVuZGVmaW5lZDtcbmZ1bmN0aW9uIG5lZWRzTWFudWFsWm9vbSgpIHtcbiAgaWYgKE5FRURTX01BTlVBTF9aT09NID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBJZiB0aGUgYnJvd3NlciBpbXBsZW1lbnRzIHN0YW5kYXJkaXplZCBDU1Mgem9vbSwgdGhlbiB0aGUgY2xpZW50IHJlY3RcbiAgICAvLyB3aWxsIGJlIHdpZGVyIGFmdGVyIHpvb20gaXMgYXBwbGllZFxuICAgIC8vIGh0dHBzOi8vY2hyb21lc3RhdHVzLmNvbS9mZWF0dXJlLzUxOTgyNTQ4Njg1MjkxNTJcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svbGV4aWNhbC9pc3N1ZXMvNjg2M1xuICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRpdi5zdHlsZS5jc3NUZXh0ID0gJ3Bvc2l0aW9uOiBhYnNvbHV0ZTsgb3BhY2l0eTogMDsgd2lkdGg6IDEwMHB4OyBsZWZ0OiAtMTAwMHB4Oyc7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpO1xuICAgIGNvbnN0IG5vWm9vbSA9IGRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBkaXYuc3R5bGUuc2V0UHJvcGVydHkoJ3pvb20nLCAnMicpO1xuICAgIE5FRURTX01BTlVBTF9aT09NID0gZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoID09PSBub1pvb20ud2lkdGg7XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChkaXYpO1xuICB9XG4gIHJldHVybiBORUVEU19NQU5VQUxfWk9PTTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSB6b29tIGxldmVsIG9mIGFuIGVsZW1lbnQgYXMgYSByZXN1bHQgb2YgdXNpbmdcbiAqIGNzcyB6b29tIHByb3BlcnR5LiBGb3IgYnJvd3NlcnMgdGhhdCBpbXBsZW1lbnQgc3RhbmRhcmRpemVkIENTU1xuICogem9vbSAoRmlyZWZveCwgQ2hyb21lID49IDEyOCksIHRoaXMgd2lsbCBhbHdheXMgcmV0dXJuIDEuXG4gKiBAcGFyYW0gZWxlbWVudFxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVab29tTGV2ZWwoZWxlbWVudCkge1xuICBsZXQgem9vbSA9IDE7XG4gIGlmIChuZWVkc01hbnVhbFpvb20oKSkge1xuICAgIHdoaWxlIChlbGVtZW50KSB7XG4gICAgICB6b29tICo9IE51bWJlcih3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKCd6b29tJykpO1xuICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHpvb207XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBlZGl0b3IgaXMgYSBuZXN0ZWQgZWRpdG9yIGNyZWF0ZWQgYnkgTGV4aWNhbE5lc3RlZENvbXBvc2VyXG4gKi9cbmZ1bmN0aW9uICRpc0VkaXRvcklzTmVzdGVkRWRpdG9yKGVkaXRvcikge1xuICByZXR1cm4gZWRpdG9yLl9wYXJlbnRFZGl0b3IgIT09IG51bGw7XG59XG5cbi8qKlxuICogQSBkZXB0aCBmaXJzdCBsYXN0LXRvLWZpcnN0IHRyYXZlcnNhbCBvZiByb290IHRoYXQgc3RvcHMgYXQgZWFjaCBub2RlIHRoYXQgbWF0Y2hlc1xuICogJHByZWRpY2F0ZSBhbmQgZW5zdXJlcyB0aGF0IGl0cyBwYXJlbnQgaXMgcm9vdC4gVGhpcyBpcyB0eXBpY2FsbHkgdXNlZCB0byBkaXNjYXJkXG4gKiBpbnZhbGlkIG9yIHVuc3VwcG9ydGVkIHdyYXBwaW5nIG5vZGVzLiBGb3IgZXhhbXBsZSwgYSBUYWJsZU5vZGUgbXVzdCBvbmx5IGhhdmVcbiAqIFRhYmxlUm93Tm9kZSBhcyBjaGlsZHJlbiwgYnV0IGFuIGltcG9ydGVyIG1pZ2h0IGFkZCBpbnZhbGlkIG5vZGVzIGJhc2VkIG9uXG4gKiBjYXB0aW9uLCB0Ym9keSwgdGhlYWQsIGV0Yy4gYW5kIHRoaXMgd2lsbCB1bndyYXAgYW5kIGRpc2NhcmQgdGhvc2UuXG4gKlxuICogQHBhcmFtIHJvb3QgVGhlIHJvb3QgdG8gc3RhcnQgdGhlIHRyYXZlcnNhbFxuICogQHBhcmFtICRwcmVkaWNhdGUgU2hvdWxkIHJldHVybiB0cnVlIGZvciBub2RlcyB0aGF0IGFyZSBwZXJtaXR0ZWQgdG8gYmUgY2hpbGRyZW4gb2Ygcm9vdFxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGlzIHVud3JhcHBlZCBvciByZW1vdmVkIGFueSBub2Rlc1xuICovXG5mdW5jdGlvbiAkdW53cmFwQW5kRmlsdGVyRGVzY2VuZGFudHMocm9vdCwgJHByZWRpY2F0ZSkge1xuICByZXR1cm4gJHVud3JhcEFuZEZpbHRlckRlc2NlbmRhbnRzSW1wbChyb290LCAkcHJlZGljYXRlLCBudWxsKTtcbn1cbmZ1bmN0aW9uICR1bndyYXBBbmRGaWx0ZXJEZXNjZW5kYW50c0ltcGwocm9vdCwgJHByZWRpY2F0ZSwgJG9uU3VjY2Vzcykge1xuICBsZXQgZGlkTXV0YXRlID0gZmFsc2U7XG4gIGZvciAoY29uc3Qgbm9kZSBvZiAkbGFzdFRvRmlyc3RJdGVyYXRvcihyb290KSkge1xuICAgIGlmICgkcHJlZGljYXRlKG5vZGUpKSB7XG4gICAgICBpZiAoJG9uU3VjY2VzcyAhPT0gbnVsbCkge1xuICAgICAgICAkb25TdWNjZXNzKG5vZGUpO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGRpZE11dGF0ZSA9IHRydWU7XG4gICAgaWYgKCRpc0VsZW1lbnROb2RlKG5vZGUpKSB7XG4gICAgICAkdW53cmFwQW5kRmlsdGVyRGVzY2VuZGFudHNJbXBsKG5vZGUsICRwcmVkaWNhdGUsICRvblN1Y2Nlc3MgPyAkb25TdWNjZXNzIDogY2hpbGQgPT4gbm9kZS5pbnNlcnRBZnRlcihjaGlsZCkpO1xuICAgIH1cbiAgICBub2RlLnJlbW92ZSgpO1xuICB9XG4gIHJldHVybiBkaWRNdXRhdGU7XG59XG5cbi8qKlxuICogQSBkZXB0aCBmaXJzdCB0cmF2ZXJzYWwgb2YgdGhlIGNoaWxkcmVuIGFycmF5IHRoYXQgc3RvcHMgYXQgYW5kIGNvbGxlY3RzXG4gKiBlYWNoIG5vZGUgdGhhdCBgJHByZWRpY2F0ZWAgbWF0Y2hlcy4gVGhpcyBpcyB0eXBpY2FsbHkgdXNlZCB0byBkaXNjYXJkXG4gKiBpbnZhbGlkIG9yIHVuc3VwcG9ydGVkIHdyYXBwaW5nIG5vZGVzIG9uIGEgY2hpbGRyZW4gYXJyYXkgaW4gdGhlIGBhZnRlcmBcbiAqIG9mIGFuIHtAbGluayBsZXhpY2FsIURPTUNvbnZlcnNpb25PdXRwdXR9LiBGb3IgZXhhbXBsZSwgYSBUYWJsZU5vZGUgbXVzdCBvbmx5IGhhdmVcbiAqIFRhYmxlUm93Tm9kZSBhcyBjaGlsZHJlbiwgYnV0IGFuIGltcG9ydGVyIG1pZ2h0IGFkZCBpbnZhbGlkIG5vZGVzIGJhc2VkIG9uXG4gKiBjYXB0aW9uLCB0Ym9keSwgdGhlYWQsIGV0Yy4gYW5kIHRoaXMgd2lsbCB1bndyYXAgYW5kIGRpc2NhcmQgdGhvc2UuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyByZWFkLW9ubHkgYW5kIHBlcmZvcm1zIG5vIG11dGF0aW9uIG9wZXJhdGlvbnMsIHdoaWNoIG1ha2VzXG4gKiBpdCBzdWl0YWJsZSBmb3IgaW1wb3J0IGFuZCBleHBvcnQgcHVycG9zZXMgYnV0IGxpa2VseSBub3QgZm9yIGFueSBpbi1wbGFjZVxuICogbXV0YXRpb24uIFlvdSBzaG91bGQgdXNlIHtAbGluayAkdW53cmFwQW5kRmlsdGVyRGVzY2VuZGFudHN9IGZvciBpbi1wbGFjZVxuICogbXV0YXRpb25zIHN1Y2ggYXMgbm9kZSB0cmFuc2Zvcm1zLlxuICpcbiAqIEBwYXJhbSBjaGlsZHJlbiBUaGUgY2hpbGRyZW4gdG8gdHJhdmVyc2VcbiAqIEBwYXJhbSAkcHJlZGljYXRlIFNob3VsZCByZXR1cm4gdHJ1ZSBmb3Igbm9kZXMgdGhhdCBhcmUgcGVybWl0dGVkIHRvIGJlIGNoaWxkcmVuIG9mIHJvb3RcbiAqIEByZXR1cm5zIFRoZSBjaGlsZHJlbiBvciB0aGVpciBkZXNjZW5kYW50cyB0aGF0IG1hdGNoICRwcmVkaWNhdGVcbiAqL1xuXG5mdW5jdGlvbiAkZGVzY2VuZGFudHNNYXRjaGluZyhjaGlsZHJlbiwgJHByZWRpY2F0ZSkge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgY29uc3Qgc3RhY2sgPSBbLi4uY2hpbGRyZW5dLnJldmVyc2UoKTtcbiAgZm9yIChsZXQgY2hpbGQgPSBzdGFjay5wb3AoKTsgY2hpbGQgIT09IHVuZGVmaW5lZDsgY2hpbGQgPSBzdGFjay5wb3AoKSkge1xuICAgIGlmICgkcHJlZGljYXRlKGNoaWxkKSkge1xuICAgICAgcmVzdWx0LnB1c2goY2hpbGQpO1xuICAgIH0gZWxzZSBpZiAoJGlzRWxlbWVudE5vZGUoY2hpbGQpKSB7XG4gICAgICBmb3IgKGNvbnN0IGdyYW5kY2hpbGQgb2YgJGxhc3RUb0ZpcnN0SXRlcmF0b3IoY2hpbGQpKSB7XG4gICAgICAgIHN0YWNrLnB1c2goZ3JhbmRjaGlsZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogUmV0dXJuIGFuIGl0ZXJhdG9yIHRoYXQgeWllbGRzIGVhY2ggY2hpbGQgb2Ygbm9kZSBmcm9tIGZpcnN0IHRvIGxhc3QsIHRha2luZ1xuICogY2FyZSB0byBwcmVzZXJ2ZSB0aGUgbmV4dCBzaWJsaW5nIGJlZm9yZSB5aWVsZGluZyB0aGUgdmFsdWUgaW4gY2FzZSB0aGUgY2FsbGVyXG4gKiByZW1vdmVzIHRoZSB5aWVsZGVkIG5vZGUuXG4gKlxuICogQHBhcmFtIG5vZGUgVGhlIG5vZGUgd2hvc2UgY2hpbGRyZW4gdG8gaXRlcmF0ZVxuICogQHJldHVybnMgQW4gaXRlcmF0b3Igb2YgdGhlIG5vZGUncyBjaGlsZHJlblxuICovXG5mdW5jdGlvbiAkZmlyc3RUb0xhc3RJdGVyYXRvcihub2RlKSB7XG4gIHJldHVybiB7XG4gICAgW1N5bWJvbC5pdGVyYXRvcl06ICgpID0+ICRjaGlsZEl0ZXJhdG9yKG5vZGUuZ2V0Rmlyc3RDaGlsZCgpLCBjaGlsZCA9PiBjaGlsZC5nZXROZXh0U2libGluZygpKVxuICB9O1xufVxuXG4vKipcbiAqIFJldHVybiBhbiBpdGVyYXRvciB0aGF0IHlpZWxkcyBlYWNoIGNoaWxkIG9mIG5vZGUgZnJvbSBsYXN0IHRvIGZpcnN0LCB0YWtpbmdcbiAqIGNhcmUgdG8gcHJlc2VydmUgdGhlIHByZXZpb3VzIHNpYmxpbmcgYmVmb3JlIHlpZWxkaW5nIHRoZSB2YWx1ZSBpbiBjYXNlIHRoZSBjYWxsZXJcbiAqIHJlbW92ZXMgdGhlIHlpZWxkZWQgbm9kZS5cbiAqXG4gKiBAcGFyYW0gbm9kZSBUaGUgbm9kZSB3aG9zZSBjaGlsZHJlbiB0byBpdGVyYXRlXG4gKiBAcmV0dXJucyBBbiBpdGVyYXRvciBvZiB0aGUgbm9kZSdzIGNoaWxkcmVuXG4gKi9cbmZ1bmN0aW9uICRsYXN0VG9GaXJzdEl0ZXJhdG9yKG5vZGUpIHtcbiAgcmV0dXJuIHtcbiAgICBbU3ltYm9sLml0ZXJhdG9yXTogKCkgPT4gJGNoaWxkSXRlcmF0b3Iobm9kZS5nZXRMYXN0Q2hpbGQoKSwgY2hpbGQgPT4gY2hpbGQuZ2V0UHJldmlvdXNTaWJsaW5nKCkpXG4gIH07XG59XG5mdW5jdGlvbiAkY2hpbGRJdGVyYXRvcihpbml0aWFsTm9kZSwgbmV4dE5vZGUpIHtcbiAgbGV0IHN0YXRlID0gaW5pdGlhbE5vZGU7XG4gIGNvbnN0IHNlZW4gPSBuZXcgU2V0KCkgO1xuICByZXR1cm4ge1xuICAgIG5leHQoKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yRG9uZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJ2YWwgPSBpdGVyYXRvck5vdERvbmUoc3RhdGUpO1xuICAgICAgaWYgKHNlZW4gIT09IG51bGwpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gc3RhdGUuZ2V0S2V5KCk7XG4gICAgICAgIGlmICghIXNlZW4uaGFzKGtleSkpIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihgJGNoaWxkSXRlcmF0b3I6IEN5Y2xlIGRldGVjdGVkLCBub2RlIHdpdGgga2V5ICR7U3RyaW5nKGtleSl9IGhhcyBhbHJlYWR5IGJlZW4gdHJhdmVyc2VkYCk7XG4gICAgICAgIH1cbiAgICAgICAgc2Vlbi5hZGQoa2V5KTtcbiAgICAgIH1cbiAgICAgIHN0YXRlID0gbmV4dE5vZGUoc3RhdGUpO1xuICAgICAgcmV0dXJuIHJ2YWw7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIEluc2VydCBhbGwgY2hpbGRyZW4gYmVmb3JlIHRoaXMgbm9kZSwgYW5kIHRoZW4gcmVtb3ZlIGl0LlxuICpcbiAqIEBwYXJhbSBub2RlIFRoZSBFbGVtZW50Tm9kZSB0byB1bndyYXAgYW5kIHJlbW92ZVxuICovXG5mdW5jdGlvbiAkdW53cmFwTm9kZShub2RlKSB7XG4gIGZvciAoY29uc3QgY2hpbGQgb2YgJGZpcnN0VG9MYXN0SXRlcmF0b3Iobm9kZSkpIHtcbiAgICBub2RlLmluc2VydEJlZm9yZShjaGlsZCk7XG4gIH1cbiAgbm9kZS5yZW1vdmUoKTtcbn1cblxuZXhwb3J0IHsgJGRlc2NlbmRhbnRzTWF0Y2hpbmcsICRkZnMsICRkZnNJdGVyYXRvciwgJGZpbHRlciwgJGZpbmRNYXRjaGluZ1BhcmVudCwgJGZpcnN0VG9MYXN0SXRlcmF0b3IsICRnZXREZXB0aCwgJGdldE5lYXJlc3RCbG9ja0VsZW1lbnRBbmNlc3Rvck9yVGhyb3csICRnZXROZWFyZXN0Tm9kZU9mVHlwZSwgJGdldE5leHRSaWdodFByZW9yZGVyTm9kZSwgJGdldE5leHRTaWJsaW5nT3JQYXJlbnRTaWJsaW5nLCAkaW5zZXJ0Rmlyc3QsICRpbnNlcnROb2RlVG9OZWFyZXN0Um9vdCwgJGlzRWRpdG9ySXNOZXN0ZWRFZGl0b3IsICRsYXN0VG9GaXJzdEl0ZXJhdG9yLCAkcmVzdG9yZUVkaXRvclN0YXRlLCAkdW53cmFwQW5kRmlsdGVyRGVzY2VuZGFudHMsICR1bndyYXBOb2RlLCAkd3JhcE5vZGVJbkVsZW1lbnQsIENBTl9VU0VfQkVGT1JFX0lOUFVULCBDQU5fVVNFX0RPTSwgSVNfQU5EUk9JRCwgSVNfQU5EUk9JRF9DSFJPTUUsIElTX0FQUExFLCBJU19BUFBMRV9XRUJLSVQsIElTX0NIUk9NRSwgSVNfRklSRUZPWCwgSVNfSU9TLCBJU19TQUZBUkksIGFkZENsYXNzTmFtZXNUb0VsZW1lbnQsIGNhbGN1bGF0ZVpvb21MZXZlbCwgaXNNaW1lVHlwZSwgbWFya1NlbGVjdGlvbiwgbWVkaWFGaWxlUmVhZGVyLCBtZXJnZVJlZ2lzdGVyLCBvYmplY3RLbGFzc0VxdWFscywgbWxjUG9zaXRpb25Ob2RlT25SYW5nZSBhcyBwb3NpdGlvbk5vZGVPblJhbmdlLCByZWdpc3Rlck5lc3RlZEVsZW1lbnRSZXNvbHZlciwgcmVtb3ZlQ2xhc3NOYW1lc0Zyb21FbGVtZW50LCBzZWxlY3Rpb25BbHdheXNPbkRpc3BsYXkgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/utils/LexicalUtils.dev.mjs\n");

/***/ })

};
;